<?xml version="1.0" encoding="UTF-8"?>
<Export generator="IRIS" version="26" zv="IRIS for UNIX (Ubuntu Server LTS for x86-64 Containers) 2024.3.0L (Build 152U)" ts="2024-10-17 16:57:49">
<Class name="PXW.DEV.Atom">
<Super>PXW.DEV.Particle</Super>
<TimeChanged>67125,77562.278435344</TimeChanged>
<TimeCreated>67125,77562.278435344</TimeCreated>

<UDLText name="T">
<Content><![CDATA[/* strictly speaking we should only need type and value*/
]]></Content>
</UDLText>

<Property name="type">
<Type>%String</Type>
</Property>

<Property name="value">
<Type>%String</Type>
</Property>

<UDLText name="T">
<Content><![CDATA[
/* a strict parser might ignore comments and white space
   but here I want to keep them so they can be represented in html
   */
]]></Content>
</UDLText>

<Property name="whitespace">
<Type>PXW.DEV.Atom</Type>
</Property>

<Property name="comment">
<Type>PXW.DEV.Atom</Type>
</Property>

<UDLText name="T">
<Content><![CDATA[/* these others are for debug and error reporting purposes */
]]></Content>
</UDLText>

<Property name="col">
<Type>%String</Type>
</Property>

<Property name="line">
<Type>%String</Type>
</Property>

<Property name="start">
<Description>
How this atom starts (optional) eg: strings may start with quotes(")</Description>
<Type>%String</Type>
</Property>

<Property name="end">
<Description>
How this atom ends (optional) eg: strings may end with quotes(")</Description>
<Type>%String</Type>
</Property>

<Method name="ToString">
<Description>
wspace="" ; return original whitespace 
wpsace=string ; return the string in place of the white space
wspace=0 ; no whitespace
Never returns comments</Description>
<FormalSpec>wspace:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set str=""
	If $ISOBJECT(..whitespace) {
		If wspace="" {
			Set str=str_..whitespace.ToString()
		} ElseIf wspace=0 {
			Set str=str
		}
		Else {
			Set str=str_wspace
		}
	}
	Set str=str_..start
	Set str=str_..value
	Set str=str_..end
	Quit str
]]></Implementation>
</Method>

<Method name="write">
<Description>
write out basic info of the atom</Description>
<FormalSpec>indent:%String</FormalSpec>
<Implementation><![CDATA[
	Write indent_"type="_..type,!
	;i $isobject(..whitespace) d ..whitespace.display(indent_"  ")
	Write indent_" "_..start_..value_..end,!
]]></Implementation>
</Method>

<Method name="writeFull">
<Description>
write out the full details of the atom (with comments etc)</Description>
<FormalSpec>indent:%String</FormalSpec>
<Implementation><![CDATA[
	Write indent_"type="_..type,!
	If $ISOBJECT(..whitespace) Do ..whitespace.writeFull(indent_"  ")
	If $ISOBJECT(..comment) Do ..comment.writeFull(indent_"  ")
	Write indent_" "_..start_..value_..end,!
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Analyse.COS">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>PXW.DEV.BNF.Compilers.analyser</Super>
<TimeChanged>67125,77562.358118346</TimeChanged>
<TimeCreated>67125,77562.358118346</TimeCreated>

<Property name="VariablesTypes">
<Description>
Keep track of variable types 
..VariableTypes(varname)=type</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="DimmedTypes">
<Description>
Keep track of variable types #dimmed by programmer, assumed to be more accurate than can be derived
..DimmedTypes(varname)=type</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="CurrentlySetting">
<Description>
Array of the variables currently being Set.</Description>
<Type>PXW.DEV.Element</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="ParameterVariables">
<Description>
Keep track of variable types passed in as parameters
..ParameterVariables(varname)=type</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="ReturnType">
<Description>
The return type of the current method</Description>
<Type>%String</Type>
</Property>

<Property name="ClassServer">
<Description>
Server that provide class information</Description>
<Type>PXW.DEV.Dictionary.ClassDefinitionObject</Type>
</Property>

<Property name="VariablesSet">
<Description>
VariablesSet(varname)=element ; means the variable is set, and the element is the variable element that set it</Description>
<Type>PXW.DEV.Element</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="VariablesUsed">
<Description>
VariablesUsed(varname)=element ; means the variable is used, and the element is the variable element that set it, element may be null</Description>
<Type>PXW.DEV.Element</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="CodeMode">
<Description>
Set by codemode attribute (generator etc)</Description>
<Type>%String</Type>
</Property>

<Property name="DefinedMacros">
<Description>
..DefinedMacros(macroname)=""</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="ShortCommand">
<Description>
flag to stop many single letter commands showing as problems in a single analysis</Description>
<Type>%Boolean</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>ClassServer:PXW.DEV.Dictionary.ClassDefinitionObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..ClassServer=ClassServer
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Reset">
<Implementation><![CDATA[

	Kill ..VariablesTypes
	Kill ..DimmedTypes
	Kill ..CurrentlySetting
	Kill ..ElementWarnings
	Kill ..ParameterVariables
	Kill ..DefinedMacros
	Set ..ShortCommand=0

	If $ISOBJECT(..ClassServer) {
		Set var=""
		For  {
			Set type=..ClassServer.KnownVariables.GetNext(.var)
			Quit:var=""

			Set ..VariablesTypes(var)=type
		}
	}
	Set ..ReturnType=""
]]></Implementation>
</Method>

<Method name="IsParameterVariable">
<FormalSpec>var:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If var="" Quit 0
	If $DATA(i%ParameterVariables(var)) Quit 1
	Quit 0
]]></Implementation>
</Method>

<Method name="begin">
<Implementation><![CDATA[	Quit
]]></Implementation>
</Method>

<Method name="end">
<Implementation><![CDATA[	Quit
]]></Implementation>
</Method>

<Method name="middle">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
	;Kill ..ElementWarnings

	If element.type="OneClassmember" {
		Do ..Reset()
		$$$DEBUG("Resetting")
		;s ..ReturnType=element.ReturnType
	}
 	Do ..checkElement(element)
]]></Implementation>
</Method>

<Method name="AddElementWarning">
<FormalSpec>element:PXW.DEV.Element,text:%String</FormalSpec>
<Implementation><![CDATA[
	; errors will be reported on atoms
	;For i=1:1:element.partsCount() {
	;	Set a=element.partsGetAt(i)
	;	Set ..ElementWarnings(+a)=$GET(..ElementWarnings(+i))_text_" "
	;}
	Set a=element.FirstAtom()
	If $ISOBJECT(a) {
		Set ..ElementWarnings(+a)=$GET(..ElementWarnings(+a))_text_" "
	}
]]></Implementation>
</Method>

<Method name="checkElement">
<Description>
best to analyse the entire codeblock all at once.</Description>
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
	#dim a as PXW.DEV.Atom

    If element.type="OneClassmember" {
		Do ..Reset()
		$$$DEBUG("Resetting")
	}

	If element.type="CosCommand" {
		Kill ..CurrentlySetting
		Set directiveE=element.findFirstElementByType("CosDirective")
		; directives count as a command (is this right?) but start with a # atom so would end up being counted as short
		; therefore only check if its NOT a directive
		If '$ISOBJECT(directiveE) {
			Set a=element.FirstAtom()
			If $LENGTH(a.ToString(0))=1 {
				If '..ShortCommand {
					If a.ToString(0)="#" Do element.write()
					Do ..AddElementWarning(element,"Short command")
					Set ..ShortCommand=1
				}
			}
		}
	}

	If element.type="FormalSpecItem" {
		Set modeE=element.findFirstElementByType("FormalSpecMode",0)
		Set mode=""
		If $ISOBJECT(modeE) {
			Set mode=modeE.ToString(0)
		}
		Set varE=element.findFirstElementByType("VariableSet",0)
		Set typeE=element.findFirstElementByType("ClassReference",1) ; go deep because of optional group
		If $ISOBJECT(varE) {
			Set var=varE.ToString(0),type=""
			If $ISOBJECT(typeE) Set type=typeE.ToString(0)
			Set ..ParameterVariables(var)=type
			If type'="" {
				Set ..VariablesTypes(var)=type
			} Else {
				; for me, byref means you pass stuff in and out so it could be array
				; or something modifiable so don't check the type
				If mode="" {
					Do ..AddElementWarning(varE,var_" no type specified on formal spec")
				}
			}
		}
	}

	If element.type="ReturnTypeClassReference" {
		Set crE=element.findFirstElementByType("ClassReference")
		If $ISOBJECT(crE) {
			Set ..ReturnType=crE.ToString(0)
		}
	}

	; if [codemode=objectgenerator] then the ReturnType of the method for analysis purposes is %Status
	If element.type="AttributeCodemodetype" {
		Set codemode=$$$UPPER(element.ToString(0))
		If codemode="OBJECTGENERATOR" {
			Set ..ReturnType="%Library.Status"
		}
		If codemode="GENERATOR" {
			Set ..ReturnType="%Library.Status"
			Set ..VariablesUsed("%code")="" ; % vars are not checked anyway, but leaving here in case this changes in the future
		}
	}
	
	If element.type="SetItem" {
        Do element.findElementsByTypePath("*,SetValueExpression,VariableSet",.variablelist)
		For i=1:1:variablelist.Count() {
			Set varE=variablelist.GetAt(i)
			Set var=varE.ToString(0)
			Set ..CurrentlySetting(var)=varE
			; if its JUST a variable then we are interested in keeping track of it
			If varE.partsCount()=1 {
				Set ..VariablesSet(var)=varE
			} Else {
				; its an array or some sort of object.property, so its a var being used
				Set varname=varE.FirstAtom().ToString(0)
				Set ..VariablesUsed(varname)=varE
			}
		}
	    Do element.findElementsByTypePath("*,SetExpression",.setvalue)
        Set value=$SELECT($ISOBJECT(setvalue):setvalue.GetAt(1),1:"")
 
		Set derivedtype=..DeriveTypeReturned(value)
 		Set var=""
		For {
			Set var=$ORDER(..CurrentlySetting(var),1,velement)
			Quit:var=""
			
			Set dimmedtype=..FullClassName($GET(..DimmedTypes(var)))
			Set currenttype=..FullClassName($GET(..VariablesTypes(var)))
			If dimmedtype'="",derivedtype'="",dimmedtype'=derivedtype {
				If (..IsExtension(derivedtype,dimmedtype)=0) && (..IsExtension(dimmedtype,derivedtype)=0) {
					Do ..AddElementWarning(velement,"Derived type of "_var_" ("_derivedtype_") differs to dimmed type ("_dimmedtype_")")
				}
			}
			; assume the programmer is right, i.e. prefer the dimmed type
			Set finaltype=..FullClassName($SELECT(dimmedtype'="":dimmedtype,1:derivedtype))

			If currenttype'="",finaltype'="",currenttype'=finaltype {
				; if the current type is a superclass of the new type then this is allowed
				If ..IsExtension(finaltype,currenttype) {
					; not an error
				} Else {
					Do ..AddElementWarning(velement,"Change of type on "_var_" from "_currenttype_" to "_finaltype)
				}
			}
			; we have a type so remember it, dont bother storing when it went to null, thats normally not useful
			If finaltype'="" {
				Set ..VariablesTypes(var)=finaltype
		}
		}
		Kill ..CurrentlySetting
	}

	If element.type="Variable" {
		;  variable name part is the only bit we are interested in
		Set varname=element.FirstAtom().ToString(0)
		Set ..VariablesUsed(varname,+element)=element
	}

	If element.type="ObjectVariable" {
		;  variable name part is the only bit we are interested in
		Set varname=element.FirstAtom().ToString(0)
		Set ..VariablesUsed(varname)=element
	}

	If element.type="CosDirectiveDimItem" {
		Set classele=element.findFirstElementByType("ClassReference")
		If $ISOBJECT(classele) {
			Set classname=classele.ToString(0)
			Do element.findElementsByType("VariableSet",.variablelist,2)
			For i=1:1:variablelist.Count() {
				Set var=variablelist.GetAt(i).ToString(0)
				Set ..DimmedTypes(var)=classname
			}	
		}
	}

	If element.type="CosDirectiveDefine" {
		Set nameE=element.findFirstElementByType("CosDirectiveDefineName")
		If $ISOBJECT(nameE) {
			Set macname=nameE.ToString(0)
			Set:macname'="" ..DefinedMacros(macname)=""
			;zw macname,$this
		}
	}


    If element.type="QuitCommand" {
		Set quitexpE=element.findFirstElementByType("QuitExpression",1)
        If $ISOBJECT(quitexpE) {
            Set derivedtype=..DeriveTypeReturned(quitexpE)
			If derivedtype="" {
                If quitexpE.ToString(0)="""""" {
                    ; if the return value is null ("") then this is always ok
                    Set derivedtype=..ReturnType
                } Else {
                    If ..ClassServer.GetClassDetails(..ReturnType,.classtype) {
                        If $$$UPPER(classtype)="DATATYPE" {
                            Set derivedtype=..ReturnType
                        }
                    }
                }
            }
            If ..ReturnType="" {
                Do ..AddElementWarning(element,"return type is not set, derived type="_derivedtype)
            } ElseIf  ..FullClassName(..ReturnType)'=..FullClassName(derivedtype) {
                If ..IsExtension(derivedtype,..ReturnType) {
                    ; the derived type EXTENDS the expected type, which is fine
                } Else {
                    Do ..AddElementWarning(element,"return type="_..ReturnType_", derived type="_derivedtype)
                }
            }
        }	
    }

	Set allAtOnce=1
	If allAtOnce {
		Set akey=""
		For  {
			Set a=element.partsGetNext(.akey)
			Quit:akey=""
			
			If a.%IsA("PXW.DEV.Element") {
				Do ..checkElement(a)
			} 
		}

		; AFTER full analysis we can flag a couple of things
	   	If element.type="OneClassmember" {
			Set var=$CHAR($ASCII("%")+1) ; skip over % variables, we don't care if they are used they might be used in deeper, untrackable ways
			For  {
				Set var=$ORDER(..VariablesSet(var))
				Quit:var=""
				; if its a parameter variable we count this as being used
				; {*} is special variable that is used on computed fields, ignore those
				If '$DATA(..VariablesUsed(var)),'$DATA(..ParameterVariables(var)),var'="{*}" {
					Set vsetE=..VariablesSet(var)
					Do ..AddElementWarning(vsetE,var_" Set but not used")
				}
			}
		}
	}
]]></Implementation>
</Method>

<Method name="IsExtension">
<Description>
Check to see if Classname is a subclass of the given superclass</Description>
<FormalSpec>Classname:%String,SuperClass:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If ..ClassServer.GetClassDetails(Classname,,,.primarysuper) {
		If primarysuper[("~"_SuperClass_"~") Quit 1
	}
	Quit 0
]]></Implementation>
</Method>

<Method name="FollowObjectChainForType">
<FormalSpec>ParentElement:PXW.DEV.Element,StartClassName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set type=StartClassName
    Set classname=StartClassName
    Set objectchain=ParentElement.findFirstElementByType("ObjectChain",0)
	If '$ISOBJECT(objectchain) Set objectchain=ParentElement.findFirstElementByType("ObjectChainNoDot",0)
    While $IsObject(objectchain) {
        ; the objectchain has the "." and the name
        Set propertyname=objectchain.ToStringAtomsOnly(0)
		Set propertyname=$SELECT($EXTRACT(propertyname,1)=".":$PIECE(propertyname,".",2),1:propertyname)
		Set found=..ClassServer.GetPropertyDetails(classname,propertyname,.type)
		Set:'found type=..ClassServer.GetMethodReturnType(classname,propertyname)
       
        Set objectchain=objectchain.findFirstElementByType("ObjectChain",0)
        Set classname=type
    }
    Quit type
]]></Implementation>
</Method>

<Method name="DeriveTypeReturned">
<FormalSpec>ValueElement:PXW.DEV.Element</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim element as PXW.DEV.Element

	; some kind of set with indirection so type cannot be derived
	; S @x
	If ValueElement="" Quit ""

	If ValueElement.type="Expression" {
		Set expression=ValueElement
	} Else {
		Set expression=ValueElement.findFirstElementByType("Expression",0)
	}

	Set simple=..SimplifyExpression(expression,.variableElement)
	If simple'="-" Quit "" ; it's a number or string
	
	If '$ISOBJECT(variableElement) Quit "" ; its something else we cannot deal with

	Set finaltype=""
    ; looking for ##class
	If variableElement.type="Classexpr" {
		Set hhclass=variableElement.findFirstElementByType("ClassExpression",0)
		If $ISOBJECT(hhclass) {
			Set classnameele=hhclass.findFirstElementByType("ClassReference",0)
			Set classname=classnameele.ToString(0)
			Set finaltype=..FollowObjectChainForType(hhclass,classname)
			$$$DEBUG("hhclass="_finaltype)
		} 
	}
    If finaltype'="" Quit finaltype

    ; looking for variable eg obj.property
	If variableElement.type="Variable" {
		Set finaltype=""
		Set variablename=variableElement.ToStringAtomsOnly(0)
		; when working out a type use the #DIM type if there is one
		; possible that name cannot be determined at this point eg {*}
		If variablename'="" {
			Set classname=$GET(..DimmedTypes(variablename))
			If classname="" Set classname=$GET(..VariablesTypes(variablename))
			If classname'=""	Set finaltype=..FollowObjectChainForType(variableElement,classname)
		}
	}
	$$$DEBUG("variable="_finaltype)
	If finaltype'="" Quit finaltype

	; this is not quite right but expressions are sooo complicated, need a generic
	; get "first thing in expression" method
	If variableElement.type="ThisObject" {
		Set thisobjectselfE=variableElement.findFirstElementByType("ThisObjectSelf",0)
		; otherwise its ..property
		If $ISOBJECT(thisobjectselfE) {
		Set finaltype=..FollowObjectChainForType(thisobjectselfE,..This)
		} Else {
			; check for $this.property
			Set thisobjectthisE=variableElement.findFirstElementByType("ThisObjectThis",0)
			If $ISOBJECT(thisobjectthisE) {
				Set finaltype=..FollowObjectChainForType(thisobjectthisE,..This)
			}
		}
	}
	$$$DEBUG("thisobject="_finaltype)
	If finaltype'="" Quit finaltype

	Quit finaltype
]]></Implementation>
</Method>

<Method name="FullClassName">
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If name="" Quit ""
	Set fullname=..ClassServer.FullClassName(name)
	Quit fullname
]]></Implementation>
</Method>

<Method name="SimplifyExpression">
<Description>
Pass in an expression element, this will return:
- if the expression is ONLY a variable (which could be an object with . etc or a global).
the String if the expression is ONLY a string.
the Number if the expression is ONLY a number.
If there is anything else eg 1+1, then this is complex (for now) so it will return -.</Description>
<FormalSpec>expressionElement:PXW.DEV.Element,*variableElement:PXW.DEV.Element</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[

	; var+1 as an expression looks like this:
	;.Element=Expression PXW.DEV.BNF.Element @19
	;..Element=Factor PXW.DEV.BNF.Element @8
	;...Element=Primary PXW.DEV.BNF.Element @3
	;....Element=Variable PXW.DEV.BNF.Element @54
	;.....type=Variable:/Expression/Factor/Primary/Variable
	;..... var
	;..Element=ExpressionRep76 PXW.DEV.BNF.Element @15
	;...Element=ExpressionRep76Grp75 PXW.DEV.BNF.Element @4
	;....Element=Dyadicop PXW.DEV.BNF.Element @2
	;.....type=punctuation:/Expression/Dyadicop
	;..... +
	;....Element=Factor PXW.DEV.BNF.Element @33
	;.....Element=Primary PXW.DEV.BNF.Element @45
	;......Element=Number PXW.DEV.BNF.Element @28
	;.......type=number:/Expression/Factor/Primary/Number
	;....... 1
	
	; more than 1 child means complex
	Set variableElement=""
	If expressionElement.partsCount()>1 Quit "-"


	Set factorE=expressionElement.partsGetAt(1)
	Set primaryOrMonE=factorE.partsGetAt(1)
	; 1 as an expression looks like this:
	;.Element=Expression PXW.DEV.BNF.Element @1
	;..Element=Factor PXW.DEV.BNF.Element @63
	;...Element=Primary PXW.DEV.BNF.Element @2
	;....Element=Number PXW.DEV.BNF.Element @37
	;.....type=number:/Expression/Factor/Primary/Number
	;..... 1

	; var as an expression looks like this:
	;.Element=Expression PXW.DEV.BNF.Element @19
	;..Element=Factor PXW.DEV.BNF.Element @8
	;...Element=Primary PXW.DEV.BNF.Element @3
	;....Element=Variable PXW.DEV.BNF.Element @54
	;.....type=Variable:/Expression/Factor/Primary/Variable
	;..... var

	; -1 as an expression
	;..Element=Factor PXW.DEV.BNF.Element @33
	;...Element=Monadicop PXW.DEV.BNF.Element @63
	;....type=keyword:/Expression/Factor/Monadicop
	;.... -
	;...Element=Primary PXW.DEV.BNF.Element @54
	;....Element=Number PXW.DEV.BNF.Element @11
	;.....type=number:/Expression/Factor/Primary/Number
	;..... 1
	
	Set type=""
	If primaryOrMonE.type="Primary" {
		; simple
		Set lowest=primaryOrMonE.partsGetAt(1)
		If lowest.type="Number" {
			Set type=lowest.ToString(0)
		} ElseIf lowest.type="String" {
			Set type=lowest.ToString(0)
		} Else {
			Set type="-"
			Set variableElement=lowest
		} 
	} Else {
		; -expression
		; simple
		Set mlowest=factorE.partsGetAt(2)
		If mlowest.type="Number" {
			Set type=primaryOrMonE.ToString(0)
		} Else {
			Set type="-"
		} 
	}
	Quit type
]]></Implementation>
</Method>

<Method name="SimplifySubscripts">
<Description>
Pass in a list of subscripts and this will return a string that looks like this
-:"string":222:-
where - means its a variable 
      "string" is a constant string
      222 is a constant number
The subscripts are delimited by : because , has other uses in the xref api 


This especially hilights the case for dedicated special objects that
can be built to hold specific things (ie a list of parameters)
or at least a "fixed" sub element type for repeat groups (rather that the random names assigned now)
This is an instance method because in the future we might want to check the VALUE of variables
- it doesn't now, but planning ahead...</Description>
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set ret=""
	If element.type="SubscriptParameterList" {
		;Set bracket=element.partsGetAt(1)
		Set first=element.partsGetAt(2)
		If $ISOBJECT(first) {
			Set type=..SimplifyExpression(first)
			Set ret=ret_type

			Set others=element.partsGetAt(3) ; the repeat group
			If $ISOBJECT(others),others.%IsA("PXW.DEV.Element") {
				For i=2:2:others.partsCount() {
					Set exp=others.partsGetAt(i)
					If $ISOBJECT(exp) {
						Set type=..SimplifyExpression(exp)
						Set ret=ret_":"_type
					}
				}
			}
		}
	}
	Quit ret
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Analyse.Python">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77562.354678026</TimeChanged>
<TimeCreated>67125,77562.354678026</TimeCreated>

<Property name="This">
<Type>%String</Type>
</Property>

<Property name="ThisMethod">
<Type>%String</Type>
</Property>

<Property name="ParameterVariables">
<Description>
Keep track of variable types passed in as parameters
..ParameterVariables(varname)=type</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="Reset">
<Implementation><![CDATA[	Kill ..ParameterVariables
]]></Implementation>
</Method>

<Method name="middle">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[ 	Do ..checkElement(element)
]]></Implementation>
</Method>

<Method name="IsParameterVariable">
<FormalSpec>var:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If var="" Quit 0
	If $DATA(i%ParameterVariables(var)) Quit 1
	Quit 0
]]></Implementation>
</Method>

<Method name="checkElement">
<Description>
best to analyse the entire codeblock all at once.</Description>
<FormalSpec>element:PXW.DEV.BNF.Elements.Python</FormalSpec>
<Implementation><![CDATA[
	#dim a as PXW.DEV.Atom

    If element.type="Param" {
        Set param=element.ToString(0)
        If param'="" Set ..ParameterVariables(param)=1
    }

	Set allAtOnce=1
	If allAtOnce {
		Set akey=""
		For  {
			Set a=element.partsGetNext(.akey)
			Quit:akey=""
			
			If a.%IsA("PXW.DEV.Element") {
				Do ..checkElement(a)
			} 
		}
	}
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Analyse.SQL">
<Super>%RegisteredObject</Super>
<TimeChanged>67128,69705.317368194</TimeChanged>
<TimeCreated>67125,77562.38912717</TimeCreated>

<Property name="This">
<Description>
Name of the class where the SQL belongs</Description>
<Type>%String</Type>
</Property>

<Property name="ClassServer">
<Type>PXW.DEV.Dictionary.ClassDefinitionObject</Type>
</Property>

<Property name="columnReferences">
<Description>
Keyed by column reference element
the data is $lb(fulltablereference,fullfieldname)
where fullfieldname is all the implicit joins strung together</Description>
<Type>%List</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="columnReferencesElement">
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="SelectedColumnsByName">
<Description>
SelectedColumnsByName(colname)=table</Description>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="WithCommandAnalysis">
<Type>PXW.DEV.BNF.Analyse.SQL</Type>
</Property>

<Property name="WithClauseAnalysis">
<Type>PXW.DEV.BNF.Analyse.SQL</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="%OnNew">
<FormalSpec>ClassServer:PXW.DEV.Dictionary.ClassDefinitionObject=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..ClassServer=ClassServer
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetColumnReference">
<Description>
Full table should be full_table.name </Description>
<FormalSpec>element:PXW.DEV.Element,fulltable:%String,fullfieldname:%String</FormalSpec>
<Implementation><![CDATA[
    Set ..columnReferences(+element)=$LISTBUILD(fulltable,fullfieldname)
    Set ..columnReferencesElement(+element)=element
]]></Implementation>
</Method>

<Method name="GetColumnReference">
<FormalSpec>element:PXW.DEV.Element,*fulltable:%String,*fullfieldname:%String</FormalSpec>
<Implementation><![CDATA[
    Set list=$GET(..columnReferences(+element))
    Set fulltable=$LISTGET(list,1)
    Set fullfieldname=$LISTGET(list,2)
]]></Implementation>
</Method>

<Method name="NextColumnReference">
<FormalSpec><![CDATA[&element:PXW.DEV.Element,*fulltable:%String,*fullfieldname:%String]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Set ret=0
    Set key=+element
    Set key=$ORDER(..columnReferencesElement(key))
    If key'="" {
        Set element=$GET(..columnReferencesElement(key))
        Do ..GetColumnReference(element,.fulltable,.fullfieldname)
        Set ret=1
    }
    Quit ret
]]></Implementation>
</Method>

<Method name="checkElement">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    If element.type="WithCommand" {
        Do ..WithCommand(element)
    }
    If element.type="SelectCommand" {
        Do ..SelectCommand(element)
    }
    If element.type="InsertCommand" {
        Do ..InsertCommand(element)
    }
    If element.type="DeleteCommand" {
        Do ..DeleteCommand(element)
    }
]]></Implementation>
</Method>

<Method name="WithCommand">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    #dim withClauseList as %ListOfObjects
	Do element.findElementsByType("WithClause",.withClauseList)
	;zw element,withClauseList
	For i=1:1:withClauseList.Count() {
		#dim withE as PXW.DEV.Element
		Set withE=withClauseList.GetAt(i)
		Set aliasE=withE.findFirstElementByType("AliasName")	    
	    If $ISOBJECT(aliasE) {
		    Set aliasname=aliasE.ToString(0)
			Set selectE=withE.findFirstElementByType("SelectCommand")
			Set analyser=..%New()
			Set analyser.ClassServer=..ClassServer
			Set analyser.WithCommandAnalysis=$THIS
			Do analyser.SelectCommand(selectE)
			Set ..WithClauseAnalysis(aliasname)=analyser
	    }
	}
]]></Implementation>
</Method>

<Method name="SelectCommand">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    #dim from as PXW.DEV.Element
    Set from=""
    Set tableexpE=element.findFirstElementByType("TableExpression",0)
    If $ISOBJECT(tableexpE) {
        Set from=tableexpE.findFirstElementByType("FromClause",0)
    }
    Kill tableelements,tables,columnelements,columns
    If $ISOBJECT(from) {
        Do ..findElementsByTypeNoSubQueries(from,"TableReference",.tableelements)
        Do ..findElementsByTypeNoSubQueries(from,"Join",.joins)
        If $ISOBJECT($GET(joins)) {
            For ji=1:1:joins.Count() {
                Do ..findElementsByTypeNoSubQueries(joins.GetAt(ji),"TableReference",.tableelements)
            }
        }
        If $ISOBJECT($GET(tableelements)) {
            #dim tref
            For ti=1:1:tableelements.Count() {
                Set tablename="",tablealias=" "
                Set tref=tableelements.GetAt(ti)
                ;w "<pre>tref="_tref.ToString(0)_"</pre>"
                Set tablenameE=tref.findFirstElementByType("TableName")
                If $ISOBJECT(tablenameE) Set tablename=tablenameE.ToString(0)
                ;w "<pre>" d tablenameE.write() zw tablename w "</pre>"
                Set tablealiasE=tref.findFirstElementByType("AliasName")
                If $ISOBJECT(tablealiasE) Set tablealias=tablealiasE.ToString(0)
                Set tables(tablealias)=tablename
            }
        }

        ; Work out all the column references and which tables they are on.
        ; This includes all the joins and where clauses etc
        ; eg SELECT col1,col2,col1+col2 as total FROM table WHERE col3=1
        ; will index col1,col2 and col3, with col1 and col2 referenced several times
        Do ..findElementsByTypeNoSubQueries(element,"ColumnReference",.columnelements)
        If $ISOBJECT($GET(columnelements)) {
            For ci=1:1:columnelements.Count() {
                Set columnname="",tablealias="",columnjoin=""
                Set cref=columnelements.GetAt(ci)
                Set fulltable=..FindTable(cref,.tables)
                Set columnnameE=cref.findFirstElementByType("ColumnName",0)
                If $ISOBJECT(columnnameE) Set columnname=columnnameE.ToString(0)
                Set columnjoinE=cref.findFirstElementByType("ColumnReferenceImplicit",0)
                If $ISOBJECT(columnjoinE) Set columnjoin=columnjoinE.ToString(0)

                ; wrap the entire column up as a single thing and work out later what 
                ; it refers to if its clicked on. EG Race->Circuit->Name
                If fulltable'="" {
                    Do ..SetColumnReference(cref,fulltable,columnname_columnjoin)
                } Else {
                    Do ..SetColumnReference(cref,"",columnname_columnjoin)                        
                }
            }
        }

        ; Work out all the column references and which tables they are on.
        ; This includes all the joins and where clauses etc
        ; eg SELECT col1,col2,col1+col2 as total FROM table WHERE col3=1
        ; will index col1,col2,total with col1 and col2 having information about which table they relate to.
        Do ..findElementsByTypeNoSubQueries(element,"DerivedColumn",.derivedColumns)
        If $ISOBJECT($GET(derivedColumns)) {
            For ci=1:1:derivedColumns.Count() {
                Set colE=derivedColumns.GetAt(ci)
                Set colname="unknown"_ci
                Do ..GetDerivedColumnInfo(colE,.colname,.cref)
                ;zw colE,colname
                Set fulltable=..FindTable(cref,.tables)
                Set ..SelectedColumnsByName(colname)=fulltable
            }
        }
    }
]]></Implementation>
</Method>

<Method name="GetDerivedColumnInfo">
<Description>
Pass in an element of type DerivedColumn and a default name. 
DervivedColumns are columns from the select list, 
SELECT col1,col2,col1+col2 as total FROM table WHERE col3=1
col1,col2 and total are the DerivedColumns, 
col1 and col2 will return the ColumnReference type element because they are direct refs to a table
For cols that use implict joins only the first table in the chain is returned.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[DerivedColumn:PXW.DEV.Element,&ColName:%String,*ColumnReference:PXW.DEV.Element]]></FormalSpec>
<Implementation><![CDATA[
    Set ColName="unknown"
    Set ColumnReference=""
    ; if the column is just a reference to another column
    Do DerivedColumn.findElementsByType("ColumnReference",.colrefs,2)
    If $ISOBJECT($GET(colrefs)),colrefs.Count()=1 {
        Set ColumnReference=colrefs.GetAt(1)
        Set colnameE=colrefs.GetAt(1).findFirstElementByType("ColumnName",0)
        If $ISOBJECT(colnameE) {
            Set ColName=$$$UPPER(colnameE.ToString(0))
        }
    }
 
    Set asclause=DerivedColumn.findFirstElementByType("AsClause",0)
    If $ISOBJECT(asclause) {
        Set colnameE=asclause.findFirstElementByType("ColumnName",0)
        If $ISOBJECT(colnameE) {
            Set ColName=$$$UPPER(colnameE.ToString(0))
        }
    } 
    ; remove quotes surrounding any names
    Set ColName=$TRANSLATE(ColName,"""","")
]]></Implementation>
</Method>

<Method name="InsertCommand">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    #dim from as PXW.DEV.Element
    Set tableE=element.findFirstElementByType("DirectTable",0)
    If $ISOBJECT(tableE) {
        Set table=tableE.ToString(0)

        Set methodE=element.findFirstElementByType("InsertMethod")
        Set methodFirstE=methodE.partsGetAt(1)
        If methodFirstE.type="InsertValuesList" {
            Do ..findElementsByTypeNoSubQueries(methodE,"ColumnName",.columnelements)
            If $ISOBJECT($GET(columnelements)) {
                For ci=1:1:columnelements.Count() {
                    Set columnnameE=columnelements.GetAt(ci)
                    Set columnname=columnnameE.ToString(0)
                    Set fulltable=..ClassServer.GetFullTableName(table,..This)
                    Do ..SetColumnReference(columnnameE,fulltable,columnname)
                    
                }
            }
        }
    }
]]></Implementation>
</Method>

<Method name="DeleteCommand">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    #dim from as PXW.DEV.Element
    Set tableE=element.findFirstElementByType("DirectTable",0)
    If $ISOBJECT(tableE) {
        Set table=tableE.ToString(0)

        Do ..findElementsByTypeNoSubQueries(element,"ColumnName",.columnelements)
        If $ISOBJECT($GET(columnelements)) {
            For ci=1:1:columnelements.Count() {
                Set columnnameE=columnelements.GetAt(ci)
                Set columnname=columnnameE.ToString(0)
                Set fulltable=..ClassServer.GetFullTableName(table,..This)
                Do ..SetColumnReference(columnnameE,fulltable,columnname)          
            }
        }
    }
]]></Implementation>
</Method>

<Method name="findElementsByTypeNoSubQueries">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Object:PXW.DEV.Element,Type:%String,&OutputList:%ListOfObjects]]></FormalSpec>
<Implementation><![CDATA[
    #dim ele as PXW.DEV.Element
    If Object.type=Type {
        If '$ISOBJECT($GET(OutputList)) { 
            Set OutputList=##class(%Library.ListOfObjects).%New()
        }
        Do OutputList.Insert(Object)				
    }
	For i=1:1:Object.partsCount() {
		Set ele=Object.partsGetAt(i)
		If ele.%IsA("PXW.DEV.Element") {
            Set derived=ele.findFirstElementByType("DerivedTable",0)
            Set subquery=ele.findFirstElementByType("SubquerySpecification",0)
			If $ISOBJECT(derived) || $ISOBJECT(subquery) {
				; do nothing for select
			} Else {
				Do ..findElementsByTypeNoSubQueries(ele,Type,.OutputList)
			}
		}
	}
]]></Implementation>
</Method>

<Method name="FindTable">
<Description>
Pass in an element of type ColumnReference, and the known tables keyed by alias
returns the full table name of the column</Description>
<FormalSpec><![CDATA[cref:PXW.DEV.Element,&tables]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    If '$ISOBJECT(cref) Quit ""

    Set columnname="",tablealias=""
    Set tablealiasE=cref.findFirstElementByType("AliasName")
    If $ISOBJECT(tablealiasE) Set tablealias=tablealiasE.ToString(0)
    Set columnnameE=cref.findFirstElementByType("ColumnName",0)
    If $ISOBJECT(columnnameE) Set columnname=columnnameE.ToString(0)
    ;Set columnjoin=""
    ;Set columnjoinE=cref.findFirstElementByType("ColumnReferenceImplicit",0)
    ;If $ISOBJECT(columnjoinE) Set columnjoin=columnjoinE.ToString(0)
    ; if there is no alias and there is 1 table only then we can use that as the alias
    ; note than on SUB SELECTS the parent tables are available.
    If tablealias="",$ORDER(tables(""))=$ORDER(tables(""),-1) Set tablealias=$ORDER(tables("")) 
    ; if still not found then try all the tables looking for one that has this field
    ; note the array will have " " as the first key, which means if this is a sub select then likely the first one will be the current table
    ; this solves solves the issue of sql like this:
    ; SELECT res.Code ,
    ;        (select Code from f1_data.race where id=res.Race)
    ; FROM f1_data.result as res
    ; we want the Code on the sub select to be from RACE rather than the parent "res"
    ;w !,"tabelalias="_tablealias_",columnname="_columnname_", coltext="_cref.ToString(0)
    If tablealias="" {
        Set a2=""
        For  {
            Set a2=$ORDER(tables(a2))
            Quit:a2=""
            ;s class=$g(tables($$$UPPER(a2)))
            Set table=$GET(tables(a2))
            If table'="" {
                Set class=..ClassServer.GetClassNameFromTableName(table,..This)   
                Set pname=..ClassServer.GetPropertyNameSQL(class,columnname)
                If pname'="" {
                    Set tablealias=a2
                    Quit  
                }
            }
        }
    }
    
    Set fulltable=""
    If tablealias'="" {
        Set fulltable=$GET(tables(tablealias))
        If fulltable="" {
        ;    s tablealias=$o(tables(""))
        ;    i tablealias'="" s fulltable=$g(tables(tablealias))
        } Else {
            Set fulltable=..ClassServer.GetFullTableName(fulltable,..This)
        }
    }
    Quit fulltable
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Compilers.BNF1">
<Description><![CDATA[
<p>Going to get a bit weird here, a bnf definition of bnf that is written to decode itself and regerate the decoder!</p>]]></Description>
<Super>PXW.DEV.BNF.Compilers.loader</Super>
<TimeChanged>67125,77562.386305478</TimeChanged>
<TimeCreated>67125,77562.386305478</TimeCreated>

<Projection name="GEN">
<Description>
This will generate into PXW.DEV.BNF.GEN.BNF2 but that class is not used.
The code will need to be copied from PXW.DEV.BNF.GEN.BNF2 to PXW.DEV.BNF.Compilers.BNF2safe</Description>
<Type>PXW.DEV.BNF.Compilers.projection</Type>
<Parameter name="GenerateTo" value="PXW.DEV.BNF.GEN.BNF1"/>
</Projection>

<XData name="file">
<Data><![CDATA[
<bnf>
<data><![CDATA[

/*
 eg
    
*/

file            ::= definition*
definition      ::= IDENTIFIER EQUALS rules
rules           ::= rule*
rule            ::= repeat_sep | repeat_zero | repeat_one | optional_single | KEYWORD | or | subrule | optional_group | call | look_ahead | not_rule
or              ::= '|'
repeat          ::= repeat_zero | repeat_one
repeat_zero     ::= repeatable_rule '*'            # 0 or more items 
repeat_one      ::= repeatable_rule '+'            # 1 or more items 
repeatable_rule ::= KEYWORD | subrule | call

subrule         ::= '(' rules ')'
optional_group  ::= '[' rules ']'                  # something in [], [ item ] means item is optional, [ item | other ] means either item or other can be there 

optional_single ::= optionalable_rule '?'          # rule::=command post_conditional? -- post_conditional is optional 
optionalable_rule ::= KEYWORD | subrule | call

call            ::= IDENTIFIER 

repeat_sep      ::= repeat_sep_separator '.' repeat_sep_rule '+'   # s.e+ 
repeat_sep_separator ::= KEYWORD | subrule | call 
repeat_sep_rule ::= KEYWORD | subrule | call 

look_ahead      ::= '&' look_ahead_rule
look_ahead_rule ::=  KEYWORD | subrule | call 

not_rule        ::= '!' notable_rule
notable_rule    ::= KEYWORD | subrule | call 



IDENTIFIER ::= 'NEEDS IDENTIFIER'
KEYWORD ::= 'NEEDS STRING'
EQUALS ::= 'NEEDS EQUALS'
    ]]]]><![CDATA[>

    </data></bnf>
]]></Data>
</XData>
</Class>


<Class name="PXW.DEV.BNF.Compilers.BNF1safe">
<Description>
This class was created by Generating PXW.DEV.BNF.GEN.BNF1 and then copying the code into here.
The idea is that this code is never generated directly by compiling something and therefore
potentially breaking the bnf compiler beyond compare.

There ARE some tweaks in here so do NOT replace methods from newly generated versions without 
thinking carefully.

Using this method of working the compiler should remain safe - hence the name.

Maybe we can go further and remove references to macros.</Description>
<Super>PXW.DEV.BNF.super</Super>
<TimeChanged>67125,77562.429013245</TimeChanged>
<TimeCreated>67125,77562.429013245</TimeCreated>

<UDLText name="T">
<Content><![CDATA[/* TWEAKED METHODS */
]]></Content>
</UDLText>

<Property name="commentMode">
<Description>
Set to CDEF, COS</Description>
<Type>%String</Type>
<InitialExpression>"BNF"</InitialExpression>
</Property>

<Method name="Call">
<Description>
Its a call to something else if we are at the START of the line</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
    ; labels only defined in first column (0)
    $$$DEBUG("Call col="_..stream.col)

    ; at the start so NOT a call to something else, this is probably a definition
	If ..stream.col=0 Quit 0

	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Identifier(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Keyword">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    #dim o as PXW.DEV.Atom

    $$$DEBUGMethodBegin
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
   
	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Set ok=1
    Set open=..peek(1)
    If open'="""",open'="'" {
        Set ok=0
    }

    If ok {
        $$$BNFSTART(subElement)

        Set dummy=..next()
        Set n=""
        Set instring=1
        While '..eof() && instring {
            Set chs=..peek(2)
            Set ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,2)
            ; embedded quotes or end of string?
            ; I am not sure how these get encoded so sticking with COS "" for quotes in quotes
            If ch=open {
                If ch2=open {
                    Set n=n_..next()_..next()
                } Else {
                    Set instring=0
                    ;Set n=n_..next()
                    Set dummy=..next()
                }
            } Else {
                Set n=n_..next()
            }
        }
        Set o=..newAtom("String",n)
        Set o.start=open,o.end=open
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="Identifier">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    Set ch=..peek(1)
    ; must start with a letter
    If value="",ch?1A Set value=..next()
    
    If value="" {
        $$$DEBUG("checking identifier, ok=0")
        Quit 0
    }
    Set ch=..peek(1)
    While (ch?1A) || (ch?1N) || (ch="_") || (ch="-")  {
        Set value=value_..next()
		;zw value,..stream.pos
        Set ch=..peek(1)
    }
    
    Set atom=..newAtom(ParentElement.type,value)
    Do ParentElement.AddPart(atom)

    Quit 1
]]></Implementation>
</Method>

<Method name="Equals">
<Description>
EQUALS ::= 'NEEDS EQUALS'
 summary=S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	If ..isStringSingle("::=",.value)=0 Quit 0 ; q1 
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; t1 
	; type=group, check=if, skip=1, skipall=1
	Set getVal=..nextNotEOL($LENGTH(value)),atom=..newAtom(..#keywordAtomType,getVal) ; k1 
	Do subElement.AddPart(atom) ; t3 
	If 1	 {
		Set done=1 ; u1 

	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Definition">
<Description><![CDATA[
definition ::= IDENTIFIER EQUALS rules
 summary=F&F&F
 type=group
 not=0]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C&C&C
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Identifier(subElement,.addedElement)  {
		If ..Equals(subElement,.addedElement)  {
			If ..Rules(subElement,.addedElement)  {
				Set done=1 ; end compileRules
			}
		}
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    If ret=0 {
        Set ret=..recover(ParentElement,.recSub,"",$LISTBUILD($CHAR(13)))
    }

	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="skipComments">
<Description>
Skip over the next set of comments, return 1 if something was done or 0</Description>
<FormalSpec>ch10:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If $EXTRACT(ch10,1,1)="#" Set ..comment=..readLineComment("#") Quit 1
    If $EXTRACT(ch10,1,2)="//" Set ..comment=..readLineComment("//") Quit 1
    If $EXTRACT(ch10,1,2)="--" Set ..comment=..readLineComment("--") Quit 1
    If $EXTRACT(ch10,1,2)="/*" Set ..comment=..readBlockComment() Quit 1
    Quit 0
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/* 
    
    DIRECTLY COPIED METHODS 

*/
]]></Content>
</UDLText>

<Method name="File">
<Description>
 file ::= definition*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	#dim a as PXW.DEV.BNF.GEN.BNF1
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..File1RepZero(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="File1RepZero">
<Description>
 definition*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	Set subElement=ParentElement
	Set done=0 ; method start
	While ..Definition(subElement,.addedElement)  {
		Set done=1
	}
	If done {
		Set ret=1
	} Else {
		Set ret=1 /* nothing found is ok in RZ */
	}
	Quit ret
]]></Implementation>
</Method>

<Method name="LookAhead">
<Description><![CDATA[
 look_ahead ::= '&' look_ahead_rule
summary values:&]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&C
	; first rule summary P
	If '(..isStringSingle("&",.value)) { Quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..addPunctuation(subElement,"&")  {
		If ..LookAheadRule(subElement,.addedElement)  {
			Set done=1 ; end compileRules
		}
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="LookAheadRule">
<Description>
 look_ahead_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C|C|C
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="NotRule">
<Description>
 not_rule ::= '!' notable_rule
summary values:!</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&C
	; first rule summary P
	If '(..isStringSingle("!",.value)) { Quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..addPunctuation(subElement,"!")  {
		If ..NotableRule(subElement,.addedElement)  {
			Set done=1 ; end compileRules
		}
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="NotableRule">
<Description>
 notable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C|C|C
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="OptionalGroup">
<Description>
 optional_group ::= '[' rules ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&C&P
	; first rule summary P
	If '(..isStringSingle("[",.value)) { Quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..addPunctuation(subElement,"[")  {
		If ..Rules(subElement,.addedElement)  {
			If ..addPunctuation(subElement,"]")  {
				Set done=1 ; end compileRules
			}
		}
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="OptionalSingle">
<Description>
 optional_single ::= optionalable_rule '?'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..OptionalableRule(subElement,.addedElement)  {
		If ..addPunctuation(subElement,"?")  {
			Set done=1 ; end compileRules
		}
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="OptionalableRule">
<Description>
 optionalable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C|C|C
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Or">
<Description>
 or ::= '|'
summary values:|</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	If '(..isStringSingle("|",.value)) { Quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..addPunctuation(subElement,"|")  {
		Set done=1 ; end compileRules
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Repeat">
<Description>
 repeat ::= repeat_zero | repeat_one</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C|C
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..RepeatZero(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..RepeatOne(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="RepeatOne">
<Description>
 repeat_one ::= repeatable_rule '+'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..RepeatableRule(subElement,.addedElement)  {
		If ..addPunctuation(subElement,"+")  {
			Set done=1 ; end compileRules
		}
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="RepeatSep">
<Description>
 repeat_sep ::= repeat_sep_separator '.' repeat_sep_rule '+'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C&P&C&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..RepeatSepSeparator(subElement,.addedElement)  {
		If ..addPunctuation(subElement,".")  {
			If ..RepeatSepRule(subElement,.addedElement)  {
				If ..addPunctuation(subElement,"+")  {
					Set done=1 ; end compileRules
				}
			}
		}
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="RepeatSepRule">
<Description>
 repeat_sep_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C|C|C
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="RepeatSepSeparator">
<Description>
 repeat_sep_separator ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C|C|C
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="RepeatZero">
<Description>
 repeat_zero ::= repeatable_rule '*'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..RepeatableRule(subElement,.addedElement)  {
		If ..addPunctuation(subElement,"*")  {
			Set done=1 ; end compileRules
		}
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="RepeatableRule">
<Description>
 repeatable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C|C|C
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Rule">
<Description>
 rule ::= repeat_sep | repeat_zero | repeat_one | optional_single | KEYWORD | or | subrule | optional_group | call | look_ahead | not_rule</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary C|C|C|C|C|C|C|C|C|C|C
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..RepeatSep(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..RepeatZero(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..RepeatOne(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..OptionalSingle(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Or(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..OptionalGroup(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..LookAhead(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..NotRule(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Rules">
<Description>
 rules ::= rule*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Rules2RepZero(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Rules2RepZero">
<Description>
 rule*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	Set subElement=ParentElement
	Set done=0 ; method start
	While ..Rule(subElement,.addedElement)  {
		Set done=1
	}
	If done {
		Set ret=1
	} Else {
		Set ret=1 /* nothing found is ok in RZ */
	}
	Quit ret
]]></Implementation>
</Method>

<Method name="Subrule">
<Description>
 subrule ::= '(' rules ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&C&P
	; first rule summary P
	If '(..isStringSingle("(",.value)) { Quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..addPunctuation(subElement,"(")  {
		If ..Rules(subElement,.addedElement)  {
			If ..addPunctuation(subElement,")")  {
				Set done=1 ; end compileRules
			}
		}
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Element</ReturnType>
<Implementation><![CDATA[	Quit ##class(PXW.DEV.BNF.Element).%New(Type)
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Compilers.BNF2">
<Super>PXW.DEV.BNF.Compilers.loader</Super>
<TimeChanged>67125,77562.417353859</TimeChanged>
<TimeCreated>67125,77562.417353859</TimeCreated>

<Projection name="GEN">
<Description>
This will generate into PXW.DEV.BNF.GEN.BNF2 but that class is not used.
The code will need to be copied from PXW.DEV.BNF.GEN.BNF2 to PXW.DEV.BNF.Compilers.BNF2safe</Description>
<Type>PXW.DEV.BNF.Compilers.projection</Type>
<Parameter name="GenerateTo" value="PXW.DEV.BNF.GEN.BNF2"/>
</Projection>

<XData name="file">
<Data><![CDATA[
<bnf>
<data><![CDATA[

# e1 e2
#   Match e1, then match e2.
# e1 | e2
#   Match e1 or e2.
#   The first alternative can also appear on the line after the rule name for
#   formatting purposes. In that case, a | must be used before the first
#   alternative, like so:
#       rule_name[return_type]:
#            | first_alt
#            | second_alt
# ( e )
#   Match e (allows also to use other operators in the group like '(e)*')
# [ e ] or e?
#   Optionally match e.
# e*
#   Match zero or more occurrences of e.
# e+
#   Match one or more occurrences of e.
# s.e+
#   Match one or more occurrences of e, separated by s. The generated parse tree
#   does not include the separator. This is otherwise identical to (e (s e)*).
# &e
#   Succeed if e can be parsed, without consuming any input.
# !e
#   Fail if e can be parsed, without consuming any input.
# ~
#   Commit to the current alternative, even if it fails to parse.
#

file            ::= definition*
definition      ::= IDENTIFIER EQUALS rules
rules           ::= rule* or_rules*
rule            ::= repeat_sep | repeat_zero | repeat_one | optional_single | KEYWORD | subrule | optional_group | call | look_ahead | not_rule | force
or_rules        ::= '|' rule*
repeat          ::= repeat_zero | repeat_one
repeat_zero     ::= repeatable_rule '*'            # 0 or more items 
repeat_one      ::= repeatable_rule '+'            # 1 or more items 
repeatable_rule ::= KEYWORD | subrule | call

subrule         ::= '(' rules ')'
optional_group  ::= '[' rules ']'                  # something in [], [ item ] means item is optional, [ item | other ] means either item or other can be there 

optional_single ::= optionalable_rule '?'          # rule::=command post_conditional? -- post_conditional is optional 
optionalable_rule ::= KEYWORD | subrule | call

call            ::= IDENTIFIER 

repeat_sep      ::= repeat_sep_separator '.' repeat_sep_rule '+'   # s.e+ 
repeat_sep_separator ::= KEYWORD | subrule | call 
repeat_sep_rule ::= KEYWORD | subrule | call 

look_ahead      ::= '&' look_ahead_rule
look_ahead_rule ::=  KEYWORD | subrule | call 

not_rule        ::= '!' notable_rule
notable_rule    ::= KEYWORD | subrule | call 

force           ::= "~" # NOT SURE WHAT THIS IS


IDENTIFIER ::= 'NEEDS IDENTIFIER'
KEYWORD ::= 'NEEDS STRING'
EQUALS ::= 'NEEDS EQUALS'    ]]]]><![CDATA[>

    </data></bnf>
]]></Data>
</XData>
</Class>


<Class name="PXW.DEV.BNF.Compilers.BNF2safe">
<Description>
This class was created by Generating PXW.DEV.BNF.GEN.BNF2 and then copying the code into here.
The idea is that this code is never generated directly by compiling something and therefore
potentially breaking the bnf compiler beyond compare.

There ARE some tweaks in here so do NOT replace methods from newly generated versions without 
thinking carefully.

Using this method of working the compiler should remain safe - hence the name.

Maybe we can go further and remove references to macros.</Description>
<Super>PXW.DEV.BNF.super</Super>
<TimeChanged>67125,77562.428229099</TimeChanged>
<TimeCreated>67125,77562.428229099</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// Set to CDEF, COS

]]></Content>
</UDLText>

<Property name="commentMode">
<Type>%String</Type>
<InitialExpression>"BNF"</InitialExpression>
</Property>

<Property name="EqualsChars">
<Type>%String</Type>
<InitialExpression>":"</InitialExpression>
</Property>

<UDLText name="T">
<Content><![CDATA[/* TWEAKED METHODS */
]]></Content>
</UDLText>

<Method name="Call">
<Description>
Its a call to something else if we are at the START of the line</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
   $$$DEBUGMethodBegin
	;set currentpath=$g(%path) new %path set %path=currentpath_$c(47)_"LabelDefinition"
    ;;$$$DEBUG("%path="_%path)
    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
    ; labels only defined in first column (0)
    $$$DEBUG("Call col="_..stream.col)

    ; at the start so NOT a call to something else, this is probably a definition
	If ..stream.col=0 Quit 0

	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Identifier(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
 
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="Keyword">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    #dim o as PXW.DEV.Atom

    $$$DEBUGMethodBegin
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
   
	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Set ok=1
    Set open=..peek(1)
    If open'="""",open'="'" {
        Set ok=0
    }

    If ok {
        $$$BNFSTART(subElement)

        Set dummy=..next()
        Set n=""
        Set instring=1
        While '..eof() && instring {
            Set chs=..peek(2)
            Set ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,2)
            ; embedded quotes or end of string?
            ; I am not sure how these get encoded so sticking with COS "" for quotes in quotes
            If ch=open {
                If ch2=open {
                    Set n=n_..next()_..next()
                } Else {
                    Set instring=0
                    ;Set n=n_..next()
                    Set dummy=..next()
                }
            } Else {
                Set n=n_..next()
            }
        }
        Set o=..newAtom("String",n)
        Set o.start=open,o.end=open
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="Identifier">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    Set ch=..peek(1)
    ; must start with a letter
    If value="",ch?1A Set value=..next()
    
    If value="" {
        $$$DEBUG("checking identifier, ok=0")
        Quit 0
    }
    Set ch=..peek(1)
    While (ch?1A) || (ch?1N) || (ch="_") || (ch="-")  {
        Set value=value_..next()
		;zw value,..stream.pos
        Set ch=..peek(1)
    }
    
    Set atom=..newAtom(ParentElement.type,value)
    Do ParentElement.AddPart(atom)

    Quit 1
]]></Implementation>
</Method>

<Method name="Equals">
<Description>
EQUALS ::= 'NEEDS EQUALS'
 summary=S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	If ..isStringSingle(..EqualsChars,.value)=0 Quit 0 ; q1 
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; t1 
	Set ownerElement=subElement
	; type=group, check=if, skip=1, skipall=1
	Set getVal=..nextNotEOL($LENGTH(value)),atom=..newAtom(..#keywordAtomType,getVal) ; k1 
	Do subElement.AddPart(atom) ; t3 
	If 1	 {
		Set done=1 ; u1 

	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Definition">
<Description><![CDATA[
definition ::= IDENTIFIER EQUALS rules
 summary=F&F&F
 type=group
 not=0]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Identifier(subElement,.addedElement)  {
		If ..Equals(subElement,.addedElement)  {
			If ..Rules(subElement,.addedElement)  {
				Set done=1 ; end compileRules
			}
		}
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
    If ret=0 {
        Set ret=..recover(ParentElement,.recSub,"",$LISTBUILD($CHAR(13)))
    }

    Quit ret
]]></Implementation>
</Method>

<Method name="skipComments">
<Description>
Skip over the next set of comments, return 1 if something was done or 0</Description>
<FormalSpec>ch10:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If $EXTRACT(ch10,1,1)="#" Set ..comment=..readLineComment("#") Quit 1
    If $EXTRACT(ch10,1,2)="//" Set ..comment=..readLineComment("//") Quit 1
    If $EXTRACT(ch10,1,2)="--" Set ..comment=..readLineComment("--") Quit 1
    If $EXTRACT(ch10,1,2)="/*" Set ..comment=..readBlockComment() Quit 1
    Quit 0
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/* 
    
    DIRECTLY COPIED METHODS 

*/
]]></Content>
</UDLText>

<Method name="File">
<Description>
 file ::= definition*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..File1RepZero(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="File1RepZero">
<Description>
 definition*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	Set subElement=ParentElement
	Set done=0 ; method start
	While ..Definition(subElement,.addedElement)  {
		Set done=1
	}
	If done {
		Set ret=1
	} Else {
		Set ret=1 /* nothing found is ok in RZ */
	}
	Quit ret
]]></Implementation>
</Method>

<Method name="Force">
<Description>
 force ::= "~"
summary values:~</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	If '(..isStringSingle("~",.value)) { Quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..addPunctuation(subElement,"~")  {
		Set done=1 ; end compileRules
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="LookAhead">
<Description><![CDATA[
 look_ahead ::= '&' look_ahead_rule
summary values:&]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	If '(..isStringSingle("&",.value)) { Quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..addPunctuation(subElement,"&")  {
		If ..LookAheadRule(subElement,.addedElement)  {
			Set done=1 ; end compileRules
		}
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="LookAheadRule">
<Description>
 look_ahead_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="NotRule">
<Description>
 not_rule ::= '!' notable_rule
summary values:!</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	If '(..isStringSingle("!",.value)) { Quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..addPunctuation(subElement,"!")  {
		If ..NotableRule(subElement,.addedElement)  {
			Set done=1 ; end compileRules
		}
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="NotableRule">
<Description>
 notable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="OptionalGroup">
<Description>
 optional_group ::= '[' rules ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	If '(..isStringSingle("[",.value)) { Quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..addPunctuation(subElement,"[")  {
		If ..Rules(subElement,.addedElement)  {
			If ..addPunctuation(subElement,"]")  {
				Set done=1 ; end compileRules
			}
		}
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="OptionalSingle">
<Description>
 optional_single ::= optionalable_rule '?'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..OptionalableRule(subElement,.addedElement)  {
		If ..addPunctuation(subElement,"?")  {
			Set done=1 ; end compileRules
		}
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="OptionalableRule">
<Description>
 optionalable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="OrRules">
<Description>
 or_rules ::= '|' rule*
summary values:|</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&(?4?)*
	; first rule summary P
	If '(..isStringSingle("|",.value)) { Quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..addPunctuation(subElement,"|")  {
		If ..OrRules4RepZero(subElement,.addedElement)  {
			Set done=1 ; end compileRules
		}
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="OrRules4RepZero">
<Description>
 rule*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	Set subElement=ParentElement
	Set done=0 ; method start
	While ..Rule(subElement,.addedElement)  {
		Set done=1
	}
	If done {
		Set ret=1
	} Else {
		Set ret=1 /* nothing found is ok in RZ */
	}
	Quit ret
]]></Implementation>
</Method>

<Method name="Repeat">
<Description>
 repeat ::= repeat_zero | repeat_one</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..RepeatZero(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..RepeatOne(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="RepeatOne">
<Description>
 repeat_one ::= repeatable_rule '+'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..RepeatableRule(subElement,.addedElement)  {
		If ..addPunctuation(subElement,"+")  {
			Set done=1 ; end compileRules
		}
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="RepeatSep">
<Description>
 repeat_sep ::= repeat_sep_separator '.' repeat_sep_rule '+'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..RepeatSepSeparator(subElement,.addedElement)  {
		If ..addPunctuation(subElement,".")  {
			If ..RepeatSepRule(subElement,.addedElement)  {
				If ..addPunctuation(subElement,"+")  {
					Set done=1 ; end compileRules
				}
			}
		}
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="RepeatSepRule">
<Description>
 repeat_sep_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="RepeatSepSeparator">
<Description>
 repeat_sep_separator ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="RepeatZero">
<Description>
 repeat_zero ::= repeatable_rule '*'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..RepeatableRule(subElement,.addedElement)  {
		If ..addPunctuation(subElement,"*")  {
			Set done=1 ; end compileRules
		}
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="RepeatableRule">
<Description>
 repeatable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Rule">
<Description>
 rule ::= repeat_sep | repeat_zero | repeat_one | optional_single | KEYWORD | subrule | optional_group | call | look_ahead | not_rule | force</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..RepeatSep(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..RepeatZero(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..RepeatOne(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..OptionalSingle(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Keyword(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Subrule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..OptionalGroup(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Call(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..LookAhead(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..NotRule(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..Force(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Rules">
<Description>
 rules ::= rule* or_rules*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Rules2RepZero(subElement,.addedElement)  {
		If ..Rules3RepZero(subElement,.addedElement)  {
			Set done=1 ; end compileRules
		}
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Rules2RepZero">
<Description>
 rule*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	Set subElement=ParentElement
	Set done=0 ; method start
	While ..Rule(subElement,.addedElement)  {
		Set done=1
	}
	If done {
		Set ret=1
	} Else {
		Set ret=1 /* nothing found is ok in RZ */
	}
	Quit ret
]]></Implementation>
</Method>

<Method name="Rules3RepZero">
<Description>
 or_rules*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	Set subElement=ParentElement
	Set done=0 ; method start
	While ..OrRules(subElement,.addedElement)  {
		Set done=1
	}
	If done {
		Set ret=1
	} Else {
		Set ret=1 /* nothing found is ok in RZ */
	}
	Quit ret
]]></Implementation>
</Method>

<Method name="Subrule">
<Description>
 subrule ::= '(' rules ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	If '(..isStringSingle("(",.value)) { Quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..addPunctuation(subElement,"(")  {
		If ..Rules(subElement,.addedElement)  {
			If ..addPunctuation(subElement,")")  {
				Set done=1 ; end compileRules
			}
		}
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Element</ReturnType>
<Implementation><![CDATA[	Quit ##class(PXW.DEV.BNF.Element).%New(Type)
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Compilers.BNF3">
<Super>PXW.DEV.BNF.Compilers.loader</Super>
<TimeChanged>67125,77562.446648656</TimeChanged>
<TimeCreated>67125,77562.446648656</TimeCreated>

<Projection name="GEN">
<Description>
This will generate into PXW.DEV.BNF.GEN.BNF2 but that class is not used.
The code will need to be copied from PXW.DEV.BNF.GEN.BNF3 to PXW.DEV.BNF.Compilers.BNF3safe</Description>
<Type>PXW.DEV.BNF.Compilers.projection</Type>
<Parameter name="GenerateTo" value="PXW.DEV.BNF.GEN.BNF3"/>
</Projection>

<XData name="file">
<Data><![CDATA[
<bnf>
<data><![CDATA[

# e1 e2
#   Match e1, then match e2.
# e1 | e2
#   Match e1 or e2.
#   The first alternative can also appear on the line after the rule name for
#   formatting purposes. In that case, a | must be used before the first
#   alternative, like so:
#       rule_name[return_type]:
#            | first_alt
#            | second_alt
# ( e )
#   Match e (allows also to use other operators in the group like '(e)*')
# [ e ] or e?
#   Optionally match e.
# e*
#   Match zero or more occurrences of e.
# e+
#   Match one or more occurrences of e.
# s.e+
#   Match one or more occurrences of e, separated by s. The generated parse tree
#   does not include the separator. This is otherwise identical to (e (s e)*).
# &e
#   Succeed if e can be parsed, without consuming any input.
# !e
#   Fail if e can be parsed, without consuming any input.
# ~
#   Commit to the current alternative, even if it fails to parse.
#

file            ::= definition*
definition      ::= IDENTIFIER EQUALS (SINGLE_CHAR | omitted | rules)
rules           ::= rule* or_rules*
rule            ::= NEEDS_OVERRIDE | repeat_sep | repeat_zero | repeat_one | optional_single | KEYWORD | subrule | optional_group | call | look_ahead | not_rule | force
or_rules        ::= '|' rule*
repeat          ::= repeat_zero | repeat_one
repeat_zero     ::= repeatable_rule '*'            # 0 or more items 
repeat_one      ::= repeatable_rule '...'            # 1 or more items 
repeatable_rule ::= KEYWORD | subrule | call

subrule         ::= '{' rules '}' 
optional_group  ::= '[' rules ']'                  # something in [], [ item ] means item is optional, [ item | other ] means either item or other can be there 

optional_single ::= optionalable_rule '?'          # rule::=command post_conditional? -- post_conditional is optional 
optionalable_rule ::= KEYWORD | subrule | call

call            ::= IDENTIFIER 

repeat_sep      ::= repeat_sep_separator '.' repeat_sep_rule '+'   # s.e+ 
repeat_sep_separator ::= KEYWORD | subrule | call 
repeat_sep_rule ::= KEYWORD | subrule | call 

look_ahead      ::= '&' look_ahead_rule
look_ahead_rule ::=  KEYWORD | subrule | call 

not_rule        ::= '!' notable_rule
notable_rule    ::= KEYWORD | subrule | call 

force           ::= "~" # NOT SURE WHAT THIS IS

omitted         ::= "...omitted..."

NEEDS_OVERRIDE  ::= '!!'
IDENTIFIER ::= 'NEEDS IDENTIFIER'
KEYWORD ::= 'NEEDS STRING'
EQUALS ::= 'NEEDS EQUALS'
SINGLE_CHAR ::= 'NEEDS SINGLE CHAR'

    ]]]]><![CDATA[>

    </data></bnf>
]]></Data>
</XData>
</Class>


<Class name="PXW.DEV.BNF.Compilers.BNF3safe">
<Description>
This class was created by Generating PXW.DEV.BNF.GEN.BNF2 and then copying the code into here.
The idea is that this code is never generated directly by compiling something and therefore
potentially breaking the bnf compiler beyond compare.

There ARE some tweaks in here so do NOT replace methods from newly generated versions without 
thinking carefully.

Using this method of working the compiler should remain safe - hence the name.

Maybe we can go further and remove references to macros.</Description>
<Super>PXW.DEV.BNF.GEN.BNF3</Super>
<TimeChanged>67125,77562.466937153</TimeChanged>
<TimeCreated>67125,77562.466937153</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// Set to CDEF, COS

]]></Content>
</UDLText>

<Property name="commentMode">
<Type>%String</Type>
<InitialExpression>"BNF"</InitialExpression>
</Property>

<Property name="EqualsChars">
<Type>%String</Type>
<InitialExpression>"::="</InitialExpression>
</Property>

<UDLText name="T">
<Content><![CDATA[/* TWEAKED METHODS */
]]></Content>
</UDLText>

<Method name="Call">
<Description>
Its a call to something else if we are at the START of the line</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
   $$$DEBUGMethodBegin
	;set currentpath=$g(%path) new %path set %path=currentpath_$c(47)_"LabelDefinition"
    ;;$$$DEBUG("%path="_%path)
    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
    ; labels only defined in first column (0)
    $$$DEBUG("Call col="_..stream.col)

    ; at the start so NOT a call to something else, this is probably a definition
	If ..stream.col=0 Quit 0

	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; method start
	If ..Identifier(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}

	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0 ; normal rollback
	}
 
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="Keyword">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    #dim o as PXW.DEV.Atom

    $$$DEBUGMethodBegin
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

	; everything is a keyword unless its < { [ ... 
	s p2=..peek(2),ch1=$e(p2,1),ch2=$e(p2,2),cr=..stream.eolChar
	i ..eof() q 0
	i ch1=..stream.eolChar q 0
	i ch1="<" q 0
	i ch1=">" q 0
	i ch1="{" q 0
	i ch1="}" q 0
	i ch1="[" q 0
	i ch1="]" q 0
	i ch1="|" q 0
	i ch1="." q 0

	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Set ok=1

    If ok {
        $$$BNFSTART(subElement)

        Set n=""
        While ('..eof()) && (..peek(1)'=..stream.eolChar) &&(..peek(1)'=" ") {
            Set n=n_..next()
        }
        Set o=..newAtom("String",n)
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="SingleChar">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    #dim o as PXW.DEV.Atom

    $$$DEBUGMethodBegin
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
	s ok=0
	s peek=..stream.PeekToEol()
	s peek=$ZSTRIP(peek,">W")
	i $l(peek)=1 s ok=1
	i peek?1.P s ok=1

    If ok {
		$$$BNFSTART(subElement)
		;set subElement=..newElement("Keyword") d ..getBookmark(.subElementBM)
		set n=""
        Set n=n_..next($l(peek))
        Set o=..newAtom("String",n)
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="Identifier">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value="",v=""
    Set ch=..peek(1)
    ; must start with a <
    If ch="<" Set v=..next() ; skip it
    
    If v="" {
        $$$DEBUG("checking identifier, ok=0")
        Quit 0
    }
    Set ch=..peek(1)
    ;While (ch?1A) || (ch?1N) || (ch="_") || (ch="-")  {
	while ch'=">" {
        Set value=value_..next()
		;zw value,..stream.pos
        Set ch=..peek(1)
    }
	if ch=">" set v=..next()
    
    Set atom=..newAtom(ParentElement.type,value)
    Do ParentElement.AddPart(atom)

    Quit 1
]]></Implementation>
</Method>

<Method name="Equals">
<Description>
EQUALS ::= 'NEEDS EQUALS'
 summary=S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	If ..isStringSingle(..EqualsChars,.value)=0 Quit 0 ; q1 
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0 ; t1 
	Set ownerElement=subElement
	; type=group, check=if, skip=1, skipall=1
	Set getVal=..nextNotEOL($LENGTH(value)),atom=..newAtom(..#keywordAtomType,getVal) ; k1 
	Do subElement.AddPart(atom) ; t3 
	If 1	 {
		Set done=1 ; u1 

	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Definition">
<Description>
 definition ::= IDENTIFIER EQUALS (SINGLE_CHAR | rules)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		if ..Equals(subElement,.addedElement)  {
			if ..Definition2Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
    If ret=0 {
        Set ret=..recover(ParentElement,.recSub,"",$LISTBUILD($CHAR(13)))
    }
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Definition2Sub">
<Description>
SINGLE_CHAR | omitted | rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleChar(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Omitted(subElement,.addedElement) {
		set done=1
	} elseif ..Rules(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NeedsOverride">
<Description>
 NEEDS_OVERRIDE ::= '!!'
summary values:!!</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("!!",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$BNFSTART(subElement)
	set subElement=..newElement("Keyword") d ..getBookmark(.subElementBM)

	set done=0 ; method start
	if ..addPunctuation(subElement,"!!")  {
		set toEol=..stream.NextToEol()
		set atom=..newAtom("String",toEol)
		do subElement.AddPart(atom)
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="skipComments">
<Description>
Skip over the next set of comments, return 1 if something was done or 0</Description>
<FormalSpec>ch10:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If $EXTRACT(ch10,1,1)="#" Set ..comment=..readLineComment("#") Quit 1
    If $EXTRACT(ch10,1,2)="//" Set ..comment=..readLineComment("//") Quit 1
    If $EXTRACT(ch10,1,2)="--" Set ..comment=..readLineComment("--") Quit 1
    If $EXTRACT(ch10,1,2)="/*" Set ..comment=..readBlockComment() Quit 1
    Quit 0
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/* 
    
    DIRECTLY COPIED METHODS 

*/
]]></Content>
</UDLText>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Element</ReturnType>
<Implementation><![CDATA[	Quit ##class(PXW.DEV.BNF.Element).%New(Type)
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Compilers.Compiler">
<IncludeCode>PXW.DEV.BNF.Compilers.macros</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>67129,60984.219931073</TimeChanged>
<TimeCreated>67125,77562.479934667</TimeCreated>
<DependsOn>PXW.DEV.BNF.super</DependsOn>

<Property name="Loader">
<Type>PXW.DEV.BNF.Compilers.loader</Type>
</Property>

<Property name="CurrentClass">
<Type>%Dictionary.ClassDefinition</Type>
</Property>

<Property name="CurrentMethod">
<Type>%Dictionary.MethodDefinition</Type>
</Property>

<Property name="UniqueMethodId">
<Type>%Integer</Type>
</Property>

<Property name="parser">
<Type>PXW.DEV.BNF.super</Type>
</Property>

<Property name="keywords">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="%OnNew">
<FormalSpec>inputText:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set ..parser=..parserNewObject()
    Set ..parser.stream=##class(PXW.DEV.InputStream).NewString(inputText)
    Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// d ##class(PXW.DEV.BNF.Compiler).goload("PXW.DEV.BNF.DEF.COS","PXW.DEV.BNF.GEN.COSauto")

]]></Content>
</UDLText>

<Method name="goload">
<ClassMethod>1</ClassMethod>
<FormalSpec>DEFClass:%String="",DestinationClass:%String,forceVersion:%Integer=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim compiler as PXW.DEV.BNF.Compilers.Compiler

    Set input=..load(DEFClass_"||"_"file",.arr,.version)
    If forceVersion'="" Set version=forceVersion
    If version=3 {
        Set compiler=##class(PXW.DEV.BNF.Compilers.Compiler3).%New(input)
     } elseif version=2 {
        Set compiler=##class(PXW.DEV.BNF.Compilers.Compiler2).%New(input)
    } Else {
        Set compiler=##class(PXW.DEV.BNF.Compilers.Compiler1).%New(input)
        ; /*************************************************** TEMP CODE ***************************/
        ;s compiler.parser=##class(PXW.DEV.BNF.Run.BNF2).%New()
        ;s compiler.parser.stream=##class(PXW.DEV.InputStream).NewString(input)
        ;s compiler.parser.EqualsChars="::="
        ; /*************************************************** TEMP CODE ***************************/
    }
    Set subElement=##class(PXW.DEV.Element).%New()
    Set compiler.Loader=$SYSTEM.OBJ.New(DEFClass)
    Set elementtype=$PARAMETER(compiler.Loader,"SubElementType")
    Set KeywordPattern=$PARAMETER(compiler.Loader,"KeywordPattern")
    If compiler.parser.File(subElement,.fileElement) {
        Set sc=compiler.compile(fileElement,DestinationClass,elementtype,KeywordPattern) 
        If $$$ISOK(sc) {
            Set sc=$SYSTEM.OBJ.Compile(DestinationClass,"ckb")
        } Else {
            Set sc1=$$$ERROR("5001","Code generate problem")
            Set sc=$$$ADDSC(sc1,sc)
        }
    } Else {
        Set sc=$$$ERROR(5001,"Code parse problem")
    }
    Quit sc
]]></Implementation>
</Method>

<Method name="compile">
<FormalSpec>Element:PXW.DEV.Element,ToClassName:%String,elementtype:%String,KeywordPattern:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim class as %Dictionary.ClassDefinition
    #dim method as %Dictionary.MethodDefinition

    Set class=##class(%Dictionary.ClassDefinition).%OpenId(ToClassName) 
    If '$ISOBJECT(class) {
        Set class=##class(%Dictionary.ClassDefinition).%New()
        Set class.Name=ToClassName
    }
    Set class.Super=##class(PXW.DEV.BNF.super).%ClassName(1)
    Do class.Methods.Clear()
    Set class.ProcedureBlock=1
    Set class.Description="Created: "_$ZDATETIME($HOROLOG,3)_" "_..%ClassName(1)

     Do class.Parameters.Clear()
    Set parameter=##class(%Dictionary.ParameterDefinition).%New()
    Set parameter.Name="KeywordPattern"
    Set parameter.parent=class
    Set parameter.Default=KeywordPattern

    Set newmethod=##class(%Dictionary.MethodDefinition).%New()
    Set newmethod.Name="newElement"
    Set newmethod.FormalSpec="Type:%String"
    Set newmethod.parent=class
    Set newmethod.ReturnType=elementtype
    Do newmethod.Implementation.Write($CHAR(9)_"quit ##class("_elementtype_").%New(Type)")

    Set ..CurrentClass=class
    Set pkey=""
    For  {
        Set def=Element.partsGetNext(.pkey)
        Quit:pkey=""

        If def.type="Definition" {
            ;w !!
            ;w def.ToString(" ")
            ;w !
            Do ..compileDefinition(def)
        } Else {
            ;w !,"**** UNKNOWN ******"
            ;break
            ;d def.write()
            ;w !,"**** UNKNOWN ******"_def.type
        }

    }

    Set words="",sep=""
    Set w="" For  { Set w=$ORDER(..keywords(w)) Quit:w=""  Set words=words_sep_w,sep="," }
    Set parameter=##class(%Dictionary.ParameterDefinition).%New()
    Set parameter.Name="Keywords"
    Set parameter.parent=class
    Set parameter.Default=words
   
    Set sc=class.%Save()
    Quit sc
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
rule::=KEYWORD|or|subrule|optional-group|call
Element=Definition PXW.DEV.BNF.Element @216
.type=Definition:
. rule
.Element=Equals PXW.DEV.BNF.Element @202
..type=Keyword:
.. ::=
.Element=Rules PXW.DEV.BNF.Element @201
..Element=Rule PXW.DEV.BNF.Element @198
...Element=Call PXW.DEV.BNF.Element @197
....type=Call:
.... KEYWORD
..Element=Rule PXW.DEV.BNF.Element @187
...Element=Or PXW.DEV.BNF.Element @173
....type=Or:
.... |
..Element=Rule PXW.DEV.BNF.Element @168
...Element=Call PXW.DEV.BNF.Element @167
....type=Call:
.... or
..Element=Rule PXW.DEV.BNF.Element @165
...Element=Or PXW.DEV.BNF.Element @160
....type=Or:
.... |
..Element=Rule PXW.DEV.BNF.Element @159
...Element=Call PXW.DEV.BNF.Element @148
....type=Call:
.... subrule
..Element=Rule PXW.DEV.BNF.Element @134
...Element=Or PXW.DEV.BNF.Element @133
....type=Or:
.... |
..Element=Rule PXW.DEV.BNF.Element @124
...Element=Call PXW.DEV.BNF.Element @119
....type=Call:
.... optional-group
..Element=Rule PXW.DEV.BNF.Element @118
...Element=Or PXW.DEV.BNF.Element @116
....type=Or:
.... |
..Element=Rule PXW.DEV.BNF.Element @104
...Element=Call PXW.DEV.BNF.Element @103
....type=Call:
.... call
*/
]]></Content>
</UDLText>

<Method name="compileDefinition">
<FormalSpec>Element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[

    #dim nameE,eqE,rulesE as PXW.DEV.Element
    #define WRITE(%code) $$$WRITENOLINE(method,%code)
    #define WRITECR(%code) $$$WRITELINE(method,%code)
    #dim method as %Dictionary.MethodDefinition

    Set pkey=""
    Set nameE=Element.partsGetNext(.pkey)
    Set eqE=Element.partsGetNext(.pkey)
    Set rulesE=Element.partsGetNext(.pkey)

    Set mname=..methodName(nameE.ToString(0))
    ;w !,mname_" compiling",!
    ;d rulesE.write()
    
    Set method=..NewMethod(mname)
    Set method.Description=Element.ToString(" ")
    Set ..CurrentMethod=method
    
    Set rkey=""
    Set indent=1
    Do ..compileQuickCheck(method,rulesE,indent)
    Do ..compileMethodStart(method,indent,1)
    Do ..compileRules(method,rulesE,indent)
    Do ..compileMethodEnd(method,indent)
 	;$$$WRITE($$$Tab(indent)_"quit done")
]]></Implementation>
</Method>

<Method name="compileQuickCheck">
<FormalSpec>Method:%Dictionary.MethodDefinition,RulesElement:PXW.DEV.Element,indent:%Integer,returnValue:%String="0 /* normal */"</FormalSpec>
<Implementation><![CDATA[
    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)

    #dim rule1E as PXW.DEV.Element

    ; check keywords before anything else (based on the entire set of rules passed in)
    Set summary=..summariseRules(RulesElement,.listOfValues)
    $$$WRITECR($$$Tab(indent)_"; rules summary "_summary)
    If (summary?1"(K"0."|K"1")") || (summary?1"K"0."|K") {
        ; Keyword list (K|K|K) or K|K|K
        Set Method.Description=Method.Description_$CHAR(13,10)_"summary values:"_$LISTTOSTRING(listOfValues)
        Set wordlist="",sep=""
        For i=1:1:$LISTLENGTH(listOfValues) Set wordlist=wordlist_sep_""""_$LISTGET(listOfValues,i)_"""",sep=","
        $$$WRITECR($$$Tab(indent)_"if '(..isKeywordInList($lb("_wordlist_"),.value)) { quit "_returnValue_" }")
    } ElseIf (summary="P") {
        ; Punctuation single (eg ,)
        Set Method.Description=Method.Description_$CHAR(13,10)_"summary values:"_$LISTTOSTRING(listOfValues)
        ; only 1 but doing the same as a list
        Set wordlist="",sep=""
        For i=1:1:$LISTLENGTH(listOfValues) Set wordlist=wordlist_sep_""""_$LISTGET(listOfValues,i)_"""",sep=","
        $$$WRITECR($$$Tab(indent)_"if '(..isStringSingle("_wordlist_",.value)) { quit "_returnValue_" }")
    } ElseIf (summary?1"(P"0."|P"1")") || (summary?1"P"0."|P") {
        ; Punctuation list (P|P|P) or P|P|P
        Set Method.Description=Method.Description_$CHAR(13,10)_"summary values:"_$LISTTOSTRING(listOfValues)
        Set wordlist="",sep="",longest=0
        For i=1:1:$LISTLENGTH(listOfValues) Set word=$LISTGET(listOfValues,i),wordlist=wordlist_sep_""""_word_"""",sep="," If $LENGTH(word)>longest Set longest=$LENGTH(word)
        $$$WRITECR($$$Tab(indent)_"if '(..isStringInList($lb("_wordlist_"),"_longest_",.value)) { quit "_returnValue_" }")
    } ElseIf (summary?1"P&".E) || (summary?1"K&".E) || (summary?1"(K"0."|K"1")&".E) {   
        ; if cannot summarize the entire set of rules, then can we do the first one?
        ; IE - its a simple thing AND something else
        Set rule1E=RulesElement.partsGetAt(1)
        If $ISOBJECT(rule1E) {
            Set listOfValues=""
            Set summary=..summariseRule(rule1E,.listOfValues)
            $$$WRITECR($$$Tab(indent)_"; first rule summary "_summary)
            If (summary?1"(K"0."|K"1")") || (summary?1"K"0."|K") {
                ; Keyword list (K|K|K) or K|K|K
                Set Method.Description=Method.Description_$CHAR(13,10)_"summary values:"_$LISTTOSTRING(listOfValues)
                Set wordlist="",sep=""
                For i=1:1:$LISTLENGTH(listOfValues) Set wordlist=wordlist_sep_""""_$LISTGET(listOfValues,i)_"""",sep=","
                $$$WRITECR($$$Tab(indent)_"if '(..isKeywordInList($lb("_wordlist_"),.value)) { quit "_returnValue_" }")
            } ElseIf (summary="P") {
                ; Punctuation single (eg ,)
                Set Method.Description=Method.Description_$CHAR(13,10)_"summary values:"_$LISTTOSTRING(listOfValues)
                ; only 1 but doing the same as a list
                Set wordlist="",sep=""
                For i=1:1:$LISTLENGTH(listOfValues) Set wordlist=wordlist_sep_""""_$LISTGET(listOfValues,i)_"""",sep=","
                $$$WRITECR($$$Tab(indent)_"if '(..isStringSingle("_wordlist_",.value)) { quit "_returnValue_" }")
            } ElseIf (summary?1"(P"0."|P"1")") || (summary?1"P"0."|P") {
                ; Punctuation list (P|P|P) or P|P|P
                Set Method.Description=Method.Description_$CHAR(13,10)_"summary values:"_$LISTTOSTRING(listOfValues)
                Set wordlist="",sep="",longest=0
                For i=1:1:$LISTLENGTH(listOfValues) Set word=$LISTGET(listOfValues,i),wordlist=wordlist_sep_""""_word_"""",sep="," If $LENGTH(word)>longest Set longest=$LENGTH(word)
                $$$WRITECR($$$Tab(indent)_"if '(..isStringInList($lb("_wordlist_"),"_longest_",.value)) { quit "_returnValue_" }")
            }
        }
        ;*/
    }
]]></Implementation>
</Method>

<Method name="compileMethodStart">
<FormalSpec>Method:%Dictionary.MethodDefinition,indent:%Integer,needsPath:%Boolean=0,needsTransation:%Boolean=1,needsDebug:%Boolean=1</FormalSpec>
<Implementation><![CDATA[
    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)
    
    If needsDebug $$$WRITECR($$$Tab(indent)_"$$$DEBUGMethodBegin")
    If needsPath $$$WRITECR($$$Tab(indent)_"$$$BNFPATH")
	If needsTransation {
        $$$WRITECR($$$Tab(indent)_"$$$BNFSTART(subElement)")
    } Else {
        $$$WRITECR($$$Tab(indent)_"set subElement=ParentElement")
    }

    $$$WRITECR($$$Tab(indent)_"set done=0 ; method start")
]]></Implementation>
</Method>

<Method name="compileMethodEnd">
<FormalSpec>Method:%Dictionary.MethodDefinition,indent:%Integer,rollbackReturns:%String="0 ; normal rollback",needsTransation:%Boolean=1,needsDebug:%Boolean=1,copyMode:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)

    $$$WRITECR($$$Tab(indent)_"if done {")
	If needsTransation {
        If copyMode=0 $$$WRITECR($$$Tab(indent+1)_"$$$BNFCOMMIT(subElement,ParentElement)")
        If copyMode=1 $$$WRITECR($$$Tab(indent+1)_"$$$BNFCOMMITCOPY(subElement,ParentElement)")
    }
	$$$WRITECR($$$Tab(indent+1)_"set ret=1")
	$$$WRITECR($$$Tab(indent)_"} else {")
	If needsTransation $$$WRITECR($$$Tab(indent+1)_"$$$BNFROLLBACK(subElement)")
	$$$WRITECR($$$Tab(indent+1)_"set ret="_rollbackReturns)
	$$$WRITECR($$$Tab(indent)_"}")
	If needsDebug $$$WRITECR($$$Tab(indent)_"$$$DEBUGMethodEnd")
	$$$WRITECR($$$Tab(indent)_"quit ret")
]]></Implementation>
</Method>

<Method name="NewMethod">
<FormalSpec>Name:%String,Element:PXW.DEV.Element</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
    Set method=##class(%Dictionary.MethodDefinition).%New()
    Set method.Name=Name
    Set method.parent=..CurrentClass
    Set method.FormalSpec="ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element"
    Set method.ReturnType="%Boolean"
    If $ISOBJECT($GET(Element)) Set method.Description=Element.ToString(" ")
    Quit method
]]></Implementation>
</Method>

<Method name="SubMethodName">
<FormalSpec>BaseName:%String,Suffix:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set ..UniqueMethodId=..UniqueMethodId+1
    Quit BaseName_..UniqueMethodId_Suffix
]]></Implementation>
</Method>

<Method name="compileRules">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indent:%Integer</FormalSpec>
<Implementation><![CDATA[
    #dim ruleE as PXW.DEV.Element
    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)

    Set summary=..summariseRules(Element)
    ;s Method.Description=Method.Description_$c(13,10)_"summary="_summary
    
    Set firstRuleE=Element.partsGetNext(.nkey)
    If $ISOBJECT(firstRuleE) {
        If firstRuleE.ToString(0)="|" {
            Set andor="OR",rkey=nkey
        } Else {
            Set andor="AND"
        }
    }
    Set first=1
    For  {
        Set ruleE=Element.partsGetNext(.rkey)
        Quit:rkey=""
        ;d ruleE.write()
        ;i andor="AND" s indent=indent+1
        If first {
            $$$WRITE($$$Tab(indent)_"if ")
            Do ..compileRule(Method,ruleE,indent)
            $$$WRITECR(" "_$$$OpenCurly)
        } ElseIf (andor="AND") {
            $$$WRITE($$$Tab(indent)_"if ")
            Do ..compileRule(Method,ruleE,indent)
            $$$WRITECR(" "_$$$OpenCurly)
        } Else {
            $$$WRITE($$$Tab(indent)_$$$CloseCurly_" elseif ")
            Do ..compileRule(Method,ruleE,indent)
            $$$WRITECR(" "_$$$OpenCurly)
        }

        Set first=0

        Set nkey=rkey
        Set nextRuleE=Element.partsGetNext(.nkey)
        If $ISOBJECT(nextRuleE) {
            If nextRuleE.ToString(0)="|" {
                Set andor="OR",rkey=nkey
                $$$WRITECR($$$Tab(indent+1)_"set done=1 ; or")
            } Else {
                Set andor="AND"
                Set indent=indent+1
            }
        }
    }

    $$$WRITECR($$$Tab(indent+1)_"set done=1 ; end compileRules")
    For indent=indent:-1:1 {
        $$$WRITECR($$$Tab(indent)_$$$CloseCurly) 
    }
    $$$WRITECR("")
]]></Implementation>
</Method>

<Method name="compileRule">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indent:%Integer,subElementVar:%String="subElement"</FormalSpec>
<Implementation><![CDATA[
    #dim atom as PXW.DEV.Atom
    #dim subelement as PXW.DEV.Element
    #dim rulesE as PXW.DEV.Element

    #define WRITE(%code) $$$WRITENOLINE(Method,%code)

    Set subelement=Element.partsGetNext("") ; get the first thing
    If subelement.type="Keyword" {
        Set atom=subelement.FirstAtom()
        Set word=atom.value
        Set word=$REPLACE(word,"""","""""") ; sort out quote in quotes
        If ..Loader.isKeyword(atom.value) {
            ;i word="class" break
            Set ..keywords($$$UPPER(atom.value))=1
            $$$WRITE("..addKeyword("_subElementVar_","""_$$$UPPER(word)_""") ")
        } Else {
            $$$WRITE("..addPunctuation("_subElementVar_","""_word_""") ")
        }
    } ElseIf subelement.type="Call" {
        Set mnameA=Element.FirstAtom()
        Set mname=..methodName(mnameA.ToString(0))
        $$$WRITE(".."_mname_"("_subElementVar_",.addedElement) ")
    } ElseIf subelement.type="Subrule" {
        Set rulesE=subelement.findFirstElementByType("rules",0)
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"Sub"))
        Set subMethod.Description=rulesE.ToString(" ")
        Do ..compileSubRule(subMethod,rulesE,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ")
    } ElseIf subelement.type="OptionalGroup" {
        Set rulesE=subelement.findFirstElementByType("Rules",0)
        If rulesE.partsCount()=1 {
            $$$WRITE("$S(")
            Set ruleE=rulesE.partsGetAt(1)
            Do ..compileRule(Method,ruleE,indent)
            $$$WRITE(":1,1:1)")
        } Else {
            Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"OptGrp"))
            Do ..compileOptionalGroup(subMethod,rulesE,indent)
            $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
        }
    } ElseIf subelement.type="NotRule" {
        Set ruleE=subelement.findFirstElementByType("NotableRule",0)
        $$$WRITE("'") ; NOT
        Do ..compileRule(Method,ruleE,indent)
    } ElseIf subelement.type="RepeatSep" {
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"RepSep"))
        Do ..compileRepeatSep(subMethod,subelement,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
    } ElseIf subelement.type="LookAhead" {
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"Peek"))
        Do ..compilePeek(subMethod,subelement,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
    } ElseIf subelement.type="RepeatOne" { 
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"RepOne"))
        Do ..compileRepeatOne(subMethod,subelement,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
    } ElseIf subelement.type="RepeatZero" { 
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"RepZero"))
        Do ..compileRepeatZero(subMethod,subelement,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
    } ElseIf subelement.type="OptionalSingle" { 
        Set ruleE=subelement.findFirstElementByType("OptionalableRule",0)
        $$$WRITE("$s(")
        Do ..compileRule(Method,ruleE)
        $$$WRITE(":1,1:1) ") 
    } Else {
        $$$WRITE("; don't know what to do with "_subelement.type)
    }
]]></Implementation>
</Method>

<Method name="compileRepeatSep">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indentOfParent:%Integer,CallThisMethod:%String</FormalSpec>
<Implementation><![CDATA[
    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)
    Set indent=1
    Set path=1
    Set transaction=1,debug=1
    Set copy=1
    Set Method.Description=Element.ToString(" ")
    Set sepE=Element.findFirstElementByType("RepeatSepSeparator",0)
    Set ruleE=Element.findFirstElementByType("RepeatSepRule",0)
    Do ..compileQuickCheck(Method,sepE,indent)
    Do ..compileMethodStart(Method,indent,path,transaction)
    $$$WRITECR($$$Tab(indent)_"set done=0 ; must be at least 1")

    $$$WRITE($$$Tab(indent)_"if ")
    Do ..compileRule(Method,ruleE,indent)
    $$$WRITECR($$$OpenCurly)
    Set indent=indent+1
            $$$WRITECR($$$Tab(indent)_"set done=1,ok=1 ; found 1")
            $$$WRITECR($$$Tab(indent)_"do "_$$$OpenCurly)
            Set indent=indent+1
            $$$WRITECR($$$Tab(indent)_"$$$BNFSTART(repElement)")
            $$$WRITE($$$Tab(indent)_"set ok=(")
            Do ..compileRule(Method,sepE,indent,"repElement")
            $$$WRITE(" && ")
            Do ..compileRule(Method,ruleE,indent,"repElement")
            $$$WRITECR(")")
            $$$WRITECR($$$Tab(indent)_"if ok "_$$$OpenCurly)
            $$$WRITECR($$$Tab(indent+1)_"$$$BNFCOMMIT(repElement,subElement)")
            $$$WRITECR($$$Tab(indent)_$$$CloseCurly_" else "_$$$OpenCurly)
            $$$WRITECR($$$Tab(indent+1)_"$$$BNFROLLBACK(repElement)")
            $$$WRITECR($$$Tab(indent)_$$$CloseCurly)
        Set indent=indent-1
        $$$WRITECR($$$Tab(indent)_$$$CloseCurly_" while ok")
    Set indent=indent-1
    $$$WRITECR($$$Tab(indent)_$$$CloseCurly_"")
    Do ..compileMethodEnd(Method,indent,,transaction,debug,copy)
    /*
		do {
			$$$BNFSTART(repElement)
			s ok=(..addPunctuation(repElement,",")  && ..Args332Sub(repElement,.addedElement) ) 
			i ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
    */
]]></Implementation>
</Method>

<Method name="compileSubRule">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indentOfParent:%Integer</FormalSpec>
<Implementation><![CDATA[
    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)

    Set indent=1
    Set path=0
    If Element.type="Rules" {
        Set transaction=1,debug=1,copy=1
        Set summary=..summariseRules(Element)
        ; this is just one or more calls to other things, those things will be in transactions so no need here
        If summary?1"C"0."|C" Set transaction=0,debug=0
        ; this is just one or more checks of keywords, no need to be in a transaction
        If summary?1"K"0."|K" Set transaction=0,debug=0
        If summary?1"P"0."|P" Set transaction=0,debug=0
        ;$$$WRITECR($$$Tab(indent)_"; sub summary="_summary_", transaction="_transaction)
        Do ..compileQuickCheck(Method,Element,indent)
        Do ..compileMethodStart(Method,indent,path,transaction,debug)
        If 'transaction $$$WRITECR($$$Tab(indent)_"Set subElement=ParentElement")
        Do ..compileRules(Method,Element,indent)
        Do ..compileMethodEnd(Method,indent,,transaction,debug,copy)
    }
]]></Implementation>
</Method>

<Method name="compileOptionalGroup">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indentOfParent:%Integer</FormalSpec>
<Implementation><![CDATA[
    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)

    Set indent=1
    If Element.type="Rules" {
        Set transaction=1,debug=1,copy=1
        Set summary=..summariseRules(Element)
        ; this is just one or more calls to other things, those things will be in transactions so no need here
        If summary?1"C"0."|C" Set transaction=0,debug=0
        ; this is just one or more checks of keywords, no need to be in a transaction
        If summary?1"K"0."|K" Set transaction=0,debug=0
        If summary?1"P"0."|P" Set transaction=0,debug=0
        Do ..compileQuickCheck(Method,Element,indent,"1 /* not found is OK */")
        Do ..compileMethodStart(Method,indent,,transaction,debug)
        If 'transaction $$$WRITECR($$$Tab(indent)_"Set subElement=ParentElement")
        Do ..compileRules(Method,Element,indent)
        Do ..compileMethodEnd(Method,indent,"1 /* failure rollsback but returns OK */",transaction,debug,copy)
    }
]]></Implementation>
</Method>

<Method name="compileRepeatOne">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indentOfParent:%Integer,CallThisMethod:%String</FormalSpec>
<Implementation><![CDATA[
    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)
    Set indent=1
    Set path=0
    Set transaction=0,debug=0
    Set Method.Description=Element.ToString(" ")
    Set ruleE=Element.findFirstElementByType("RepeatableRule")
    Do ..compileQuickCheck(Method,ruleE,indent)
    Do ..compileMethodStart(Method,indent,path,transaction,debug)
    $$$WRITECR($$$Tab(indent)_"set done=0 ; must be at least 1")
    $$$WRITE($$$Tab(indent)_"while ") 
    Do ..compileRule(Method,ruleE,indent)
    $$$WRITECR(" "_$$$OpenCurly)
    $$$WRITECR($$$Tab(indent+1)_"set done=1")
    $$$WRITECR($$$Tab(indent)_$$$CloseCurly)
    Do ..compileMethodEnd(Method,indent,,transaction,debug)
]]></Implementation>
</Method>

<Method name="compileRepeatZero">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indentOfParent:%Integer,CallThisMethod:%String</FormalSpec>
<Implementation><![CDATA[
    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)
    Set indent=1
    Set path=0
    Set transaction=0,debug=0
    Set Method.Description=Element.ToString(" ")
    Set ruleE=Element.findFirstElementByType("RepeatableRule")
    Do ..compileQuickCheck(Method,ruleE,indent,"1 /* not found is OK in RZ */")
    Do ..compileMethodStart(Method,indent,path,transaction,debug)

    $$$WRITE($$$Tab(indent)_"while ") 
    Do ..compileRule(Method,ruleE,indent)
    $$$WRITECR(" "_$$$OpenCurly)
    
    $$$WRITECR($$$Tab(indent+1)_"set done=1")
    $$$WRITECR($$$Tab(indent)_$$$CloseCurly)
    Do ..compileMethodEnd(Method,indent,"1 /* nothing found is ok in RZ */",transaction,debug)
]]></Implementation>
</Method>

<Method name="compilePeek">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indentOfParent:%Integer,CallThisMethod:%String</FormalSpec>
<Implementation><![CDATA[
    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)
    Set indent=1
    Set path=1
    Set transaction=1,debug=1
    Set Method.Description=Element.ToString(" ")
    Set ruleE=Element.findFirstElementByType("LookAheadRule")
    $$$WRITECR($$$Tab(indent)_"; ruleE="_ruleE.type_" :"_ruleE.ToString(" "))
    Set transaction=1,debug=1
    Do ..compileQuickCheck(Method,ruleE,indent)
    Do ..compileMethodStart(Method,indent,path,transaction,debug)
    $$$WRITE($$$Tab(indent)_"if ")
    Do ..compileRule(Method,ruleE,indent)
    $$$WRITECR(" "_$$$OpenCurly)
    $$$WRITECR($$$Tab(indent+1)_"set done=1")
    $$$WRITECR($$$Tab(indent)_$$$CloseCurly)

    ; for lookahead we ALWAYS rollback even if we are returning 0 - this is a Peek only
    ;d ..compileMethodEnd(Method,indent,,transaction,debug)
    $$$WRITECR($$$Tab(indent)_"if done {")
	$$$WRITECR($$$Tab(indent+1)_"set ret=1")
	$$$WRITECR($$$Tab(indent+1)_"$$$BNFROLLBACK(subElement)")
    $$$WRITECR($$$Tab(indent)_"} else {")
	$$$WRITECR($$$Tab(indent+1)_"$$$BNFROLLBACK(subElement)")
	$$$WRITECR($$$Tab(indent+1)_"set ret=0")
	$$$WRITECR($$$Tab(indent)_"}")
	If debug $$$WRITECR($$$Tab(indent)_"$$$DEBUGMethodEnd")
	$$$WRITECR($$$Tab(indent)_"quit ret")
]]></Implementation>
</Method>

<Method name="findModifier">
<FormalSpec>Element:PXW.DEV.Element</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set modE=Element.findFirstElementByType("Modifier",0)
    If $ISOBJECT(modE) {        
        ;i ..CurrentMethod.Name="SetItem" d Element.write() break
        Set subelement=Element.findFirstElementByType("Optionalsingle",0)
        If $ISOBJECT(subelement) Quit $$$UPPER(subelement.type)
        Set subelement=Element.findFirstElementByType("Repeat",1)
        If $ISOBJECT(subelement) {
            Set rsub=subelement.findFirstElementByType("RepeatZero",0)
            ;i ..CurrentMethod.Name="UdlStatement" break
            If $ISOBJECT(rsub) Quit $$$UPPER(rsub.type)
            Set rsub=subelement.findFirstElementByType("RepeatOne",0)
            If $ISOBJECT(rsub) Quit $$$UPPER(rsub.type)
        }
    }
   Quit ""
]]></Implementation>
</Method>

<Method name="methodName">
<FormalSpec>text:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
    Set s1=$TRANSLATE(text,"_-"," ")
    Set s1=$ZCONVERT(s1,"W")
    Set s1=$TRANSLATE(s1," ","")
    Quit s1
]]></Implementation>
</Method>

<Method name="load">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[XDATAname:%String,*array:%String,&version:%String]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    ;#define strip(%x) $ZSTRIP($tr(%x,$c(9,160)," "),"<>W")
    #define strip(%x) $ZSTRIP($tr(%x,$c(9,160)," "),"<>W")
    Set cr=$CHAR(13,10),eq="::="
    Set xdata=##class(%Dictionary.XDataDefinition).%OpenId(XDATAname)
    Do xdata.Data.Rewind()
    Set alltext=xdata.Data.Read()
    Set cdata=$PIECE($PIECE(alltext,"<![CDATA[",2),"]]]]><![CDATA[>",1)
    Set bnf=$PIECE($PIECE(alltext,"<bnf",2),">",1)
    Set version=$PIECE(bnf,"version=",2)
    Set version=$TRANSLATE(version,"'""","")
    Quit cdata
]]></Implementation>
</Method>

<Method name="summariseRules">
<FormalSpec><![CDATA[Element:PXW.DEV.Element,&listOfValues:%List]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set summary=""
    Set andor=""
    For  {
        Set ruleE=Element.partsGetNext(.rkey)
        Quit:rkey=""
        Set summary=summary_andor_..summariseRule(ruleE,.listOfValues)
        Set nkey=rkey
        Set nextRuleE=Element.partsGetNext(.nkey)
        If $ISOBJECT(nextRuleE) {
            If nextRuleE.ToString(0)="|" {
                Set andor="|",rkey=nkey
            } Else {
                Set andor="&"
            }
        }
    }  
    Quit summary
]]></Implementation>
</Method>

<Method name="summariseRule">
<FormalSpec>Element:PXW.DEV.Element,listOfValues:%List=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    #dim atom as PXW.DEV.Atom
    #dim subelement as PXW.DEV.Element
    #dim rulesE as PXW.DEV.Element

    If Element.%IsA("PXW.DEV.Element") {
        Set summary="?1"_Element.type_"?"
        Set subelement=Element.partsGetNext("") ; get the first thing

        If subelement.type="Keyword" {
            Set atom=subelement.FirstAtom()
            Set word=atom.value
            Set word=$REPLACE(word,"""","""""") ; sort out quote in quotes
            If ..Loader.isKeyword(atom.value) {
                ;i word="class" break
                Set summary="K" ; keyword
                Set listOfValues=listOfValues_$LISTBUILD($$$UPPER(word))
            } Else {
                Set summary="P" ; punctuation
                Set listOfValues=listOfValues_$LISTBUILD($$$UPPER(word)) ; needs to be upper because of things like i%
            }
        } ElseIf subelement.type="Call" {
            Set mnameA=Element.FirstAtom()
            Set mname=..methodName(mnameA.ToString(0))
        } ElseIf subelement.type="Subrule" {
            Set rulesE=subelement.findFirstElementByType("rules",0)
            Set subsumm=..summariseRules(rulesE,.listOfValues)
        } ElseIf subelement.type="Optionalgroup" {
            Set rulesE=subelement.findFirstElementByType("rules",0)
            Set summary="["_..summariseRules(rulesE,.listOfValues)_"]"
        } ElseIf subelement.type="RepeatOne" {
            Set ruleE=subelement.findFirstElementByType("RepeatableRule") 
            Set summary="("_..summariseRules(ruleE,.listOfValues)_")+"
        } ElseIf subelement.type="RepeatZero" {
            Set ruleE=subelement.findFirstElementByType("RepeatableRule") 
            Set summary="("_..summariseRules(ruleE,.listOfValues)_")*"
        } Else {
            Set summary="?4?"
        }
    } Else {
        Set summary=""
    }
    Quit summary
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Compilers.Compiler1">
<Super>PXW.DEV.BNF.Compilers.Compiler</Super>
<TimeChanged>67125,77562.469579163</TimeChanged>
<TimeCreated>67125,77562.469579163</TimeCreated>
<DependsOn>PXW.DEV.BNF.Compilers.BNF1safe</DependsOn>

<Property name="parser">
<Type>PXW.DEV.BNF.Compilers.BNF1safe</Type>
</Property>
</Class>


<Class name="PXW.DEV.BNF.Compilers.Compiler2">
<Super>PXW.DEV.BNF.Compilers.Compiler</Super>
<TimeChanged>67130,30122.953234125</TimeChanged>
<TimeCreated>67125,77562.50503308</TimeCreated>
<DependsOn>PXW.DEV.BNF.Compilers.BNF2safe</DependsOn>

<Property name="parser">
<Type>PXW.DEV.BNF.Compilers.BNF2safe</Type>
</Property>

<Parameter name="COMPACT">
<Description>
Attempt to remove all the nonsense element structure 
its not really working so turning off!</Description>
<Default>0</Default>
</Parameter>

<Method name="compileDefinition">
<FormalSpec>Element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    #dim nameE,eqE,rulesE as PXW.DEV.Element
    #define WRITE(%code) $$$WRITENOLINE(method,%code)
    #define WRITECR(%code) $$$WRITELINE(method,%code)
    #dim method as %Dictionary.MethodDefinition

    Set pkey=""
    Set nameE=Element.partsGetNext(.pkey)
    Set eqE=Element.partsGetNext(.pkey)
    Set rulesE=Element.partsGetNext(.pkey)

    Set mname=..methodName(nameE.ToString(0))
   
    Set method=..NewMethod(mname)
    Set method.Description=Element.ToString(" ")
    Set ..CurrentMethod=method
    
    ; simple check to look for recursion (the rules contains the name
    ;i mname="TPrimary" break
    If $$$UPPER(" "_rulesE.ToString(" ")_" ")[$$$UPPER(" "_nameE.ToString(0)_" ") {
        Set indent=1,transaction=0,path=0
        ; recursive function
        ; create a new method containing the basics
        Set recmethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"Recurse"))
        Do ..compileQuickCheck(recmethod,rulesE,indent)
        Do ..compileMethodStart(recmethod,indent,path,transaction)
        Do ..compileRules(recmethod,rulesE,indent)
        Do ..compileMethodEnd(recmethod,indent,,transaction)

        ; ideas from https://medium.com/@gvanrossum_83706/left-recursive-peg-grammars-65dab3c580e1
        $$$WRITECR($$$Tab(indent)_"$$$DEBUGMethodBegin")
        $$$WRITECR($$$Tab(indent)_"$$$BNFPATH")
        $$$WRITECR($$$Tab(indent)_"set done=0,ok=1,pos=..stream.pos,lastpos=pos")
        $$$WRITECR($$$Tab(indent)_"if $$$BNFMEMOExists(pos) {")
        $$$WRITECR($$$Tab(indent+1)_"$$$BNFMEMOGET(pos,subElement)")
        $$$WRITECR($$$Tab(indent+1)_"set ret=($isobject(subElement))")
        $$$WRITECR($$$Tab(indent+1)_"if ret $$$BNFCOMMITCOPY(subElement,ParentElement)")
        $$$WRITECR($$$Tab(indent+1)_"quit ret")
        $$$WRITECR($$$Tab(indent)_"}")
        $$$WRITECR($$$Tab(indent)_"$$$BNFMEMOSET(pos,"""")")
        $$$WRITECR($$$Tab(indent)_"do ..getBookmark(.bm)")
        $$$WRITECR($$$Tab(indent)_"while ok {")
        $$$WRITECR($$$Tab(indent)_"$$$BNFSTART(subElement)")
        $$$WRITECR($$$Tab(indent+1)_"do ..gotoBookmark(.bm)")
        ;$$$WRITECR($$$Tab(indent+1)_"set rec=.."_recmethod.Name_"(ParentElement,.addedElement)")
        $$$WRITECR($$$Tab(indent+1)_"set rec=.."_recmethod.Name_"(subElement,.addedElement)")
        $$$WRITECR($$$Tab(indent+1)_"if rec,..stream.pos>lastpos {")
        $$$WRITECR($$$Tab(indent+2)_"$$$BNFMEMOSET(pos,addedElement)")
        $$$WRITECR($$$Tab(indent+2)_"set done=1,lastpos=..stream.pos")
        $$$WRITECR($$$Tab(indent+1)_"} else {")
        $$$WRITECR($$$Tab(indent+2)_"set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best ") 
        $$$WRITECR($$$Tab(indent+1)_"}")
        $$$WRITECR($$$Tab(indent)_"}")
        $$$WRITECR($$$Tab(indent)_"if done {")
            If '..#COMPACT {
                $$$WRITECR($$$Tab(indent+1)_"$$$BNFCOMMIT(subElement,ParentElement)")
            } Else {
                $$$WRITECR($$$Tab(indent+1)_"if subElement.partsCount()=1,subElement.partsGetAt(1).%IsA(""PXW.DEV.Atom"") {")
                $$$WRITECR($$$Tab(indent+2)_"$$$BNFCOMMITCOPY(subElement,ParentElement)")
                $$$WRITECR($$$Tab(indent+1)_"} elseif subElement.partsCount()=1,subElement.partsGetAt(1).type'="""_mname_""" {")
                $$$WRITECR($$$Tab(indent+2)_"$$$BNFCOMMITCOPY(subElement,ParentElement)")
                $$$WRITECR($$$Tab(indent+1)_"} else {")
                $$$WRITECR($$$Tab(indent+2)_"$$$BNFCOMMIT(subElement,ParentElement)")
                $$$WRITECR($$$Tab(indent+1)_"}")
            }
        $$$WRITECR($$$Tab(indent+1)_"set ret=1")
        $$$WRITECR($$$Tab(indent)_"} else {")
        $$$WRITECR($$$Tab(indent+1)_"if $isobject(subElement) $$$BNFROLLBACK(subElement)")
        $$$WRITECR($$$Tab(indent+1)_"set ret=0")
        $$$WRITECR($$$Tab(indent)_"}")
        $$$WRITECR($$$Tab(indent)_"$$$DEBUGMethodEnd")
        $$$WRITECR($$$Tab(indent)_"quit ret")
    } Else {
        Set rkey=""
        Set indent=1
        Do ..compileQuickCheck(method,rulesE,indent)
        Do ..compileMethodStart(method,indent,1)
        If 1 {
            $$$WRITECR($$$Tab(indent)_"set pos=..stream.pos")
            $$$WRITECR($$$Tab(indent)_"if $$$BNFMEMOExists(pos) {")
            $$$WRITECR($$$Tab(indent+1)_"$$$BNFMEMOGET(pos,subElement)")
            $$$WRITECR($$$Tab(indent+1)_"set done=$isobject(subElement)")
            ;$$$WRITECR($$$Tab(indent+1)_"$$$BNFCOMMIT(subElement,ParentElement)")
            ;$$$WRITECR($$$Tab(indent+1)_"quit ret")
            $$$WRITECR($$$Tab(indent)_$$$CloseCurly_" else "_$$$OpenCurly)
            Set indent=indent+1

        }
        Do ..compileRules(method,rulesE,indent)
        $$$WRITECR("")
        If 1 {
            Set indent=indent-1
            $$$WRITECR($$$Tab(indent)_$$$CloseCurly)
            $$$WRITECR($$$Tab(indent)_"if done "_$$$OpenCurly)
            $$$WRITECR($$$Tab(indent+1)_"$$$BNFMEMOSET(pos,subElement)")
            $$$WRITECR($$$Tab(indent)_$$$CloseCurly_" else "_$$$OpenCurly)
            ;$$$WRITECR($$$Tab(indent+1)_"$$$BNFMEMOKILL(pos,subElement)")
            $$$WRITECR($$$Tab(indent)_$$$CloseCurly)
        }
        Do ..compileMethodEnd(method,indent)
    }
]]></Implementation>
</Method>

<Method name="compileRules">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indent:%Integer</FormalSpec>
<Implementation><![CDATA[
    #dim ruleE as PXW.DEV.Element
    #define WRITE(%code) $$$WRITENOLINE(Method,%code) 
    #define WRITECR(%code) $$$WRITELINE(Method,%code) 

    Set summary=..summariseRules(Element)
    ;s Method.Description=Method.Description_$c(13,10)_"summary="_summary    
    
    Set initialIndent=indent
    Set first=1
    For  {
        Set ruleE=Element.findNextElement(.rkey)
        Quit:rkey=""
        If first {
            $$$WRITE($$$Tab(indent)_"if ")
            If ruleE.type="Rule" {
                Do ..compileRule(Method,ruleE,indent)
            } ElseIf ruleE.type="OrRules" {
                Do ..compileOrRules(Method,ruleE,indent)
            } Else {
                $$$WRITE("unexpected "_ruleE.type_", expected Rule,OrRules")
            }
        } ElseIf (ruleE.type="Rule") {
            $$$WRITE(" && ")
            Do ..compileRule(Method,ruleE,indent)
        } ElseIf (ruleE.type="OrRules") {
            $$$WRITECR(" "_$$$OpenCurly)
            $$$WRITECR($$$Tab(indent+1)_"set done=1 ; or")
            $$$WRITE($$$Tab(indent)_$$$CloseCurly_" elseif ")
            ;do ruleE.write()
            Do ..compileOrRules(Method,ruleE,indent)
        } Else {
            $$$WRITECR(" ; don't know what to do Rules"_ruleE.Type)
        }

        Set first=0
    }
    $$$WRITECR(" "_$$$OpenCurly)
    $$$WRITECR($$$Tab(indent+1)_"set done=1 ; end compileRules")
    $$$WRITE($$$Tab(indent)_$$$CloseCurly)
    For indent=indent-1:-1:initialIndent {
        $$$WRITECR($$$Tab(indent)_$$$CloseCurly) 
    }
    $$$WRITECR("")
]]></Implementation>
</Method>

<Method name="compileQuickCheck">
<FormalSpec>Method:%Dictionary.MethodDefinition,RulesElement:PXW.DEV.Element,indent:%Integer,returnValue:%String="0 /* normal */"</FormalSpec>
<Implementation><![CDATA[	Quit
]]></Implementation>
</Method>

<Method name="compileOrRules">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indent:%Integer</FormalSpec>
<Implementation><![CDATA[
    #dim ruleE as PXW.DEV.Element
    #define WRITE(%code) $$$WRITENOLINE(Method,%code) 
    #define WRITECR(%code) $$$WRITELINE(Method,%code) 

    Set rkey=""
    Set copy=1
    Set elementcount=Element.countElements()
    If elementcount=1 {
        Set ruleE=Element.findNextElement(.rkey)
        Do ..compileRule(Method,ruleE,indent)
    } Else {
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"Or"))
        Do ..compileMethodStart(subMethod,indent,0,1,1)
        Do ..compileRules(subMethod,Element,indent)
        Do ..compileMethodEnd(subMethod,indent,0,1,1,copy)
        $$$WRITE(".."_subMethod.Name_"(subElement,.addedElement) ") 
    }
]]></Implementation>
</Method>

<Method name="compileRule">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indent:%Integer,subElementVar:%String="subElement"</FormalSpec>
<Implementation><![CDATA[
    #dim atom as PXW.DEV.Atom
    #dim subelement as PXW.DEV.Element
    #dim rulesE as PXW.DEV.Element

    #define WRITE(%code) $$$WRITENOLINE(Method,%code)

    Set subelement=Element.findNextElement("") ; get the first thing, atoms are not interesting
    If subelement.type="Keyword" {
        Set atom=subelement.FirstAtom()
        Set word=atom.value
        Set word=$REPLACE(word,"""","""""") ; sort out quote in quotes
        If ..Loader.isKeyword(atom.value) {
            If atom.start="'" {
                Set ..keywords($$$UPPER(atom.value))=1
            } Else {
                ; keywords in double quotes are "soft" and should not be in the keyword check
            }
            $$$WRITE("..addKeyword("_subElementVar_","""_$$$UPPER(word)_""") ")
        } Else {
            $$$WRITE("..addPunctuation("_subElementVar_","""_word_""") ")
        }
    } ElseIf subelement.type="Call" {
        Set mnameA=Element.FirstAtom()
        Set mname=..methodName(mnameA.ToString(0))
        $$$WRITE(".."_mname_"("_subElementVar_",.addedElement) ")
    } ElseIf subelement.type="Subrule" {
        Set rulesE=subelement.findFirstElementByType("rules",0)
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"Sub"))
        Set subMethod.Description=rulesE.ToString(" ")
        Do ..compileSubRule(subMethod,rulesE,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ")
    } ElseIf subelement.type="OptionalGroup" {
        Set rulesE=subelement.findFirstElementByType("Rules",0)
        If rulesE.partsCount()=1 {
            $$$WRITE("$S(")
            Set ruleE=rulesE.partsGetAt(1)
            Do ..compileRule(Method,ruleE,indent)
            $$$WRITE(":1,1:1)")
        } Else {
            Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"OptGrp"))
            Do ..compileOptionalGroup(subMethod,rulesE,indent)
            $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
        }
    } ElseIf subelement.type="NotRule" {
        Set ruleE=subelement.findFirstElementByType("NotableRule",0)
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"Not"))
        Set subMethod.Description=ruleE.ToString(" ")
        Do ..compileNotRule(subMethod,ruleE,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ")
    } ElseIf subelement.type="RepeatSep" {
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"RepSep"))
        Do ..compileRepeatSep(subMethod,subelement,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
    } ElseIf subelement.type="LookAhead" {
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"Peek"))
        Do ..compilePeek(subMethod,subelement,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
    } ElseIf subelement.type="RepeatOne" { 
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"RepOne"))
        Do ..compileRepeatOne(subMethod,subelement,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
    } ElseIf subelement.type="RepeatZero" { 
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"RepZero"))
        Do ..compileRepeatZero(subMethod,subelement,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
    } ElseIf subelement.type="OptionalSingle" { 
        Set ruleE=subelement.findFirstElementByType("OptionalableRule",0)
        $$$WRITE("$s(")
        Do ..compileRule(Method,ruleE)
        $$$WRITE(":1,1:1) ") 
    } ElseIf subelement.type="Force" {
        $$$WRITE("1 /* force means? */")
    } Else {

        $$$WRITE("; don't know what to do with "_subelement.type)
    }
]]></Implementation>
</Method>

<Method name="compileNotRule">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indentOfParent:%Integer</FormalSpec>
<Implementation><![CDATA[
    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)

    Set indent=1
    Set path=0
    Set transaction=1,debug=1
    ;s summary=..summariseRules(Element)
    ; this is just one or more calls to other things, those things will be in transactions so no need here
    ;i summary?1"C"0."|C" s transaction=0,debug=0
    ; this is just one or more checks of keywords, no need to be in a transaction
    ;i summary?1"K"0."|K" s transaction=0,debug=0
    ;i summary?1"P"0."|P" s transaction=0,debug=0
    ;$$$WRITECR($$$Tab(indent)_"; sub summary="_summary_", transaction="_transaction)
    ;d ..compileQuickCheck(Method,Element,indent)
    Do ..compileMethodStart(Method,indent,path,transaction,debug)
    If 'transaction $$$WRITECR($$$Tab(indent)_"Set subElement=ParentElement")
    $$$WRITE($$$Tab(indent)_"if ")
    Do ..compileRule(Method,Element,indent)
    $$$WRITECR(" "_$$$OpenCurly_" set done=1 "_$$$CloseCurly)
    ;d ..compileMethodEnd(Method,indent,,transaction,debug)

	$$$WRITECR($$$Tab(indent)_"$$$BNFROLLBACK(subElement)") ; always rollback

    $$$WRITECR($$$Tab(indent)_"if done {")
	$$$WRITECR($$$Tab(indent+1)_"set ret=0") ; reverse for NOT
	$$$WRITECR($$$Tab(indent)_"} else {")
	$$$WRITECR($$$Tab(indent+1)_"set ret=1") ; reverse for NOT
	$$$WRITECR($$$Tab(indent)_"}")
	$$$WRITECR($$$Tab(indent)_"$$$DEBUGMethodEnd")
	$$$WRITECR($$$Tab(indent)_"quit ret")
]]></Implementation>
</Method>

<Method name="compileMethodEnd">
<FormalSpec>Method:%Dictionary.MethodDefinition,indent:%Integer,rollbackReturns:%String="0 ; normal rollback",needsTransation:%Boolean=1,needsDebug:%Boolean=1,copyMode:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
   #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)

    $$$WRITECR($$$Tab(indent)_"if done {")
	If needsTransation {
        If copyMode=0 {
            If ..#COMPACT {
                $$$WRITECR($$$Tab(indent+1)_"; if the only thing is an atom then the element is adding no value so copy to parent")
                $$$WRITECR($$$Tab(indent+1)_"if subElement.partsCount()=1,subElement.partsGetAt(1).%IsA(""PXW.DEV.Atom"") {")
                $$$WRITECR($$$Tab(indent+2)_"$$$BNFCOMMITCOPY(subElement,ParentElement)")
                $$$WRITECR($$$Tab(indent+1)_"} else {")
                $$$WRITECR($$$Tab(indent+2)_"$$$BNFCOMMIT(subElement,ParentElement)")
                $$$WRITECR($$$Tab(indent+1)_"}")
            } Else {
                $$$WRITECR($$$Tab(indent+2)_"$$$BNFCOMMIT(subElement,ParentElement)")
            }
        }
        If copyMode=1 $$$WRITECR($$$Tab(indent+1)_"$$$BNFCOMMITCOPY(subElement,ParentElement)")
    }
	$$$WRITECR($$$Tab(indent+1)_"set ret=1")
	$$$WRITECR($$$Tab(indent)_"} else {")
	If needsTransation $$$WRITECR($$$Tab(indent+1)_"$$$BNFROLLBACK(subElement)")
	$$$WRITECR($$$Tab(indent+1)_"set ret="_rollbackReturns)
	$$$WRITECR($$$Tab(indent)_"}")
	If needsDebug $$$WRITECR($$$Tab(indent)_"$$$DEBUGMethodEnd")
	$$$WRITECR($$$Tab(indent)_"quit ret")
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Compilers.Compiler3">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>PXW.DEV.BNF.Compilers.Compiler</Super>
<TimeChanged>67130,57627.314409985</TimeChanged>
<TimeCreated>67125,77562.514073563</TimeCreated>

<Property name="parser">
<Type>PXW.DEV.BNF.Compilers.BNF3safe</Type>
</Property>

<Parameter name="COMPACT">
<Description>
Attempt to remove all the nonsense element structure 
its not really working so turning off!</Description>
<Default>0</Default>
</Parameter>

<Method name="methodName">
<FormalSpec>text:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set s1=$TRANSLATE(text,"_-/\:","     ")
    Set s1=$ZCONVERT(s1,"W")
    Set s1=$TRANSLATE(s1," ","")
    if $e(s1,1)?1N set s1="mn"_s1
    Quit s1
]]></Implementation>
</Method>

<Method name="compileDefinition">
<FormalSpec>Element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    #dim nameE,eqE,rulesE as PXW.DEV.Element
    #define WRITE(%code) $$$WRITENOLINE(method,%code)
    #define WRITECR(%code) $$$WRITELINE(method,%code)
    #dim method as %Dictionary.MethodDefinition

    Set pkey=""
    Set nameE=Element.partsGetNext(.pkey)
    Set eqE=Element.partsGetNext(.pkey)
    Set rulesE=Element.partsGetNext(.pkey)

    Set mname=..methodName(nameE.ToString(0))
   
    ;if $$$LOWER(nameE.ToString(0))=$$$LOWER("CobolVariableDefinition") $$$DEBUGNew("")
    ;if $$$LOWER(mname)=$$$LOWER("CobolVariableDefinition") $$$DEBUGNew("")
     zw mname
    $$$DEBUGBreak
    Set method=..NewMethod(mname)
    Set method.Description=Element.ToString(" ")
    Set ..CurrentMethod=method
    
    ; simple check to look for recursion (the rules contains the name
    If $$$UPPER(" "_rulesE.ToString(" ")_" ")[$$$UPPER(" "_nameE.ToString(0)_" ") {
        Set indent=1,transaction=0,path=0
        ; recursive function
        ; create a new method containing the basics
        Set recmethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"Recurse"))
        Do ..compileQuickCheck(recmethod,rulesE,indent)
        Do ..compileMethodStart(recmethod,indent,path,transaction)
        Do ..compileRules(recmethod,rulesE,indent)
        Do ..compileMethodEnd(recmethod,indent,,transaction)

        ; ideas from https://medium.com/@gvanrossum_83706/left-recursive-peg-grammars-65dab3c580e1
        $$$WRITECR($$$Tab(indent)_"$$$DEBUGMethodBegin")
        $$$WRITECR($$$Tab(indent)_"$$$BNFPATH")
        $$$WRITECR($$$Tab(indent)_"set done=0,ok=1,pos=..stream.pos,lastpos=pos")
        $$$WRITECR($$$Tab(indent)_"if $$$BNFMEMOExists(pos) {")
        $$$WRITECR($$$Tab(indent+1)_"$$$BNFMEMOGET(pos,subElement)")
        $$$WRITECR($$$Tab(indent+1)_"set ret=($isobject(subElement))")
        $$$WRITECR($$$Tab(indent+1)_"if ret $$$BNFCOMMITCOPY(subElement,ParentElement)")
        $$$WRITECR($$$Tab(indent+1)_"quit ret")
        $$$WRITECR($$$Tab(indent)_"}")
        $$$WRITECR($$$Tab(indent)_"$$$BNFMEMOSET(pos,"""")")
        $$$WRITECR($$$Tab(indent)_"do ..getBookmark(.bm)")
        $$$WRITECR($$$Tab(indent)_"while ok {")
        $$$WRITECR($$$Tab(indent)_"$$$BNFSTART(subElement)")
        $$$WRITECR($$$Tab(indent+1)_"do ..gotoBookmark(.bm)")
        ;$$$WRITECR($$$Tab(indent+1)_"set rec=.."_recmethod.Name_"(ParentElement,.addedElement)")
        $$$WRITECR($$$Tab(indent+1)_"set rec=.."_recmethod.Name_"(subElement,.addedElement)")
        $$$WRITECR($$$Tab(indent+1)_"if rec,..stream.pos>lastpos {")
        $$$WRITECR($$$Tab(indent+2)_"$$$BNFMEMOSET(pos,addedElement)")
        $$$WRITECR($$$Tab(indent+2)_"set done=1,lastpos=..stream.pos")
        $$$WRITECR($$$Tab(indent+1)_"} else {")
        $$$WRITECR($$$Tab(indent+2)_"set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best ") 
        $$$WRITECR($$$Tab(indent+1)_"}")
        $$$WRITECR($$$Tab(indent)_"}")
        $$$WRITECR($$$Tab(indent)_"if done {")
            If '..#COMPACT {
                $$$WRITECR($$$Tab(indent+1)_"$$$BNFCOMMIT(subElement,ParentElement)")
            } Else {
                $$$WRITECR($$$Tab(indent+1)_"if subElement.partsCount()=1,subElement.partsGetAt(1).%IsA(""PXW.DEV.Atom"") {")
                $$$WRITECR($$$Tab(indent+2)_"$$$BNFCOMMITCOPY(subElement,ParentElement)")
                $$$WRITECR($$$Tab(indent+1)_"} elseif subElement.partsCount()=1,subElement.partsGetAt(1).type'="""_mname_""" {")
                $$$WRITECR($$$Tab(indent+2)_"$$$BNFCOMMITCOPY(subElement,ParentElement)")
                $$$WRITECR($$$Tab(indent+1)_"} else {")
                $$$WRITECR($$$Tab(indent+2)_"$$$BNFCOMMIT(subElement,ParentElement)")
                $$$WRITECR($$$Tab(indent+1)_"}")
            }
        $$$WRITECR($$$Tab(indent+1)_"set ret=1")
        $$$WRITECR($$$Tab(indent)_"} else {")
        $$$WRITECR($$$Tab(indent+1)_"if $isobject(subElement) $$$BNFROLLBACK(subElement)")
        $$$WRITECR($$$Tab(indent+1)_"set ret=0")
        $$$WRITECR($$$Tab(indent)_"}")
        $$$WRITECR($$$Tab(indent)_"$$$DEBUGMethodEnd")
        $$$WRITECR($$$Tab(indent)_"quit ret")
    } elseif rulesE.type="SingleChar" {
        Set indent=1
        Do ..compileQuickCheck(method,rulesE,indent)
        Do ..compileMethodStart(method,indent,1)
        $$$WRITECR($$$Tab(indent)_"if ..addPunctuation(subElement,"""_$replace(rulesE.ToString(0),"""","""""")_""") "_$$$OpenCurly)
        $$$WRITECR($$$Tab(indent+1)_"set done=1")
        $$$WRITECR($$$Tab(indent)_$$$CloseCurly)
        ;$$$WRITECR($$$Tab(indent)_"if done "_$$$OpenCurly)
        ;$$$WRITECR($$$Tab(indent+1)_"$$$BNFCOMMIT(subElement,ParentElement)")
        ;$$$WRITECR($$$Tab(indent+1)_"set ret=1")
        ;$$$WRITECR($$$Tab(indent)_$$$CloseCurly_" else "_$$$OpenCurly)
        ;$$$WRITECR($$$Tab(indent+1)_"if $isobject(subElement) $$$BNFROLLBACK(subElement)")
        ;$$$WRITECR($$$Tab(indent+1)_"set ret=0")
        ;$$$WRITECR($$$Tab(indent)_$$$CloseCurly)
        
        Do ..compileMethodEnd(method,indent)
    }  elseif rulesE.type="Omitted" {
        Set indent=1
        Do ..compileQuickCheck(method,rulesE,indent)
        $$$WRITECR($$$Tab(indent)_"quit 0 ; omitted rule never true")
    } Else {
        Set rkey=""
        Set indent=1
        Do ..compileQuickCheck(method,rulesE,indent)
        Do ..compileMethodStart(method,indent,1)
        If 1 {
            $$$WRITECR($$$Tab(indent)_"set pos=..stream.pos")
            $$$WRITECR($$$Tab(indent)_"if $$$BNFMEMOExists(pos) {")
            $$$WRITECR($$$Tab(indent+1)_"$$$BNFMEMOGET(pos,subElement)")
            $$$WRITECR($$$Tab(indent+1)_"set done=$isobject(subElement)")
            ;$$$WRITECR($$$Tab(indent+1)_"$$$BNFCOMMIT(subElement,ParentElement)")
            ;$$$WRITECR($$$Tab(indent+1)_"quit ret")
            $$$WRITECR($$$Tab(indent)_$$$CloseCurly_" else "_$$$OpenCurly)
            Set indent=indent+1

        }
        Do ..compileRules(method,rulesE,indent)
        $$$WRITECR("")
        If 1 {
            Set indent=indent-1
            $$$WRITECR($$$Tab(indent)_$$$CloseCurly)
            $$$WRITECR($$$Tab(indent)_"if done "_$$$OpenCurly)
            $$$WRITECR($$$Tab(indent+1)_"$$$BNFMEMOSET(pos,subElement)")
            $$$WRITECR($$$Tab(indent)_$$$CloseCurly_" else "_$$$OpenCurly)
            ;$$$WRITECR($$$Tab(indent+1)_"$$$BNFMEMOKILL(pos,subElement)")
            $$$WRITECR($$$Tab(indent)_$$$CloseCurly)
        }
        Do ..compileMethodEnd(method,indent)
    }
]]></Implementation>
</Method>

<Method name="compileRules">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indent:%Integer</FormalSpec>
<Implementation><![CDATA[
    #dim ruleE as PXW.DEV.Element
    #define WRITE(%code) $$$WRITENOLINE(Method,%code) 
    #define WRITECR(%code) $$$WRITELINE(Method,%code) 

    Set summary=..summariseRules(Element)
    ;s Method.Description=Method.Description_$c(13,10)_"summary="_summary    
    
    Set initialIndent=indent
    Set first=1
    For  {
        Set ruleE=Element.findNextElement(.rkey)
        Quit:rkey=""
        If first {
            $$$WRITE($$$Tab(indent)_"if ")
            If ruleE.type="Rule" {
                Do ..compileRule(Method,ruleE,indent)
            } ElseIf ruleE.type="OrRules" {
                Do ..compileOrRules(Method,ruleE,indent)
            } Else {
                $$$WRITE("unexpected "_ruleE.type_", expected Rule,OrRules")
            }
        } ElseIf (ruleE.type="Rule") {
            $$$WRITE(" && ")
            Do ..compileRule(Method,ruleE,indent)
        } ElseIf (ruleE.type="OrRules") {
            $$$WRITECR(" "_$$$OpenCurly)
            $$$WRITECR($$$Tab(indent+1)_"set done=1 ; or")
            $$$WRITE($$$Tab(indent)_$$$CloseCurly_" elseif ")
            ;do ruleE.write()
            Do ..compileOrRules(Method,ruleE,indent)
        } Else {
            $$$WRITECR(" ; don't know what to do Rules"_ruleE.Type)
        }

        Set first=0
    }
    $$$WRITECR(" "_$$$OpenCurly)
    $$$WRITECR($$$Tab(indent+1)_"set done=1 ; end compileRules")
    $$$WRITE($$$Tab(indent)_$$$CloseCurly)
    For indent=indent-1:-1:initialIndent {
        $$$WRITECR($$$Tab(indent)_$$$CloseCurly) 
    }
    $$$WRITECR("")
]]></Implementation>
</Method>

<Method name="compileQuickCheck">
<FormalSpec>Method:%Dictionary.MethodDefinition,RulesElement:PXW.DEV.Element,indent:%Integer,returnValue:%String="0 /* normal */"</FormalSpec>
<Implementation><![CDATA[	Quit
]]></Implementation>
</Method>

<Method name="compileOrRules">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indent:%Integer</FormalSpec>
<Implementation><![CDATA[
    #dim ruleE as PXW.DEV.Element
    #define WRITE(%code) $$$WRITENOLINE(Method,%code) 
    #define WRITECR(%code) $$$WRITELINE(Method,%code) 

    Set rkey=""
    Set copy=1
    Set elementcount=Element.countElements()
    If elementcount=1 {
        Set ruleE=Element.findNextElement(.rkey)
        Do ..compileRule(Method,ruleE,indent)
    } Else {
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"Or"))
        Do ..compileMethodStart(subMethod,indent,0,1,1)
        Do ..compileRules(subMethod,Element,indent)
        Do ..compileMethodEnd(subMethod,indent,0,1,1,copy)
        $$$WRITE(".."_subMethod.Name_"(subElement,.addedElement) ") 
    }
]]></Implementation>
</Method>

<Method name="compileRule">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indent:%Integer,subElementVar:%String="subElement"</FormalSpec>
<Implementation><![CDATA[
    #dim atom as PXW.DEV.Atom
    #dim subelement as PXW.DEV.Element
    #dim rulesE as PXW.DEV.Element

    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    $$$DEBUGBreak

    Set subelement=Element.findNextElement("") ; get the first thing, atoms are not interesting
    If subelement.type="Keyword" {
        Set atom=subelement.FirstAtom()
        Set word=atom.value
        Set word=$REPLACE(word,"""","""""") ; sort out quote in quotes
        If ..Loader.isKeyword(atom.value) {
            If atom.start="'" {
                Set ..keywords($$$UPPER(atom.value))=1
            } Else {
                ; keywords in double quotes are "soft" and should not be in the keyword check
            }
            $$$WRITE("..addKeyword("_subElementVar_","""_$$$UPPER(word)_""") ")
        } Else {
            $$$WRITE("..addPunctuation("_subElementVar_","""_word_""") ")
        }
    } ElseIf subelement.type="Call" {
        Set mnameA=Element.FirstAtom()
        Set mname=..methodName(mnameA.ToString(0))
        $$$WRITE(".."_mname_"("_subElementVar_",.addedElement) ")
    } ElseIf subelement.type="Subrule" {
        Set rulesE=subelement.findFirstElementByType("rules",0)
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"Sub"))
        Set subMethod.Description=rulesE.ToString(" ")
        Do ..compileSubRule(subMethod,rulesE,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ")
    } ElseIf subelement.type="OptionalGroup" {
        Set rulesE=subelement.findFirstElementByType("Rules",0)
        If rulesE.partsCount()=1 {
            $$$WRITE("$S(")
            Set ruleE=rulesE.partsGetAt(1)
            Do ..compileRule(Method,ruleE,indent)
            $$$WRITE(":1,1:1)")
        } Else {
            Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"OptGrp"))
            Do ..compileOptionalGroup(subMethod,rulesE,indent)
            $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
        }
    } ElseIf subelement.type="NotRule" {
        Set ruleE=subelement.findFirstElementByType("NotableRule",0)
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"Not"))
        Set subMethod.Description=ruleE.ToString(" ")
        Do ..compileNotRule(subMethod,ruleE,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ")
    } ElseIf subelement.type="RepeatSep" {
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"RepSep"))
        Do ..compileRepeatSep(subMethod,subelement,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
    } ElseIf subelement.type="LookAhead" {
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"Peek"))
        Do ..compilePeek(subMethod,subelement,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
    } ElseIf subelement.type="RepeatOne" { 
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"RepOne"))
        Do ..compileRepeatOne(subMethod,subelement,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
    } ElseIf subelement.type="RepeatZero" { 
        Set subMethod=..NewMethod(..SubMethodName(..CurrentMethod.Name,"RepZero"))
        Do ..compileRepeatZero(subMethod,subelement,indent)
        $$$WRITE(".."_subMethod.Name_"("_subElementVar_",.addedElement) ") 
    } ElseIf subelement.type="OptionalSingle" { 
        Set ruleE=subelement.findFirstElementByType("OptionalableRule",0)
        $$$WRITE("$s(")
        Do ..compileRule(Method,ruleE)
        $$$WRITE(":1,1:1) ") 
    } ElseIf subelement.type="Force" {
        $$$WRITE("1 /* force means? */")
    } Else {

        $$$WRITE("; don't know what to do with "_subelement.type)
    }
]]></Implementation>
</Method>

<Method name="compileNotRule">
<FormalSpec>Method:%Dictionary.MethodDefinition,Element:PXW.DEV.Element,indentOfParent:%Integer</FormalSpec>
<Implementation><![CDATA[
    #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)

    Set indent=1
    Set path=0
    Set transaction=1,debug=1
    ;s summary=..summariseRules(Element)
    ; this is just one or more calls to other things, those things will be in transactions so no need here
    ;i summary?1"C"0."|C" s transaction=0,debug=0
    ; this is just one or more checks of keywords, no need to be in a transaction
    ;i summary?1"K"0."|K" s transaction=0,debug=0
    ;i summary?1"P"0."|P" s transaction=0,debug=0
    ;$$$WRITECR($$$Tab(indent)_"; sub summary="_summary_", transaction="_transaction)
    ;d ..compileQuickCheck(Method,Element,indent)
    Do ..compileMethodStart(Method,indent,path,transaction,debug)
    If 'transaction $$$WRITECR($$$Tab(indent)_"set subElement=ParentElement")
    $$$WRITE($$$Tab(indent)_"if ")
    Do ..compileRule(Method,Element,indent)
    $$$WRITECR(" "_$$$OpenCurly_" set done=1 "_$$$CloseCurly)
    ;d ..compileMethodEnd(Method,indent,,transaction,debug)

	$$$WRITECR($$$Tab(indent)_"$$$BNFROLLBACK(subElement)") ; always rollback

    $$$WRITECR($$$Tab(indent)_"if done {")
	$$$WRITECR($$$Tab(indent+1)_"set ret=0") ; reverse for NOT
	$$$WRITECR($$$Tab(indent)_"} else {")
	$$$WRITECR($$$Tab(indent+1)_"set ret=1") ; reverse for NOT
	$$$WRITECR($$$Tab(indent)_"}")
	$$$WRITECR($$$Tab(indent)_"$$$DEBUGMethodEnd")
	$$$WRITECR($$$Tab(indent)_"quit ret")
]]></Implementation>
</Method>

<Method name="compileMethodEnd">
<FormalSpec>Method:%Dictionary.MethodDefinition,indent:%Integer,rollbackReturns:%String="0 ; normal rollback",needsTransation:%Boolean=1,needsDebug:%Boolean=1,copyMode:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
   #define WRITE(%code) $$$WRITENOLINE(Method,%code)
    #define WRITECR(%code) $$$WRITELINE(Method,%code)

    $$$WRITECR($$$Tab(indent)_"if done {")
	If needsTransation {
        If copyMode=0 {
            If ..#COMPACT {
                $$$WRITECR($$$Tab(indent+1)_"; if the only thing is an atom then the element is adding no value so copy to parent")
                $$$WRITECR($$$Tab(indent+1)_"i subElement.partsCount()=1,subElement.partsGetAt(1).%IsA(""PXW.DEV.Atom"") {")
                $$$WRITECR($$$Tab(indent+2)_"$$$BNFCOMMITCOPY(subElement,ParentElement)")
                $$$WRITECR($$$Tab(indent+1)_"} else {")
                $$$WRITECR($$$Tab(indent+2)_"$$$BNFCOMMIT(subElement,ParentElement)")
                $$$WRITECR($$$Tab(indent+1)_"}")
            } Else {
                $$$WRITECR($$$Tab(indent+2)_"$$$BNFCOMMIT(subElement,ParentElement)")
            }
        }
        If copyMode=1 $$$WRITECR($$$Tab(indent+1)_"$$$BNFCOMMITCOPY(subElement,ParentElement)")
    }
	$$$WRITECR($$$Tab(indent+1)_"set ret=1")
	$$$WRITECR($$$Tab(indent)_"} else {")
	If needsTransation $$$WRITECR($$$Tab(indent+1)_"$$$BNFROLLBACK(subElement)")
	$$$WRITECR($$$Tab(indent+1)_"set ret="_rollbackReturns)
	$$$WRITECR($$$Tab(indent)_"}")
	If needsDebug $$$WRITECR($$$Tab(indent)_"$$$DEBUGMethodEnd")
	$$$WRITECR($$$Tab(indent)_"quit ret")
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Compilers.analyser">
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77562.385815144</TimeChanged>
<TimeCreated>67125,77562.385815144</TimeCreated>

<Property name="This">
<Description>
Name of the class being analysed</Description>
<Type>%String</Type>
</Property>

<Property name="ThisMethod">
<Description>
Name of the method being analysed</Description>
<Type>%String</Type>
</Property>

<Property name="ElementWarnings">
<Description>
Warnings assigned to elements
..ElementWarnings(+elementid)="text of the warning"</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>
</Class>


<Class name="PXW.DEV.BNF.Compilers.loader">
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77562.515502715</TimeChanged>
<TimeCreated>67125,77562.515502715</TimeCreated>

<Parameter name="Paths">
<Description>
include the %path code  in the generated code, helps with debug</Description>
<Default>1</Default>
</Parameter>

<Parameter name="KeywordPattern">
<Description>
Used by the code generator and passed onto the generated code.
The check is done lots of times to keep building up a word until the test fails.</Description>
<Default>1.A</Default>
</Parameter>

<Parameter name="SubElementType">
<Default>PXW.DEV.BNF.Element</Default>
</Parameter>

<Projection name="GEN">
<Type>PXW.DEV.BNF.Compilers.projection</Type>
<Parameter name="GenerateTo"/>
</Projection>

<Property name="type">
<Type>%String</Type>
</Property>

<UDLText name="T">
<Content><![CDATA[/* text,col and linenumber refer to the data within a rule (not the entire file) */
]]></Content>
</UDLText>

<Property name="text">
<Type>%String</Type>
</Property>

<Property name="col">
<Type>%String</Type>
</Property>

<Property name="linenumber">
<Type>%String</Type>
</Property>

<Property name="maincode">
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="functioncode">
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="code">
<Type>%String</Type>
</Property>

<Property name="codeNoWrap">
<Type>%String</Type>
</Property>

<Property name="counter">
<Type>%Integer</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="isKeyword">
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>string:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    ; q (string?1.A)
    Do %code.WriteLine($CHAR(9)_"q (string?"_%parameter("KeywordPattern")_")")
    Quit $$$OK
]]></Implementation>
</Method>

<XData name="file">
<Data><![CDATA[
<data><![CDATA[
    ]]]]><![CDATA[>

    </data>
]]></Data>
</XData>
</Class>


<Class name="PXW.DEV.BNF.Compilers.projection">
<Super>%Projection.AbstractProjection</Super>
<TimeChanged>67125,77562.535664067</TimeChanged>
<TimeCreated>67125,77562.535664067</TimeCreated>

<Parameter name="GenerateTo">
<Description>
Name of the class that should be generated</Description>
</Parameter>

<Parameter name="GenerateToNew">
<Description>
Name of the class that should be generated using new compiler</Description>
</Parameter>

<Parameter name="oGenerateTo">
<Description>
So you can edit the projection easily to turn off generate</Description>
</Parameter>

<Parameter name="oGenerateToNew">
<Description>
So you can edit the projection easily to turn off generate</Description>
</Parameter>

<Method name="CreateProjection">
<Description>
This method is invoked when a class is compiled</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[cls:%String,&params:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set genclass=$GET(params("GenerateTo"),"UNDEF")
    If genclass="UNDEF" Quit $$$ERROR(5001,"GenerateTo parameter is not set")
 
    If genclass'="UNDEF" {
        If genclass'="" {
            If '$GET(^PXW.DEV.BNF("AUTOCOMPILE")) {
                Write !,"AUTOCOMPILE is OFF, Set sc=##class(PXW.DEV.BNF.Compilers.Compiler).goload("""_cls_""","""_genclass_""") " ;  manually"
                Set sc=$$$OK
            } Else {
                Set sc=##class(PXW.DEV.BNF.Compilers.Compiler).goload(cls,genclass)
            }
        } Else {
            Set sc=$$$OK
        }
    }
    Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.DEF.COS">
<Super>PXW.DEV.BNF.Compilers.loader</Super>
<TimeChanged>67125,77562.550128716</TimeChanged>
<TimeCreated>67125,77562.550128716</TimeCreated>

<Projection name="GEN">
<Type>PXW.DEV.BNF.Compilers.projection</Type>
<Parameter name="GenerateTo" value="PXW.DEV.BNF.GEN.COS"/>
<Parameter name="GenerateToNew" value="PXW.DEV.BNF.GEN.COSnew"/>
</Projection>

<Parameter name="SubElementType">
<Default>PXW.DEV.BNF.Elements.COS</Default>
</Parameter>

<Parameter name="KeywordPattern">
<Description>
Used by the code generator and passed onto the generated code.
The check is done lots of times to keep building up a word until the test fails.</Description>
<Default>1A.AN</Default>
</Parameter>

<XData name="file">
<Data><![CDATA[
<bnf>
<data><![CDATA[
 
/*
 * COS grammar
 */ 

open_bracket                        ::= '('  /* this is a special check that should NOT remove whitespace so things like $p(x,a,2) works and $p (x,a,2) is a fail */
close_bracket                       ::= ')'

cos_code_block                      ::= one_cos_statement ( one_cos_statement )*
cos_code_block_sql                  ::= one_cos_Statement_sql ( one_cos_statement_sql)*
cos_code_block_sql_storage          ::= one_cos_Statement_sql ( one_cos_statement_sql)*
cos_code_block_trigger              ::= one_cos_statement ( one_cos_statement )*
                                  
one_cos_statement                   ::= [ label_definition ] ('.')* cos_command 
one_cos_statement_sql               ::= ('.')* cos_command  /* in SQLCompute mode line labels are not allowed, and variables can be {*} or {field} */

label_definition                    ::= label_identifier [ label_formal_specification ] [ label_scope ] [ '{' cos_code_block '}']
label_formal_specification          ::= '(' [ label-formal-param-list ]  ')'
label-formal-param-list             ::= label-one-formal-param ( ',' label-one-formal-param )* ['...']
label-one-formal-param              ::= [ '&' ] label-param-name [ label-param-default-value ]
label-param-default-value           ::= '=' expression
label-param-name                    ::= variable_set /*identifier*/
label_scope                         ::= ( [ label_public_vars ] 'public' | 'private' | 'methodimpl' ) /*'{' [ command_list ] '}'*/
label_public_vars                   ::= '[' variable ( ',' variable )* ']'

label_reference                     ::= (( label_identifier  | simple_indirection ) [ '^' [routine_env] ( routine_identifier  | simple_indirection) ])  /* lab^rouine */
                                        | ('^' [routine_env] (routine_identifier | simple_indirection) ) /* ^routine -- no label */
label_identifier                    ::= [ '%' ] 'regexp:[0-9A-Za-z]+'
routine_identifier                  ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)' 
routine_env                         ::= '|' [ expression ] '|' 
cos_directive                       ::= '#' ( cos_directive_define
                                        | cos_directive_dim
                                        | cos_directive_ifdef
                                        | cos_directive_ifndef
                                        | cos_directive_if
                                        | cos_directive_else
                                        | cos_directive_elseif
                                        | cos_directive_endif 
                                        | cos_directive_defonearg
                                        | cos_directive_include
                                        | cos_directive_undef
                                        | cos_directive_execute
                                        | cos_directive_sqlcompile
                                        )

cos_directive_defonearg             ::= 'def1arg' cos_directive_define_name [ array_parameter_list ] [cos_directive_define_subst] /* text_to_eol_continue */
cos_directive_define                ::= 'define' cos_directive_define_name [ array_parameter_list ] [cos_directive_define_subst]  /*[ text_to_eol_continue]*/
cos_directive_define_name           ::= macro_identifier
cos_directive_define_subst          ::= [command_list_eol | expression_list ] text_to_eol_continue 
cos_directive_dim                   ::= 'dim' cos_directive_dim_item (',' cos_directive_dim_item )* /*Studio and VSCode do not allow multiple dims on one line, but the compiler does not complain (unless there is an =) and some intersystems code has it! %Installer.Invoke  */
cos_directive_dim_item              ::= variable_set [(',' variable_set )*] [ 'as' [('array' | 'list') 'of'] class_reference ] [ '=' dim_expression ] 
cos_directive_else                  ::= 'else'
cos_directive_elseif                ::= 'elseif' expression
cos_directive_endif                 ::= 'endif'
cos_directive_execute               ::= 'execute' command_list_eol
cos_directive_if                    ::= 'if' expression 
cos_directive_ifdef                 ::= 'ifdef' macro_identifier 
cos_directive_ifndef                ::= 'ifndef' macro_identifier 
cos_directive_include               ::= 'include' (cos_directive_include_list | cos_directive_include_name)
cos_directive_sqlcompile            ::= 'sqlcompile' ( 
                                            ( 'select' '=' ('display' | 'logical' | 'odbc' | 'runtime' | 'text' | 'FDBMS') )
                                            | ( 'mode' '=' ('deferred') ) )
cos_directive_undef                 ::= 'undef' macro_identifier 

cos_directive_include_list          ::= '(' cos_directive_include_name ( ',' cos_directive_include_name )* ')'
cos_directive_include_name          ::= identifier


dim_expression                      ::= expression

class_identifier                    ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)' 

cos_command                         ::=  set_command
                                         | if_command
                                         | quit_command
                                         | do_command
                                         | for_command
                                         | kill_command
                                         | break_command
                                         | continue_command
                                         | goto_command
                                         | else_command
                                         | hang_command /* hang must come before halt */
                                         | halt_command
                                         | job_command
                                         | sql_command
                                         | js_command
                                         | lock_command
                                         | merge_command
                                         | new_command
                                         | open_command
                                         | close_command
                                         | return_command
                                         | read_command
                                         | tcommit_command
                                         | throw_command
                                         | trollback_command
                                         | try_command
                                         | tstart_command
                                         | use_command
                                         | view_command
                                         | while_command
                                         | write_command
                                         | xecute_command
                                         | macrocall
                                         | cos_directive
                                         | zallocate_command
                                         | zbreak_command
                                         | zdeallocate_command
                                         | zinsert_command
                                         | zkill_command
                                         | zload_command
                                         | znspace_command
                                         | zprint_command
                                         | zquit_command
                                         | zremove_command
                                         | zsave_command
                                         | zsync_command
                                         | ztrap_command
                                         | zwrite_command
                                         | zzdump_command
                                         | zzwrite_command
                                         | html_command
                                         | print_command
                                         | mpv_command

command_list                        ::= cos_command ( cos_command )*
command_list_eol                    ::= cos_command ( cos_command )* /* needs to stop at end of line */

whitespace                          ::= ( [ comment ] [ ( ' ' | '\t' | '\r') ] )*

comment                             ::= line_comment
                                        | block_comment

line_comment                        ::= ';' text_to_eol
                                         | '//' text_to_eol
                                         | '#;' text_to_eol
                                         | '##;' text_to_eol
block_comment                       ::= '/*' text '*/'

text_to_eol                         ::= 'regexp:[^\r\n]*'
text_to_eol_continue                 ::= 'regexp:[^\r\n]*' 

text                                ::= 'regexp:.*'

expression                          ::= factor ( pattern_match | (dyadicop factor ))*

factor                              ::= ( monadicop )* primary /* can be any number of +- or ' */
monadicop                           ::= "+" | "-" | "'" | "~" /* not sure what ~ is but its used in bitlogic */

dyadicop                            ::= "+" 
                                          | "-" 
                                          | "\\" 
                                          | "/" | "\"
                                          | ">=" | ">" 
                                          | "'>=" | "'>" 
                                          | "<="  | "<" 
                                          | "'<=" | "'<" 
                                          | "=" 
                                          | "'=" 
                                          | "**" 
                                          | "*" 
                                          | "&&" 
                                          | "']]" | "]]" | "']" | "]"
                                          | "'["  | "["
                                          | "!" 
                                          | "||" 
                                          | "_" 
                                          | hash_op
                                          | amp_op

hash_op                             ::= '#' /* HASH is a special case and needs coding */
amp_op                              ::= '&' /* & is a special case and needs coding */

term                                ::= primary 

pattern_match                       ::= ( "?" | "'?" ) (pattern_match_combo )*
pattern_match_combo                 ::=  pattern_match_repeat ( pattern_match_code | pattern_match_alternating  ) 
pattern_match_alternating           ::= '(' ( pattern_match_combo ( ',' pattern_match_combo )*  )')'
pattern_match_repeat                ::= ('regexp:[0-9]*' [ '.' [ 'regexp:[0-9]*' ] ]) | ('.' ['regexp:[0-9]*'])
pattern_match_code                  ::= 'a' | 'c' | 'e' | 'l' | 'n' | 'p' | 'u' | 'b' | 'm' 
                                        | 'ZFWCHARZ' | 'ZHWKATAZ' 
                                        | string


macrocall                           ::= '$$$' macro_identifier [ macro_parameter_list | macro_parameter_text ] [ macro_parameter_list ]  [ object_chain ] /* PXW $$mac(1,2)(3,4) is valid, also calling .property etc is possible */
macro_parameter_list                ::= '(' [ [macro_parameter] ( ',' [macro_parameter] )* ] ')'
macro_parameter                     ::= ('.' variable_set ) | expression 
macro_parameter_text                ::= '(' any_text_upto_close_bracket  ')'
macro_identifier                    ::= [ '%' ] 'regexp:[0-9A-Za-z]+'
any_text_upto_close_bracket         ::= 'code this'

extrinsicfncall                     ::= '$$' label_reference  [extrinsicfncall_parameter_list ]
extrinsicfncall_parameter_list                ::= open_bracket [ [extrinsicfncall_parameter] ( ',' [extrinsicfncall_parameter] )* ] ['...'] close_bracket
extrinsicfncall_parameter                     ::= ('.' (this_object_direct_property | simple_indirection | variable )) | expression 

OLDintrinsicfncall                     ::= case_function_call
                                        | select_function_call
                                        | extract_function_call
                                        | piece_function_call
                                        | listitem_function_call
                                        | listupdate_function_call
                                        | increment_function_call
                                        | method_function_call
                                        | classmethod_function_call
                                        | zobjmethod_function_call
                                        | zobjclassmethod_function_call
                                        | text_function_call
                                        | bitlogic_function_call 
                                        | expression_function_call
                                        | ('$' identifier function_parameter_list /* intrinsicfncall_parameter_list */ [ object_chain ])

intrinsicfncall                     ::= '$' (special_intrinsic | general_intrinsic )
special_intrinsic                   ::= case_function_call
                                        | select_function_call
                                        | extract_function_call
                                        | piece_function_call
                                        | listitem_function_call
                                        | listupdate_function_call
                                        | increment_function_call
                                        | method_function_call
                                        | classmethod_function_call
                                        | zobjmethod_function_call
                                        | zobjclassmethod_function_call
                                        | text_function_call
                                        | bitlogic_function_call 
general_intrinsic                   ::= any_keyword function_parameter_list  [ object_chain ]


intrinsicfncall_parameter_list      ::= open_bracket [expression] ( ',' [expression]  )*  close_bracket
intrinsicfncall_parameter           ::= expression

function_parameter_list             ::= open_bracket [ [function_parameter] ( ',' [function_parameter] )* ] ['...'] close_bracket
function_parameter                  ::= ( '.' ( this_object_direct_property | simple_indirection | variable )) | expression 


intrinsicfncall_set                 ::= '$' (special_intrinsic_set | general_intrinsic_set )
special_intrinsic_set               ::= extract_function_call_set
                                        | piece_function_call_set
                                        | listitem_function_call_set
                                        | listbuild_function_call_set
general_intrinsic_set               ::= any_keyword function_parameter_list  [ object_chain ]
 

parameter_list                      ::= '(' [ parameter_values ] ')'
parameter_values                    ::= one_parameter_value ( ',' [ one_parameter_value ] )*
one_parameter_value                 ::= ( [ '.' ] identifier ) | ( identifier '...' ) | expression

macro_expression                    ::= expression_function_call | safeexpression_function_call

classexpr                           ::= super_expression | class_expression
super_expression                    ::= '##super' function_parameter_list
class_expression                    ::= '##class' '('  class_reference  ')' [ class_casting ] object_chain 
class_casting                       ::= ['(' ] ( '##this' | '$this' | variable_identifier ) [')'] 
class_reference                     ::= class_identifier

oldthis_object                           ::= ('..' | 'i%' | 'r%' | '$this' | '##this') object_chain_item  [ object_chain] 
oldthis_object_set                       ::= ('..' | 'i%' | 'r%' | '$this' | '##this' ) object_chain_item  [ object_chain] 
this_object                         ::= this_object_self | this_object_this
this_object_set                     ::= this_object_self | this_object_this
this_object_self                    ::= ('..' | 'i%' | 'r%' | 'm%' | 's%') [object_chain_no_dot] 
this_object_this                    ::= ('$this' | '##this') [ object_chain]
this_object_direct_property         ::= 'i%' object_chain_item  

system_object                       ::='$system.' object_chain_item [ object_chain ]

object_variable                     ::= variable_identifier [ array_parameter_list ] object_chain 

member_ref                          ::= identifier | string

Indirection                         ::= Subscript_Indirection | Simple_Indirection 
Simple_Indirection                  ::= '@' term
Subscript_Indirection               ::= '@' term '@'  subscript_parameter_list 
subscript_parameter_list                ::= '(' expression ( ',' expression )*  ')'

global_ref_set                       ::= global_ref_naked | global_ref_full
global_ref                           ::= global_ref_naked | global_ref_full
global_ref_full                      ::= '^' [ global_ref_env  | global_ref_env_two ] (macrocall |  global_name ) [subscript_parameter_list]
global_ref_naked                     ::= '^' subscript_parameter_list
global_ref_env                       ::= '|' [ expression ] '|' 
global_ref_env_two                   ::= '[' primary [ ',' primary ] ']' /* for now we use primary, expression uses [] which confuse the expression (where ] is a valid operator) */
global_name                         ::= global_identifier

primary                             ::= number
                                          | string
                                          | macrocall
                                          | macro_expression /* not sure "primary" is the right place for this but we are not validating, just trying to make sense */
                                          | this_object
                                          | extrinsicfncall /* PXW $$lab() */
                                          | intrinsicfncall /* PXW $function() */
                                          | classexpr
                                          | variable
                                          | special_variable /* $h etc */
                                          | Indirection
                                          | global_ref
                                          | ( sub_expression [ object_chain ] ) /* a brackeded expression can return an object (x).prop */
                                          | (cos_json [ object_chain ])

sub_expression                      ::= '(' expression ')' 

special_variable                    ::= '$' ('DEVICE' -- Contains user-specified device status information.
                                          | 'ECODE' -- Contains the current error code string.
                                          | 'EC'
                                          | 'ESTACK' -- Contains the number of context frames saved on the call stack from a user-defined point.
                                          | 'ES'
                                          | 'ETRAP' -- Contains a string of ObjectScript commands to be executed when an error occurs.
                                          | 'ET'
                                          | 'HALT' -- Contains a halt trap routine call.
                                          | 'HOROLOG' -- Contains the local date and time for the current process.
                                          | 'H' -- Contains the local date and time for the current process.
                                          | 'IO' -- Contains the ID of the current input/output device.
                                          | 'I'
                                          | 'JOB' -- Contains the ID of the current process.
                                          | 'J' -- Contains the ID of the current process.
                                          | 'KEY' -- Contains the terminator character from the most recent READ.
                                          | 'NAMESPACE' -- Contains the namespace for the current stack level.
                                          | 'PRINCIPAL' -- Contains the ID of the principal I/O device.
                                          | 'P'
                                          | 'QUIT' -- Contains a flag indicating what kind of QUIT is required to exit the current context.
                                          | 'ROLES' -- Contains the roles assigned to the current process.
                                          | 'STACK' -- Special variable that contains the number of context frames saved on the call stack.
                                          | 'STORAGE' -- Contains the number of bytes available for local variable storage.
                                          | python_import
                                          | ('SYSTEM' [ object_chain ])  -- Contains system information about system objects.
                                          | 'S' -- storage
                                          | 'TEST' -- Contains the truth value resulting from the last command using the timeout option.
                                          /*| ('THIS' [ object_chain ] )  -- Contains the current class context.*/
                                          | 'THIS'
                                          | 'THROWOBJ' -- Contains the OREF from an unsuccessful THROW.
                                          | 'TLEVEL' -- Contains the current nesting level for transaction processing.
                                          | 'Tl'
                                          | 'T' -- test 
                                          | 'USERNAME' -- Contains the username for the current process.
                                          | 'X' -- Contains the current horizontal position of the cursor.
                                          | 'Y' -- Contains the current vertical position of the cursor.
                                          | 'ZA' -- Contains the status of the last READ on the current device.
                                          | 'ZB' -- Contains status information for the current I/O device.
                                          | 'ZCHILD' -- Contains the ID of the last child process.
                                          | 'ZEOF' -- Contains flag indicating whether end-of-file has been reached.
                                          | 'ZEOS' -- Contains end-of-stream status when reading a compressed stream.
                                          | 'ZERROR' -- Contains the name and location of the last error.
                                          | 'ZE' -- Contains the name and location of the last error.
                                          | 'ZHOROLOG' -- Contains the number of seconds elapsed since InterSystems IRIS startup.
                                          | 'ZH' -- Contains the number of seconds elapsed since InterSystems IRIS startup.
                                          | 'ZIO' -- Contains information about the current terminal I/O device.
                                          | 'ZJOB' -- Contains job status information.
                                          | 'ZMODE' -- Contains current I/O device OPEN parameters.
                                          | 'ZNAME' -- Special variable that contains the current routine name.
                                          | 'ZNSPACE' -- Contains the current namespace name.
                                          | 'ZN'
                                          | 'ZORDER' -- Contains the value of the next global node.
                                          | 'ZPARENT' -- Contains the ID of the parent process of the current process.
                                          | 'ZPI' -- Contains the value of pi.
                                          | 'ZPOS' -- Contains the current file position during the reading of a sequential file.
                                          | 'ZREFERENCE' -- Contains the current global reference.
                                          | 'ZR'
                                          | 'ZSTORAGE' -- Contains the maximum available memory for a process.
                                          | 'ZS' -- Contains the maximum available memory for a process.
                                          | 'ZTIMESTAMP' -- Contains the current date and time in Coordinated Universal Time format.
                                          | 'ZTS'
                                          | 'ZTIMEZONE' -- Contains the time zone offset from the Greenwich meridian.
                                          | 'ZTRAP' -- Contains the location of the current error trap handler.
                                          | 'ZT' -- Contains the location of the current error trap handler.
                                          | 'ZUTIL' -- 
                                          | 'ZU' --
                                          | 'ZVERSION' -- Contains a string describing the current version of InterSystems IRIS.
                                          | 'ZV'
                                          ) /* should this be just a general "read anything" ?*/

/* Special function that we want to deal with  - need to make it so we can extend this without changing this bnf - different apps may want to look for something else. */
python_import                       ::= 'system' '.' 'python' '.' 'import' '(' string ')' -- $ is already consumed by caller

variable                            ::= variable_identifier [ array_parameter_list ] [ object_chain ]
variable_set                        ::= variable_identifier [ array_parameter_list ] [ object_chain ]
variable_identifier                 ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
array_parameter_list                ::= open_bracket  expression ( ',' expression )*  close_bracket

object_chain99                        ::= '.' object_chain_item ( '.' object_chain_item )* 
object_chain                        ::= '.' object_member_identifier [ function_parameter_list ] [ object_chain ]
object_chain_no_dot                 ::= object_member_identifier [ function_parameter_list ] [ object_chain ]
object_dot                          ::= '.' /* this exists simply so that extra checks can be coded on the generated method to check for white*/
object_chain_item                   ::= object_member_identifier [ function_parameter_list ] 
object_member_identifier           ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'


number                              ::= ('regexp:[0-9]*' [ '.' 'regexp:[0-9]+'] [ ('e' | 'E' ) 'regexp:[0-9]+']) | ('.' 'regexp:[0-9]+' [ ('e' | 'E') 'regexp:[0-9]+'])  

string                              ::= '""' | ('"' 'regexp:[^\"\r\n]*' '"')

identifier                          ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
global_identifier                          ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'

post_conditional                    ::= ':' expression

expression_list                     ::= expression ( ',' expression )*

lvalue_expression                   ::= this_object_set
                                        | variable_set
                                        | intrinsicfncall_set /* $property, $list, $piece, $extract */
                                        | special_variable /* some can be set or newed ! */
                                        | macrocall
                                        | Indirection
                                        | global_ref_set


/**
 * COS commands
 */
break_command                       ::= ('break' | 'b') [ post_conditional ]  [ naked | ( break_extend | break_flag )]
break_extend                        ::= expression
break_flag                          ::= expression

close_command                       ::= ('close' | 'c') [ post_conditional ]  close_item (',' close_item)*
close_item                          ::= open_device [ ':' device_parameters ]
device_parameters                   ::= ( '(' device_parameter_list ')' ) | one_device_parameter
device_parameter_list               ::= ( one_device_parameter ( ':' one_device_parameter )* )
one_device_parameter                ::= text // to next : or ) or space

continue_command                    ::= 'continue' [ post_conditional ] 

do_command                          ::= ('do' | 'd') ( do_while | do_label ) 
do_label                            ::= [ post_conditional ] ( naked | do_item_list)
do_while                            ::= '{' [ cos_code_block ] '}' 'while' expression_list
do_item_list                        ::= do_item ( ',' do_item)*
do_item                             ::=  (object_variable)
                                          | this_object 
                                          | simple_indirection 
                                          | ( label_reference [ function_parameter_list ] ) 
                                          | system_object
                                          | macrocall
                                          | intrinsicfncall /* not all of these are "valid" but it should be ok here */
                                          | classexpr 
                                          | ( '(' expression ')' [ object_chain ])

do_while_command                    ::= ('do' | 'd') '{' [ cos_code_block ] '}' 'while' expression_list

for_command                         ::= ('for' | 'f') [ for_parameters ] for_loop_statement
for_loop_statement                  ::= ( '{' [ cos_command] [ cos_code_block ] '}' ) | (naked | command_list_eol )
for_parameters                      ::= for_parameter ( ',' for_parameter )*
for_parameter                       ::= lvalue_expression '=' for_loop_specifier_list
for_loop_specifier_list             ::= for_loop_specifier ( ',' for_loop_specifier )*
for_loop_specifier                  ::= for_start_value [ ':' for_increment_value [ ':' for_end_loop_value ] ]
for_start_value                     ::= expression
for_increment_value                 ::= expression
for_end_loop_value                  ::= expression

goto_command                        ::= ('goto' | 'g') [ post_conditional ]  goto_dest_list
goto_dest_list                      ::= goto_dest ( ',' goto_dest )*
goto_dest                           ::= goto_case_function_call | ( /* identifier [ '+' number ] [ '^' identifier ]*/ label_reference [ post_conditional ] )


halt_command                        ::= ('halt' | 'h') [ post_conditional ] naked

hang_command                        ::= ('hang' | 'h') [ post_conditional ] hangtime
hangtime                            ::= hang_value ( ',' hang_value )*
hang_value                          ::= expression

if_command                          ::= ('if' | 'i')  ( naked | expression_list) ( naked | [then_block] ) [ elseif_block_list ] [ else_block ] /* not sure what "if   set x=1 " means but no expression is possible */
then_block                          ::= ( '{'  [ cos_code_block ] '}' ) | command_list_eol
elseif_block_list                   ::= elseif_block ( elseif_block )*
elseif_block                        ::= 'elseif' expression_list ( ( '{' [ cos_code_block ] '}' ) | command_list_eol )
else_block                          ::= 'else' ( ( '{' [ cos_code_block ] '}' ) | command_list_eol )

else_command                        ::= ('else' | 'e') naked /* this happen in some situations like if x d .dotstructure else  d .otherdots */

job_command                         ::= ('job' | 'j') [ post_conditional ] job_arguments
job_arguments                       ::= job_argument ( ',' job_argument )*
job_argument                        ::= job_call [ job_process_parameters ] [ job_timeout_spec ]
job_call                            ::= job_routine_call | job_class_method_call | job_instanceMethod_call | job_classmethodfn_call
job_process_parameters              ::= ':' ( job_process_parameters_inbrackets | job_process_parameters_nobrackets )

job_process_parameters_inbrackets   ::= '('  ( job_nspace_param 
                                                [ ':' [ job_switch_param]
                                                [ ':' [ job_principal-input]
                                                [ ':' [ job_principal-output]
                                                [ ':' [ job_priority]
                                                [ ':' [ job_os-directory]
                                                [ ':' [job_process-name]
                                                ]
                                                ]
                                                ]
                                                ]
                                                ]
                                                ]
                                        ) ')' 
job_process_parameters_nobrackets   ::= [ job_nspace_param ]

job_nspace_param                    ::= [ expression ]
job_switch_param                    ::= [ expression ]
job_principal-input                 ::= [ expression ]
job_principal-output                ::= [ expression ]
job_priority                        ::= [ expression ]
job_os-directory                    ::= [ expression ]
job_process-name                    ::= [ expression ]
job_routine_call                    ::= identifier [ '^' identifier ] [ parameter_list]
job_class_method_call               ::= class_expression /*'##class' '(' identifier ').' identifier parameter_list*/
job_instanceMethod_call             ::= '..' identifier function_parameter_list
job_classmethodfn_call              ::= '$classmethod' '(' expression ',' expression ( ',' expression )* ')'
job_timeout_spec                    ::= ':' expression

kill_command                        ::= ( 'kill' | 'k') [ post_conditional ] ( naked | kill_parameter_list )
kill_parameter_list                 ::= kill_parameter ( ',' kill_parameter )*
kill_parameter                      ::= kill_exclusive_list | kill_item
kill_exclusive_list                 ::= '(' kill_item_list ')'
kill_item_list                      ::= kill_item ( ',' kill_item )*
kill_item                           ::= set_item_single /*this_object_set | variable_set| macrocall| Indirection| global_ref */
                                        
lock_command                        ::= ('lock' | 'l') [post_conditional ] ( naked | ( [ lock_parameter ( ',' lock_parameter)* ] [ else_block ] ) )
lock_parameter                      ::= [ '+' | '-' ] (lockname_list | lockname_list_item) [ lock_timeout ]
lockname_list                       ::= '(' lockname_list_item ( ',' lockname_list_item )* ')'
lockname_list_item                  ::= lockname [ lock_type ]
OLDlock_type                        ::= '#' '"' ( 'S' | 'E' | 'I' | 'D' )* '"' /* this does not work as it treats these as keywords and #"SI" is not in the keyword list...*/
lock_type                           ::= hash_op expression
lock_timeout                        ::= ':' expression
lockname                            ::= global_ref | variable | macrocall | indirection

merge_command                       ::= ('merge' | 'm') [ post_conditional ] merge_list
merge_list                          ::= merge_item ( ',' merge_item )*
merge_item                          ::= lvalue_expression '=' expression

new_command                         ::= ('new' | 'n') [ post_conditional ] ( naked | new_item_list )
new_item_list                       ::= new_item ( ',' new_item )*
new_item                            ::= new_item_single | new_item_varlist
new_item_single                     ::= lvalue_expression
new_item_varlist                    ::= '(' new_item_single_list ')'
new_item_single_list                ::= new_item_single ( ',' new_item_single )*

naked                               ::= ' ' /* this is going to need some special code to recognise naked commands */

open_command                        ::= ('open' | 'o') [ post_conditional ] open_arguments
open_arguments                      ::= one_open_argument ( ',' one_open_argument )*
one_open_argument                   ::= open_device [ ':' [ ( '('  open_device_parameters ')' ) | expression ] ] [ ':' open_timeout ] [ ':' open_mnemonic_space ]
open_device                         ::= expression
open_device_parameters              ::= [one_open_device_parameter] ( ':'[ one_open_device_parameter] )*
one_open_device_parameter           ::= ('/' identifier [ '=' open_expression_list ] ) | expression    /* text */// text up to next : or )
open_timeout                        ::= expression
open_mnemonic_space                 ::= expression
open_expression_list                ::= (variable '...') | expression_list   /* this is for Open pDevice:(/COMMAND=pCmd:/ARGS=pCmdArgs...:/ENV=pEnvVars...:"R"):pTimeoutOpen */

print_command                       ::= 'print'  [ post_conditional ] [ lineref1 [ ':' lineref2 ] ]
lineref1                            ::= line_reference
lineref2                            ::= line_reference
line_reference                      ::= [ label ] [ [ offset_sign ] offset ]
label                               ::= 'regexp:[0-9A-Za-z]+'
offset_sign                         ::= '+' | '-'
offset                              ::= 'regexp:[0-9]+'

quit_command                        ::= ('quit' | 'q') [ post_conditional ] ( naked | [ quit_expression ])
quit_expression                     ::= expression

return_command                      ::= 'return' [ post_conditional ] [ naked | expression ]

set_command                         ::= ('set' | 's') [ post_conditional ] set_item_list
set_item_list                       ::= set_item ( ',' set_item )*
set_item_old                            ::= (( set_item_single | set_item_varlist ) '=' expression) | simple_indirection /* PXW deal with set @x */
set_item                            ::= (( set_value_expression | ('(' set_value_expression ( ',' set_value_expression )* ')'  )) '=' set_expression) | simple_indirection /* PXW deal with set @x */
set_item_single                     ::= lvalue_expression
set_item_varlist                    ::= '(' set_item_single_list ')'
set_item_single_list                ::= set_item_single ( ',' set_item_single )*
set_value_expression                   ::= this_object_set
                                        | variable_set
                                        | macrocall
                                        | Indirection
                                        | global_ref_set
                                        | intrinsicfncall_set /* $property, $list, $piece, $extract */
                                        | special_variable
                                        | ( '(' set_value_expression ')'  [ object_chain ] )
set_expression                      ::= expression

tcommit_command                     ::= ('tcommit' | 'tc') [ post_conditional ]

throw_command                       ::= 'throw' [ post_conditional ] [ naked | expression ]

trollback_command                   ::= 'trollback' [ post_conditional ] [ '1' ]

try_command                         ::= 'try' '{' [ cos_code_block ] '}'
                                        (cos_directive)* /* #dim between try and catch */
                                         'catch' [ identifier | ( '(' identifier ')' ) ] '{' [ cos_code_block ] '}'

tstart_command                      ::= ('tstart' | 'ts' ) [ post_conditional ]

use_command                         ::= ('use' | 'u') [ post_conditional ] use_arguments
use_arguments                       ::= one_use_argument ( ',' one_use_argument )*
one_use_argument                    ::= use_device [ ':' ( use_device_parameters_inbrackets | use_device_parameters)  ] [ ':' use_mnemonic_space ]
use_device                          ::= expression
use_device_parameters_inbrackets    ::=  '('  use_device_parameters ')'
use_device_parameters               ::= [one_use_device_parameter] ( ':' [one_use_device_parameter] )*
one_use_device_parameter            ::= ('/' identifier [ '=' expression ] ) | expression /* text // text up to next : or ) */
use_mnemonic_space                  ::= expression

view_command                        ::= ('view' | 'v') [ post_conditional ]  ( view_offset_form | view_block_form   )
view_block_form                     ::= expression
view_offset_form                    ::= view_offset ':' view_mode ':' view_length ':' view_newvalue
view_offset                         ::= expression
view_mode                           ::= expression
view_length                         ::= expression
view_newvalue                       ::= expression

while_command                       ::= 'while' expression_list '{'  [ cos_code_block ] '}' 

write_command                       ::= ('write' | 'w') [ post_conditional ] [ write_argument_list ]
write_argument_list                 ::= one_write_argument ( ',' one_write_argument)*
one_write_argument                  ::= expression | write_control_expression_list 
write_control_expression_list       ::= write_control_expression (write_control_expression)*
write_control_expression            ::= write_format_expression
                                        | write_device_expression
                                        | write_escape_expression
write_format_expression             ::= write_bang_expression
                                        | write_hash_expression
                                        | write_pos_expression
                                        | write_mnemonic_expression
write_bang_expression               ::= '!'
write_hash_expression               ::= '#'
write_pos_expression                ::= '?' expression
write_mnemonic_expression           ::= '/' identifier [ '('  mnemonic_arguments* ')' ]
write_escape_expression             ::= '*' expression
write_device_expression             ::= '*-' expression
mnemonic_arguments                  ::= expression ( ',' expression )*

mpv_command                         ::= ('mvprint' | 'mvp') [ post_conditional ] [ write_argument_list ] /* found in %Projection.MV */


read_command                        ::= ('read' | 'r') [ post_conditional ] read_argument ( ',' read_argument )*
read_argument                       ::= read_format_character /* _set PXW removed set */
                                        | read_prompt
                                        | read_single_char
                                        | read_length
read_format_character_set           ::= read_format_character+
read_format_character               ::= '!'
                                        | '#'
                                        | ('?' expression)
                                        | ('/' read_keyword [ '(' read_keyword_parameters ')' ])
read_keyword                        ::= text // to next (!#?,/"
read_keyword_parameters             ::= read_keyword_parameter ( ',' read_keyword_parameter )*
read_keyword_parameter              ::= text // to next ,)!#?/
read_prompt                         ::= string
read_single_char                    ::= '*' lvalue_expression [ ':' expression ]
read_length                         ::= lvalue_expression [ '#' expression ] [ ':' expression ]



xecute_command                      ::= ( 'xecute' | 'x') [ post_conditional ] xecute_args
xecute_args                         ::= one_xecute_arg ( ',' one_xecute_arg )*
my_one_xecute_arg                      ::= expression [ post_conditional] 
one_xecute_arg                      ::= ( xecute_arg_with_params | xecute_arg_no_params ) [ post_conditional ]
xecute_arg_with_params              ::= '(' xecute_command_text ',' xecute_param_list ')'
xecute_arg_no_params                ::= xecute_command_text
xecute_command_text                 ::= expression /*string*/
xecute_param_list                   ::= xecute_parameter ( ',' xecute_parameter )*
xecute_parameter                     ::= ('.' variable ) | expression 

zallocate_command                   ::= 'zallocate' [post_conditional ] [ zallocate_parameter ( ',' zallocate_parameter)* ] [ else_block ]
zallocate_parameter                 ::= [ '+' | '-' ] zallocatename_list [ zallocate_timeout ]
zallocatename_list                  ::= one_zallocatename ( ',' one_zallocatename )*
one_zallocatename                   ::= zallocatename [ zallocate_type ]
zallocate_type                      ::= '#' '"' ( 'S' | 'E' | 'I' | 'D' )+ '"'
zallocate_timeout                   ::= ':' expression
zallocatename                       ::= text // all to next , \t\r\n;#:

zbreak_command                      ::= ('zbreak' | 'zb') [ post_conditional ] [ '/' identifier [ ':' identifier ] ] /* much more possible but are they used in real life? */

zdeallocate_command                 ::= 'zdeallocate' [post_conditional ] [ zdeallocate_parameter ( ',' zdeallocate_parameter)* ] [ else_block ]
zdeallocate_parameter               ::= [ '+' | '-' ] zdeallocatename_list [ zdeallocate_timeout ]
zdeallocatename_list                ::= one_zdeallocatename ( ',' one_zdeallocatename )*
one_zdeallocatename                 ::= zdeallocatename [ zdeallocate_type ]
zdeallocate_type                    ::= '#' '"' ( 'S' | 'E' | 'I' | 'D' )+ '"'
zdeallocate_timeout                 ::= ':' expression
zdeallocatename                     ::= text // all to next , \t\r\n;#:

zinsert_command                     ::= 'zinsert' // TODO

zkill_command                       ::= ('zkill' | 'zk') [ post_conditional ] [ kill_parameter_list ]

zload_command                       ::= 'zload' // TODO

znspace_command                     ::= ('znspace'|'zn') [ post_conditional ] expression

zprint_command                      ::= 'zprint'  [ post_conditional ] [ lineref1 [ ':' lineref2 ] ]

zquit_command                       ::= 'zquit' // TODO

zremove_command                     ::= 'zremove' // TODO

zsave_command                       ::= 'zsave' // TODO

zsync_command                       ::= 'zsync' [ post_conditional ]

ztrap_command                       ::= ('ztrap' | 'zt') [post_conditional ] [naked | expression]

zwrite_command                      ::= ( 'zwrite' | 'zw' ) [ post_conditional ] [ zwrite_argument_list ]

zwrite_argument_list                ::= zwrite_argument ( ',' zwrite_argument )*

zzdump_command                      ::= 'zzdump' [post_conditional] expression

zzwrite_command                     ::= 'zzwrite' [post_conditional] expression

html_command                        ::= '&html<' html_body '>'
html_body                           ::= 'NEED HTML BODY'

js_command                          ::= ('&javascript<' | '&js<') js_body '>'
js_body                             ::= 'NEED JS BODY'

sql_command                        ::= '&sql(' sql_body ')'
sql_body                           ::= 'NEED SQL BODY'


// TODO: zwrite argument is more restrictive than an expression
zwrite_argument                     ::= expression

case_function_call                  ::= 'case' open_bracket expression [ case_clauses ] [ case_clause_default ] close_bracket
case_clauses                        ::= (( ',' case_clause ))* /* BUG IN WHILE LOOP CONSTRUCTION FOR THIS CHECK - THE COMMA IS ADDED BUT THE CASE_CLAUSE MIGHT FAIL - ONLY THE CASE_CLAUSE IS ROLLED BACK THE COMMA IS COMMITTED */
case_clause_default                 ::= ',' ':' expression
case_clause                         ::= case_clause_case ':' case_clause_value
case_clause_case                    ::= expression
case_clause_value                   ::= expression

goto_case_function_call                  ::= '$case' open_bracket expression [ goto_case_clauses ] [ goto_case_clause_default ] close_bracket
goto_case_clauses                        ::= (( ',' goto_case_clause ))* /* BUG IN WHILE LOOP CONSTRUCTION FOR THIS CHECK - THE COMMA IS ADDED BUT THE CASE_CLAUSE MIGHT FAIL - ONLY THE CASE_CLAUSE IS ROLLED BACK THE COMMA IS COMMITTED */
goto_case_clause_default                 ::= ',' ':' label_reference
goto_case_clause                         ::= goto_case_clause_case ':' goto_case_clause_value
goto_case_clause_case                    ::= expression
goto_case_clause_value                   ::= label_reference



extract_function_call               ::= ('extract' | 'e') open_bracket expression [ ',' star_parameter [ ',' star_parameter ] ] close_bracket
extract_function_call_set           ::= ('extract' | 'e') open_bracket set_value_expression [ ',' star_parameter [ ',' star_parameter ] ] close_bracket
 
piece_function_call                 ::= ('piece' | 'p') open_bracket expression ',' expression [ ',' star_parameter [ ',' star_parameter ] ] close_bracket
piece_function_call_set             ::= ('piece' | 'p') open_bracket set_value_expression ',' expression [ ',' star_parameter [ ',' star_parameter ] ] close_bracket

listbuild_function_call             ::= ('listbuild' | 'lb') open_bracket  expression (',' expression)* close_bracket
listbuild_function_call_set         ::= ('listbuild' | 'lb') open_bracket  set_value_expression (',' variable_set)* close_bracket

listupdate_function_call            ::= ('listupdate' | 'lu') open_bracket  expression /* list */ ',' expression /* pos */ (',' expression ':' expression)* close_bracket

listitem_function_call              ::= ('listget' | 'list' | 'li' |'lg' ) open_bracket expression  [ ',' star_parameter [ ',' star_parameter ] ] close_bracket
listitem_function_call_set          ::= ('list' | 'li') open_bracket set_value_expression  [ ',' star_parameter [ ',' star_parameter ] ] close_bracket

bitlogic_function_call              ::= 'bitlogic' open_bracket bitlogic_expression [ ',' expression ] close_bracket
bitlogic_expression                  ::= (expression ('|' | '&' | '^' |'~')* )*

text_function_call                  ::= ('text') open_bracket label_reference close_bracket

star_parameter                      ::= ('*' [expression]) | expression

increment_function_call             ::= ('increment' | '$i') '(' variable_set [',' expression ] ')'

method_function_call                ::= 'method' function_parameter_list [ object_chain ]
classmethod_function_call           ::= 'classmethod' function_parameter_list [ object_chain ]
zobjmethod_function_call            ::= 'zobjmethod' function_parameter_list [ object_chain ]
zobjclassmethod_function_call       ::= 'zobjclassmethod' function_parameter_list [ object_chain ]

select_function_call                ::= ('select' | 's') '(' select_clauses ')' [ object_chain ] /* who returns an object from a $s? */
select_clauses                      ::= select_clause ( ',' select_clause )*
select_clause_default               ::= '1' ':' expression
select_clause                       ::= expression ':' expression

expression_function_call            ::= '##expression' function_parameter_list  /* function? or more similar to macro? */
safeexpression_function_call        ::= '##safeexpression' function_parameter_list  /* function? or more similar to macro? */

any_keyword                         ::= 'need any keyword'

cos_json                            ::= cos_json_object | cos_json_array | cos_json_prim
cos_json_object                     ::= '{' [ cos_json_pair ( ',' cos_json_pair )*] '}'
cos_json_pair                       ::= json_string ':' cos_json
cos_json_prim                       ::= number | json_string | 'true' | 'false' | 'null' | ( '(' expression ')' )
cos_json_array                      ::= '[' [ cos_json (',' cos_json)* ] ']' 

json_string                         ::= 'NEEDS JSON STRING'
    ]]]]><![CDATA[>

    </data>
    </bnf>
]]></Data>
</XData>
</Class>


<Class name="PXW.DEV.BNF.DEF.CSP">
<Super>PXW.DEV.BNF.Compilers.loader</Super>
<TimeChanged>67125,77562.566957192</TimeChanged>
<TimeCreated>67125,77562.566957192</TimeCreated>

<Projection name="GEN">
<Type>PXW.DEV.BNF.Compilers.projection</Type>
<Parameter name="GenerateTo" value="PXW.DEV.BNF.GEN.CSP"/>
</Projection>

<XData name="file">
<Data><![CDATA[
<data><![CDATA[

csp_tag_s_a                         ::= '<'
csp_tag_s_b                         ::= '>'
csp_tag_s_c                         ::= '/>'
csp_tag_e_a                         ::= '</'
csp_tag_e_b                         ::= '>'

csp_page                            ::= (csp_xml | csp_element | csp_end_tag | csp_content )*                                                /* <tag> or </tag> could be the START! in a &html */
csp_element                         ::= csp_special_tag | (csp_start_tag ( csp_element | csp_content)* [csp_end_tag]) | csp_empty_tag /* end tag is optional  */
csp_start_tag                       ::= csp_tag_s_a csp_tag_ns_name (csp_attribute )* csp_tag_s_b                    /* <tag attributes> */
csp_end_tag                         ::= csp_tag_e_a csp_tag_ns_name csp_tag_e_b
csp_empty_tag                       ::= csp_tag_s_a csp_tag_ns_name (csp_attribute )* csp_tag_s_c 
csp_tag_ns_name                     ::= [ csp_schema ':'] csp_tag_name
csp_schema                          ::= csp_identifier | cos_expression 
csp_tag_name                        ::= csp_identifier | cos_expression 
csp_attribute                       ::= ( [ csp_schema ':' ] csp_identifier ['=' ( string | ( number ['%'] )| cos_expression | ('#' [text_no_space] ) | csp_identifier | text_no_space) ] )  | cos_expression /* # needed for href=# */
csp_content                         ::= text
csp_identifier                      ::= identifier
csp_xml                             ::= csp_tag_s_a '?xml' ['-' 'stylesheet'] (csp_attribute)* '?' csp_tag_s_b


csp_special_tag                     ::= csp_doctype | csp_javascript | csp_javascript_text | csp_javascript_both | csp_javascript_bothopp | cos_expression 

csp_doctype                         ::= '<!DOCTYPE' csp_attribute ['PUBLIC' string string]'>'

csp_javascript                      ::= csp_tag_s_a 'script' 'language' '=' ('javascript' | '"javascript"' ) csp_tag_s_b  javascript_body csp_tag_e_a 'script' csp_tag_e_b  /* <script language="javascript"> */
csp_javascript_text                 ::= csp_tag_s_a 'script' 'type' '=' ('"text/javascript"') csp_tag_s_b  javascript_body csp_tag_e_a 'script' csp_tag_e_b 
csp_javascript_both                 ::= csp_tag_s_a 'script' 'language' '=' ('javascript' | '"javascript"' ) 'type' '=' ('"text/javascript"') csp_tag_s_b  javascript_body csp_tag_e_a 'script' csp_tag_e_b 
csp_javascript_bothopp              ::= csp_tag_s_a 'script' 'type' '=' ('"text/javascript"') 'language' '=' ('javascript' | '"javascript"' ) csp_tag_s_b  javascript_body csp_tag_e_a 'script' csp_tag_e_b 

javascript_body                     ::= 'NEEDS JS BODY'

cos_expression                      ::= cos_expression_compiletime | cos_expression_runtime | cos_expression_other
cos_expression_compiletime          ::= '##(' cos_expression_body ')##'
cos_expression_runtime              ::= '#(' cos_expression_body ')#'
cos_expression_other                ::= '<%=' cos_expression_body '%>'
cos_expression_body                 ::= 'NEEDS COS EXPRESSION BODY'

string                              ::= 'NEEDS STRING'
number                              ::= 'NEEDS NUMBER'
text                                ::= 'NEEDS TEXT'
identifier                          ::= 'NEEDS IDENTIFIER'
text_no_space                       ::= 'NEEDS TEXT'

    ]]]]><![CDATA[>

    </data>
]]></Data>
</XData>
</Class>


<Class name="PXW.DEV.BNF.DEF.ClassDefinition">
<Super>PXW.DEV.BNF.Compilers.loader</Super>
<TimeChanged>67125,77562.546615276</TimeChanged>
<TimeCreated>67125,77562.546615276</TimeCreated>

<Projection name="GEN">
<Type>PXW.DEV.BNF.Compilers.projection</Type>
<Parameter name="GenerateTo" value="PXW.DEV.BNF.GEN.ClassDefinition"/>
<Parameter name="GenerateToNew" value="PXW.DEV.BNF.GEN.ClassDefinitionAuto"/>
</Projection>

<Parameter name="SubElementType">
<Default>PXW.DEV.BNF.Elements.ClassDefinition</Default>
</Parameter>

<Parameter name="KeywordPattern">
<Description>
Used by the code generator and passed onto the generated code
1 alpha, possibly "/" and more alphas
Parameter KeywordPattern = "1.A.1""/"".A";</Description>
<Default>1.A.(1"/".A)</Default>
</Parameter>

<XData name="file">
<Data><![CDATA[
<bnf>
<data><![CDATA[
    // Uses plugin https://plugins.jetbrains.com/plugin/6606-grammar-kit
// Docs: https://github.com/JetBrains/Grammar-Kit
/**
 * UDL grammar
 */

udl_program                         ::= udl_statement

udl_statement                       ::= ( import_definition | include_generator_definition | include_definition  )*
                                        class_definition

import_definition                   ::= 'import'  ( package_name | ( '(' package_list ')' ) )
include_generator_definition        ::= 'includegenerator'  ( include_list | include_name )
include_definition                  ::= 'include'  ( include_list | include_name )
package_list                        ::= package_name ( ',' package_name )*
package_name                        ::= identifier
include_list                        ::= '(' include_name ( ',' include_name )* ')'
include_name                        ::= identifier

class_item_identifier               ::= string | identifier

class_definition                    ::= 'class' class_name [ 'extends' (  class_reference_list | class_reference  ) ] [class_attributes] class_member_section 
class_name                          ::= class_identifier /* used for defining the name of the class */
class_reference                     ::= class_identifier /* used for referring to a class */
class_reference_list                ::= '(' [class_reference] ( ',' class_reference )* ')' /* oddly there can be items missing from the list! see %ListOfPersistentChildObjects*/
class_attributes                    ::= '[' class_attribute_list ']'
class_attribute_list                ::= class_attribute ( ',' class_attribute )*
class_member_section                ::= '{' class_member_list? '}'
class_member_list                   ::= one_classMember ( one_classMember )*
one_classMember                     ::= class_class_method 
                                        | class_ForeignKey
                                        | class_index
                                        | class_method
                                        | class_property  
                                        | class_parameter 
                                        | class_projection
                                        | class_query
                                        | class_relationship
                                        | class_storage
                                        | class_trigger
                                        /*| class_view*/ 
                                        | class_xdata
                                        | class_client_method

class_projection                    ::= 'projection' projection_name [ class_projection_type ] [ class_property_attributes ] ';'
projection_name                     ::= string | identifier
class_projection_type               ::= 'as'  type_class_reference

return_type_class_reference         ::= class_reference  [ type_parameters ]
type_class_reference                ::= class_reference  [ type_parameters ]
type_parameters                     ::= '(' type_parameters_list ')'
type_parameters_list                ::= type_parameter_item (',' type_parameter_item)*
type_parameter_item                 ::= class_item_identifier '=' ( string | number )

class_property                      ::= 'property' property_name [ class_property_type ] [ class_property_attributes ] ';'
property_name                       ::= class_item_identifier /* used for defining the property */
property_reference                    ::= class_item_identifier /* used when referring to a property */
class_property_type                 ::= ('as' [ ( 'array' | 'list' ) 'of' ] type_class_reference ) | type_parameters /* there can be parameters with no class! */
class_property_attributes           ::= '[' class_property_attribute_list ']'
class_property_attribute_list       ::= class_property_attribute ( ',' class_property_attribute )*
class_property_attribute            ::= attribute_Aliases
                                        | attribute_Calculated
                                        | attribute_Cardinality
                                        | attribute_ClientName
                                        | attribute_Deprecated
                                        | attribute_Final
                                        | attribute_Identity
                                        | attribute_InitialExpression
                                        | attribute_Internal
                                        | attribute_Inverse
                                        | attribute_MultiDimensional
                                        | attribute_OnDelete
                                        | attribute_Private
                                        | attribute_ReadOnly
                                        | attribute_Required
                                        | attribute_ServerOnly
                                        | attribute_SQLColumnNumber
                                        | attribute_SQLComputeCode
                                        | attribute_SQLComputed
                                        | attribute_SQLComputeOnChange
                                        | attribute_SQLFieldname
                                        | attribute_SQLListDelimiter
                                        | attribute_SQLListType
                                        | attribute_Transient
                                        | attribute_Not


class_relationship                  ::= 'relationship' property_name  [ class_property_type ]  class_property_attributes ';'
relationship_attributes             ::= '[' relationship_attribute ( ',' relationship_attribute )* ']'
relationship_attribute             ::= attribute_Cardinality
                                        | attribute_Final
                                        | attribute_Internal
                                        | attribute_Inverse
                                        | attribute_Required
                                        | attribute_SQLFieldname
                                        | attribute_Private
                                        | attribute_OnDelete

class_attribute                     ::= attribute_Abstract
                                        | attribute_ClassType
                                        | attribute_ClientDataType
                                        | attribute_ClientName
                                        | attribute_CompileAfter
                                        | attribute_DDLAllowed
                                        | attribute_DependsOn
                                        | attribute_Deprecated
                                        | attribute_Embeddedclass
                                        | attribute_Final
                                        | attribute_GeneratedBy
                                        | attribute_Hidden
                                        | attribute_Inheritance
                                        | attribute_Language
                                        | attribute_LegacyInstanceContext
                                        | attribute_MemberSuper 
                                        | attribute_NoContext
                                        | attribute_NoExtent
                                        | attribute_Not
                                        | attribute_ODBCType
                                        | attribute_Owner
                                        | attribute_ProcedureBlock
                                        | attribute_PropertyClass
                                        | attribute_ServerOnly
                                        | attribute_SOAPBindingStyle
                                        | attribute_SOAPBodyuse
                                        | attribute_SQLCategory
                                        | attribute_SQLRowidName
                                        | attribute_SQLRowidPrivate
                                        | attribute_SQLTableName
                                        | attribute_StorageStrategy
                                        | attribute_System
                                        | attribute_ViewQuery

attribute_Not                       ::= 'not' ( attribute_Abstract
                                        | attribute_DDLAllowed
                                        | attribute_Deprecated
                                        | attribute_Final
                                        | attribute_Hidden
                                        | attribute_Internal
                                        | attribute_LegacyInstanceContext
                                        | attribute_NoExtent
                                        | attribute_Private
                                        | attribute_ProcedureBlock
                                        | attribute_ReadOnly
                                        | attribute_Required
                                        | attribute_ServerOnly
                                        | attribute_SQLComputed
                                        | attribute_Transient
                                        | attribute_Unique
                                        )

class_class_method                  ::= 'classmethod' method_name '(' [ formal_spec_list ] ')' [ 'as' return_type_class_reference ] [ method_attribute_list ] '{' method_body '}'
class_method                        ::= 'method' method_name '(' [ formal_spec_list ] ')' [ 'as' return_type_class_reference ] [ method_attribute_list ] '{' method_body '}'
method_name                         ::= class_item_identifier
method_reference                    ::= class_item_identifier
formal_spec_list                    ::= formal_spec_item( ',' formal_spec_item )*
variable                            ::= variable_identifier
variable_set                        ::= variable_identifier

formal_spec_item                    ::= [ formal_spec_mode ] variable_set ['...'] [ as_type_class_reference ] [ parameter_default_value ]
formal_spec_mode                    ::= 'byref' | 'output' | 'byval'
as_type_class_reference             ::= 'as' type_class_reference
method_attribute_list               ::= '[' method_attribute ( ',' method_attribute )* ']'
method_attribute                    ::= attribute_Abstract
                                        | attribute_ClientName
                                        | attribute_CodeMode
                                        | attribute_Deprecated
                                        | attribute_ExternalProcName
                                        | attribute_Final
                                        | attribute_ForceGenerate
                                        | attribute_GenerateAfter
                                        | attribute_Internal
                                        | attribute_Language
                                        | attribute_NoContext
                                        | attribute_NotInheritable
                                        | attribute_PlaceAfter
                                        | attribute_Private
                                        | attribute_ProcedureBlock
                                        | attribute_PublicList
                                        | attribute_ReturnResultSets
                                        | attribute_ServerOnly
                                        | attribute_SOAPAction
                                        | attribute_SOAPBindingStyle
                                        | attribute_SOAPBodyuse
                                        | attribute_SOAPMessageName
                                        | attribute_SOAPNameSpace
                                        | attribute_SOAPRequestMessage
                                        | attribute_SOAPTypeNamespace
                                        | attribute_SQLName
                                        | attribute_SQLProc
                                        | attribute_WebMethod
                                        | attribute_ZenMethod

class_client_method                  ::= 'clientmethod' method_name '(' [ formal_spec_list ] ')' [ 'as' type_class_reference ] [ method_attribute_list ] '{' javascript_code_block '}'

parameter_default_value             ::= '=' ( 'NULL' | parameter_default_simple | parameter_default_expression )
parameter_default_simple            ::= [ '+' ] number | string
parameter_default_expression        ::= '{' expression '}'

method_body                         ::= cos_code_block
//                                        | javascript_code_block
//                                        | sql_code_block
//                                        | html_code_block

class_ForeignKey                    ::= 'foreignkey' foreignkey_name [ '(' key_props ')' ] 'references' class_reference [ '(' [ref_props] ')' ] [ foreignKey_attribute_list ] ';' 
foreignkey_name                     ::= class_item_identifier
key_props                           ::= name_value_pair_list
ref_props                           ::= name_value_pair_list
name_value_pair_list                ::= one_name_value_pair ( ',' one_name_value_pair )*
one_name_value_pair                 ::= class_item_identifier [ '=' expression ]
foreignKey_attribute_list           ::= '[' one_foreignkey_atttribute ( ',' one_foreignkey_atttribute )* ']'
one_foreignkey_atttribute           ::= attribute_Internal
                                        | attribute_NoCheck
                                        | attribute_OnDelete
                                        | attribute_OnUpdate
                                        | attribute_SQLName

class_parameter                     ::= 'parameter' class_parameter_name [ 'as' class_parameter_type ] [ class_parameter_attribute_list ] [ '=' class_parameter_value ] ';'
class_parameter_name                ::= class_item_identifier
class_parameter_type                ::= class_reference | 'COSEXPRESSION'
class_parameter_value               ::= string | number | ( '{' expression '}' )
class_parameter_attribute_list      ::= '[' class_parameter_attribute ( ',' class_parameter_attribute )* ']'

class_parameter_attribute           ::=  attribute_Abstract
                                        | attribute_Constraint
                                        | attribute_Final
                                        | attribute_Flags
                                        | attribute_Internal
                                        | attribute_Deprecated

class_storage                       ::= 'storage' storage_name '{' storage_xml '}'
storage_name                        ::= class_item_identifier
storage_xml                         ::= (xml_data)*

storage_xml_complex                         ::= ( storage_xml_data 
                                            | storage_xml_data_location 
                                            | storage_xml_default_data 
                                            | storage_xml_description
                                            | storage_xml_extent_location
                                            | storage_xml_extent_size 
                                            | storage_xml_id_function 
                                            | storage_xml_id_location 
                                            | storage_xml_index_location 
                                            | storage_xml_index 
                                            | storage_xml_stream_location 
                                            | storage_xml_state 
                                            | storage_xml_type 
                                            | storage_xml_property 
                                            | storage_xml_sqlmap 
                                            | storage_xml_counterlocation
                                        )*

storage_xml_data                    ::= xml_tag_s_a 'Data' 'name' '=' string ( xml_tag_s_c | (xml_tag_s_b (storage_xml_dataelement)* xml_tag_e_a 'Data' xml_tag_e_b) )
storage_xml_dataelement             ::= storage_xml_attribute
                                        | storage_xml_structure
                                        | storage_xml_subscript
                                        | storage_xml_data_position
                                        | storage_xml_data_piece
                                        | storage_xml_data_node
                                        | storage_xml_data_delimiter
                                        | storage_xml_data_retrieval_code  
                                        
storage_xml_description             ::= xml_tag_s_a 'Description' xml_tag_s_b (xml_cdata | xml_content) xml_tag_e_a 'Description' xml_tag_e_b
storage_xml_attribute               ::=	xml_tag_s_a 'Attribute' xml_tag_s_b identifier xml_tag_e_a 'Attribute' xml_tag_e_b
storage_xml_structure               ::=	xml_tag_s_a 'Structure' xml_tag_s_b ( 'subnode' | 'node') xml_tag_e_a 'Structure' xml_tag_e_b
storage_xml_subscript               ::= xml_tag_s_a 'Subscript' xml_tag_s_b (string | number) xml_tag_e_a 'Subscript' xml_tag_e_b
storage_xml_data_position           ::= xml_tag_s_a 'Value' 'name' '=' string xml_tag_s_b (storage_xml_data_position_field)* xml_tag_e_a 'Value' xml_tag_e_b
storage_xml_data_position_field     ::= xml_tag_s_a 'Value' xml_tag_s_b (identifier) xml_tag_e_a 'Value' xml_tag_e_b
storage_xml_data_location           ::= xml_tag_s_a 'DataLocation'xml_tag_s_b (expression | ('{%%PARENT}' ['(' string ')'])) xml_tag_e_a 'DataLocation' xml_tag_e_b
storage_xml_data_piece              ::= xml_tag_s_a 'Piece' xml_tag_s_b number [ ',' number ] xml_tag_e_a 'Piece' xml_tag_e_b
storage_xml_data_delimiter          ::= xml_tag_s_a 'Delimiter' xml_tag_s_b cos_expression_storage xml_tag_e_a 'Delimiter' xml_tag_e_b
storage_xml_data_node               ::= xml_tag_s_a 'Node' xml_tag_s_b (number | string) xml_tag_e_a 'Node' xml_tag_e_b
storage_xml_data_retrieval_code     ::= xml_tag_s_a 'RetrievalCode' xml_tag_s_b cos_code_block_storage xml_tag_e_a 'RetrievalCode' xml_tag_e_b
storage_xml_default_data            ::=	xml_tag_s_a 'DefaultData' xml_tag_s_b cos_expression_storage xml_tag_e_a 'DefaultData' xml_tag_e_b
storage_xml_extent_location         ::= xml_tag_s_a 'ExtentLocation' xml_tag_s_b global xml_tag_e_a 'ExtentLocation' xml_tag_e_b
storage_xml_extent_size	            ::= xml_tag_s_a 'ExtentSize' xml_tag_s_b number xml_tag_e_a 'ExtentSize' xml_tag_e_b
storage_xml_id_function             ::= xml_tag_s_a 'IdFunction' xml_tag_s_b ( 'sequence' )xml_tag_e_a 'IdFunction' xml_tag_e_b
storage_xml_id_location             ::= xml_tag_s_a 'IdLocation' xml_tag_s_b  (   ('{%%PARENT}' ['(' string ')']) |    (expression [ '(' string ')' ]) ) xml_tag_e_a 'IdLocation' xml_tag_e_b
storage_xml_global                  ::= xml_tag_s_a 'Global' xml_tag_s_b global xml_tag_e_a 'Global' xml_tag_e_b
storage_xml_index_location          ::=	xml_tag_s_a 'IndexLocation' xml_tag_s_b expression xml_tag_e_a 'IndexLocation' xml_tag_e_b
storage_xml_stream_location         ::= xml_tag_s_a 'StreamLocation' xml_tag_s_b expression xml_tag_e_a 'StreamLocation' xml_tag_e_b
storage_xml_state                   ::=	xml_tag_s_a 'State' xml_tag_s_b identifier xml_tag_e_a 'State' xml_tag_e_b
storage_xml_type                    ::=	xml_tag_s_a 'Type' xml_tag_s_b class_reference xml_tag_e_a 'Type' xml_tag_e_b
storage_xml_counterlocation         ::= xml_tag_s_a 'CounterLocation' xml_tag_s_b global xml_tag_e_a 'CounterLocation' xml_tag_e_b
storage_xml_index                   ::= xml_tag_s_a 'Index' 'name' '=' string xml_tag_s_b (storage_xml_index_sublocation)* xml_tag_e_a 'Index' xml_tag_e_b
storage_xml_index_sublocation       ::= xml_tag_s_a 'Location' xml_tag_s_b (expression)xml_tag_e_a 'Location' xml_tag_e_b


storage_xml_property                ::= storage_xml_property_empty | storage_xml_property_full
storage_xml_property_empty          ::= xml_tag_s_a 'Property' 'name' '=' string xml_tag_s_b (storage_xml_property_selectivity | storage_xml_property_outlier_selectivity | storage_xml_property_fieldsize | storage_xml_property_histogram)* xml_tag_e_a 'Property' xml_tag_e_b
storage_xml_property_full            ::= xml_tag_s_a 'Property' 'name' '=' string xml_tag_s_c
storage_xml_property_selectivity    ::= xml_tag_s_a 'Selectivity' xml_tag_s_b number ['%'] xml_tag_e_a 'Selectivity' xml_tag_e_b
storage_xml_property_outlier_selectivity    ::= xml_tag_s_a 'OutlierSelectivity' xml_tag_s_b number ':' number xml_tag_e_a 'OutlierSelectivity' xml_tag_e_b
storage_xml_property_fieldsize      ::= xml_tag_s_a 'AverageFieldSize' xml_tag_s_b number xml_tag_e_a 'AverageFieldSize' xml_tag_e_b
storage_xml_property_histogram      ::= xml_tag_s_a 'Histogram' xml_tag_s_b expression xml_tag_e_a 'Histogram' xml_tag_e_b
storage_xml_sqlmap                  ::= xml_tag_s_a 'SQLMap' 'name' '=' string xml_tag_s_b (storage_xml_sqlmap_blockcount 
                                                                                            | storage_xml_data 
                                                                                            | storage_xml_global
                                                                                            | storage_xml_sqlmap_condition
                                                                                            | storage_xml_sqlmap_population
                                                                                            | storage_xml_sqlmap_type
                                                                                            | storage_xml_sqlmap_structure
                                                                                            | storage_xml_sqlmap_subscript
                                                                                            | storage_xml_sqlmap_rowidspec )* xml_tag_e_a 'SQLMap' xml_tag_e_b
storage_xml_sqlmap_blockcount       ::= xml_tag_s_a 'BlockCount' xml_tag_s_b number xml_tag_e_a 'BlockCount' xml_tag_e_b
storage_xml_sqlmap_condition        ::= xml_tag_s_a 'Condition' xml_tag_s_b cos_expression_storage xml_tag_e_a 'Condition' xml_tag_e_b
storage_xml_sqlmap_population       ::= xml_tag_s_a 'PopulationType' xml_tag_s_b identifier xml_tag_e_a 'PopulationType' xml_tag_e_b
storage_xml_sqlmap_type             ::= xml_tag_s_a 'Type' xml_tag_s_b identifier xml_tag_e_a 'Type' xml_tag_e_b
storage_xml_sqlmap_structure        ::= xml_tag_s_a 'Structure' xml_tag_s_b identifier xml_tag_e_a 'Structure' xml_tag_e_b
storage_xml_sqlmap_subscript        ::= xml_tag_s_a 'Subscript' 'name' '=' string xml_tag_s_b (storage_xml_sqlmap_sub_expression 
                                                                                                | storage_xml_sqlmap_sub_accessvar 
                                                                                                | storage_xml_sqlmap_sub_accesstype
                                                                                                | storage_xml_sqlmap_sub_invcond 
                                                                                                | storage_xml_data_delimiter
                                                                                                | storage_xml_sqlmap_sub_loopinitval
                                                                                                | storage_xml_sqlmap_sub_dataaccess
                                                                                                | storage_xml_sqlmap_sub_next_code
                                                                                                )* xml_tag_e_a 'Subscript' xml_tag_e_b
storage_xml_sqlmap_sub_accesstype   ::= xml_tag_s_a 'AccessType' xml_tag_s_b identifier xml_tag_e_a 'AccessType' xml_tag_e_b
storage_xml_sqlmap_sub_dataaccess   ::= xml_tag_s_a 'DataAccess' xml_tag_s_b cos_expression_storage xml_tag_e_a 'DataAccess' xml_tag_e_b
storage_xml_sqlmap_sub_expression   ::= xml_tag_s_a 'Expression' xml_tag_s_b cos_expression_storage xml_tag_e_a 'Expression' xml_tag_e_b
storage_xml_sqlmap_sub_invcond      ::= xml_tag_s_a 'InvalidCondition' 'name' '=' string xml_tag_s_b storage_xml_sqlmap_sub_expression xml_tag_e_a 'Invalidcondition' xml_tag_e_b
storage_xml_sqlmap_sub_accessvar    ::= xml_tag_s_a 'Accessvar' 'name' '=' string xml_tag_s_b (storage_xml_sqlmap_sub_code storage_xml_sqlmap_sub_variable)   xml_tag_e_a 'Accessvar' xml_tag_e_b
storage_xml_sqlmap_sub_loopinitval  ::= xml_tag_s_a 'LoopInitValue' xml_tag_s_b cos_expression_storage xml_tag_e_a 'LoopInitValue' xml_tag_e_b
storage_xml_sqlmap_sub_code         ::= xml_tag_s_a 'Code' xml_tag_s_b cos_code_block_storage xml_tag_e_a 'Code' xml_tag_e_b
storage_xml_sqlmap_sub_variable     ::= xml_tag_s_a 'Variable' xml_tag_s_b cos_expression_storage xml_tag_e_a 'Variable' xml_tag_e_b
storage_xml_sqlmap_sub_next_code    ::= xml_tag_s_a 'NextCode' xml_tag_s_b cos_code_block_storage xml_tag_e_a 'NextCode' xml_tag_e_b

storage_xml_sqlmap_rowidspec        ::= xml_tag_s_a 'RowIdSpec' 'name' '=' string xml_tag_s_b (storage_xml_sqlmap_row_expression | storage_xml_sqlmap_row_field)* xml_tag_e_a 'RowIdSpec' xml_tag_e_b
storage_xml_sqlmap_row_expression   ::= xml_tag_s_a 'Expression' xml_tag_s_b cos_expression_storage xml_tag_e_a 'Expression' xml_tag_e_b
storage_xml_sqlmap_row_field        ::= xml_tag_s_a 'Field' xml_tag_s_b identifier xml_tag_e_a 'Field' xml_tag_e_b

global                              ::= cos_expression_sql /* '^' identifier [ '(' string ')' ] */

xml_tag_s_a                         ::= '<'
xml_tag_s_b                         ::= '>'
xml_tag_s_c                         ::= '/>'
xml_tag_e_a                         ::= '</'
xml_tag_e_b                         ::= '>'


text_brace_block                    ::= '{' text '}'

class_query                         ::= 'query' query_name '(' [ formal_spec_list ] ')' [ 'as' type_class_reference ] [ class_query_attributes ] '{' class_query_body '}'
query_name                          ::= class_item_identifier
class_query_body                    ::= text_brace_block
class_query_attributes              ::= '[' class_query_attribute ( ',' class_query_attribute )* ']'
class_query_attribute               ::= attribute_ClientName
                                        | attribute_Deprecated
                                        | attribute_Final
                                        | attribute_Internal
                                        | attribute_Private
                                        | attribute_SOAPBindingStyle
                                        | attribute_SOAPBodyuse
                                        | attribute_SOAPNameSpace
                                        | attribute_SQLName
                                        | attribute_SQLProc
                                        | attribute_SQLView
                                        | attribute_SQLViewname
                                        | attribute_WebMethod


class_xdata                         ::= 'xdata' xdata_name [ '[' (xdata_attributes)* ']' ] '{' (xdata_text | xdata_xml | xdata_json )   /* ([xml_xml] [xml_data] [xdata_json] */ '}'
xdata_name                          ::= class_item_identifier
xdata_attributes                    ::= attribute_Internal
                                        | attribute_MimeType
                                        | attribute_SchemaSpec
                                        | attribute_XMLNamespace
xdata_xml                      ::= [xml_xml] xml_data
xdata_text                         ::= text 

xml_data                            ::= xml_cdata | ( xml_start_tag ( xml_data | xml_content)* xml_end_tag) | xml_empty_tag
xml_start_tag                       ::= xml_tag_s_a xml_tag_ns_name (xml_attribute)* xml_tag_s_b 
xml_end_tag                         ::= xml_tag_e_a xml_tag_ns_name xml_tag_e_b
xml_empty_tag                       ::= xml_tag_s_a xml_tag_ns_name (xml_attribute)* xml_tag_s_c 
xml_tag_ns_name                     ::= [ xml_schema ':'] xml_tag_name
xml_schema                          ::= xml_identifier
xml_tag_name                        ::= xml_identifier
xml_attribute                       ::= [ xml_schema ':' ] xml_attribute_name '=' xml_attribute_value
xml_attribute_name                  ::= xml_identifier
xml_attribute_value                 ::= string | number
xml_content                         ::= text 
xml_identifier                      ::= 'NEEDS XML identifier'
xml_xml                             ::= xml_tag_s_a '?xml' (xml_attribute)* '?' xml_tag_s_b

xml_cdata                           ::= '<' '!' '[CDATA[' xml_cdata_text ']]' '>' /* special tag so not using xml_tag_s_a etc  and also spacing out as this is already stored in XML!*/
xml_cdata_text                      ::= 'NEED XML CDATA TEXT THAT READS UP TO END OF CDATA'

xdata_json                            ::= xdata_json_object | xdata_json_array | xdata_json_prim
xdata_json_object                     ::= '{' [ xdata_json_pair ( ',' xdata_json_pair )*] '}'
xdata_json_pair                       ::= json_string ':' xdata_json
xdata_json_prim                       ::= number | json_string | 'true' | 'false' | 'null' /* | ( '(' expression ')' ) */
xdata_json_array                      ::= '[' [ xdata_json_array_items ] ']'
xdata_json_array_items              ::= xdata_json (',' xdata_json)* 

json_string                         ::= 'NEED JSON STRING'

class_trigger                       ::= 'trigger' trigger_name [ trigger_attribute_list ] '{' [ trigger_code_block ] '}'
trigger_name                        ::= class_item_identifier
trigger_attribute_list              ::= '[' trigger_attribute ( ',' trigger_attribute )* ']'
trigger_attribute                   ::= attribute_CodeMode
                                        | attribute_Event
                                        | attribute_Final
                                        | attribute_ForEach
                                        | attribute_Internal
                                        | attribute_Language
                                        | attribute_NewTable
                                        | attribute_OldTable
                                        | attribute_Order
                                        | attribute_SQLName
                                        | attribute_Time
                                        | attribute_UpdateColumnList
trigger_code_block                  ::= cos_code_block_trigger


class_index                         ::= 'index' index_name [ 'on' index_property_expression_list ] [ index_attributes ] [ 'as' type_class_reference ]';'
index_name                          ::= class_item_identifier
index_property_expression_list      ::= index_property | index_property_list
index_property_list                 ::= '(' index_property ( ',' index_property )* ')'
index_property                      ::= fieldname ['(ELEMENTS)' | '(KEYS)' ] [ 'as' collation_type]
fieldname                           ::= property_reference
collation_type                      ::= 'exact' | 'mvr' | 'sqlstring' | ('sqlupper' [ '(' number ')' ] )| 'truncate' | 'plus' | 'minus' | 'alphaup' | 'string' | 'upper' | 'space'
index_attributes                    ::= '[' index_attribute ( ',' index_attribute )* ']'
index_attribute                     ::= attribute_Condition
                                        | attribute_Data
                                        | attribute_Extent
                                        | attribute_IdKey
                                        | attribute_Internal
                                        | attribute_PrimaryKey
                                        | attribute_SQLName
                                        | attribute_Type
                                        | attribute_Unique
                                        
/*
 * UDL attributes
 */
attribute_Abstract                  ::= 'abstract'

attribute_Aliases                   ::= 'aliases' '=' '{'  attribute_AliasList '}'
attribute_AliasList                 ::= attribute_OneAlias ( ',' attribute_OneAlias )*
attribute_OneAlias                  ::= alias_identifier

attribute_Calculated                ::= 'calculated'

attribute_Cardinality               ::= 'cardinality' '=' attribute_Cardinality_type
attribute_Cardinality_type          ::= 'one' | 'many' | 'parent' | 'children'

attribute_ClassType                 ::= 'classtype' '=' class_type_name
class_type_name                     ::= 'datatype' | 'persistent' | 'serial' | 'stream' | 'view' | 'index' | 'donotuse' | 'dynamic' | '""'

attribute_ClientDataType            ::= 'clientdatatype' '=' client_data_type_name
client_data_type_name               ::= 'bigint' | 'binary' | 'binarystream' | 'boolean' | 'characterstream' | 'currency' | 'date' | 'decimal' | 'double' | 'fdate' | 'ftimestamp'
                                        | 'handle' | 'integer' | 'list' | 'longvarchar' | 'numeric' | 'status' |  'timestamp' | 'time' |  'varchar' | 'MVDATE'

attribute_ClientName                ::= 'clientname' '=' attribute_ClientName_value
attribute_ClientName_value          ::= client_identifier        /* text is all charss to next , ] space tab or eol */

attribute_CodeMode                  ::= 'codemode' '=' attribute_CodeModeType
attribute_CodeModeType              ::= 'call' | 'code' | 'expression' | 'objectgenerator' | 'generator'

attribute_Condition                 ::= 'condition' '=' '{' expression '}'

attribute_Constraint                ::= 'constraint' '=' (number | string | identifier)

attribute_CompileAfter              ::= 'compileafter' '=' [class_reference_list | class_reference]  /* compileafter=, (nothing) is ok - odd */

attribute_Data                      ::= 'data' '=' ( one_data_attribute_value | (  '('  one_data_attribute_value ( ',' one_data_attribute_value )* ')'  ) )
one_data_attribute_value            ::= property_reference ['(ELEMENTS)' | '(KEYS)' ]

attribute_Deprecated                ::= 'deprecated'

attribute_DDLAllowed                ::= 'ddlallowed'

attribute_DependsOn                 ::= 'dependson' '=' (  class_reference_list | class_reference )

attribute_EmbeddedClass             ::= 'EmbeddedClass' '=' class_reference

attribute_Event                     ::= 'event' '=' event_keyword
event_keyword                       ::= 'insert/update/delete' | 'insert/update' | 'insert/delete' | 'update/delete' | 'delete' | 'insert' | 'update' 

attribute_Extent                    ::= 'extent'

attribute_ExternalProcName          ::= 'externalprocname' '=' text // text is any character except ],\\\r\n \t()'"

attribute_Final                     ::= 'final'

attribute_Flags                     ::= 'flags' '=' ( 'enumedit' | 'enum' | 'list' )

attribute_ForceGenerate             ::= 'forcegenerate'

attribute_ForEach                   ::= 'foreach' '=' foreach_type
foreach_type                        ::= 'row' | 'row/object' | 'statement'

attribute_GenerateAfter             ::= 'generateafter' '=' ( method_reference | ( '(' method_reference ( ',' method_reference )* ')' ) )

attribute_GeneratedBy               ::= 'generatedby' '=' (class_reference | string | filename)

attribute_Hidden                    ::= 'hidden'

attribute_Identity                  ::= 'identity'

attribute_IdKey                     ::= 'idkey'

attribute_Internal                  ::= 'internal'

attribute_InitialExpression         ::= 'initialexpression' '=' initialexpression_value
initialexpression_value             ::= initial_expression_complex | initial_expression_simple
initial_expression_simple           ::= string | number
initial_expression_complex          ::= '{' expression '}'

attribute_Inheritance               ::= 'inheritance' '=' inheritance_direction
inheritance_direction               ::= 'left' | 'right'

attribute_Inverse                   ::= 'inverse' '=' identifier

attribute_Language                  ::= 'language' '=' class_language_name
class_language_name                 ::= 'cache' | 'basic' |  'javascript' | 'java' | 'mvbasic' | 'tsql' | 'cpp' | 'objectscript' | 'python' 

attribute_LegacyInstanceContext     ::= 'legacyinstancecontext'

attribute_MemberSuper               ::= 'MemberSuper' '=' ( ( '(' class_reference ( ',' class_reference )*')' ) | class_reference )

attribute_MimeType                  ::= 'mimetype' '=' identifier ('/' identifier)* /*mime_type*/
mime_type                           ::= 'regex:[a-zA-Z][a-zA-Z0-9]*\/[a-zA-Z][a-zA-Z0-9]*'

attribute_MultiDimensional          ::= 'multidimensional'

attribute_NewTable                  ::= 'newtable' '=' tablename
tablename                           ::= identifier

attribute_NoCheck                   ::= 'nocheck'

attribute_NoContext                  ::= 'nocontext'

attribute_NoExtent                  ::= 'noextent'

attribute_NotInheritable            ::= 'notinheritable'

attribute_OnDelete                  ::= 'ondelete' '=' attribute_OnAction_type
attribute_OnAction_type             ::= 'cascade' | 'noaction' | 'setdefault' | 'setnull'

attribute_OnUpdate                  ::= 'onupdate' '=' attribute_OnAction_type

attribute_ODBCType                  ::= 'odbctype' '=' ( 'bigint' | 'bit' | 'date' | 'double' | 'integer' | 'longvarbinary'
                                        | 'longvarchar' | 'numeric' | 'resultset' | 'smallint' | 'struct' | 'time'
                                        | 'timestamp' | 'tinyint' | 'varbinary' | 'varchar' | 'guid' | 'POSIXTIME')

attribute_OldTable                  ::= 'oldtable' '=' tablename

attribute_Order                     ::= 'order' '=' expression

attribute_Owner                     ::= 'owner' '=' ( string | number | '{' text_in_curly '}' ) /* Text is any char except space tab
}
*/

attribute_PlaceAfter                ::= 'placeafter' '=' method_reference ('(' ',' method_reference ')')* 

attribute_PrimaryKey                ::= 'primarykey'

attribute_Private                   ::= 'private'

attribute_ProcedureBlock            ::= 'procedureblock' [ '=' ( '0' | '1' ) ]

attribute_PropertyClass             ::= 'propertyclass' '=' class_reference ('(' ',' class_reference ')')* 

attribute_PublicList                ::= 'publiclist' '=' ( ('(' identifier (',' identifier )* ')' )  | identifier)

attribute_ReadOnly                  ::= 'readonly'

attribute_Required                  ::= 'required'

attribute_ReturnResultSets          ::= 'returnresultsets'

attribute_SchemaSpec                ::= 'schemaspec' '=' string

attribute_ServerOnly                ::= 'serveronly' '=' ( '0' | '1' )

attribute_SOAPAction                ::= 'soapaction' '=' (identifier | string)

attribute_SOAPBindingStyle          ::= 'SoapBindingStyle' '=' ( 'document' | 'rcp' )

attribute_SOAPBodyuse               ::= 'soapbodyuse' '=' ( 'literal' | 'encoded' )

attribute_SOAPMessageName           ::= 'soapmessagename' '=' ( string | soap_identifier ) 

attribute_SOAPNameSpace             ::= 'soapnamespace' '=' ( string | soap_identifier)

attribute_SOAPRequestMessage        ::= 'soaprequestmessage' '=' ( string | soap_identifier  )

attribute_SOAPTypeNamespace         ::= 'soaptypenamespace' '=' ( string | soap_identifier ) 

attribute_SQLCategory               ::= 'sqlcategory' '=' ( 'date' | 'double' | 'fmdate' | 'fmtimestamp' | 'integer' | 'mvdate' | 'name' | 'numeric' | 'string' | 'time' | 'timestamp' | 'POSIXTS' )

attribute_SQLColumnNumber           ::= 'SqlColumnNumber' '=' number

attribute_SQLComputeCode            ::= 'sqlcomputecode' '=' '{'  cos_code_block_sql '}'

attribute_SQLComputed               ::= 'sqlcomputed'

attribute_SQLComputeOnChange        ::= 'sqlcomputeonchange' '=' property_reference  | ('('  property_reference (',' property_reference )* ')')

attribute_SQLFieldname              ::= 'sqlfieldname' '=' sql_field_name
sql_field_name                        ::= text /* any valid sql field name character */

attribute_SQLListDelimiter          ::= 'sqllistdelimiter' '=' expression

attribute_SQLListType               ::= 'sqllisttype' '=' ( 'list' | 'delimited' | 'subnode' )

attribute_SQLName                   ::= 'sqlname' '=' (sql_table_name | string  ) // text is any valid XML element name up to the next ' ] or whitespace

attribute_SQLProc                   ::= 'sqlproc'

attribute_SQLRowidName              ::= 'sqlrowidname' '=' ( '""' | string | sql_table_name ) // text is any valid XML element name up to the next ' ] or whitespace

attribute_SQLRowidPrivate           ::= 'sqlrowidprivate'

attribute_SQLTableName              ::= 'sqltablename' '=' ( '""' | sql_table_name )
sql_table_name                      ::= 'NEEDS SQL TABLE NAME'

attribute_SQLView                   ::= 'sqlview'

attribute_SQLViewname               ::= 'sqlviewname' '=' ( string | sql_table_name ) // text is any valid XML element name up to the next ' ] or whitespace

attribute_StorageStrategy           ::= 'storagestrategy' '=' ('""' | class_item_identifier)

attribute_System                    ::= 'system' '=' ( '0' | '1' | '2' | '3' | '4' )

attribute_Time                      ::= 'time' '=' time_value
time_value                          ::= 'after' | 'before'

attribute_Transient                 ::= 'transient'

attribute_Type                      ::= 'type' '=' ( 'bitmap' | 'bitslice' | 'index' |'key' | 'collatedkey' )

attribute_Unique                    ::= 'unique'

attribute_UpdateColumnList          ::= 'updatecolumnlist' '=' ( one_column_name | ( '('  one_column_name ( ',' one_column_name )* ')' ) )
one_column_name                     ::= string | text // Test continues to first break character

attribute_ViewQuery                 ::= 'viewquery' '=' '{' class_query_body '}' // Text ends at the next unbalanced }
attribute_WebMethod                 ::= 'webmethod'

attribute_XMLNamespace              ::= 'xmlnamespace' '=' (string | identifier)

attribute_ZenMethod                 ::= 'zenmethod'

number                              ::= ['-'] ('regexp:[0-9]*' [ '.' 'regexp:[0-9]+'] [ ('e' | 'E') 'regexp:[0-9]+']) | ('.' 'regexp:[0-9]+' [ ('e' | 'E') 'regexp:[0-9]+'])  

string                              ::= '""' | ('"' 'regexp:[^\"\r\n]*' '"')

alias_identifier                    ::= 'NEED ALIAS IDENT'
identifier                          ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
variable_identifier                 ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'

class_identifier                    ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
soap_identifier                     ::= identifier

text                                ::= 'regexp:.*'
text_in_curly                       ::= 'NEEDS TEXT IN CURLY'

client_identifier                   ::= 'NEEDS CLIENT IDENTIFIER'
expression                          ::= 'NEEDS EXPRESSION'
cos_expression_sql                  ::= 'NEEDS COS EXPRESSION SQL'

cos_code_block                      ::= 'NEEDS COS CODE BLOCK'
cos_code_block_sql                  ::= 'NEEDS COS SQL CODE BLOCK'
cos_code_block_sql_storage          ::= 'NEEDS COS SQL CODE BLOCK'
cos_code_block_trigger              ::= 'NEEDS COS SQL CODE BLOCK'
javascript_code_block                      ::= 'NEEDS JS CODE BLOCK'
filename                            ::= 'NEEDS FILE NAME'

cos_expression_storage              ::= ('<!' '[CDATA[' cos_expression_sql ']]' '>') | cos_expression_sql
cos_code_block_storage              ::= ('<!' '[CDATA[' cos_code_block_sql_storage ']]' '>') | cos_code_block_sql_storage


    ]]]]><![CDATA[> 

    </data></bnf>
]]></Data>
</XData>
</Class>


<Class name="PXW.DEV.BNF.DEF.JS">
<Super>PXW.DEV.BNF.Compilers.loader</Super>
<TimeChanged>67125,77562.589965718</TimeChanged>
<TimeCreated>67125,77562.589965718</TimeCreated>

<Projection name="GEN">
<Description>
This BNF is incomplete so do not project</Description>
<Type>PXW.DEV.BNF.Compilers.projection</Type>
<Parameter name="GenerateTo" value="PXW.DEV.BNF.GEN.JS"/>
</Projection>

<XData name="file">
<Description>
https://github.com/antlr/grammars-v4/blob/master/javascript/javascript/JavaScriptParser.g4
with major fixes to make it work for me</Description>
<Data><![CDATA[
<data><![CDATA[ 

/*program
    : HashBangLine? sourceElements? end_of_file
    ;
*/
OpenBracket                ::='['
CloseBracket               ::=']'
OpenParen                  ::= '('
CloseParen                 ::= ')'
OpenBrace                  ::= '{' /* {this.ProcessOpenBrace();}; */
--TemplateCloseBrace         ::=     {this.IsInTemplateString()}? '}' -> popMode;
CloseBrace                 ::= '}' /* {this.ProcessCloseBrace();}; */
SemiColon                  ::= ';'
Comma                      ::= ','
Assign                     ::= '='
QuestionMark               ::= '?'
QuestionMarkDot            ::= '?.'
Colon                      ::= ':'
Ellipsis                   ::= '...'
Dot                        ::= '.'
PlusPlus                   ::= '++'
MinusMinus                 ::= '--'
Plus                       ::= '+'
Minus                      ::= '-'
BitNot                     ::= '~'
Not                        ::= '!'
Multiply                   ::= '*'
Divide                     ::= '/'
Modulus                    ::= '%'
Power                      ::= '**'
NullCoalesce               ::= '??'
Hashtag                    ::= '#'
RightShiftArithmetic       ::= '>>'
LeftShiftArithmetic        ::= '<<'
RightShiftLogical          ::= '>>>'
LessThan                   ::= '<'
MoreThan                   ::= '>'
LessThanEquals             ::= '<='
GreaterThanEquals          ::= '>='
Equals                    ::= '=='
NotEquals                  ::= '!='
IdentityEquals             ::= '==='
IdentityNotEquals          ::= '!=='
BitAnd                     ::= '&'
BitXOr                     ::= '^'
BitOr                      ::= '|'
And                        ::= '&&'
Or                         ::= '||'
MultiplyAssign             ::= '*='
DivideAssign               ::= '/='
ModulusAssign              ::= '%='
PlusAssign                 ::= '+='
MinusAssign                ::= '-='
LeftShiftArithmeticAssign  ::= '<<='
RightShiftArithmeticAssign ::= '>>='
RightShiftLogicalAssign    ::= '>>>='
BitAndAssign               ::= '&='
BitXorAssign               ::= '^='
BitOrAssign                ::= '|='
PowerAssign                ::= '**='
NullishCoalescingAssign    ::= '??='
ARROW                      ::= '=>'

source_Element    ::= statement

statement         ::= block
    | variable_Statement
    | import_Statement
    | export_Statement
    | empty_Statement
    | class_Declaration
    | function_Declaration
    | expression_Statement
    | if_Statement
    | iteration_Statement
    | continue_Statement
    | break_Statement
    | return_Statement
    | yield_Statement
    | with_Statement
    | labelled_Statement
    | switch_Statement
    | throw_Statement
    | try_Statement
    | debugger_Statement
    
block    ::= '{' [statement_List] '}'
    
statement_List ::= statement*
    
import_Statement ::= "Import" import_From_Block
    
import_From_Block ::= [import_Default] (import_Namespace | import_Module_Items) import_From eos
    | String_Literal eos
    
import_Module_Items    ::= '{' import_Alias_Name (',' import_Alias_Name )*  '}'    

import_Alias_Name    ::= module_Export_Name [("As" imported_Binding)]

module_Export_Name    ::= identifier_Name
    | String_Literal
    
// yield and await are permitted as BindingIdentifier in the grammar
imported_Binding    ::= Identifier
    | "Yield"
    | "Await"
    
import_Default    ::= alias_Name ','
    
import_Namespace   ::= ('*' | identifier_Name) [("As" identifier_Name)]

import_From  ::= "From" String_Literal
    
alias_Name   ::= identifier_Name ["As" identifier_Name]


export_Statement    ::= ("Export" ["Default"] (export_From_Block | declaration) eos) /* # ExportDeclaration*/
                        | ("Export" "Default" single_Expression eos)                 /*# ExportDefaultDeclaration*/

export_From_Block    ::= (import_Namespace import_From eos)
    | (export_Module_Items [import_From] eos)
    
export_Module_Items ::= '{' export_Alias_Name (',' export_Alias_Name  )* '}'

export_Alias_name   ::= module_Export_Name [("As" module_Export_Name)]
    
declaration ::= variable_Statement
    | class_Declaration
    | function_Declaration

variable_Statement    ::= variable_Declaration_List eos
    
variable_Declaration_List ::= var_Modifier variable_Declaration (',' variable_Declaration)*
    
variable_Declaration    ::= assignable [('=' single_Expression)] 
    
empty_Statement ::= ';'
    
expression_Statement ::= /*{this.notOpenBraceAndNotFunction()}?*/ expression_Sequence eos
    
if_Statement ::= "If" '(' expression_Sequence ')' statement [("Else" statement)]
    
iteration_Statement ::= ("Do" statement "While" '(' expression_Sequence ')' eos)                                             /*# DoStatement*/
    | ("While" '(' expression_Sequence ')' statement )                                                                           /*# WhileStatement*/
    | ( "for" "(" "var" Variable_Declaration ";" [ single_Expression ] ";" [ single_Expression ] ")" Statement )
    | ("For" '(' [expression_Sequence | variable_Declaration_List] ';' [expression_Sequence] ';' [expression_Sequence] ')' statement ) /*# ForStatement*/
    | ("For" '(' (single_Expression | variable_Declaration_List) "In" expression_Sequence ')' statement )                              /*# ForInStatement*/
    | ("For" ["Await"] '(' (single_Expression | variable_Declaration_List) "Of" expression_Sequence ')' statement )                       /*# ForOfStatement*/
    
var_Modifier     ::= "Var"
    | "let"
    | "Const"
    
continue_Statement    ::= "Continue" [/*{this.notLineTerminator()}?*/ identifier] eos
    
break_Statement ::= "Break" [/*{this.notLineTerminator()}*/ identifier] eos
    
return_Statement    ::= "Return" [/*{this.notLineTerminator()}?*/ expression_Sequence] eos

yield_Statement     ::= "Yield" [/*({this.notLineTerminator()}?*/ expression_Sequence] eos
    
with_Statement    ::= "With" '(' expression_Sequence ')' statement

switch_Statement   ::= "Switch" '(' expression_Sequence ')' case_Block
    
case_Block  ::= '{' [case_Clauses] [default_Clause [case_Clauses]] '}'

case_Clauses  ::= case_Clause*
    
case_Clause  ::= "Case" expression_Sequence ':' [statement_List]
    
default_Clause   ::= "Default" ':' [ statement_List ]

labelled_Statement ::= identifier ':' statement

throw_Statement   ::= "Throw" /*{this.notLineTerminator()}?*/ expression_Sequence eos

try_Statement ::= "Try" block ((catch_Production [finally_Production]) | finally_Production)
    
catch_Production    ::= "Catch" ['(' assignable? ')'] block
    
finally_Production    ::= "Finally" block
    
debugger_Statement    ::= "Debugger" eos
    
function_Declaration     ::=  ["Async"] "Function" ['*'] identifier '(' [formal_Parameter_List] ')' function_Body
    
class_Declaration    ::= "Class" identifier class_Tail
    
class_Tail    ::= ["Extends" single_Expression] '{' class_Element* '}'
    
/*class_Element
    : (Static | {this.n("static")}? identifier)? methodDefinition
    | (Static | {this.n("static")}? identifier)? fieldDefinition
    | (Static | {this.n("static")}? identifier) block
    | emptyStatement_
    */
class_Element    ::= ([["Static"] identifier] method_Definition)
    | ([["Static"] identifier] field_Definition)
    | ([["Static"] identifier] block)
    | empty_Statement
  
method_Definition    ::= (["Async" /*{this.notLineTerminator()}?*/] ['*'] class_Element_Name '(' [formal_Parameter_List ] ')' function_Body)
    | (['*'] getter '(' ')' function_Body)
    | (['*'] setter '(' formal_Parameter_List? ')' function_Body)
    
field_Definition    ::= class_Element_Name [initializer]
    
class_Element_Name    ::= property_Name
    | private_Identifier 
    
private_Identifier    ::= '#' identifier_Name
    
formal_Parameter_List    ::= (formal_Parameter_Arg (',' formal_Parameter_Arg)* [',' last_Formal_Parameter_Arg])
    | last_Formal_Parameter_Arg
    
formal_Parameter_Arg    ::= assignable ['=' single_Expression] /* ECMAScript 6: Initialization */
    
last_Formal_Parameter_Arg ::= Ellipsis single_Expression /* ECMAScript 6: Rest Parameter */

function_Body    ::= '{' [source_Elements] '}'

source_Elements    ::= source_Element*
    
array_Literal    ::= '[' element_List ']'
    
element_List    ::= [array_Element] (',' array_Element)*  /* Yes, everything is optional */

array_Element    ::= [Ellipsis] single_Expression
 
property_Assignment ::= (property_Name ':' single_Expression )                                 /* PropertyExpressionAssignment */
    | ('[' single_Expression ']' ':' single_Expression)                      /*# ComputedPropertyExpressionAssignment*/
    | ([ "Async" ] ['*'] property_Name '(' [formal_Parameter_List] ')' function_Body ) /*# FunctionProperty*/
    | (getter '(' ')' function_Body )                                        /*# PropertyGetter*/
    | (setter '(' formal_Parameter_Arg ')' function_Body )                     /*# PropertySetter*/
    | ([Ellipsis] single_Expression )                                        /*# PropertyShorthand*/
    

property_Name   ::= identifier_Name
    | String_Literal
    | numeric_Literal
    | ('[' single_Expression ']')
    
arguments    ::= '(' [argument (',' argument)*] ')'

argument    ::= [Ellipsis] (single_Expression | identifier)

expression_Sequence ::= single_Expression (',' single_Expression)*

oldsingle_Expression    ::= anonymous_Function                                /* # FunctionExpression*/
    | ( 'Class' identifier? class_Tail )                     /* ClassExpression */
    | ( single_Expression '?.' single_Expression )            /* OptionalChainExpression */
    | ( single_Expression ['?.'] '[' expression_Sequence ']') /* MemberIndexExpression */
    | ( single_Expression ['?'] '.' ['#'] identifier_Name )     /* MemberDotExpression */
    /* Split to try `new Date()` first, then `new Date`. */
    | ( "New" identifier arguments)                                             /* NewExpression */
    | ( "New" single_Expression arguments)                                       /* NewExpression */
    | ( "New" single_Expression)                                                 /* NewExpression */
    | ( single_Expression arguments)                                           /* ArgumentsExpression */
    | ( "New" '.' identifier )                                                    /* MetaExpression // new.target */
    | ( single_Expression /*{this.notLineTerminator()}?*/ '++' )                    /* PostIncrementExpression */
    | ( single_Expression /*{this.notLineTerminator()}?*/ '--' )                   /* PostDecreaseExpression */
    | ( "Delete" single_Expression )                                             /* DeleteExpression */
    | ( "Void" single_Expression )                                               /* VoidExpression */
    | ( "Typeof" single_Expression )                                             /* TypeofExpression */
    | ('++' single_Expression )                                               /* PreIncrementExpression */
    | ('--' single_Expression )                                               /* PreDecreaseExpression */
    | ('+' single_Expression )                                                 /* UnaryPlusExpression */
    | ('-' single_Expression )                                                /* UnaryMinusExpression */
    | ('~' single_Expression )                                                /* BitNotExpression */
    | ('!' single_Expression )                                                /* NotExpression */
    | ("Await" single_Expression )                                               /* AwaitExpression */
    | (/*<assoc = right>*/ single_Expression '**' single_Expression )              /* PowerExpression */
    | ( single_Expression ('*' | '/' | '%') single_Expression )                 /* MultiplicativeExpression */
    | ( single_Expression ('+' | '-') single_Expression )                       /* AdditiveExpression */
    | ( single_Expression '??' single_Expression )                              /* CoalesceExpression */
    | ( single_Expression ('<<' | '>>' | '>>>') single_Expression )              /* BitShiftExpression */
    | ( single_Expression ('<' | '>' | '<=' | '>=') single_Expression )          /* RelationalExpression */
    | ( single_Expression "Instanceof" single_Expression )                         /* InstanceofExpression */
    | ( single_Expression "In" single_Expression )                                 /* InExpression */
    | ( single_Expression ('==' | '!=' | '===' | '!==') single_Expression )      /* EqualityExpression */
    | ( single_Expression '&' single_Expression )                                /* BitAndExpression */
    | ( single_Expression '^' single_Expression )                               /* BitXOrExpression */
    | ( single_Expression '|' single_Expression )                               /* BitOrExpression */
    | ( single_Expression '&&' single_Expression )                              /* LogicalAndExpression */
    | ( single_Expression '||' single_Expression )                               /* LogicalOrExpression */
    | ( single_Expression '?' single_Expression ':' single_Expression )          /* TernaryExpression */
    | (/*<assoc = right>*/ single_Expression '=' single_Expression )                /* AssignmentExpression */
    | (/*<assoc = right>*/ single_Expression assignment_Operator single_Expression ) /* AssignmentOperatorExpression */
    | ( "Import" '(' single_Expression ')' )                                      /* ImportExpression */
    /*| ( single_Expression template_String_Literal ) */                              /* TemplateStringExpression // ECMAScript 6 */
    | ( yield_Statement )                                                       /* YieldExpression          // ECMAScript 6 */
    | "This"                                                                 /* ThisExpression */
    | identifier                                                           /* IdentifierExpression */
    | "Super"                                                                /* SuperExpression */
    | literal                                                              /* LiteralExpression */
    | array_Literal                                                         /* ArrayLiteralExpression */
    | object_Literal                                                        /* ObjectLiteralExpression */
    | ('(' expression_Sequence ')')                                           /* ParenthesizedExpression */
 

single_expression                  ::= factor ( dyadicop factor )*

factor                              ::= ( monadicop )* primary /* can be any number of +- or ' */
monadicop                           ::= "++" | "--" | "+" | "-" | "~" | "!"

dyadicop                            ::= ('?' primary ':') | '++' | '--' | '**' | '*' | '/' | '%' | '+' | '-' |'??' | '<<' | '>>' | '>>>' | '<' | '>' | '<=' | '>=' | '==' | '!=' | '===' | '!==' | '&' | '^' | '|' | '&&' | '||' | '='
                                        | "InstanceOf" | "In"

primary ::= anonymous_Function 
    | ('[' expression_sequence ']')
    | ( 'Class' identifier? class_Tail )                     /* ClassExpression */
    | ( "New" identifier arguments)                                             /* NewExpression */
    | ( "New" single_Expression arguments)                                       /* NewExpression */
    | ( "New" single_Expression)                                                 /* NewExpression */
    | ( "New" '.' identifier )                                                    /* MetaExpression // new.target */
    | ( "Delete" single_Expression )                                             /* DeleteExpression */
    | ( "Void" single_Expression )                                               /* VoidExpression */
    | ( "Typeof" single_Expression )                                             /* TypeofExpression */
    | ("Await" single_Expression )                                               /* AwaitExpression */
    | ( "Import" '(' single_Expression ')' )                                      /* ImportExpression */
    | ( yield_Statement )                                                       /* YieldExpression          // ECMAScript 6 */
    | ("This" (member_expression_part)* )                                                               /* ThisExpression */
    | macro
    | (function (member_expression_part)* )                                                         /* IdentifierExpression */
    | (identifier (member_expression_part)* )                                                         /* IdentifierExpression */
    | "Super"                                                                /* SuperExpression */
    | literal                                                              /* LiteralExpression */
    | (array_Literal (member_expression_part)*)                                                        /* ArrayLiteralExpression */
    | object_Literal                                                        /* ObjectLiteralExpression */
    | ('(' expression_Sequence ')')                                           /* ParenthesizedExpression */

Member_Expression_Part	::=	( "[" single_Expression "]" )
   |	( "." Identifier [( "(" [ expression_Sequence ] ")" )] )

macro   ::= '$$$' identifier ['(' expression_sequence ')']

function ::= identifier '(' expression_sequence ')'

initializer    ::= '=' single_Expression
    /* TODO: must be `= AssignmentExpression` and we have such label alredy but it doesn't respect the specification.
      See https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-Initializer
    */

assignable    ::= identifier
    | array_Literal
    | object_Literal
    
object_Literal ::= '{' [property_Assignment (',' property_Assignment)* ] '}'

anonymous_Function    ::= (["Async"] "Function" ['*'] '(' [formal_Parameter_List] ')' function_Body) /*# AnonymousFunctionDecl*/
    | (["Async"] arrow_Function_Parameters '=>' arrow_Function_Body )           /*# ArrowFunction*/

arrow_Function_Parameters    ::= identifier
    | ('(' [formal_Parameter_List] ')')
    
arrow_Function_Body    ::= single_Expression
    | function_Body

assignment_Operator    ::= '*='
    | '/='
    | '%='
    | '+='
    | '-='
    | '<<='
    | '>>='
    | '>>>='
    | '&='
    | '^='
    | '|='
    | '**='
    | '??='

literal    ::= Null_Literal
    | Boolean_Literal
    | String_Literal
    | Regular_Expression_Literal
    | numeric_Literal
    | bigint_Literal


numeric_Literal    ::= Decimal_Literal
    | Hex_Integer_Literal
    | Octal_Integer_Literal
    | Octal_Integer_Literal2
    | Binary_Integer_Literal
    

bigint_Literal    ::= Big_Decimal_Integer_Literal
    | Big_Hex_Integer_Literal
    | Big_Octal_Integer_Literal
    | Big_Binary_Integer_Literal
    
getter    ::= "get" /*{this.n("get")}?*/ identifier class_Element_Name
    
setter    ::= "set" /*{this.n("set")}?*/ identifier class_Element_Name
    

identifier_Name    ::= identifier
    | reserved_Word
    
/* don't understand this yet
identifier
    : Identifier
    | NonStrictLet
    | Async
    | As
    | From
    | Yield
    | Of
    ;
*/
identifier ::= "NEED IDENTIFIER"

reserved_Word    ::= keyword
    | Null_Literal
    | Boolean_Literal
    

keyword    ::= "Break"
    | "Do"
    | "Instanceof"
    | "Typeof"
    | "Case"
    | "Else"
    | "New"
    | "Var"
    | "Catch"
    | "Finally"
    | "Return"
    | "Void"
    | "Continue"
    | "For"
    | "Switch"
    | "While"
    | "Debugger"
    | "Function"
    | "This"
    | "With"
    | "Default"
    | "If"
    | "Throw"
    | "Delete"
    | "In"
    | "Try"
    | "Class"
    | "Enum"
    | "Extends"
    | "Super"
    | "Const"
    | "Export"
    | "Import"
    | "Implements"
    | "let"
    | "Private"
    | "Public"
    | "Interface"
    | "Package"
    | "Protected"
    | "Static"
    | "Yield"
    | "Async"
    | "Await"
    | "From"
    | "As"
    | "Of"
    

let    ::= "let"

eos    ::= SemiColon
    | end_of_file
    /*| {this.lineTerminatorAhead()}?
    | {this.closeBrace()}?
    */


Decimal_literal ::= 'NEED decimal_literal'
Hex_Integer_Literal ::= ('0x' | '0X')  ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' )*
Octal_Integer_Literal ::= ('0o' | '0O')  ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'  )* 
Octal_Integer_Literal2 ::= Octal_Integer_Literal
Binary_Integer_Literal::= ('0b' | '0B')  ('0' | '1' )* 

Big_Decimal_Integer_Literal ::= decimal_integer_literal 'n'
Big_Hex_Integer_Literal ::= ('0x' | '0X')  ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' )* 'n'
Big_Octal_Integer_Literal ::= ('0o' | '0O')  ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'  )* 'n'
Big_Binary_Integer_Literal::= ('0b' | '0B')  ('0' | '1' )* 'n'
null_literal    ::= 'null'
boolean_literal ::= 'true' | 'false'

decimal_integer_literal ::= 'NEED decimal_integer_literal'
end_of_file ::= 'NEED end_of_file'
string_literal ::= 'NEED string literal'
regular_expression_literal ::= 'NEED regex literal'

    ]]]]><![CDATA[></data>
]]></Data>
</XData>
</Class>


<Class name="PXW.DEV.BNF.DEF.Python">
<Super>PXW.DEV.BNF.Compilers.loader</Super>
<TimeChanged>67125,77562.591941413</TimeChanged>
<TimeCreated>67125,77562.591941413</TimeCreated>

<Projection name="GEN">
<Description>
This BNF is incomplete so do not project</Description>
<Type>PXW.DEV.BNF.Compilers.projection</Type>
<Parameter name="GenerateTo" value="PXW.DEV.BNF.GEN.Python"/>
</Projection>

<Parameter name="SubElementType">
<Default>PXW.DEV.BNF.Elements.Python</Default>
</Parameter>

<Parameter name="KeywordPattern">
<Description>
Used by the code generator and passed onto the generated code.
The check is done lots of times to keep building up a word until the test fails.</Description>
<Default>1A.AN</Default>
</Parameter>

<XData name="file">
<Data><![CDATA[
<bnf version="2">
<data><![CDATA[ 

# PEG grammar for Python
  
# RULES ADDED BY ME FOR completeness. And need to be hand coded?
ASYNC           : 'async' # why is this special?
AWAIT           : 'await' # why is this special?
DEDENT          : 'code dedent'
ENDMARKER       : 'code endmarker'
FSTRING_END     : 'code fstring_end'
FSTRING_START   : 'code fstring_start'
INDENT          : 'code indent'
invalid_default : 'code invalid_default'
NAME            : 'code name'
NEWLINE         : 'code newline'
NUMBER          : 'code number'
TYPE_COMMENT    : 'code type_comment'

# ========================= START OF THE GRAMMAR =========================

# General grammatical elements and rules:
#
# * Strings with double quotes (") denote SOFT KEYWORDS
# * Strings with single quotes (') denote KEYWORDS
# * Upper case names (NAME) denote tokens in the Grammar/Tokens file
# * Rule names starting with "invalid_" are used for specialized syntax errors
#     - These rules are NOT used in the first pass of the parser.
#     - Only if the first pass fails to parse, a second pass including the invalid
#       rules will be executed.
#     - If the parser fails in the second phase with a generic syntax error, the
#       location of the generic failure of the first pass will be used (this avoids
#       reporting incorrect locations due to the invalid rules).
#     - The order of the alternatives involving invalid rules matter
#       (like any rule in PEG).
#
# Grammar Syntax (see PEP 617 for more information):
#
# rule_name: expression
#   Optionally, a type can be included right after the rule name, which
#   specifies the return type of the C or Python function corresponding to the
#   rule:
# rule_name[return_type]: expression
#   If the return type is omitted, then a void * is returned in C and an Any in
#   Python.
# e1 e2
#   Match e1, then match e2.
# e1 | e2
#   Match e1 or e2.
#   The first alternative can also appear on the line after the rule name for
#   formatting purposes. In that case, a | must be used before the first
#   alternative, like so:
#       rule_name[return_type]:
#            | first_alt
#            | second_alt
# ( e )
#   Match e (allows also to use other operators in the group like '(e)*')
# [ e ] or e?
#   Optionally match e.
# e*
#   Match zero or more occurrences of e.
# e+
#   Match one or more occurrences of e.
# s.e+
#   Match one or more occurrences of e, separated by s. The generated parse tree
#   does not include the separator. This is otherwise identical to (e (s e)*).
# &e
#   Succeed if e can be parsed, without consuming any input.
# !e
#   Fail if e can be parsed, without consuming any input.
# ~
#   Commit to the current alternative, even if it fails to parse.
#

# STARTING RULES
# ==============

file: [statements] ENDMARKER 
interactive: statement_newline 
eval: expressions NEWLINE* ENDMARKER 
func_type: '(' [type_expressions] ')' '->' expression NEWLINE* ENDMARKER 

# GENERAL STATEMENTS
# ==================

statements: statement+ 

statement: compound_stmt  | simple_stmts 

statement_newline:
    | compound_stmt NEWLINE 
    | simple_stmts
    | NEWLINE 
    | ENDMARKER 

simple_stmts:
    | simple_stmt !';' NEWLINE  # Not needed, there for speedup
    | ';'.simple_stmt+ [';'] NEWLINE 

# NOTE: assignment MUST precede expression, else parsing a simple assignment
# will throw a SyntaxError.
simple_stmt:
    | assignment
    | type_alias
    | star_expressions 
    | return_stmt
    | import_stmt
    | raise_stmt
    | 'pass' 
    | del_stmt
    | yield_stmt
    | assert_stmt
    | 'break' 
    | 'continue' 
    | global_stmt
    | nonlocal_stmt

compound_stmt:
    | function_def
    | if_stmt
    | class_def
    | with_stmt
    | for_stmt
    | try_stmt
    | while_stmt
    | match_stmt

# SIMPLE STATEMENTS
# =================

# NOTE: annotated_rhs may start with 'yield'; yield_expr must start with 'yield'
assignment:
    | NAME ':' expression ['=' annotated_rhs ] 
    | ('(' single_target ')' 
         | single_subscript_attribute_target) ':' expression ['=' annotated_rhs ] 
    | (star_targets '=' )+ (yield_expr | star_expressions) !'=' [TYPE_COMMENT] 
    | single_target augassign ~ (yield_expr | star_expressions) 

annotated_rhs: yield_expr | star_expressions

augassign:
    | '+=' 
    | '-=' 
    | '*=' 
    | '@=' 
    | '/=' 
    | '%=' 
    | '&='  
    | '|='  
    | '^=' 
    | '<<=' 
    | '>>=' 
    | '**=' 
    | '//=' 

return_stmt:
    | 'return' [star_expressions] 

raise_stmt:
    | 'raise' expression ['from' expression ] 
    | 'raise' 

global_stmt: 'global' ','.NAME+ 

nonlocal_stmt: 'nonlocal' ','.NAME+ 

del_stmt:
    | 'del' del_targets &(';' | NEWLINE) 

yield_stmt: yield_expr 

assert_stmt: 'assert' expression [',' expression ] 

import_stmt:
    | import_name
    | import_from

# Import statements
# -----------------

import_name: 'import' dotted_as_names 
# note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
import_from:
    | 'from' ('.' | '...')* dotted_name 'import' import_from_targets 
    | 'from' ('.' | '...')+ 'import' import_from_targets 
import_from_targets:
    | '(' import_from_as_names [','] ')' 
    | import_from_as_names !','
    | '*' 
import_from_as_names:
    | ','.import_from_as_name+ 
import_from_as_name:
    | NAME ['as' NAME ] 
dotted_as_names:
    | ','.dotted_as_name+ 
dotted_as_name:
    | dotted_name ['as' NAME ] 
dotted_name:
    | dotted_name '.' NAME 
    | NAME

# COMPOUND STATEMENTS
# ===================

# Common elements
# ---------------

block:
    | NEWLINE INDENT statements DEDENT 
    | simple_stmts

decorators: ('@' named_expression NEWLINE )+ 

# Class definitions
# -----------------

class_def:
    | decorators class_def_raw 
    | class_def_raw

class_def_raw:
    | 'class' NAME [type_params] ['(' [arguments] ')' ] ':' block 

# Function definitions
# --------------------

function_def:
    | decorators function_def_raw 
    | function_def_raw

function_def_raw:
    | 'def' NAME [type_params] '(' [params] ')' ['->' expression ] ':' [func_type_comment] block 
    | ASYNC 'def' NAME [type_params] '(' [params] ')' ['->' expression ] ':' [func_type_comment] block 

# Function parameters
# -------------------

params:
    | parameters

parameters:
    | slash_no_default param_no_default* param_with_default* [star_etc] 
    | slash_with_default param_with_default* [star_etc] 
    | param_no_default+ param_with_default* [star_etc] 
    | param_with_default+ [star_etc] 
    | star_etc 

# Some duplication here because we can't write (',' | &')'),
# which is because we don't support empty alternatives (yet).

slash_no_default:
    | param_no_default+ '/' ',' 
    | param_no_default+ '/' &')' 
slash_with_default:
    | param_no_default* param_with_default+ '/' ',' 
    | param_no_default* param_with_default+ '/' &')' 

star_etc:
    | '*' param_no_default param_maybe_default* [kwds] 
    | '*' param_no_default_star_annotation param_maybe_default* [kwds] 
    | '*' ',' param_maybe_default+ [kwds] 
    | kwds 

kwds:
    | '**' param_no_default 

# One parameter.  This *includes* a following comma and type comment.
#
# There are three styles:
# - No default
# - With default
# - Maybe with default
#
# There are two alternative forms of each, to deal with type comments:
# - Ends in a comma followed by an optional type comment
# - No comma, optional type comment, must be followed by close paren
# The latter form is for a final parameter without trailing comma.
#

param_no_default:
    | param ',' TYPE_COMMENT? 
    | param TYPE_COMMENT? &')' 
param_no_default_star_annotation:
    | param_star_annotation ',' TYPE_COMMENT? 
    | param_star_annotation TYPE_COMMENT? &')' 
param_with_default:
    | param default ',' TYPE_COMMENT? 
    | param default TYPE_COMMENT? &')' 
param_maybe_default:
    | param default? ',' TYPE_COMMENT? 
    | param default? TYPE_COMMENT? &')' 
param: NAME annotation? 
param_star_annotation: NAME star_annotation 
annotation: ':' expression 
star_annotation: ':' star_expression 
default: '=' expression  | invalid_default

# If statement
# ------------

if_stmt:
    | 'if' named_expression ':' block elif_stmt 
    | 'if' named_expression ':' block [else_block] 
elif_stmt:
    | 'elif' named_expression ':' block elif_stmt 
    | 'elif' named_expression ':' block [else_block] 
else_block:
    | 'else' ':' block 

# While statement
# ---------------

while_stmt:
    | 'while' named_expression ':' block [else_block] 

# For statement
# -------------

for_stmt:
    | 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_block] 
    | ASYNC 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_block] 

# With statement
# --------------

with_stmt:
    | 'with' '(' ','.with_item+ ','? ')' ':' block 
    | 'with' ','.with_item+ ':' [TYPE_COMMENT] block 
    | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block 
    | ASYNC 'with' ','.with_item+ ':' [TYPE_COMMENT] block 

with_item:
    | expression 'as' star_target &(',' | ')' | ':') 
    | expression 

# Try statement
# -------------

try_stmt:
    | 'try' ':' block finally_block 
    | 'try' ':' block except_block+ [else_block] [finally_block] 
    | 'try' ':' block except_star_block+ [else_block] [finally_block] 


# Except statement
# ----------------

except_block:
    | 'except' expression ['as' NAME ] ':' block 
    | 'except' ':' block 
except_star_block:
    | 'except' '*' expression ['as' NAME ] ':' block 
finally_block:
    | 'finally' ':' block 

# Match statement
# ---------------

match_stmt:
    | "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT 

subject_expr:
    | star_named_expression ',' star_named_expressions? 
    | named_expression

case_block:
    | "case" patterns guard? ':' block 

guard: 'if' named_expression 

patterns:
    | open_sequence_pattern 
    | pattern

pattern:
    | as_pattern
    | or_pattern

as_pattern:
    | or_pattern 'as' pattern_capture_target 

or_pattern:
    | '|'.closed_pattern+ 

closed_pattern:
    | literal_pattern
    | capture_pattern
    | wildcard_pattern
    | value_pattern
    | group_pattern
    | sequence_pattern
    | mapping_pattern
    | class_pattern

# Literal patterns are used for equality and identity constraints
literal_pattern:
    | signed_number !('+' | '-') 
    | complex_number 
    | strings 
    | 'None' 
    | 'True' 
    | 'False' 

# Literal expressions are used to restrict permitted mapping pattern keys
literal_expr:
    | signed_number !('+' | '-')
    | complex_number
    | strings
    | 'None' 
    | 'True' 
    | 'False' 

complex_number:
    | signed_real_number '+' imaginary_number 
    | signed_real_number '-' imaginary_number  

signed_number:
    | NUMBER
    | '-' NUMBER 

signed_real_number:
    | real_number
    | '-' real_number 

real_number:
    | NUMBER 

imaginary_number:
    | NUMBER 

capture_pattern:
    | pattern_capture_target 

pattern_capture_target:
    | !"_" NAME !('.' | '(' | '=') 

wildcard_pattern:
    | "_" 

value_pattern:
    | attr !('.' | '(' | '=') 

attr:
    | name_or_attr '.' NAME 

name_or_attr:
    | attr
    | NAME

group_pattern:
    | '(' pattern ')' 

sequence_pattern:
    | '[' maybe_sequence_pattern? ']' 
    | '(' open_sequence_pattern? ')' 

open_sequence_pattern:
    | maybe_star_pattern ',' maybe_sequence_pattern? 

maybe_sequence_pattern:
    | ','.maybe_star_pattern+ ','? 

maybe_star_pattern:
    | star_pattern
    | pattern

star_pattern:
    | '*' pattern_capture_target 
    | '*' wildcard_pattern 

mapping_pattern:
    | '{' '}' 
    | '{' double_star_pattern ','? '}' 
    | '{' items_pattern ',' double_star_pattern ','? '}' 
    | '{' items_pattern ','? '}' 

items_pattern:
    | ','.key_value_pattern+

key_value_pattern:
    | (literal_expr | attr) ':' pattern 

double_star_pattern:
    | '**' pattern_capture_target 

class_pattern:
    | name_or_attr '(' ')' 
    | name_or_attr '(' positional_patterns ','? ')' 
    | name_or_attr '(' keyword_patterns ','? ')' 
    | name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')' 

positional_patterns:
    | ','.pattern+ 

keyword_patterns:
    | ','.keyword_pattern+

keyword_pattern:
    | NAME '=' pattern 

# Type statement
# ---------------

type_alias:
    | "type" NAME [type_params] '=' expression 

# Type parameter declaration
# --------------------------

type_params: '[' type_param_seq  ']' 

type_param_seq: ','.type_param+ [','] 

type_param:
    | NAME [type_param_bound] 
    | '*' NAME 
    | '**' NAME 

type_param_bound: ':' expression 

# EXPRESSIONS
# -----------

expressions:
    | expression (',' expression )+ [','] 
    | expression ',' 
    | expression

expression:
    | disjunction 'if' disjunction 'else' expression 
    | disjunction
    | lambdef

yield_expr:
    | 'yield' 'from' expression 
    | 'yield' [star_expressions] 

star_expressions:
    | star_expression (',' star_expression )+ [','] 
    | star_expression ',' 
    | star_expression

star_expression:
    | '*' bitwise_or 
    | expression

star_named_expressions: ','.star_named_expression+ [','] 

star_named_expression:
    | '*' bitwise_or 
    | named_expression

assignment_expression:
    | NAME ':=' ~ expression 

named_expression:
    | assignment_expression
    | expression !':='

disjunction:
    | conjunction ('or' conjunction )+ 
    | conjunction

conjunction:
    | inversion ('and' inversion )+ 
    | inversion

inversion:
    | 'not' inversion 
    | comparison

# Comparison operators
# --------------------

comparison:
    | bitwise_or compare_op_bitwise_or_pair+ 
    | bitwise_or

compare_op_bitwise_or_pair:
    | eq_bitwise_or
    | noteq_bitwise_or
    | lte_bitwise_or
    | lt_bitwise_or
    | gte_bitwise_or
    | gt_bitwise_or
    | notin_bitwise_or
    | in_bitwise_or
    | isnot_bitwise_or
    | is_bitwise_or

eq_bitwise_or: '==' bitwise_or 
noteq_bitwise_or:
    | ('!=' ) bitwise_or 
lte_bitwise_or: '<=' bitwise_or 
lt_bitwise_or: '<' bitwise_or 
gte_bitwise_or: '>=' bitwise_or 
gt_bitwise_or: '>' bitwise_or 
notin_bitwise_or: 'not' 'in' bitwise_or 
in_bitwise_or: 'in' bitwise_or 
isnot_bitwise_or: 'is' 'not' bitwise_or 
is_bitwise_or: 'is' bitwise_or 

# Bitwise operators
# -----------------

bitwise_or:
    | bitwise_or '|' bitwise_xor 
    | bitwise_xor

bitwise_xor:
    | bitwise_xor '^' bitwise_and 
    | bitwise_and

bitwise_and:
    | bitwise_and '&' shift_expr 
    | shift_expr

shift_expr:
    | shift_expr '<<' sum 
    | shift_expr '>>' sum 
    | sum

# Arithmetic operators
# --------------------

sum:
    | sum '+' term 
    | sum '-' term 
    | term

term:
    | term '*' factor 
    | term '/' factor 
    | term '//' factor 
    | term '%' factor 
    | term '@' factor 
    | factor

factor:
    | '+' factor 
    | '-' factor 
    | '~' factor 
    | power

power:
    | await_primary '**' factor 
    | await_primary

# Primary elements
# ----------------

# Primary elements are things like "obj.something.something", "obj[something]", "obj(something)", "obj" ...

await_primary:
    | AWAIT primary 
    | primary

primary:
    | primary '.' NAME 
    | primary genexp 
    | primary '(' [arguments] ')' 
    | primary '[' slices ']' 
    | atom

slices:
    | slice !',' 
    | ','.(slice | starred_expression)+ [','] 

slice:
    | [expression] ':' [expression] [':' [expression] ] 
    | named_expression 

atom:
    | NAME
    | 'True' 
    | 'False' 
    | 'None' 
    | strings
    | NUMBER
    | (tuple | group | genexp)
    | (list | listcomp)
    | (dict | set | dictcomp | setcomp)
    | '...' 

group:
    | '(' (yield_expr | named_expression) ')' 

# Lambda functions
# ----------------

lambdef:
    | 'lambda' [lambda_params] ':' expression 

lambda_params:
    | lambda_parameters

# lambda_parameters etc. duplicates parameters but without annotations
# or type comments, and if there's no comma after a parameter, we expect
# a colon, not a close parenthesis.  (For more, see parameters above.)
#
lambda_parameters:
    | lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* [lambda_star_etc] 
    | lambda_slash_with_default lambda_param_with_default* [lambda_star_etc] 
    | lambda_param_no_default+ lambda_param_with_default* [lambda_star_etc] 
    | lambda_param_with_default+ [lambda_star_etc] 
    | lambda_star_etc 

lambda_slash_no_default:
    | lambda_param_no_default+ '/' ',' 
    | lambda_param_no_default+ '/' &':' 

lambda_slash_with_default:
    | lambda_param_no_default* lambda_param_with_default+ '/' ',' 
    | lambda_param_no_default* lambda_param_with_default+ '/' &':' 

lambda_star_etc:
    | '*' lambda_param_no_default lambda_param_maybe_default* [lambda_kwds] 
    | '*' ',' lambda_param_maybe_default+ [lambda_kwds] 
    | lambda_kwds 

lambda_kwds:
    | '**' lambda_param_no_default 

lambda_param_no_default:
    | lambda_param ',' 
    | lambda_param &':' 
lambda_param_with_default:
    | lambda_param default ',' 
    | lambda_param default &':' 
lambda_param_maybe_default:
    | lambda_param default? ',' 
    | lambda_param default? &':' 
lambda_param: NAME 

# LITERALS
# ========

fstring_middle:
    | fstring_replacement_field
    | FSTRING_MIDDLE 
fstring_replacement_field:
    | '{' (yield_expr | star_expressions) '='? [fstring_conversion] [fstring_full_format_spec] '}' 
fstring_conversion:
    | "!" NAME 
fstring_full_format_spec:
    | ':' fstring_format_spec* 
fstring_format_spec:
    | FSTRING_MIDDLE 
    | fstring_replacement_field
fstring:
    | FSTRING_START fstring_middle* FSTRING_END 

string: STRING 
strings: (fstring|string)+ 

list:
    | '[' [star_named_expressions] ']' 

tuple:
    | '(' [star_named_expression ',' [star_named_expressions]  ] ')' 

set: '{' star_named_expressions '}' 

# Dicts
# -----

dict:
    | '{' [double_starred_kvpairs] '}' 

double_starred_kvpairs: ','.double_starred_kvpair+ [','] 

double_starred_kvpair:
    | '**' bitwise_or 
    | kvpair

kvpair: expression ':' expression 

# Comprehensions & Generators
# ---------------------------

for_if_clauses:
    | for_if_clause+ 

for_if_clause:
    | ASYNC 'for' star_targets 'in' ~ disjunction ('if' disjunction )* 
    | 'for' star_targets 'in' ~ disjunction ('if' disjunction )* 

listcomp:
    | '[' named_expression for_if_clauses ']' 

setcomp:
    | '{' named_expression for_if_clauses '}' 

genexp:
    | '(' ( assignment_expression | expression !':=') for_if_clauses ')' 

dictcomp:
    | '{' kvpair for_if_clauses '}' 

# FUNCTION CALL ARGUMENTS
# =======================

arguments:
    | args [','] &')' 

args:
    | ','.(starred_expression | ( assignment_expression | expression !':=') !'=')+ [',' kwargs ] 
    | kwargs 

kwargs:
    | ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+ 
    | ','.kwarg_or_starred+
    | ','.kwarg_or_double_starred+

starred_expression:
    | '*' expression 

kwarg_or_starred:
    | NAME '=' expression 
    | starred_expression 

kwarg_or_double_starred:
    | NAME '=' expression 
    | '**' expression 

# ASSIGNMENT TARGETS
# ==================

# Generic targets
# ---------------

# NOTE: star_targets may contain *bitwise_or, targets may not.
star_targets:
    | star_target !',' 
    | star_target (',' star_target )* [','] 

star_targets_list_seq: ','.star_target+ [','] 

star_targets_tuple_seq:
    | star_target (',' star_target )+ [','] 
    | star_target ',' 

star_target:
    | '*' (!'*' star_target) 
    | target_with_star_atom

target_with_star_atom:
    | t_primary '.' NAME !t_lookahead 
    | t_primary '[' slices ']' !t_lookahead 
    | star_atom

star_atom:
    | NAME 
    | '(' target_with_star_atom ')' 
    | '(' [star_targets_tuple_seq] ')' 
    | '[' [star_targets_list_seq] ']' 

single_target:
    | single_subscript_attribute_target
    | NAME 
    | '(' single_target ')' 

single_subscript_attribute_target:
    | t_primary '.' NAME !t_lookahead 
    | t_primary '[' slices ']' !t_lookahead 

t_primary:
    | t_primary '.' NAME &t_lookahead 
    | t_primary '[' slices ']' &t_lookahead 
    | t_primary genexp &t_lookahead 
    | t_primary '(' [arguments] ')' &t_lookahead 
    | atom &t_lookahead 

t_lookahead: '(' | '[' | '.'

# Targets for del statements
# --------------------------

del_targets: ','.del_target+ [','] 

del_target:
    | t_primary '.' NAME !t_lookahead 
    | t_primary '[' slices ']' !t_lookahead 
    | del_t_atom

del_t_atom:
    | NAME 
    | '(' del_target ')' 
    | '(' [del_targets] ')' 
    | '[' [del_targets] ']' 

# TYPING ELEMENTS
# ---------------

# type_expressions allow */** but ignore them
type_expressions:
    | ','.expression+ ',' '*' expression ',' '**' expression 
    | ','.expression+ ',' '*' expression 
    | ','.expression+ ',' '**' expression 
    | '*' expression ',' '**' expression 
    | '*' expression 
    | '**' expression 
    | ','.expression+ 

func_type_comment:
    | NEWLINE TYPE_COMMENT &(NEWLINE INDENT)   # Must be followed by indented block
    | TYPE_COMMENT

# ========================= END OF THE GRAMMAR ===========================



# ========================= START OF INVALID RULES =======================
    ]]]]><![CDATA[></data></bnf>
]]></Data>
</XData>
</Class>


<Class name="PXW.DEV.BNF.DEF.SQL">
<Super>PXW.DEV.BNF.Compilers.loader</Super>
<TimeChanged>67125,77562.601304596</TimeChanged>
<TimeCreated>67125,77562.601304596</TimeCreated>

<Projection name="GEN">
<Type>PXW.DEV.BNF.Compilers.projection</Type>
<Parameter name="GenerateTo" value="PXW.DEV.BNF.GEN.SQL"/>
</Projection>

<Parameter name="SubElementType">
<Default>PXW.DEV.BNF.Elements.SQL</Default>
</Parameter>

<XData name="file">
<Data><![CDATA[
<bnf>
<data><![CDATA[

sql_program					::= query_specification
								| call_command
								| insert_command
								| update_command
								| declare_command
								| open_command
								| fetch_command
								| close_command
								| delete_command
								| CHECKPRIV_command

query_specification         ::= [with_command ] select_command ( union select_command )*
subquery_specification 		::= select_command ( union select_command )*

with_command 				::= 'WITH' with_clause (',' with_clause)*
with_clause					::= alias_name 'AS' '(' select_command ')' 
with_name					::= identifier 
 
select_command				::= 'SELECT' [ set_quantifier ] select_list [select_into] [ table_expression ]

set_quantifier              ::= ( ( 'DISTINCT' ['BY' '(' sql_expression ( ',' sql_expression )* ')' ] ) | 'ALL' | ('TOP' sql_expression) | '%NOFPLAN' | '%NOLOCK' | '%NORUNTIME' | ('%PROFILE' ['ALL']) )*
 
select_list                 ::= select_sublist ( ',' select_sublist )*

select_sublist              ::= derived_column | (qualifier  '.' '*')

derived_column              ::= sql_expression [ as_clause ] 

as_clause                   ::= [ 'AS' ] column_name

table_expression            ::= from_clause	[ where_clause ] [ group_by_clause ] [ having_clause ] [ order_by_clause ]

from_clause                 ::= 'FROM' [from_optimise_list] ( table_reference) [ ( ',' table_reference )* ] ( join )*
from_optimise_list			::= from_optimise ( from_optimise )*
from_optimise				::= ('%firsttable' [alias_name])
								| '%ALLINDEX'
								| '%STARTTABLE'
								| '%INORDER'
								| '%FULL'
								| '%NOFLATTEN'
								| '%NOMERGE'
								| '%NOREDUCE'
								| '%NOSVSO'
								| '%NOTOPOPT'
								| '%NOUNIONOROPT'
								| '%PARALLEL'
								| ('%IGNOREINDEX' index_reference_list )
								| ('%IGNOREINDICES' index_reference_list )

join 						::= [('INNER' | 'OUTER' | 'LEFT' | 'RIGHT' | 'CROSS' | 'NATURAL' |'FULL' )*] 'JOIN' table_reference [ join_on ]
join_on						::= 'ON' sql_expression 
	/* defined the first group as 0 to many AND optional (limitation of my parser optimisation - if I ever fix the parser we can get rid of the []) */
table_reference             ::= stored_proc_table | direct_table | derived_table
direct_table				::= table_name [ table_as_clause ]

table_reference_noalias     ::= direct_table_noalias | derived_table_noalias
direct_table_noalias		::= table_name 

index_reference				::= [ table_reference_noalias '.' ] identifier
index_reference_list		::= index_reference ( ',' index_reference )*


table_as_clause                   ::= [ 'AS' ] alias_name

select_into				  	::= 'INTO' select_into_variable ( ',' select_into_variable)*
select_into_variable		::= [':'] sql_cos_variable /*variable *//* it appears that on the INTO the : is not required */

correlation_specification ::= [ 'AS' ] correlation_name /* [ '(' derived_column_list ')' ]*/

derived_column_list         ::= column_name_list

derived_table               ::= table_subquery [ table_as_clause ]
derived_table_noalias       ::= table_subquery

table_subquery              ::= subquery

joined_table                ::= cross_join | qualified_join |  ('(' joined_table ')')

cross_join                  ::= table_reference 'CROSS' 'JOIN'  table_reference

qualified_join              ::= table_reference [ 'NATURAL' ] [ join_type ] 'JOIN' table_reference [ join_specification ]

join_type                   ::=	'INNER' |  (outer_join_type [ 'OUTER' ]) /* |   'UNION' */

outer_join_type             ::= 'LEFT' | 'RIGHT' | 'FULL'

join_specification          ::= join_condition | named_columns_join

join_condition              ::= 'ON' search_condition


named_columns_join          ::= 'USING' '(' join_column_list ')'

join_column_list            ::= column_name_list

where_clause                ::= 'WHERE' sql_expression /* search_condition */

group_by_clause             ::= 'GROUP' 'BY' grouping_column_reference_list

grouping_column_reference_list ::=	grouping_column_reference  ( ',' grouping_column_reference )* 

grouping_column_reference   ::= sql_expression /* column_reference */ /*[ <collate clause> ]*/

having_clause               ::= 'HAVING' sql_expression

order_by_clause             ::= 'ORDER' 'BY' ordering_column_reference_list

ordering_column_reference_list ::=	ordering_column_reference  ( ',' ordering_column_reference )* 

ordering_column_reference   ::= sql_expression [ 'ASC' | 'DESC']  /*[ <collate clause> ]*/


union						::= 'UNION' ('ALL' | '%PARALLEL')*

scalar_subquery ::= subquery

subquery ::= '(' query_expression ')'

query_expression ::= non_join_query_expression | joined_table

non_join_query_expression ::= non_join_query_term
	/* |	<query expression> UNION [ ALL ] [ <corresponding spec> ] <query term> */
	/* |	<query expression> EXCEPT [ ALL ] [ <corresponding spec> ] <query term> */

non_join_query_term ::= non_join_query_primary 
	/*|	<query term> INTERSECT [ ALL ] [ <corresponding spec> ] <query primary>*/

non_join_query_primary ::= simple_table | ( '(' non_join_query_expression ')' )

simple_table ::= query_specification
	/*|	<table value constructor>*/
	/*|	<explicit table> */
 
column_name_list ::= column_name ( ',' column_name )*

table_name ::=  [ schema_name '.' ] qualified_identifier /* | qualified_local_table_name*/

insert_command				::= 'INSERT' (update_keyword)* ['INTO'] direct_table insert_method
insert_method				::= insert_set_list | insert_values_list | insert_multirow
insert_set_list				::= 'SET' insert_set (',' insert_set)*
insert_values_list			::= update_columns 'VALUES' update_values
insert_multirow				::= [ update_columns ] select_command
insert_set					::= column_reference '=' sql_expression

update_command				::= 'UPDATE' (update_keyword)* direct_table ( ('SET' update_set (',' update_set)* ) 
																			 | ( update_columns (('VALUES' update_values) | select_command) )
																		   ) [where_clause]
update_set					::= column_reference '=' sql_expression

update_keyword				::= '%NOCHECK' | '%NOFPLAN' | '%NOINDEX' | '%NOJOURN' | '%NOLOCK' | '%NOTRIGGER' | '%PROFILE_ALL' | '%PROFILE_ALL'

update_columns				::= '(' column_name ( ',' column_name)*  ')'
update_values				::= '(' sql_expression ( ',' sql_expression )* ')'

declare_command 			::= 'DECLARE' cursor_name 'CURSOR' 'FOR' query_specification [ 'FOR' ('UPDATE' | ('READ' 'ONLY'))]
cursor_name					::= identifier

open_command				::= 'OPEN' cursor_name

fetch_command				::= 'FETCH' cursor_name [ select_into ]

close_command				::= 'CLOSE' cursor_name

delete_command              ::= 'DELETE' (update_keyword)* ['FROM'] direct_table [ where_clause ]

CHECKPRIV_command			::= '%CHECKPRIV' checkpriv_objpriv [ '(' column_name ( ',' column_name)* ')' ] 'ON' table_reference
checkpriv_objpriv			::= '%ALTER' | 'DELETE' | 'SELECT' | 'INSERT' | 'UPDATE' | 'EXECUTE' | 'REFERENCES'

call_command				::= 'CALL' stored_proc_call

/* Search Condition */
search_condition	::= condition_expression
condition_expression                       ::= condition_factor ( condition_dyadicop condition_factor )*
condition_dyadicop                      ::=  "+" | "-" | "\\" | "/" | "<>" | ">" | "'>" | ">=" | "<" | "'<" | "<="
                                        | "=" | "'=" | "**" | "*" | "&&" | "&" | "]]" | "[" | "'[" | "!" | "||" | "_" | "#" 
										| "AND" | "OR" 
										| "%STARTSWITH" | "LIKE"
										| 'IS'
                                        /* | "?" | "'?" */ 


condition_factor                       ::= [ condition_monadicop ] condition_term
condition_monadicop                    ::= "+" | "-"  | 'NOT' 

condition_term                         ::= condition_primary 
condition_primary                      ::= sql_number
                                          | sql_string
										  | sql_cos_variable
										  | sql_special_variable
										  | column_reference
										  | macrocall
										  | ( '(' subquery_specification ')' ) 
										  | ( '(' sql_expression ')' )

sql_special_variable					::= 'NULL' | '?' | '$H'  | '$ZNSPACE'
										  
/* expression */
sql_expression                       ::= sql_factor ( sql_dyadicop sql_factor )*  /* using star as an expression on its own not strictly correct but good enough?*/
sql_dyadicop                            ::=  "+" | "-" | "\\" | "/" | "<>" | ">=" | ">" | "!>" | "<=" |  "<" | "!<" 
                                        | "=" | "!=" | "**" | "*" | "&&" | "&" | "]]" | "[" | "'[" | "!" | "||" | "_" | "#" | '\'
										| "AND" | "OR" | "NOT=" 
										| "SIZE" | "ESCAPE" /* size and escape do not really belong here, but I am just using on already valid sql */
										| sql_predicate
										| ("NOT" sql_predicate)
sql_predicate						::= "%STARTSWITH" | "BETWEEN" | "IS" | "IN" | "%INLIST" | "LIKE" | "%PATTERN" | "%MATCHES"

sql_factor                       ::= [ sql_monadicop ] sql_term
sql_monadicop                    ::= "+" | "-" | "NOT" | "%NOINDEX"

sql_term                         ::= sql_primary 
sql_primary                      ::= sql_number
                                          | sql_string
										  | sql_case_expression
										  | sql_fn_function
										  | sql_function
										  | colon_sql_cos_variable
										  | stored_proc_call
										  | column_reference
										  | sql_special_variable
										  | macrocall
										  | ( '(' subquery_specification ')' )
										  | ( '(' sql_expression ( ',' sql_expression )* ')' ) /* for IN ( a,b,c) type expressions (IN is being treated like a +) this may cause more issues but a nice solution for now*/


sql_number								::= 'NEED NUMBER'
sql_string								::= 'NEED STRING'

colon_sql_cos_variable					::= ':' sql_cos_variable
sql_cos_variable						::= 'NEED COS VAR'

macrocall                           ::= '$$$' macro_identifier [ macro_parameter_list | macro_parameter_text ] 
macro_parameter_list                ::= '(' [ [macro_parameter] ( ',' [macro_parameter] )* ] ')'
macro_parameter                     ::= sql_expression 
macro_parameter_text                ::= '(' any_text_upto_close_bracket  ')'
macro_identifier                    ::= identifier /* [ '%' ] 'regexp:[0-9A-Za-z]+' */
any_text_upto_close_bracket         ::= 'code this'

sql_function						::= ('$' identifier '(' [ sql_expression ( ',' sql_expression)* ] ')')
										| ('%exact' sql_expression )
										| ('count' '(' ['distinct' | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ] ) 
										| ('min' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ] ) 
										| ('max' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ] ) 
										| ('sum' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ] ) 
										| ('avg' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ] ) 
										| ('cast' '('  sql_expression 'as' identifier ['(' sql_expression ( ',' sql_expression)* ')' ] ')' )
										| ('exists'  '(' subquery_specification ')' )
										| ('list' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')') 
										| ('%dlist' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')') 
										| ('FOR' 'SOME' '%ELEMENT' '(' sql_expression ')' sql_expression )
										| ('trim' '(' ['leading' | 'trailing' | 'both'] [(sql_expression 'from')] sql_expression  ')'  )
										| ('dateadd' '(' sql_function_datepart_part ',' sql_expression ',' sql_expression ')' )
										| ('datediff' '(' sql_function_datepart_part ',' sql_expression ',' sql_expression ')' )
										| ('datename' '(' sql_function_datepart_part ',' sql_expression ')' )
										| ('datepart' '(' sql_function_datepart_part ',' sql_expression ')' )
                                        | (identifier '(' [ '*' | (sql_expression ( ',' sql_expression)*) ] ')'  [ sql_window ] )
                                        /* need to code some of the functions to decide where * is valid? */

sql_fn_function						::= '{' 'fn' sql_function '}' /* too simple? */
sql_window							::= 'OVER' '(' [ sql_window_partition ] [ order_by_clause ]  [ (sql_window_rows_between | sql_window_rows ) ]  ')'
sql_window_partition 				::= 'PARTITION' 'BY' col_list
sql_window_rows						::= 'ROWS' sql_window_frame
sql_window_rows_between				::= 'ROWS' 'BETWEEN' sql_window_frame 'AND' sql_window_frame
sql_window_frame					::= ('UNBOUNDED' 'PRECEDING') | (sql_expression 'PRECEDING') | ('CURRENT' 'ROW') | ('UNBOUNDED' 'FOLLOWING') | (sql_expression 'FOLLOWING')

sql_function_datepart_part ::= sql_function_datepart_part_word
								| sql_string
								| colon_sql_cos_variable
sql_function_datepart_part_word ::= 'year' | 'yy' | 'yyyy'
									| 'quarter' | 'qq' | 'q'
									| 'month' | 'mm' | 'm'
									| 'week' | 'wk' | 'ww'
									| 'weekday' | 'dw' | 'w'
									| 'dayofyear' | 'dy' | 'y'
									| 'day' | 'dd' | 'd'
									| 'hour' | 'hh' | 'h'
									| 'minute' | 'mi' | 'n'
									| 'second' | 'ss' | 's'
									| 'millisecond' | 'ms'
									| 'sqltimestamp' | 'sts'
									
sql_case_expression					::= 'CASE' ( sql_case_expression1 | sql_case_expression2 ) ['ELSE' sql_expression ] 'END'
sql_case_expression1				::= 'WHEN' sql_expression 'THEN' sql_expression  ('WHEN' sql_expression 'THEN' sql_expression )* /* glitch in generated code where (x)* always returns true because * means 0 or more we need a way of saying at least 1 */
sql_case_expression2				::= sql_expression ('WHEN' sql_expression 'THEN' sql_expression )* 

col_list							::= column_reference ( ',' column_reference )*



value_expression    ::=	numeric_value_expression |  string_value_expression
	/*|   <datetime value expression>	|   <interval value expression> */

/* NUMERIC */

numeric_value_expression ::= term
	|  ( numeric_value_expression '+' term )
	|  ( numeric_value_expression '-' term )

term                    ::= factor
	|  ( term '*' factor )
	|  ( term '/' factor )

factor ::= [ sign ] numeric_primary

sign ::= '+' | '-'

numeric_primary ::= value_expression_primary | numeric_value_function


value_expression_primary ::= number /* unsigned_value_specification */
    |   column_reference
	/*|   <set function specification>	|   <scalar subquery>	|   <case expression>	|   <left paren> <value expression> <right paren>	|   <cast specification> */


column_reference 					::= [ alias_name '.' ] column_name [column_reference_implicit]
column_reference_implicit 			::= ('->' column_name)*

stored_proc_call	::=   stored_proc_name stored_proc_parameter_list
stored_proc_table	::=   stored_proc_name stored_proc_parameter_list [ table_as_clause ]
stored_proc_parameter_list                ::= '(' [ [stored_proc_parameter] ( ',' [stored_proc_parameter] )* ] ')'
stored_proc_parameter                     ::= sql_expression 
stored_proc_name    ::= [ schema_name '.' ] qualified_identifier
qualifier ::= table_name /* | <correlation name> */

number                              ::= ('regexp:[0-9]*' [ '.' 'regexp:[0-9]+'] [ ('e' | 'E') 'regexp:[0-9]+']) | ('.' 'regexp:[0-9]+' [ ('e' | 'E') 'regexp:[0-9]+'])  


unsigned_value_specification ::= unsigned_literal | general_value_specification

unsigned_literal ::= unsigned_numeric_literal | general_literal

unsigned_numeric_literal ::= exact_numeric_literal | approximate_numeric_literal

exact_numeric_literal ::= (unsigned_integer [ '.' [ unsigned_integer ] ] )
	                    |	('.' unsigned_integer)

unsigned_integer_ ::= ( '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '0')*

approximate_numeric_literal ::= mantissa 'E' exponent

mantissa ::= exact_numeric_literal

exponent ::= signed_integer

signed_integer ::= [ sign ] unsigned_integer

general_literal ::= character_string_literal /*	|	<national character string literal> 	|	<bit string literal>	|	<hex string literal>	|	<datetime literal>	|	<interval literal> */

character_string_literal ::= '"' 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'  '"'

general_value_specification ::= cos_variable_identifier | '?' 
	|   'USER'
	|   'CURRENT_USER'
	|   'SESSION_USER'
	|   'SYSTEM_USER'
	|   'VALUE'


numeric_value_function ::= /*<position expression> | <extract expression> |	*/ length_expression

length_expression ::= 'LENGTH' '(' character_Value_expression ')'

/* STRINGS */

string_value_expression ::= character_value_expression /* | <bit value expression> */

character_value_expression ::= concatenation | character_factor

concatenation ::= character_value_expression '||' character_factor

character_factor ::= character_primary /* [ <collate clause> ]*/

character_primary ::= value_expression_primary | string_value_function

string_value_function ::= character_value_function /* | <bit value function>*/

character_value_function ::= character_substring_function 
	/*|   <fold>	|   <form-of-use conversion>	|   <character translation>	|   <trim function> */

character_substring_function ::= 'SUBSTRING' '(' character_value_expression ',' numeric_value_expression ',' numeric_value_expression ')'


schema_name ::= identifier
qualified_identifier ::= identifier
correlation_name ::= identifier
column_name ::= identifier 
alias_name ::= identifier
cos_variable_identifier ::= ':' (['{' identifier '}'] | identifier ) /* if the SQL is in a trigger then we can allow {var} coding for ALL sql for ease*/ 
identifier                    ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)' 

    ]]]]><![CDATA[></data></bnf>
]]></Data>
</XData>
</Class>


<Class name="PXW.DEV.BNF.DEF.SQL92">
<Super>PXW.DEV.BNF.Compilers.loader</Super>
<TimeChanged>67125,77562.630257265</TimeChanged>
<TimeCreated>67125,77562.630257265</TimeCreated>

<Projection name="GEN">
<Type>PXW.DEV.BNF.Compilers.projection</Type>
<Parameter name="GenerateTo" value="PXW.DEV.BNF.GEN.SQL92"/>
</Projection>

<Parameter name="SubElementType">
<Default>PXW.DEV.BNF.Elements.SQL</Default>
</Parameter>

<XData name="file">
<Data><![CDATA[
<bnf version="3">
<data><![CDATA[
/*
--hr
--h2 Key SQL Statements and Fragments
--/h2
--bl
--li ALLOCATE CURSOR <allocate cursor statement>
--li ALTER DOMAIN <alter domain statement>
--li ALTER TABLE <alter table statement>
--li CLOSE cursor <close statement> <dynamic close statement>
--li Column definition <column definition>
--li COMMIT WORK <commit statement>
--li CONNECT <connect statement>
--li CREATE ASSERTION <assertion definition>
--li CREATE CHARACTER SET <character set definition>
--li CREATE COLLATION <collation definition>
--li CREATE DOMAIN <domain definition>
--li CREATE SCHEMA <schema definition>
--li CREATE TABLE <table definition>
--li CREATE TRANSLATION <translation definition>
--li CREATE VIEW <view definition>
--li Data type <data type>
--li DEALLOCATE PREPARE <deallocate prepared statement>
--li DECLARE cursor <declare cursor> <dynamic declare cursor>
--li DECLARE LOCAL TEMPORARY TABLE <temporary table declaration>
--li DELETE <delete statement: positioned> <delete statement: searched> <dynamic delete statement: positioned>
--li DESCRIBE <describe statement>
--li DESCRIPTOR statements <system descriptor statement>
--li DISCONNECT <disconnect statement>
--li EXECUTE <execute statement>
--li EXECUTE IMMEDIATE <execute immediate statement>
--li FETCH cursor <fetch statement> <dynamic fetch statement>
--li GET DIAGNOSTICS <get diagnostics statement>
--li GRANT <grant statement>
--li INSERT <insert statement>
--li Literal <literal>
--li MODULE <module>
--li OPEN cursor <open statement> <dynamic open statement>
--li PREPARE <prepare statement>
--li Preparable statement <preparable statement>
--li REVOKE <revoke statement>
--li ROLLBACK WORK <rollback statement>
--li Search condition <search condition>
--li SELECT <query specification>
--li SET CATALOG <set catalog statement>
--li SET CONNECTION <set connection statement>
--li SET CONSTRAINTS <set constraints mode statement>
--li SET NAMES <set names statement>
--li SET SCHEMA <set schema statement>
--li SET SESSION AUTHORIZATION <set session authorization identifier statement>
--li SET TIME ZONE <set local time zone statement>
--li SET TRANSACTION <set transaction statement>
--li UPDATE <update statement: positioned> <update statement: searched> <dynamic update statement: positioned>
--li Value expression <value expression>
--/bl
--hr 

--h2 Basic Definitions of Characters Used, Tokens, Symbols, Etc.
--/h2
*/
<SQL terminal character> ::=
		<SQL language character>
	|	<SQL embedded language character>

<SQL language character> ::=
		<simple Latin letter>
	|	<digit>
	|	<SQL special character>

<simple Latin letter> ::=
		<simple Latin upper case letter>
	|	<simple Latin lower case letter>

<simple Latin upper case letter> ::=
	A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z

<simple Latin lower case letter> ::=
	a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z

<digit> ::=
	0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<SQL special character> ::=
		<space>
	|	<double quote>
	|	<percent>
	|	<ampersand>
	|	<quote>
	|	<left paren>
	|	<right paren>
	|	<asterisk>
	|	<plus sign>
	|	<comma>
	|	<minus sign>
	|	<period>
	|	<solidus>
	|	<colon>
	|	<semicolon>
	|	<less than operator>
	|	<greater than operator>
	|	<equals operator>
	|	<question mark>
	|	<underscore>
	|	<vertical bar>

<space> ::= !! space character in character set in use

<double quote> ::= "

<percent> ::= %

<ampersand> ::= &

<quote> ::= '

<left paren> ::= (

<right paren> ::= )

<asterisk> ::= *

<plus sign> ::= +

<comma> ::= ,

<minus sign> ::= -

<period> ::= .

<solidus> ::= /

<colon> ::= :

<semicolon> ::= ;

<less than operator> ::= <

<equals operator> ::= =

<greater than operator> ::= >

<question mark> ::= ?

<underscore> ::= _

<vertical bar> ::= |

<SQL embedded language character> ::= <left bracket> | <right bracket>

<left bracket> ::= [

<right bracket> ::= ]

<token> ::=
		<nondelimiter token>
	|	<delimiter token>

<nondelimiter token> ::=
		<regular identifier>
	|	<key word>
	|	<unsigned numeric literal>
	|	<national character string literal>
	|	<bit string literal>
	|	<hex string literal>

<regular identifier> ::= <identifier body>

<identifier body> ::= <identifier start> [ { <underscore> | <identifier part> } ... ]

<identifier start> ::= !! See the Syntax rules

<identifier part> ::= <identifier start> | <digit>

<key word> ::= <reserved word> | <non-reserved word>

<reserved word> ::=
		ABSOLUTE | ACTION | ADD | ALL | ALLOCATE | ALTER | AND | ANY | ARE
	|	AS | ASC | ASSERTION | AT | AUTHORIZATION | AVG
	|	BEGIN | BETWEEN | BIT | BIT_LENGTH | BOTH | BY
	|	CASCADE | CASCADED | CASE | CAST | CATALOG | CHAR | CHARACTER | CHARACTER_LENGTH
	|	CHAR_LENGTH | CHECK | CLOSE | COALESCE | COLLATE | COLLATION | COLUMN | COMMIT
	|	CONNECT | CONNECTION | CONSTRAINT | CONSTRAINTS | CONTINUE | CONVERT | CORRESPONDING
	|	CREATE | CROSS | CURRENT | CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR
	|	DATE | DAY | DEALLOCATE | DEC | DECIMAL | DECLARE | DEFAULT
	|	DEFERRABLE | DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR | DIAGNOSTICS
	|	DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP
	|	ELSE | END | END-EXEC | ESCAPE | EXCEPT | EXCEPTION | EXEC | EXECUTE | EXISTS | EXTERNAL | EXTRACT
	|	FALSE | FETCH | FIRST | FLOAT | FOR | FOREIGN | FOUND | FROM | FULL
	|	GET | GLOBAL | GO | GOTO | GRANT | GROUP
	|	HAVING | HOUR
	|	IDENTITY | IMMEDIATE | IN | INDICATOR | INITIALLY | INNER | INPUT | INSENSITIVE
	|	INSERT | INT | INTEGER | INTERSECT | INTERVAL | INTO | IS | ISOLATION
	|	JOIN
	|	KEY
	|	LANGUAGE | LAST | LEADING | LEFT | LEVEL | LIKE | LOCAL | LOWER
	|	MATCH | MAX | MIN | MINUTE | MODULE | MONTH
	|	NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO | NOT | NULL | NULLIF | NUMERIC
	|	OCTET_LENGTH | OF | ON | ONLY | OPEN | OPTION | OR | ORDER | OUTER | OUTPUT | OVERLAPS
	|	PAD | PARTIAL | POSITION | PRECISION | PREPARE | PRESERVE | PRIMARY | PRIOR | PRIVILEGES | PROCEDURE | PUBLIC
	|	READ | REAL | REFERENCES | RELATIVE | RESTRICT | REVOKE | RIGHT | ROLLBACK | ROWS
	|	SCHEMA | SCROLL | SECOND | SECTION | SELECT | SESSION | SESSION_USER | SET
	|	SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE | SQLERROR | SQLSTATE | SUBSTRING | SUM | SYSTEM_USER
	|	TABLE | TEMPORARY | THEN | TIME | TIMESTAMP | TIMEZONE_HOUR | TIMEZONE_MINUTE
	|	TO | TRAILING | TRANSACTION | TRANSLATE | TRANSLATION | TRIM | TRUE
	|	UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE | USER | USING
	|	VALUE | VALUES | VARCHAR | VARYING | VIEW
	|	WHEN | WHENEVER | WHERE | WITH | WORK | WRITE
	|	YEAR
	|	ZONE

<non-reserved word> ::=
		ADA
	|	C | CATALOG_NAME | CHARACTER_SET_CATALOG | CHARACTER_SET_NAME | CHARACTER_SET_SCHEMA
	|	CLASS_ORIGIN | COBOL | COLLATION_CATALOG | COLLATION_NAME | COLLATION_SCHEMA
	|	COLUMN_NAME | COMMAND_FUNCTION | COMMITTED | CONDITION_NUMBER | CONNECTION_NAME
	|	CONSTRAINT_CATALOG | CONSTRAINT_NAME | CONSTRAINT_SCHEMA | CURSOR_NAME
	|	DATA | DATETIME_INTERVAL_CODE | DATETIME_INTERVAL_PRECISION | DYNAMIC_FUNCTION
	|	FORTRAN
	|	LENGTH
	|	MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH | MESSAGE_TEXT | MORE | MUMPS
	|	NAME | NULLABLE | NUMBER
	|	PASCAL | PLI
	|	REPEATABLE | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_SQLSTATE | ROW_COUNT
	|	SCALE | SCHEMA_NAME | SERIALIZABLE | SERVER_NAME | SUBCLASS_ORIGIN
	|	TABLE_NAME | TYPE
	|	UNCOMMITTED | UNNAMED

/*
--hr
--h2 Literal Numbers, Strings, Dates and Times
--/h2
*/

<unsigned numeric literal> ::=
		<exact numeric literal>
	|	<approximate numeric literal>

<exact numeric literal> ::=
		<unsigned integer> [ <period> [ <unsigned integer> ] ]
	|	<period> <unsigned integer>

<unsigned integer> ::= <digit> ...

<approximate numeric literal> ::=
		<mantissa> E <exponent>

<mantissa> ::= <exact numeric literal>

<exponent> ::= <signed integer>

<signed integer> ::= [ <sign> ] <unsigned integer>

<sign> ::= <plus sign> | <minus sign>

<national character string literal> ::=
		N <quote> [ <character representation> ... ] <quote> [ { <separator>... <quote> [ <character representation>... ] <quote> }... ]

<character representation> ::= <nonquote character> | <quote symbol>

<nonquote character> ::= !! See the Syntax rules

<quote symbol> ::= <quote> <quote>

<separator> ::= { <comment> | <space> | <newline> }...

<comment> ::= <comment introducer> [ <comment character>... ] <newline>

<comment introducer> ::= <minus sign><minus sign> [<minus sign>...]

<comment character> ::= <nonquote character> | <quote>

<newline> ::= !! implementation defined end of line indicator

<bit string literal> ::=
		B <quote> [ <bit> ... ] <quote> [ { <separator>... <quote> [ <bit>... ] <quote> }... ]

<bit> ::= 0 | 1

<hex string literal> ::=
		X <quote> [ <hexit> ... ] <quote> [ { <separator>... <quote> [ <hexit>... ] <quote> }... ]

<hexit> ::= <digit> | A | B | C | D | E | F | a | b | c | d | e | f

<delimiter token> ::=
		<character string literal>
	|	<date string>
	|	<time string>
	|	<timestamp string>
	|	<delimited identifier>
	|	<SQL special character>
	|	<not equals operator>
	|	<greater than or equals operator>
	|	<less than or equals operator>
	|	<concatenation operator>
	|	<double period>
	|	<left bracket>
	|	<right bracket>

<character string literal> ::=
	[ <introducer><character set specification> ] <quote> [ <character representation>... ] <quote> [ { <separator>... <quote> [ <character representation>... ] <quote> }... ]

<introducer> ::= <underscore>

<character set specification> ::=
		<standard character repertoire name>
	|	<implementation-defined character repertoire name>
	|	<user-defined character repertoire name>
	|	<standard universal character form-of-use name>
	|	<implementation-defined universal character form-of-use name>

<standard character repertoire name> ::= <character set name>

<character set name> ::= [ <schema name> <period> ] <SQL language identifier>

<schema name> ::= [ <catalog name> <period> ] <unqualified schema name>

<catalog name> ::= <identifier>

<identifier> ::= [ <introducer><character set specification> ] <actual identifier>

<actual identifier> ::= <regular identifier> | <delimited identifier>

<delimited identifier> ::= <double quote> <delimited identifier body> <double quote>

<delimited identifier body> ::= <delimited identifier part>...

<delimited identifier part> ::= <nondoublequote character> | <doublequote symbol>

<nondoublequote character> ::= !! See the syntax rules

<doublequote symbol> ::= <double quote><double quote>

<unqualified schema name> ::= <identifier>

<SQL language identifier> ::=
		<SQL language identifier start> [ { <underscore> | <SQL language identifier part> }... ]

<SQL language identifier start> ::= <simple Latin letter>

<SQL language identifier part> ::= <simple Latin letter> | <digit>

<implementation-defined character repertoire name> ::= <character set name>

<user-defined character repertoire name> ::= <character set name>

<standard universal character form-of-use name> ::= <character set name>

<implementation-defined universal character form-of-use name> ::= <character set name>

<date string> ::= <quote> <date value> <quote>

<date value> ::= <years value> <minus sign> <months value> <minus sign> <days value>

<years value> ::= <datetime value>

<datetime value> ::= <unsigned integer>

<months value> ::= <datetime value>

<days value> ::= <datetime value>

<time string> ::= <quote> <time value> [ <time zone interval> ] <quote>

<time value> ::= <hours value> <colon> <minutes value> <colon> <seconds value>

<hours value> ::= <datetime value>

<minutes value> ::= <datetime value>

<seconds value> ::= <seconds integer value> [ <period> [ <seconds fraction> ] ]

<seconds integer value> ::= <unsigned integer>

<seconds fraction> ::= <unsigned integer>

<time zone interval> ::= <sign> <hours value> <colon> <minutes value>

<timestamp string> ::= <quote> <date value> <space> <time value> [ <time zone interval> ] <quote>

<interval string> ::= <quote> { <year-month literal> | <day-time literal> } <quote>

<year-month literal> ::=
		<years value>
	|	[ <years value> <minus sign> ] <months value>

<day-time literal> ::= <day-time interval> | <time interval>

<day-time interval> ::=
		<days value> [ <space> <hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ] ]

<time-interval> ::=
		<hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ]
	|	<minutes value> [ <colon> <seconds value> ]
	|	<seconds value>

<not equals operator> ::= <>

<greater than or equals operator> ::= >=

<less than or equals operator> ::= <=

<concatenation operator> ::= ||

<double period> ::= ..

/*
--hr
--h2 SQL Module
--/h2
*/

<module> ::=
		<module name clause> <language clause> <module authorization clause>
		[ <temporary table declaration>... ]
		<module contents>...

<module name clause> ::=
		MODULE [ <module name> ] [ <module character set specification> ]

<module name> ::= <identifier>

<module character set specification> ::= NAMES ARE <character set specification>

<language clause> ::= LANGUAGE <language name>

<language name> ::= ADA | C | COBOL | FORTRAN | MUMPS | PASCAL | PLI

<module authorization clause> ::=
		SCHEMA <schema name>
	|	AUTHORIZATION <module authorization identifier>
	|	SCHEMA <schema name> AUTHORIZATION <module authorization identifier>

<module authorization identifier> ::= <authorization identifier>

<authorization identifier> ::= <identifier>

<temporary table declaration> ::=
	DECLARE LOCAL TEMPORARY TABLE <qualified local table name> <table element list> [ ON COMMIT { PRESERVE | DELETE } ROWS ]

<qualified local table name> ::= MODULE <period> <local table name>

<local table name> ::= <qualified identifier>

<qualified identifier> ::= <identifier>

<table element list> ::= <left paren> <table element> [ { <comma> <table element> }... ] <right paren>

<table element> ::= <column definition> | <table constraint definition>

<column definition> ::=
		<column name> { <data type> | <domain name> } [ <default clause> ] [ <column constraint definition>... ] [ <collate clause> ]

<column name> ::= <identifier>

/*
--hr
--h2 Data Types
--/h2
*/

<data type> ::=
		<character string type> [ CHARACTER SET <character set specification> ]
	|	<national character string type>
	|	<bit string type>
	|	<numeric type>
	|	<datetime type>
	|	<interval type>

<character string type> ::=
		CHARACTER [ <left paren> <length> <right paren> ]
	|	CHAR [ <left paren> <length> <right paren> ]
	|	CHARACTER VARYING [ <left paren> <length> <right paren> ]
	|	CHAR VARYING [ <left paren> <length> <right paren> ]
	|	VARCHAR [ <left paren> <length> <right paren> ]

<length> ::= <unsigned integer>

<national character string type> ::=
		NATIONAL CHARACTER [ <left paren> <length> <right paren> ]
	|	NATIONAL CHAR [ <left paren> <length> <right paren> ]
	|	NCHAR [ <left paren> <length> <right paren> ]
	|	NATIONAL CHARACTER VARYING [ <left paren> <length> <right paren> ]
	|	NATIONAL CHAR VARYING [ <left paren> <length> <right paren> ]
	|	NCHAR VARYING [ <left paren> <length> <right paren> ]

<bit string type> ::=
		BIT [ <left paren> <length> <right paren> ]
	|	BIT VARYING [ <left paren> <length> <right paren> ]

<numeric type> ::=
		<exact numeric type>
	|	<approximate numeric type>

<exact numeric type> ::=
	 	NUMERIC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
	| 	DECIMAL [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
	| 	DEC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
	|	INTEGER
	|	INT
	|	SMALLINT

<precision> ::= <unsigned integer>

<scale> ::= <unsigned integer>

<approximate numeric type> ::=
	 	FLOAT [ <left paren> <precision> <right paren> ]
	|	REAL
	|	DOUBLE PRECISION

<datetime type> ::=
		DATE
	|   TIME [ <left paren> <time precision> <right paren> ] [ WITH TIME ZONE ]
	|   TIMESTAMP [ <left paren> <timestamp precision> <right paren> ] [ WITH TIME ZONE ]

<time precision> ::= <time fractional seconds precision>

<time fractional seconds precision> ::= <unsigned integer>

<timestamp precision> ::= <time fractional seconds precision>

<interval type> ::= INTERVAL <interval qualifier>

<interval qualifier> ::=
		<start field> TO <end field>
	|   <single datetime field>

<start field> ::=
		<non-second datetime field> [ <left paren> <interval leading field precision> <right paren> ]

<non-second datetime field> ::= YEAR | MONTH | DAY | HOUR | MINUTE

<interval leading field precision> ::= <unsigned integer>

<end field> ::=
		<non-second datetime field>
	|   SECOND [ <left paren> <interval fractional seconds precision> <right paren> ]

<interval fractional seconds precision> ::= <unsigned integer>

<single datetime field> ::=
		<non-second datetime field> [ <left paren> <interval leading field precision> <right paren> ]
	|   SECOND [ <left paren> <interval leading field precision> [ <comma> <interval fractional seconds precision> ] <right paren> ]

<domain name> ::= <qualified name>

<qualified name> ::= [ <schema name> <period> ] <qualified identifier>

<default clause> ::= DEFAULT <default option>

<default option> ::=
		<literal>
	|	<datetime value function>
	|	USER
	|	CURRENT_USER
	|	SESSION_USER
	|	SYSTEM_USER
	|	NULL

--hr
--h2 Literals
--/h2

<literal> ::= <signed numeric literal> | <general literal>

<signed numeric literal> ::= [ <sign> ] <unsigned numeric literal>

<general literal> ::=
		<character string literal>
	|	<national character string literal>
	|	<bit string literal>
	|	<hex string literal>
	|	<datetime literal>
	|	<interval literal>

<datetime literal> ::=
		<date literal>
	|	<time literal>
	|	<timestamp literal>

<date literal> ::= DATE <date string>

<time literal> ::= TIME <time string>

<timestamp literal> ::= TIMESTAMP <timestamp string>

<interval literal> ::= INTERVAL [ <sign> ] <interval string> <interval qualifier>

<datetime value function> ::=
		<current date value function>
	|	<current time value function>
	|	<current timestamp value function>

<current date value function> ::= CURRENT_DATE

<current time value function> ::= CURRENT_TIME [ <left paren> <time precision> <right paren> ]

<current timestamp value function> ::= CURRENT_TIMESTAMP [ <left paren> <timestamp precision> <right paren> ]
/*
--hr
--h2 Constraints
--/h2
*/
<column constraint definition> ::=
		[ <constraint name definition> ] <column constraint> [ <constraint attributes> ]

<constraint name definition> ::= CONSTRAINT <constraint name>

<constraint name> ::= <qualified name>

<column constraint> ::=
		NOT NULL
	|	<unique specification>
	|	<references specification>
	|	<check constraint definition>

<unique specification> ::= UNIQUE | PRIMARY KEY

<references specification> ::=
		REFERENCES <referenced table and columns> [ MATCH <match type> ] [ <referential triggered action> ]

<referenced table and columns> ::= <table name> [ <left paren> <reference column list> <right paren> ]

<table name> ::= <qualified name> | <qualified local table name>

<reference column list> ::= <column name list>

<column name list> ::= <column name> [ { <comma> <column name> }... ]

<match type> ::= FULL | PARTIAL

<referential triggered action> ::=
		<update rule> [ <delete rule> ]
	|	<delete rule> [ <update rule> ]

<update rule> ::= ON UPDATE <referential action>

<referential action> ::= CASCADE | SET NULL | SET DEFAULT | NO ACTION

<delete rule> ::= ON DELETE <referential action>

<check constraint definition> ::= CHECK <left paren> <search condition> <right paren>
/*
--hr
--h2 Search Condition
--/h2
*/
<search condition> ::=
		<boolean term>
	|   <search condition> OR <boolean term>

<boolean term> ::=
		<boolean factor>
	|   <boolean term> AND <boolean factor>

<boolean factor> ::= [ NOT ] <boolean test>

<boolean test> ::= <boolean primary> [ IS [ NOT ] <truth value> ]

<boolean primary> ::= <predicate> | <left paren> <search condition> <right paren>

<predicate> ::=
		<comparison predicate>
	|   <between predicate>
	|   <in predicate>
	|   <like predicate>
	|   <null predicate>
	|   <quantified comparison predicate>
	|   <exists predicate>
	|   <match predicate>
	|   <overlaps predicate>

<comparison predicate> ::= <row value constructor> <comp op> <row value constructor>

<row value constructor> ::=
		<row value constructor element>
	|   <left paren> <row value constructor list> <right paren>
	|   <row subquery>

<row value constructor element> ::=
		<value expression>
	|   <null specification>
	|   <default specification>

<value expression> ::=
		<numeric value expression>
	|   <string value expression>
	|   <datetime value expression>
	|   <interval value expression>

<numeric value expression> ::=
		<term>
	|   <numeric value expression> <plus sign> <term>
	|   <numeric value expression> <minus sign> <term>

<term> ::=
		<factor>
	|   <term> <asterisk> <factor>
	|   <term> <solidus> <factor>

<factor> ::= [ <sign> ] <numeric primary>

<numeric primary> ::= <value expression primary> | <numeric value function>

<value expression primary> ::=
		<unsigned value specification>
	|   <column reference>
	|   <set function specification>
	|   <scalar subquery>
	|   <case expression>
	|   <left paren> <value expression> <right paren>
	|   <cast specification>

<unsigned value specification> ::= <unsigned literal> | <general value specification>

<unsigned literal> ::= <unsigned numeric literal> | <general literal>

<general value specification> ::=
		<parameter specification>
	|   <dynamic parameter specification>
	|   <variable specification>
	|   USER
	|   CURRENT_USER
	|   SESSION_USER
	|   SYSTEM_USER
	|   VALUE

<parameter specification> ::= <parameter name> [ <indicator parameter> ]

<parameter name> ::= <colon> <identifier>

<indicator parameter> ::= [ INDICATOR ] <parameter name>

<dynamic parameter specification> ::= <question mark>

<variable specification> ::= <embedded variable name> [ <indicator variable> ]

<embedded variable name> ::= <colon><host identifier>

<host identifier> ::=
		<Ada host identifier>
	|	<C host identifier>
	|	<Cobol host identifier>
	|	<Fortran host identifier>
	|	<MUMPS host identifier>
	|	<Pascal host identifier>
	|	<PL/I host identifier>

<Ada host identifier> ::= !! See syntax rules

<C host identifier> ::= !! See syntax rules

<Cobol host identifier> ::= !! See syntax rules

<Fortran host identifier> ::= !! See syntax rules

<MUMPS host identifier> ::= !! See syntax rules

<Pascal host identifier> ::= !! See syntax rules

<PL/I host identifier> ::= !! See syntax rules

<indicator variable> ::= [ INDICATOR ] <embedded variable name>

<column reference> ::= [ <qualifier> <period> ] <column name>

<qualifier> ::= <table name> | <correlation name>

<correlation name> ::= <identifier>

<set function specification> ::=
		COUNT <left paren> <asterisk> <right paren>
	|   <general set function>

<general set function> ::=
		<set function type> <left paren> [ <set quantifier> ] <value expression> <right paren>

<set function type> ::= AVG | MAX | MIN | SUM | COUNT

<set quantifier> ::= DISTINCT | ALL

/*
--hr
--h2 Queries
--/h2
*/

<scalar subquery> ::= <subquery>

<subquery> ::= <left paren> <query expression> <right paren>

<query expression> ::= <non-join query expression> | <joined table>

<non-join query expression> ::=
		<non-join query term>
	|	<query expression> UNION [ ALL ] [ <corresponding spec> ] <query term>
	|	<query expression> EXCEPT [ ALL ] [ <corresponding spec> ] <query term>

<non-join query term> ::=
		<non-join query primary>
	|	<query term> INTERSECT [ ALL ] [ <corresponding spec> ] <query primary>

<non-join query primary> ::= <simple table> | <left paren> <non-join query expression> <right paren>

<simple table> ::=
		<query specification>
	|	<table value constructor>
	|	<explicit table>

<query specification> ::=
		SELECT [ <set quantifier> ] <select list> <table expression>

<select list> ::=
		<asterisk>
	|	<select sublist> [ { <comma> <select sublist> }... ]

<select sublist> ::= <derived column> | <qualifier> <period> <asterisk>

<derived column> ::= <value expression> [ <as clause> ]

<as clause> ::= [ AS ] <column name>

<table expression> ::=
		<from clause>
		[ <where clause> ]
		[ <group by clause> ]
		[ <having clause> ]

<from clause> ::= FROM <table reference> [ { <comma> <table reference> }... ]

/*
--small
--i
Note that <correlation specification> does not appear in the ISO/IEC grammar.
The notation is written out longhand several times, instead.
--/i
--/small
*/

<table reference> ::=
	    <table name> [ <correlation specification> ]
	|   <derived table> <correlation specification>
	|   <joined table>

<correlation specification> ::=
		[ AS ] <correlation name> [ <left paren> <derived column list> <right paren> ]

<derived column list> ::= <column name list>

<derived table> ::= <table subquery>

<table subquery> ::= <subquery>

<joined table> ::=
		<cross join>
	|   <qualified join>
	|   <left paren> <joined table> <right paren>

<cross join> ::=
		<table reference> CROSS JOIN <table reference>

<qualified join> ::=
		<table reference> [ NATURAL ] [ <join type> ] JOIN <table reference> [ <join specification> ]

<join type> ::=
		INNER
	|   <outer join type> [ OUTER ]
	|   UNION

<outer join type> ::= LEFT | RIGHT | FULL

<join specification> ::= <join condition> | <named columns join>

<join condition> ::= ON <search condition>

<named columns join> ::= USING <left paren> <join column list> <right paren>

<join column list> ::= <column name list>

<where clause> ::= WHERE <search condition>

<group by clause> ::= GROUP BY <grouping column reference list>

<grouping column reference list> ::=
		<grouping column reference> [ { <comma> <grouping column reference> }... ]

<grouping column reference> ::= <column reference> [ <collate clause> ]

<collate clause> ::= COLLATE <collation name>

<collation name> ::= <qualified name>

<having clause> ::= HAVING <search condition>

<table value constructor> ::= VALUES <table value constructor list>

<table value constructor list> ::= <row value constructor> [ { <comma> <row value constructor> }... ]

<explicit table> ::= TABLE <table name>

<query term> ::= <non-join query term> | <joined table>

<corresponding spec> ::= CORRESPONDING [ BY <left paren> <corresponding column list> <right paren> ]

<corresponding column list> ::= <column name list>

<query primary> ::= <non-join query primary> | <joined table>

/*
--hr
--h2 Query expression components
--/h2
*/

<case expression> ::= <case abbreviation> | <case specification>

<case abbreviation> ::=
		NULLIF <left paren> <value expression> <comma> <value expression> <right paren>
	|	COALESCE <left paren> <value expression> { <comma> <value expression> }...  <right paren>

<case specification> ::= <simple case> | <searched case>

<simple case> ::=
		CASE <case operand>
			<simple when clause>...
			[ <else clause> ]
		END

<case operand> ::= <value expression>

<simple when clause> ::= WHEN <when operand> THEN <result>

<when operand> ::= <value expression>

<result> ::= <result expression> | NULL

<result expression> ::= <value expression>

<else clause> ::= ELSE <result>

<searched case> ::=
		CASE
		<searched when clause>...
		[ <else clause> ]
		END

<searched when clause> ::= WHEN <search condition> THEN <result>

<cast specification> ::= CAST <left paren> <cast operand> AS <cast target> <right paren>

<cast operand> ::= <value expression> | NULL

<cast target> ::= <domain name> | <data type>

<numeric value function> ::= <position expression> | <extract expression> |	<length expression>

<position expression> ::=
	POSITION <left paren> <character value expression> IN <character value expression> <right paren>

<character value expression> ::= <concatenation> | <character factor>

<concatenation> ::= <character value expression> <concatenation operator> <character factor>

<character factor> ::= <character primary> [ <collate clause> ]

<character primary> ::= <value expression primary> | <string value function>

<string value function> ::= <character value function> | <bit value function>

<character value function> ::=
		<character substring function>
	|   <fold>
	|   <form-of-use conversion>
	|   <character translation>
	|   <trim function>

<character substring function> ::=
		SUBSTRING <left paren> <character value expression> FROM <start position> [ FOR <string length> ] <right paren>

<start position> ::= <numeric value expression>

<string length> ::= <numeric value expression>

<fold> ::= { UPPER | LOWER } <left paren> <character value expression> <right paren>

<form-of-use conversion> ::=
		CONVERT <left paren> <character value expression> USING <form-of-use conversion name> <right paren>

<form-of-use conversion name> ::= <qualified name>

<character translation> ::=
		TRANSLATE <left paren> <character value expression> USING <translation name> <right paren>

<translation name> ::= <qualified name>

<trim function> ::= TRIM <left paren> <trim operands> <right paren>

<trim operands> ::= [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source>

<trim specification> ::= LEADING | TRAILING | BOTH

<trim character> ::= <character value expression>

<trim source> ::= <character value expression>

<bit value function> ::= <bit substring function>

<bit substring function> ::=
		SUBSTRING <left paren> <bit value expression> FROM <start position> [ FOR <string length> ] <right paren>

<bit value expression> ::= <bit concatenation> | <bit factor>

<bit concatenation> ::= <bit value expression> <concatenation operator> <bit factor>

<bit factor> ::= <bit primary>

<bit primary> ::= <value expression primary> | <string value function>

<extract expression> ::= EXTRACT <left paren> <extract field> FROM <extract source> <right paren>

<extract field> ::= <datetime field> | <time zone field>

<datetime field> ::= <non-second datetime field> | SECOND

<time zone field> ::= TIMEZONE_HOUR | TIMEZONE_MINUTE

<extract source> ::= <datetime value expression> | <interval value expression>

<datetime value expression> ::=
		<datetime term>
	|	<interval value expression> <plus sign> <datetime term>
	|	<datetime value expression> <plus sign> <interval term>
	|	<datetime value expression> <minus sign> <interval term>

<interval term> ::=
		<interval factor>
	|	<interval term 2> <asterisk> <factor>
	|	<interval term 2> <solidus> <factor>
	|	<term> <asterisk> <interval factor>

<interval factor> ::= [ <sign> ] <interval primary>

<interval primary> ::= <value expression primary> [ <interval qualifier> ]

<interval term 2> ::= <interval term>

<interval value expression> ::=
		<interval term>
	|	<interval value expression 1> <plus sign> <interval term 1>
	|	<interval value expression 1> <minus sign> <interval term 1>
	|	<left paren> <datetime value expression> <minus sign> <datetime term> <right paren> <interval qualifier>

<interval value expression 1> ::= <interval value expression>

<interval term 1> ::= <interval term>

<datetime term> ::= <datetime factor>

<datetime factor> ::= <datetime primary> [ <time zone> ]

<datetime primary> ::= <value expression primary> | <datetime value function>

<time zone> ::= AT <time zone specifier>

<time zone specifier> ::= LOCAL | TIME ZONE <interval value expression>

<length expression> ::= <char length expression> | <octet length expression> | <bit length expression>

<char length expression> ::= { CHAR_LENGTH | CHARACTER_LENGTH } <left paren> <string value expression> <right paren>

<string value expression> ::= <character value expression> | <bit value expression>

<octet length expression> ::= OCTET_LENGTH <left paren> <string value expression> <right paren>

<bit length expression> ::= BIT_LENGTH <left paren> <string value expression> <right paren>

<null specification> ::= NULL

<default specification> ::= DEFAULT

<row value constructor list> ::= <row value constructor element> [ { <comma> <row value constructor element> } ... ]

<row subquery> ::= <subquery>

<comp op> ::=
		<equals operator>
	|   <not equals operator>
	|   <less than operator>
	|   <greater than operator>
	|   <less than or equals operator>
	|   <greater than or equals operator>

<between predicate> ::=
		<row value constructor> [ NOT ] BETWEEN <row value constructor> AND <row value constructor>

<in predicate> ::= <row value constructor> [ NOT ] IN <in predicate value>

<in predicate value> ::= <table subquery> | <left paren> <in value list> <right paren>

<in value list> ::= <value expression> { <comma> <value expression> } ...

<like predicate> ::= <match value> [ NOT ] LIKE <pattern> [ ESCAPE <escape character> ]

<match value> ::= <character value expression>

<pattern> ::= <character value expression>

<escape character> ::= <character value expression>

<null predicate> ::= <row value constructor> IS [ NOT ] NULL

<quantified comparison predicate> ::= <row value constructor> <comp op> <quantifier> <table subquery>

<quantifier> ::= <all> | <some>

<all> ::= ALL

<some> ::= SOME | ANY

<exists predicate> ::= EXISTS <table subquery>

<unique predicate> ::= UNIQUE <table subquery>

<match predicate> ::= <row value constructor> MATCH [ UNIQUE ] [ PARTIAL | FULL ] <table subquery>

<overlaps predicate> ::= <row value constructor 1> OVERLAPS <row value constructor 2>

<row value constructor 1> ::= <row value constructor>

<row value constructor 2> ::= <row value constructor>

<truth value> ::= TRUE | FALSE | UNKNOWN

/*
--hr
--h2 More about constraints
--/h2
*/

<constraint attributes> ::=
		<constraint check time> [ [ NOT ] DEFERRABLE ]
	|	[ NOT ] DEFERRABLE [ <constraint check time> ]

<constraint check time> ::= INITIALLY DEFERRED | INITIALLY IMMEDIATE

<table constraint definition> ::= [ <constraint name definition> ] <table constraint> [ <constraint check time> ]

<table constraint> ::=
		<unique constraint definition>
	|	<referential constraint definition>
	|	<check constraint definition>

<unique constraint definition> ::= <unique specification> <left paren> <unique column list> <right paren>

<unique column list> ::= <column name list>

<referential constraint definition> ::=
		FOREIGN KEY <left paren> <referencing columns> <right paren> <references specification>

<referencing columns> ::= <reference column list>

/*
--hr
--h2 Module contents
--/h2
*/

<module contents> ::=
		<declare cursor>
	|	<dynamic declare cursor>
	|	<procedure>

<declare cursor> ::=
		DECLARE <cursor name> [ INSENSITIVE ] [ SCROLL ] CURSOR FOR <cursor specification>

<cursor name> ::= <identifier>

<cursor specification> ::= <query expression> [ <order by clause> ] [ <updatability clause> ]

<order by clause> ::= ORDER BY <sort specification list>

<sort specification list> ::= <sort specification> [ { <comma> <sort specification> }... ]

<sort specification> ::= <sort key> [ <collate clause> ] [ <ordering specification> ]

<sort key> ::= <column name> | <unsigned integer>

<ordering specification> ::= ASC | DESC

<updatability clause> ::= FOR { READ ONLY | UPDATE [ OF <column name list> ] }

<dynamic declare cursor> ::=
		DECLARE <cursor name> [ INSENSITIVE ] [ SCROLL ] CURSOR FOR <statement name>

<statement name> ::= <identifier>

/*
--hr
--h2 SQL Procedures
--/h2
*/

<procedure> ::=
	PROCEDURE <procedure name> <parameter declaration list> <semicolon> <SQL procedure statement> <semicolon>

<procedure name> ::= <identifier>

<parameter declaration list> ::=
		<left paren> <parameter declaration> [ { <comma> <parameter declaration> }... ] <right paren>

<parameter declaration> ::= <parameter name> <data type> | <status parameter>

<status parameter> ::= SQLCODE | SQLSTATE

<SQL procedure statement> ::=
		<SQL schema statement>
	|	<SQL data statement>
	|	<SQL transaction statement>
	|	<SQL connection statement>
	|	<SQL session statement>
	|	<SQL dynamic statement>
	|	<SQL diagnostics statement>

/*
--hr
--h2 SQL Schema Definition Statements
--/h2
*/

<SQL schema statement> ::=
		<SQL schema definition statement>
	|	<SQL schema manipulation statement>

<SQL schema definition statement> ::=
		<schema definition>
	|	<table definition>
	|	<view definition>
	|	<grant statement>
	|	<domain definition>
	|	<character set definition>
	|	<collation definition>
	|	<translation definition>
	|	<assertion definition>

<schema definition> ::=
		CREATE SCHEMA <schema name clause>
			[ <schema character set specification> ]
			[ <schema element>... ]

<schema name clause> ::=
		<schema name>
	|	AUTHORIZATION <schema authorization identifier>
	|	<schema name> AUTHORIZATION <schema authorization identifier>

<schema authorization identifier> ::= <authorization identifier>

<schema character set specification> ::= DEFAULT CHARACTER SET <character set specification>

<schema element> ::=
		<domain definition>
	|	<table definition>
	|	<view definition>
	|	<grant statement>
	|	<assertion definition>
	|	<character set definition>
	|	<collation definition>
	|	<translation definition>

<domain definition> ::=
		CREATE DOMAIN <domain name> [ AS ] <data type>
			[ <default clause> ] [ <domain constraint> ] [ <collate clause> ]

<domain constraint> ::=
		[ <constraint name definition> ] <check constraint definition> [ <constraint attributes> ]

<table definition> ::=
		CREATE [ { GLOBAL | LOCAL } TEMPORARY ] TABLE <table name> <table element list> [ ON COMMIT { DELETE | PRESERVE } ROWS ]

<view definition> ::=
		CREATE VIEW <table name> [ <left paren> <view column list> <right paren> ]
			AS <query expression> [ WITH [ <levels clause> ] CHECK OPTION ]

<view column list> ::= <column name list>

<levels clause> ::= CASCADED | LOCAL

<grant statement> ::=
		GRANT <privileges> ON <object name> TO <grantee> [ { <comma> <grantee> }... ] [ WITH GRANT OPTION ]

<privileges> ::= ALL PRIVILEGES | <action list>

<action list> ::= <action> [ { <comma> <action> }... ]

<action> ::=
		SELECT
	|	DELETE
	|	INSERT [ <left paren> <privilege column list> <right paren> ]
	|	UPDATE [ <left paren> <privilege column list> <right paren> ]
	|	REFERENCES [ <left paren> <privilege column list> <right paren> ]
	|	USAGE

<privilege column list> ::= <column name list>

<object name> ::=
		[ TABLE ] <table name>
	|	DOMAIN <domain name>
	|	COLLATION <collation name>
	|	CHARACTER SET <character set name>
	|	TRANSLATION <translation name>

<grantee> ::= PUBLIC | <authorization identifier>

<assertion definition> ::=
		CREATE ASSERTION <constraint name> <assertion check> [ <constraint attributes> ]

<assertion check> ::= CHECK <left paren> <search condition> <right paren>

<character set definition> ::=
		CREATE CHARACTER SET <character set name> [ AS ] <character set source>
		[ <collate clause> | <limited collation definition> ]

<character set source> ::= GET <existing character set name>

<existing character set name> ::=
		<standard character repertoire name>
	|	<implementation-defined character repertoire name>
	|	<schema character set name>

<schema character set name> ::= <character set name>

<limited collation definition> ::=
		COLLATION FROM <collation source>

<collation source> ::= <collating sequence definition> | <translation collation>

<collating sequence definition> ::=
		<external collation>
	|	<schema collation name>
	|	DESC <left paren> <collation name> <right paren>
	|	DEFAULT

<external collation> ::=
	EXTERNAL <left paren> <quote> <external collation name> <quote> <right paren>

<external collation name> ::= <standard collation name> | <implementation-defined collation name>

<standard collation name> ::= <collation name>

<implementation-defined collation name> ::= <collation name>

<schema collation name> ::= <collation name>

<translation collation> ::= TRANSLATION <translation name> [ THEN COLLATION <collation name> ]

<collation definition> ::=
		CREATE COLLATION <collation name> FOR <character set specification>
			FROM <collation source> [ <pad attribute> ]

<pad attribute> ::= NO PAD | PAD SPACE

<translation definition> ::=
		CREATE TRANSLATION <translation name>
			FOR <source character set specification>
			TO <target character set specification>
			FROM <translation source>

<source character set specification> ::= <character set specification>

<target character set specification> ::= <character set specification>

<translation source> ::= <translation specification>

<translation specification> ::=
		<external translation>
	|	IDENTITY
	|	<schema translation name>

<external translation> ::=
		EXTERNAL <left paren> <quote> <external translation name> <quote> <right paren>

<external translation name> ::=
		<standard translation name>
	|	<implementation-defined translation name>

<standard translation name> ::= <translation name>

<implementation-defined translation name> ::= <translation name>

<schema translation name> ::= <translation name>

<SQL schema manipulation statement> ::=
		<drop schema statement>
	|	<alter table statement>
	|	<drop table statement>
	|	<drop view statement>
	|	<revoke statement>
	|	<alter domain statement>
	|	<drop domain statement>
	|	<drop character set statement>
	|	<drop collation statement>
	|	<drop translation statement>
	|	<drop assertion statement>

<drop schema statement> ::= DROP SCHEMA <schema name> <drop behaviour>

<drop behaviour> ::= CASCADE | RESTRICT

<alter table statement> ::= ALTER TABLE <table name> <alter table action>

<alter table action> ::=
		<add column definition>
	|	<alter column definition>
	|	<drop column definition>
	|	<add table constraint definition>
	|	<drop table constraint definition>

<add column definition> ::= ADD [ COLUMN ] <column definition>

<alter column definition> ::= ALTER [ COLUMN ] <column name> <alter column action>

<alter column action> ::= <set column default clause> | <drop column default clause>

<set column default clause> ::= SET <default clause>

<drop column default clause> ::= DROP DEFAULT

<drop column definition> ::= DROP [ COLUMN ] <column name> <drop behaviour>

<add table constraint definition> ::= ADD <table constraint definition>

<drop table constraint definition> ::= DROP CONSTRAINT <constraint name> <drop behaviour>

<drop table statement> ::= DROP TABLE <table name> <drop behaviour>

<drop view statement> ::= DROP VIEW <table name> <drop behaviour>

<revoke statement> ::=
		REVOKE [ GRANT OPTION FOR ] <privileges> ON <object name>
			FROM <grantee> [ { <comma> <grantee> }... ] <drop behaviour>

<alter domain statement> ::= ALTER DOMAIN <domain name> <alter domain action>

<alter domain action> ::=
		<set domain default clause>
	|	<drop domain default clause>
	|	<add domain constraint definition>
	|	<drop domain constraint definition>

<set domain default clause> ::= SET <default clause>

<drop domain default clause> ::= DROP DEFAULT

<add domain constraint definition> ::= ADD <domain constraint>

<drop domain constraint definition> ::= DROP CONSTRAINT <constraint name>

<drop domain statement> ::= DROP DOMAIN <domain name> <drop behaviour>

<drop character set statement> ::= DROP CHARACTER SET <character set name>

<drop collation statement> ::= DROP COLLATION <collation name>

<drop translation statement> ::= DROP TRANSLATION <translation name>

<drop assertion statement> ::= DROP ASSERTION <constraint name>

/*
--hr
--h2 SQL Data Manipulation Statements
--/h2
*/

<SQL data statement> ::=
		<open statement>
	|	<fetch statement>
	|	<close statement>
	|	<select statement: single row>
	|	<SQL data change statement>

<open statement> ::= OPEN <cursor name>

<fetch statement> ::=
		FETCH [ [ <fetch orientation> ] FROM ] <cursor name> INTO <fetch target list>

<fetch orientation> ::=
		NEXT
	|	PRIOR
	|	FIRST
	|	LAST
	|	{ ABSOLUTE | RELATIVE } <simple value specification>

<simple value specification> ::= <parameter name> | <embedded variable name> | <literal>

<fetch target list> ::= <target specification> [ { <comma> <target specification> }... ]

<target specification> ::=
		<parameter specification>
	|	<variable specification>

<close statement> ::= CLOSE <cursor name>

<select statement: single row> ::=
	SELECT [ <set quantifier> ] <select list> INTO <select target list> <table expression>

<select target list> ::= <target specification> [ { <comma> <target specification> }... ]

<SQL data change statement> ::=
		<delete statement: positioned>
	|	<delete statement: searched>
	|	<insert statement>
	|	<update statement: positioned>
	|	<update statement: searched>

<delete statement: positioned> ::= DELETE FROM <table name> WHERE CURRENT OF <cursor name>

<delete statement: searched> ::= DELETE FROM <table name> [ WHERE <search condition> ]

<insert statement> ::= INSERT INTO <table name> <insert columns and source>

<insert columns and source> ::=
		[ <left paren> <insert column list> <right paren> ] <query expression>
	|	DEFAULT VALUES

<insert column list> ::= <column name list>

<update statement: positioned> ::=
		UPDATE <table name> SET <set clause list> WHERE CURRENT OF <cursor name>

<set clause list> ::= <set clause> [ { <comma> <set clause> } ... ]

<set clause> ::= <object column> <equals operator> <update source>

<object column> ::= <column name>

<update source> ::= <value expression> | <null specification> | DEFAULT

<update statement: searched> ::=
		UPDATE <table name> SET <set clause list> [ WHERE <search condition> ]

<SQL transaction statement> ::=
		<set transaction statement>
	|	<set constraints mode statement>
	|	<commit statement>
	|	<rollback statement>

<set transaction statement> ::=
		SET TRANSACTION <transaction mode> [ { <comma> <transaction mode> }... ]

<transaction mode> ::=
		<isolation level>
	|	<transaction access mode>
	|	<diagnostics size>

<isolation level> ::= ISOLATION LEVEL <level of isolation>

<level of isolation> ::=
		READ UNCOMMITTED
	|	READ COMMITTED
	|	REPEATABLE READ
	|	SERIALIZABLE

<transaction access mode> ::= READ ONLY | READ WRITE

<diagnostics size> ::= DIAGNOSTICS SIZE <number of conditions>

<number of conditions> ::= <simple value specification>

<set constraints mode statement> ::=
		SET CONSTRAINTS <constraint name list> { DEFERRED | IMMEDIATE }

<constraint name list> ::= ALL | <constraint name> [ { <comma> <constraint name> }... ]

<commit statement> ::= COMMIT [ WORK ]

<rollback statement> ::= ROLLBACK [ WORK ]

/*
--hr
--h2 Connection Management
--/h2
*/

<SQL connection statement> ::=
		<connect statement>
	|	<set connection statement>
	|	<disconnect statement>

<connect statement> ::= CONNECT TO <connection target>

<connection target> ::=
		<SQL-server name> [ AS <connection name> ] [ USER <user name> ]
	|	DEFAULT

<SQL-server name> ::= <simple value specification>

<connection name> ::= <simple value specification>

<user name> ::= <simple value specification>

<set connection statement> ::= SET CONNECTION <connection object>

<connection object> ::= DEFAULT | <connection name>

<disconnect statement> ::= DISCONNECT <disconnect object>

<disconnect object> ::= <connection object> | ALL | CURRENT

--hr
--h2 Session Attributes
--/h2

<SQL session statement> ::=
		<set catalog statement>
	|	<set schema statement>
	|	<set names statement>
	|	<set session authorization identifier statement>
	|	<set local time zone statement>

<set catalog statement> ::= SET CATALOG <value specification>

<value specification> ::= <literal> | <general value specification>

<set schema statement> ::= SET SCHEMA <value specification>

<set names statement> ::= SET NAMES <value specification>

<set session authorization identifier statement> ::= SET SESSION AUTHORIZATION <value specification>

<set local time zone statement> ::= SET TIME ZONE <set time zone value>

<set time zone value> ::= <interval value expression> | LOCAL

/*
--hr
--h2 Dynamic SQL
--/h2
*/

<SQL dynamic statement> ::=
		<system descriptor statement>
	|	<prepare statement>
	|	<deallocate prepared statement>
	|	<describe statement>
	|	<execute statement>
	|	<execute immediate statement>
	|	<SQL dynamic data statement>

<system descriptor statement> ::=
		<allocate descriptor statement>
	|	<deallocate descriptor statement>
	|	<get descriptor statement>
	|	<set descriptor statement>

<allocate descriptor statement> ::= ALLOCATE DESCRIPTOR <descriptor name> [ WITH MAX <occurrences> ]

<descriptor name> ::= [ <scope option> ] <simple value specification>

<scope option> ::= GLOBAL | LOCAL

<occurrences> ::= <simple value specification>

<deallocate descriptor statement> ::= DEALLOCATE DESCRIPTOR <descriptor name>

<set descriptor statement> ::=
		SET DESCRIPTOR <descriptor name> <set descriptor information>

<set descriptor information> ::=
		<set count>
	|	VALUE <item number> <set item information> [ { <comma> <set item information> }... ]

<set count> ::= COUNT <equals operator> <simple value specification 1>

<simple value specification 1> ::= <simple value specification>

<item number> ::= <simple value specification>

<set item information> ::= <descriptor item name> <equals operator> <simple value specification 2>

<descriptor item name> ::=
		TYPE
	|	LENGTH
	|	OCTET_LENGTH
	|	RETURNED_LENGTH
	|	RETURNED_OCTET_LENGTH
	|	PRECISION
	|	SCALE
	|	DATETIME_INTERVAL_CODE
	|	DATETIME_INTERVAL_PRECISION
	|	NULLABLE
	|	INDICATOR
	|	DATA
	|	NAME
	|	UNNAMED
	|	COLLATION_CATALOG
	|	COLLATION_SCHEMA
	|	COLLATION_NAME
	|	CHARACTER_SET_CATALOG
	|	CHARACTER_SET_SCHEMA
	|	CHARACTER_SET_NAME

<simple value specification 2> ::= <simple value specification>

<get descriptor statement> ::= GET DESCRIPTOR <descriptor name> <get descriptor information>

<get descriptor information> ::=
		<get count>
	|	VALUE <item number> <get item information> [ { <comma> <get item information> }... ]

<get count> ::= <simple target specification 1> <equals operator> COUNT

<simple target specification 1> ::= <simple target specification>

<simple target specification> ::= <parameter name> | <embedded variable name>

<get item information> ::= <simple target specification 2> <equals operator> <descriptor item name>

<simple target specification 2> ::= <simple target specification>

<prepare statement> ::= PREPARE <SQL statement name> FROM <SQL statement variable>

<SQL statement name> ::= <statement name> | <extended statement name>

<extended statement name> ::= [ <scope option> ] <simple value specification>

<SQL statement variable> ::= <simple value specification>

<deallocate prepared statement> ::= DEALLOCATE PREPARE <SQL statement name>

<describe statement> ::= <describe input statement> | <describe output statement>

<describe input statement> ::= DESCRIBE INPUT <SQL statement name> <using descriptor>

<using descriptor> ::= { USING | INTO } SQL DESCRIPTOR <descriptor name>

<describe output statement> ::= DESCRIBE [ OUTPUT ] <SQL statement name> <using descriptor>

<execute statement> ::= EXECUTE <SQL statement name> [ <result using clause> ] [ <parameter using clause> ]

<result using clause> ::= <using clause>

<using clause> ::= <using arguments> | <using descriptor>

<using arguments> ::= { USING | INTO } <argument> [ { <comma> <argument> }... ]

<argument> ::= <target specification>

<parameter using clause> ::= <using clause>

<execute immediate statement> ::= EXECUTE IMMEDIATE <SQL statement variable>

<SQL dynamic data statement> ::=
		<allocate cursor statement>
	|	<dynamic open statement>
	|	<dynamic close statement>
	|	<dynamic fetch statement>
	|	<dynamic delete statement: positioned>
	|	<dynamic update statement: positioned>

<allocate cursor statement> ::=
		ALLOCATE <extended cursor name> [ INSENSITIVE ] [ SCROLL ] CURSOR FOR <extended statement name>

<extended cursor name> ::= [ <scope option> ] <simple value specification>

<dynamic open statement> ::= OPEN <dynamic cursor name> [ <using clause> ]

<dynamic cursor name> ::= <cursor name> | <extended cursor name>

<dynamic close statement> ::= CLOSE <dynamic cursor name>

<dynamic fetch statement> ::=
		FETCH [ [ <fetch orientation> ] FROM ] <dynamic cursor name>

<dynamic delete statement: positioned> ::=
		DELETE FROM <table name> WHERE CURRENT OF <dynamic cursor name>

<dynamic update statement: positioned> ::=
		UPDATE <table name>
			SET <set clause> [ { <comma> <set clause> }... ]
			WHERE CURRENT OF <dynamic cursor name>

<SQL diagnostics statement> ::= <get diagnostics statement>

<get diagnostics statement> ::= GET DIAGNOSTICS <sql diagnostics information>

<sql diagnostics information> ::= <statement information> | <condition information>

<statement information> ::=
		<statement information item> [ { <comma> <statement information item> }... ]

<statement information item> ::=
		<simple target specification> <equals operator> <statement information item name>

<statement information item name> ::= NUMBER | MORE | COMMAND_FUNCTION | DYNAMIC_FUNCTION | ROW_COUNT

<condition information> ::=
		EXCEPTION <condition number> <condition information item> [ { <comma> <condition information item> }... ]

<condition number> ::= <simple value specification>

<condition information item> ::=
		<simple target specification> <equals operator> <condition information item name>

<condition information item name> ::=
		CONDITION_NUMBER
	|	RETURNED_SQLSTATE
	|	CLASS_ORIGIN
	|	SUBCLASS_ORIGIN
	|	SERVER_NAME
	|	CONNECTION_NAME
	|	CONSTRAINT_CATALOG
	|	CONSTRAINT_SCHEMA
	|	CONSTRAINT_NAME
	|	CATALOG_NAME
	|	SCHEMA_NAME
	|	TABLE_NAME
	|	COLUMN_NAME
	|	CURSOR_NAME
	|	MESSAGE_TEXT
	|	MESSAGE_LENGTH
	|	MESSAGE_OCTET_LENGTH

<embedded SQL host program> ::=
		<embedded SQL Ada program>
	|	<embedded SQL C program>
	|	<embedded SQL Cobol program>
	|	<embedded SQL Fortran program>
	|	<embedded SQL MUMPS program>
	|	<embedded SQL Pascal program>
	|	<embedded SQL PL/I program>

<embedded SQL Ada program> ::= !! See the syntax rules

<embedded SQL C program> ::= !! See the syntax rules

<embedded SQL Cobol program> ::= !! See the syntax rules

<embedded SQL Fortran program> ::= !! See the syntax rules

<embedded SQL MUMPS program> ::= !! See the syntax rules

<embedded SQL Pascal program> ::= !! See the syntax rules

<embedded SQL PL/I program> ::= !! See the syntax rules

<embedded SQL declare section> ::=
		<embedded SQL begin declare>
			[ <embedded character set declaration> ]
			[ <host variable definition> ... ]
			<embedded SQL end declare>
	|	<embedded SQL MUMPS declare>

<embedded SQL begin declare> ::= <SQL prefix> BEGIN DECLARE SECTION [ <SQL terminator> ]

<SQL prefix> ::= EXEC SQL | <ampersand>SQL<left paren>

<SQL terminator> ::= END-EXEC | <semicolon> | <right paren>

<embedded character set declaration> ::= SQL NAMES ARE <character set specification>

<host variable definition> ::=
		<Ada variable definition>
	|	<C variable definition>
	|	<Cobol variable definition>
	|	<Fortran variable definition>
	|	<MUMPS variable definition>
	|	<Pascal variable definition>
	|	<PL/I variable definition>

/*
--small
--i
Note that <colon> is written as a literal colon in the ANSI grammar.
--/i
--/small
*/

<Ada variable definition> ::=
		<Ada host identifier> [ { <comma> <Ada host identifier> }... ] <colon>
		<Ada type specification> [ <Ada initial value> ]

<Ada type specification> ::= <Ada qualified type specification> | <Ada unqualified type specification>

<Ada qualified type specification> ::=
		SQL_STANDARD.CHAR [ CHARACTER SET [ IS ] <character set specification> ] <left paren> 1 <double period> <length> <right paren>
	|	SQL_STANDARD.BIT <left paren> 1 <double period> <length> <right paren>
	|	SQL_STANDARD.SMALLINT
	|	SQL_STANDARD.INT
	|	SQL_STANDARD.REAL
	|	SQL_STANDARD.DOUBLE_PRECISION
	|	SQL_STANDARD.SQLCODE_TYPE
	|	SQL_STANDARD.SQLSTATE_TYPE
	|	SQL_STANDARD.INDICATOR_TYPE

<Ada unqualified type specification> ::=
		CHAR <left paren> 1 <double period> <length> <right paren>
	|	BIT <left paren> 1 <double period> <length> <right paren>
	|	SMALLINT
	|	INT
	|	REAL
	|	DOUBLE_PRECISION
	|	SQLCODE_TYPE
	|	SQLSTATE_TYPE
	|	INDICATOR_TYPE

<Ada initial value> ::= <Ada assignment operator> <character representation>

<Ada assignment operator> ::= <colon><equals operator>

<C variable definition> ::= [ <C storage class> ] [ <C class modifier> ] <C variable specification> <semicolon>

<C storage class> ::= auto | extern | static

<C class modifier> ::= const | volatile

<C variable specification> ::=
		<C numeric variable>
	|	<C character variable>
	|	<C derived variable>

<C numeric variable> ::=
		{ long | short | float | double }
			<C host identifier> [ <C initial value> ]
			[ { <comma> <C host identifier> [ <C initial value> ] }... ]

<C initial value> ::= <equals operator> <character representation>

<C character variable> ::=
		char [ CHARACTER SET [ IS ] <character set specification> ]
			<C host identifier> <C array specification> [ <C initial value> ]
			[ { <comma> <C host identifier> <C array specification> [ <C initial value> ] }... ]

<C array specification> ::= <left bracket> <length> <right bracket>

<C derived variable> ::= <C VARCHAR variable> | <C bit variable>

<C VARCHAR variable> ::=
		VARCHAR [ CHARACTER SET [ IS ] <character set specification> ]
			<C host identifier> <C array specification> [ <C initial value> ]
			[ { <comma> <C host identifier> <C array specification> [ <C initial value> ] }... ]

<C bit variable> ::=
		BIT <C host identifier> <C array specification> [ <C initial value> ]
			[ { <comma> <C host identifier> <C array specification> [ <C initial value> ] }... ]

<Cobol variable definition> ::=
	...omitted...

<Fortran variable definition> ::=
	...omitted...

<MUMPS variable definition> ::=
	...omitted...

<Pascal variable definition> ::=
	...omitted...

<PL/I variable definition> ::=
	...omitted...

<embedded SQL end declare> ::= <SQL prefix> END DECLARE SECTION [ <SQL terminator> ]

<embedded SQL MUMPS declare> ::=
	<SQL prefix>
	BEGIN DECLARE SECTION
		[ <embedded character set declaration> ]
		[ <host variable definition>... ]
	END DECLARE SECTION
	<SQL terminator>

<embedded SQL statement> ::= <SQL prefix> <statement or declaration> [ <SQL terminator> ]

<statement or declaration> ::=
		<declare cursor>
	|	<dynamic declare cursor>
	|	<temporary table declaration>
	|	<embedded exception declaration>
	|	<SQL procedure statement>

<embedded exception declaration> ::= WHENEVER <condition> <condition action>

<condition> ::= SQLERROR | NOT FOUND

<condition action> ::= CONTINUE | <go to>

<go to> ::= { GOTO | GO TO } <goto target>

<goto target> ::=
		<host label identifier>
	|	<unsigned integer>
	|	<host PL/I label variable>

<host label identifier> ::= !! See the syntax rules

<host PL/I label variable> ::= !! See the syntax rules

<preparable statement> ::=
		<preparable SQL data statement>
	|	<preparable SQL schema statement>
	|	<preparable SQL transaction statement>
	|	<preparable SQL session statement>
	|	<preparable SQL implementation-defined statement>

<preparable SQL data statement> ::=
		<delete statement: searched>
	|	<dynamic single row select statement>
	|	<insert statement>
	|	<dynamic select statement>
	|	<update statement: searched>
	|	<preparable dynamic delete statement: positioned>
	|	<preparable dynamic update statement: positioned>

<dynamic single row select statement> ::= <query specification>

<dynamic select statement> ::= <cursor specification>

<preparable dynamic delete statement: positioned> ::=
		DELETE [ FROM <table name> ] WHERE CURRENT OF <cursor name>

<preparable dynamic update statement: positioned> ::=
		UPDATE [ <table name> ] SET <set clause> WHERE CURRENT OF <cursor name>

<preparable SQL schema statement> ::= <SQL schema statement>

<preparable SQL transaction statement> ::= <SQL transaction statement>

<preparable SQL session statement> ::= <SQL session statement>

<preparable SQL implementation-defined statement> ::= !! See the syntax rules

<direct SQL statement> ::=
		<direct SQL data statement>
	|	<SQL schema statement>
	|	<SQL transaction statement>
	|	<SQL connection statement>
	|	<SQL session statement>
	|	<direct implementation-defined statement>

<direct SQL data statement> ::=
		<delete statement: searched>
	|	<direct select statement: multiple rows>
	|	<insert statement>
	|	<update statement: searched>
	|	<temporary table declaration>

<direct select statement: multiple rows> ::= <query expression> [ <order by clause> ]

<direct implementation-defined statement> ::= !! See the syntax rules

/*
--hr
--h2 Identifying the version of SQL in use
--/h2
*/

<SQL object identifier> ::= <SQL provenance> <SQL variant>

<SQL provenance> ::= <arc1> <arc2> <arc3>

<arc1> ::= iso | 1 | iso <left paren> 1 <right paren>

<arc2> ::= standard | 0 | standard <left paren> 0 <right paren>

<arc3> ::= 9075

<SQL variant> ::= <SQL edition> <SQL conformance>

<SQL edition> ::= <1987> | <1989> | <1992>

<1987> ::= 0 | edition1987 <left paren> 0 <right paren>

<1989> ::= <1989 base> <1989 package>

<1989 base> ::= 1 | edition1989 <left paren> 1 <right paren>

<1989 package> ::= <integrity no> | <integrity yes>

<integrity no> ::= 0 | IntegrityNo <left paren> 0 <right paren>

<integrity yes> ::= 1 | IntegrityYes <left paren> 1 <right paren>

<1992> ::= 2 | edition1992 <left paren> 2 <right paren>

<SQL conformance> ::= <low> | <intermediate> | <high>

<low> ::= 0 | Low <left paren> 0 <right paren>

<intermediate> ::= 1 | Intermediate <left paren> 1 <right paren>

<high> ::= 2 | High <left paren> 2 <right paren>
/*
--hr
--h2 END OF SQL-92 GRAMMAR
--/h2
*/
]]]]><![CDATA[></data></bnf>
]]></Data>
</XData>
</Class>


<Class name="PXW.DEV.BNF.Element">
<Super>PXW.DEV.Element</Super>
<TimeChanged>67125,77562.321854836</TimeChanged>
<TimeCreated>67125,77562.321854836</TimeCreated>

<Property name="CodeClass">
<Type>%String</Type>
</Property>

<Property name="Analyser">
<Type>%RegisteredObject</Type>
</Property>

<Property name="DirectParts">
<Type>%ListOfObjects</Type>
</Property>
</Class>


<Class name="PXW.DEV.BNF.Elements.COS">
<Super>PXW.DEV.BNF.Element</Super>
<TimeChanged>67125,77562.633171634</TimeChanged>
<TimeCreated>67125,77562.633171634</TimeCreated>
</Class>


<Class name="PXW.DEV.BNF.Elements.ClassDefinition">
<Super>PXW.DEV.BNF.Element</Super>
<TimeChanged>67125,77562.630047443</TimeChanged>
<TimeCreated>67125,77562.630047443</TimeCreated>
</Class>


<Class name="PXW.DEV.BNF.Elements.Python">
<Super>PXW.DEV.BNF.Element</Super>
<TimeChanged>67125,77562.661557531</TimeChanged>
<TimeCreated>67125,77562.661557531</TimeCreated>
</Class>


<Class name="PXW.DEV.BNF.Elements.SQL">
<Super>PXW.DEV.BNF.Element</Super>
<TimeChanged>67125,77562.664886965</TimeChanged>
<TimeCreated>67125,77562.664886965</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
/*
property AliasName as list of PXW.DEV.BNF.Elements.SQL;
property AsClause as list of PXW.DEV.BNF.Elements.SQL;
property TableAsClause as list of PXW.DEV.BNF.Elements.SQL;
property DerivedColumn as list of PXW.DEV.BNF.Elements.SQL;
property SelectList as list of PXW.DEV.BNF.Elements.SQL;
property SelectSublist as list of PXW.DEV.BNF.Elements.SQL;
property ColumnName as list of PXW.DEV.BNF.Elements.SQL;
*/
]]></Content>
</UDLText>
</Class>


<Class name="PXW.DEV.BNF.Format.SQL">
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77562.67267283</TimeChanged>
<TimeCreated>67125,77562.67267283</TimeCreated>

<Property name="indent">
<Type>%Integer</Type>
<InitialExpression>2</InitialExpression>
</Property>

<Method name="writetest">
<Description>
d ##class(PXW.DEV.BNF.Format.SQL).writetest(a)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    Set formatter=##class(PXW.DEV.BNF.Format.SQL).%New()
    Do formatter.formatElement(element)
    Set str=element.ToString()
    Write !,"---------",!,str,!,"--------------"
]]></Implementation>
</Method>

<Method name="formatElement">
<Description>
This only expects SQL things into it, passing in other language elements may produce some strange results</Description>
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    #dim a as PXW.DEV.Atom

    Do ..resetAll(element)
    Do ..setAll(element)
]]></Implementation>
</Method>

<Method name="resetAll">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
	For  {
		Set a=element.partsGetNext(.akey)
		Quit:akey=""
		
	    If a.%IsA("PXW.DEV.Element") {
			Do ..resetAll(a)
		} ElseIf a.%IsA("PXW.DEV.Atom") {
            Set type=$$$UPPER($PIECE(a.type,":",1))
            ; this is the word "method" or "property" etc
            If type="KEYWORD" {
            }
            Do ..resetWhitespace(a)     
		}
	}
]]></Implementation>
</Method>

<Method name="resetWhitespace">
<Description>
If there is NO whitespace leave alone, otherwise make it a single space.
Whitespace on Comments is untouched.</Description>
<FormalSpec>Atom:PXW.DEV.Atom</FormalSpec>
<Implementation><![CDATA[
    If $ISOBJECT(Atom.whitespace) {
        If Atom.whitespace.value'="" Set Atom.whitespace.value=" "
        Do ..resetWhitespace(Atom.whitespace)
    }
]]></Implementation>
</Method>

<Method name="setAll">
<FormalSpec>element:PXW.DEV.Element,indent:%Integer=0</FormalSpec>
<Implementation><![CDATA[
    If element.type="SelectCommand" {
        Do ..setWhitespaceNewLineElement(element,indent)
        ; need to do the froms and joins to the same indent?
        Set indent=indent+1 
    }

    If element.type="FromClause" {
        Do ..setWhitespaceNewLineElement(element,indent)
    }

    If element.type="Join" {
        Do ..setWhitespaceNewLineElement(element,indent)
        Set indent=indent+1
    }
    If element.type="JoinOn" {
        Do ..setWhitespaceNewLineElement(element,indent)
    }

    If element.type="WhereClause" {
        Do ..setWhitespaceNewLineElement(element,indent)
    }

    If element.type="SelectSublist" {
        Do ..setWhitespaceNewLineElement(element,indent)
    }

   	For  {
		Set a=element.partsGetNext(.akey)
		Quit:akey=""
		
	    If a.%IsA("PXW.DEV.Element") {
			Do ..setAll(a,indent)
		} 
	}

    ;i element.type="SelectCommand" {
     ;   s ..indent=..indent-1 
    ;}
]]></Implementation>
</Method>

<Method name="setWhitespaceNewLineElement">
<FormalSpec>Element:PXW.DEV.Element,indent:%Integer</FormalSpec>
<Implementation><![CDATA[
    Set a=Element.FirstAtom()
    Do ..setWhitespaceNewLine(a,indent)
]]></Implementation>
</Method>

<Method name="setWhitespaceNewLine">
<FormalSpec>Atom:PXW.DEV.Atom,indent:%Integer</FormalSpec>
<Implementation><![CDATA[
    ;w !,"moving "_Atom.value_" onto new line with "_..indent_" tabs"
    Set cr=$CHAR(13,10)
    Set tabs=$CHAR(9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9)
    ;s tabs="..................."
    Set Atom.whitespace=##class(PXW.DEV.Atom).%New()
    Set Atom.whitespace.value=cr_$EXTRACT(tabs,1,indent)
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.GEN.BNF1">
<Description>
Created: 2024-10-17 15:58:36 PXW.DEV.BNF.Compilers.Compiler1</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>PXW.DEV.BNF.super</Super>
<TimeChanged>67130,57516.622241538</TimeChanged>
<TimeCreated>67129,61169.937056382</TimeCreated>

<Method name="Call">
<Description>
 call ::= IDENTIFIER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Definition">
<Description>
 definition ::= IDENTIFIER EQUALS rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		if ..Equals(subElement,.addedElement)  {
			if ..Rules(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Equals">
<Description>
 EQUALS ::= 'NEEDS EQUALS'
summary values:NEEDS EQUALS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS EQUALS",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS EQUALS")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="File">
<Description>
 file ::= definition*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..File1RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="File1RepZero">
<Description>
 definition*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Definition(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<Description>
 IDENTIFIER ::= 'NEEDS IDENTIFIER'
summary values:NEEDS IDENTIFIER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS IDENTIFIER",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS IDENTIFIER")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Keyword">
<Description>
 KEYWORD ::= 'NEEDS STRING'
summary values:NEEDS STRING</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS STRING",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS STRING")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LookAhead">
<Description><![CDATA[
 look_ahead ::= '&' look_ahead_rule
summary values:&]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("&",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"&")  {
		if ..LookAheadRule(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LookAheadRule">
<Description>
 look_ahead_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NotRule">
<Description>
 not_rule ::= '!' notable_rule
summary values:!</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("!",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"!")  {
		if ..NotableRule(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NotableRule">
<Description>
 notable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OptionalGroup">
<Description>
 optional_group ::= '[' rules ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..Rules(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"]")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OptionalSingle">
<Description>
 optional_single ::= optionalable_rule '?'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OptionalableRule(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"?")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OptionalableRule">
<Description>
 optionalable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Or">
<Description>
 or ::= '|'
summary values:|</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("|",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"|")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Repeat">
<Description>
 repeat ::= repeat_zero | repeat_one</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatZero(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RepeatOne(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatOne">
<Description>
 repeat_one ::= repeatable_rule '+'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatableRule(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatSep">
<Description>
 repeat_sep ::= repeat_sep_separator '.' repeat_sep_rule '+'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatSepSeparator(subElement,.addedElement)  {
		if ..addPunctuation(subElement,".")  {
			if ..RepeatSepRule(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"+")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatSepRule">
<Description>
 repeat_sep_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatSepSeparator">
<Description>
 repeat_sep_separator ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatZero">
<Description>
 repeat_zero ::= repeatable_rule '*'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatableRule(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"*")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatableRule">
<Description>
 repeatable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rule">
<Description>
 rule ::= repeat_sep | repeat_zero | repeat_one | optional_single | KEYWORD | or | subrule | optional_group | call | look_ahead | not_rule</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatSep(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RepeatZero(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RepeatOne(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OptionalSingle(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OptionalGroup(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..LookAhead(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NotRule(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rules">
<Description>
 rules ::= rule*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Rules2RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rules2RepZero">
<Description>
 rule*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Rule(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Subrule">
<Description>
 subrule ::= '(' rules ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..Rules(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Element</ReturnType>
<Implementation><![CDATA[	quit ##class(PXW.DEV.BNF.Element).%New(Type)
]]></Implementation>
</Method>

<Parameter name="KeywordPattern">
<Default>1.A</Default>
</Parameter>

<Parameter name="Keywords"/>
</Class>


<Class name="PXW.DEV.BNF.GEN.BNF2">
<Description>
Created: 2024-10-17 15:58:36 PXW.DEV.BNF.Compilers.Compiler1</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>PXW.DEV.BNF.super</Super>
<TimeChanged>67130,57516.817286348</TimeChanged>
<TimeCreated>67129,61170.086264946</TimeCreated>

<Method name="Call">
<Description>
 call ::= IDENTIFIER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Definition">
<Description>
 definition ::= IDENTIFIER EQUALS rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		if ..Equals(subElement,.addedElement)  {
			if ..Rules(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Equals">
<Description>
 EQUALS ::= 'NEEDS EQUALS'
summary values:NEEDS EQUALS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS EQUALS",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS EQUALS")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="File">
<Description>
 file ::= definition*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..File1RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="File1RepZero">
<Description>
 definition*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Definition(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Force">
<Description>
 force ::= "~"
summary values:~</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("~",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"~")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<Description>
 IDENTIFIER ::= 'NEEDS IDENTIFIER'
summary values:NEEDS IDENTIFIER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS IDENTIFIER",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS IDENTIFIER")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Keyword">
<Description>
 KEYWORD ::= 'NEEDS STRING'
summary values:NEEDS STRING</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS STRING",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS STRING")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LookAhead">
<Description><![CDATA[
 look_ahead ::= '&' look_ahead_rule
summary values:&]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("&",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"&")  {
		if ..LookAheadRule(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LookAheadRule">
<Description>
 look_ahead_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NotRule">
<Description>
 not_rule ::= '!' notable_rule
summary values:!</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("!",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"!")  {
		if ..NotableRule(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NotableRule">
<Description>
 notable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OptionalGroup">
<Description>
 optional_group ::= '[' rules ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..Rules(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"]")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OptionalSingle">
<Description>
 optional_single ::= optionalable_rule '?'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OptionalableRule(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"?")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OptionalableRule">
<Description>
 optionalable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OrRules">
<Description>
 or_rules ::= '|' rule*
summary values:|</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&(?4?)*
	; first rule summary P
	if '(..isStringSingle("|",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"|")  {
		if ..OrRules4RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OrRules4RepZero">
<Description>
 rule*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Rule(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Repeat">
<Description>
 repeat ::= repeat_zero | repeat_one</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatZero(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RepeatOne(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatOne">
<Description>
 repeat_one ::= repeatable_rule '+'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatableRule(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatSep">
<Description>
 repeat_sep ::= repeat_sep_separator '.' repeat_sep_rule '+'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatSepSeparator(subElement,.addedElement)  {
		if ..addPunctuation(subElement,".")  {
			if ..RepeatSepRule(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"+")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatSepRule">
<Description>
 repeat_sep_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatSepSeparator">
<Description>
 repeat_sep_separator ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatZero">
<Description>
 repeat_zero ::= repeatable_rule '*'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatableRule(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"*")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatableRule">
<Description>
 repeatable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rule">
<Description>
 rule ::= repeat_sep | repeat_zero | repeat_one | optional_single | KEYWORD | subrule | optional_group | call | look_ahead | not_rule | force</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatSep(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RepeatZero(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RepeatOne(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OptionalSingle(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OptionalGroup(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..LookAhead(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NotRule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Force(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rules">
<Description>
 rules ::= rule* or_rules*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Rules2RepZero(subElement,.addedElement)  {
		if ..Rules3RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rules2RepZero">
<Description>
 rule*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Rule(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Rules3RepZero">
<Description>
 or_rules*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..OrRules(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Subrule">
<Description>
 subrule ::= '(' rules ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..Rules(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Element</ReturnType>
<Implementation><![CDATA[	quit ##class(PXW.DEV.BNF.Element).%New(Type)
]]></Implementation>
</Method>

<Parameter name="KeywordPattern">
<Default>1.A</Default>
</Parameter>

<Parameter name="Keywords"/>
</Class>


<Class name="PXW.DEV.BNF.GEN.BNF3">
<Description>
Created: 2024-10-17 15:58:36 PXW.DEV.BNF.Compilers.Compiler1</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>PXW.DEV.BNF.super</Super>
<TimeChanged>67130,57517.022030769</TimeChanged>
<TimeCreated>67125,77562.702518952</TimeCreated>

<Method name="Call">
<Description>
 call ::= IDENTIFIER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Definition">
<Description>
 definition ::= IDENTIFIER EQUALS (SINGLE_CHAR | omitted | rules)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		if ..Equals(subElement,.addedElement)  {
			if ..Definition2Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Definition2Sub">
<Description>
SINGLE_CHAR | omitted | rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleChar(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Omitted(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Rules(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Equals">
<Description>
 EQUALS ::= 'NEEDS EQUALS'
summary values:NEEDS EQUALS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS EQUALS",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS EQUALS")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="File">
<Description>
 file ::= definition*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..File1RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="File1RepZero">
<Description>
 definition*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Definition(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Force">
<Description>
 force ::= "~"
summary values:~</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("~",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"~")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<Description>
 IDENTIFIER ::= 'NEEDS IDENTIFIER'
summary values:NEEDS IDENTIFIER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS IDENTIFIER",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS IDENTIFIER")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Keyword">
<Description>
 KEYWORD ::= 'NEEDS STRING'
summary values:NEEDS STRING</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS STRING",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS STRING")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LookAhead">
<Description><![CDATA[
 look_ahead ::= '&' look_ahead_rule
summary values:&]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("&",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"&")  {
		if ..LookAheadRule(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LookAheadRule">
<Description>
 look_ahead_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NeedsOverride">
<Description>
 NEEDS_OVERRIDE ::= '!!'
summary values:!!</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("!!",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"!!")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NotRule">
<Description>
 not_rule ::= '!' notable_rule
summary values:!</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("!",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"!")  {
		if ..NotableRule(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NotableRule">
<Description>
 notable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Omitted">
<Description>
 omitted ::= "...omitted..."
summary values:...OMITTED...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("...OMITTED...",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"...omitted...")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OptionalGroup">
<Description>
 optional_group ::= '[' rules ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..Rules(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"]")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OptionalSingle">
<Description>
 optional_single ::= optionalable_rule '?'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OptionalableRule(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"?")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OptionalableRule">
<Description>
 optionalable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OrRules">
<Description>
 or_rules ::= '|' rule*
summary values:|</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&(?4?)*
	; first rule summary P
	if '(..isStringSingle("|",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"|")  {
		if ..OrRules5RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OrRules5RepZero">
<Description>
 rule*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Rule(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Repeat">
<Description>
 repeat ::= repeat_zero | repeat_one</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatZero(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RepeatOne(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatOne">
<Description>
 repeat_one ::= repeatable_rule '...'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatableRule(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"...")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatSep">
<Description>
 repeat_sep ::= repeat_sep_separator '.' repeat_sep_rule '+'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatSepSeparator(subElement,.addedElement)  {
		if ..addPunctuation(subElement,".")  {
			if ..RepeatSepRule(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"+")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatSepRule">
<Description>
 repeat_sep_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatSepSeparator">
<Description>
 repeat_sep_separator ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatZero">
<Description>
 repeat_zero ::= repeatable_rule '*'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RepeatableRule(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"*")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RepeatableRule">
<Description>
 repeatable_rule ::= KEYWORD | subrule | call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rule">
<Description>
 rule ::= NEEDS_OVERRIDE | repeat_sep | repeat_zero | repeat_one | optional_single | KEYWORD | subrule | optional_group | call | look_ahead | not_rule | force</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NeedsOverride(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RepeatSep(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RepeatZero(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RepeatOne(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OptionalSingle(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Subrule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OptionalGroup(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Call(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..LookAhead(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NotRule(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Force(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rules">
<Description>
 rules ::= rule* or_rules*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Rules3RepZero(subElement,.addedElement)  {
		if ..Rules4RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rules3RepZero">
<Description>
 rule*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Rule(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Rules4RepZero">
<Description>
 or_rules*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..OrRules(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SingleChar">
<Description>
 SINGLE_CHAR ::= 'NEEDS SINGLE CHAR'
summary values:NEEDS SINGLE CHAR</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS SINGLE CHAR",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS SINGLE CHAR")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Subrule">
<Description>
 subrule ::= '{' rules '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..Rules(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Element</ReturnType>
<Implementation><![CDATA[	quit ##class(PXW.DEV.BNF.Element).%New(Type)
]]></Implementation>
</Method>

<Parameter name="KeywordPattern">
<Default>1.A</Default>
</Parameter>

<Parameter name="Keywords"/>
</Class>


<Class name="PXW.DEV.BNF.GEN.COS">
<Description>
Created: 2024-10-17 15:58:40 PXW.DEV.BNF.Compilers.Compiler1</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>PXW.DEV.BNF.super</Super>
<TimeChanged>67130,57534.139884143</TimeChanged>
<TimeCreated>67125,77562.931356806</TimeCreated>

<Method name="AmpOp">
<Description><![CDATA[
 amp_op ::= '&'
summary values:&]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("&",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"&")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AnyKeyword">
<Description>
 any_keyword ::= 'need any keyword'
summary values:NEED ANY KEYWORD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED ANY KEYWORD",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"need any keyword")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AnyTextUptoCloseBracket">
<Description>
 any_text_upto_close_bracket ::= 'code this'
summary values:CODE THIS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("CODE THIS",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"code this")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ArrayParameterList">
<Description>
 array_parameter_list ::= open_bracket expression ( ',' expression )* close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&(?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OpenBracket(subElement,.addedElement)  {
		if ..Expression(subElement,.addedElement)  {
			if ..ArrayParameterList103RepZero(subElement,.addedElement)  {
				if ..CloseBracket(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ArrayParameterList103RepZero">
<Description>
 ( ',' expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ArrayParameterList104Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ArrayParameterList104Sub">
<Description>
 ',' expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitlogicExpression">
<Description><![CDATA[
 bitlogic_expression ::= (expression ('|' | '&' | '^' |'~')* )*]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BitlogicExpression349RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitlogicExpression349RepZero">
<Description><![CDATA[
 (expression ('|' | '&' | '^' |'~')* )*]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..BitlogicExpression350Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BitlogicExpression350Sub">
<Description><![CDATA[
expression ('|' | '&' | '^' |'~')*]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		if ..BitlogicExpression351RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitlogicExpression351RepZero">
<Description><![CDATA[
 ('|' | '&' | '^' |'~')*]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..BitlogicExpression352Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BitlogicExpression352Sub">
<Description><![CDATA[
'|' | '&' | '^' |'~'
summary values:|,&,^,~]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P
	if '(..isStringInList($lb("|","&","^","~"),1,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"|")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"&")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"^")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"~")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BitlogicFunctionCall">
<Description>
 bitlogic_function_call ::= 'bitlogic' open_bracket bitlogic_expression [ ',' expression ] close_bracket
summary values:BITLOGIC</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("BITLOGIC"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BITLOGIC")  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..BitlogicExpression(subElement,.addedElement)  {
				if ..BitlogicFunctionCall348OptGrp(subElement,.addedElement)  {
					if ..CloseBracket(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitlogicFunctionCall348OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BlockComment">
<Description>
 block_comment ::= '/*' text '*/'
summary values:/*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("/*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"/*")  {
		if ..Text(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"*/")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BreakCommand">
<Description>
 break_command ::= ('break' | 'b') [ post_conditional ] [ naked | ( break_extend | break_flag )]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BreakCommand117Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..BreakCommand118OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BreakCommand117Sub">
<Description>
'break' | 'b'
summary values:BREAK,B</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("BREAK","B"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"BREAK")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"B")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BreakCommand118OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Naked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BreakCommand119Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BreakCommand119Sub">
<Description>
 break_extend | break_flag</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BreakExtend(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BreakFlag(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BreakExtend">
<Description>
 break_extend ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BreakFlag">
<Description>
 break_flag ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseClause">
<Description>
 case_clause ::= case_clause_case ':' case_clause_value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CaseClauseCase(subElement,.addedElement)  {
		if ..addPunctuation(subElement,":")  {
			if ..CaseClauseValue(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseClauseCase">
<Description>
 case_clause_case ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseClauseDefault">
<Description>
 case_clause_default ::= ',' ':' expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..addPunctuation(subElement,":")  {
			if ..Expression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseClauseValue">
<Description>
 case_clause_value ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseClauses">
<Description>
 case_clauses ::= (( ',' case_clause ))*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CaseClauses315RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseClauses315RepZero">
<Description>
 (( ',' case_clause ))*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CaseClauses316Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CaseClauses316Sub">
<Description>
( ',' case_clause )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CaseClauses317Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseClauses317Sub">
<Description>
 ',' case_clause
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..CaseClause(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseFunctionCall">
<Description>
 case_function_call ::= 'case' open_bracket expression [ case_clauses ] [ case_clause_default ] close_bracket
summary values:CASE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?&?4?&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CASE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CASE")  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..Expression(subElement,.addedElement)  {
				if $S(..CaseClauses(subElement,.addedElement) :1,1:1) {
					if $S(..CaseClauseDefault(subElement,.addedElement) :1,1:1) {
						if ..CloseBracket(subElement,.addedElement)  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassCasting">
<Description>
 class_casting ::= ['(' ] ( '##this' | '$this' | variable_identifier ) [')']</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addPunctuation(subElement,"(") :1,1:1) {
		if ..ClassCasting89Sub(subElement,.addedElement)  {
			if $S(..addPunctuation(subElement,")") :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassCasting89Sub">
<Description>
 '##this' | '$this' | variable_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"##this")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"$this")  {
		set done=1 ; or
	} elseif ..VariableIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassExpression">
<Description>
 class_expression ::= '##class' '(' class_reference ')' [ class_casting ] object_chain
summary values:##CLASS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P&?4?&?1Rule?
	; first rule summary P
	if '(..isStringSingle("##CLASS",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"##class")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ClassReference(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					if $S(..ClassCasting(subElement,.addedElement) :1,1:1) {
						if ..ObjectChain(subElement,.addedElement)  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassIdentifier">
<Description>
 class_identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
summary values:REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassReference">
<Description>
 class_reference ::= class_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Classexpr">
<Description>
 classexpr ::= super_expression | class_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SuperExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassmethodFunctionCall">
<Description>
 classmethod_function_call ::= 'classmethod' function_parameter_list [ object_chain ]
summary values:CLASSMETHOD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("CLASSMETHOD"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CLASSMETHOD")  {
		if ..FunctionParameterList(subElement,.addedElement)  {
			if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CloseBracket">
<Description>
 close_bracket ::= ')'
summary values:)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(")",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,")")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CloseCommand">
<Description>
 close_command ::= ('close' | 'c') [ post_conditional ] close_item (',' close_item)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CloseCommand120Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..CloseItem(subElement,.addedElement)  {
				if ..CloseCommand121RepZero(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CloseCommand120Sub">
<Description>
'close' | 'c'
summary values:CLOSE,C</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("CLOSE","C"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"CLOSE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"C")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CloseCommand121RepZero">
<Description>
 (',' close_item)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CloseCommand122Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CloseCommand122Sub">
<Description>
',' close_item
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..CloseItem(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CloseItem">
<Description>
 close_item ::= open_device [ ':' device_parameters ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OpenDevice(subElement,.addedElement)  {
		if ..CloseItem123OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CloseItem123OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..DeviceParameters(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CommandList">
<Description>
 command_list ::= cos_command ( cos_command )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosCommand(subElement,.addedElement)  {
		if ..CommandList43RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CommandList43RepZero">
<Description>
 ( cos_command )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CommandList44Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CommandList44Sub">
<Description>
 cos_command</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosCommand(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CommandListEol">
<Description>
 command_list_eol ::= cos_command ( cos_command )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosCommand(subElement,.addedElement)  {
		if ..CommandListEol45RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CommandListEol45RepZero">
<Description>
 ( cos_command )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CommandListEol46Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CommandListEol46Sub">
<Description>
 cos_command</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosCommand(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Comment">
<Description>
 comment ::= line_comment | block_comment</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LineComment(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BlockComment(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ContinueCommand">
<Description>
 continue_command ::= 'continue' [ post_conditional ]
summary values:CONTINUE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("CONTINUE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CONTINUE")  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlock">
<Description>
 cos_code_block ::= one_cos_statement ( one_cos_statement )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneCosStatement(subElement,.addedElement)  {
		if ..CosCodeBlock1RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlock1RepZero">
<Description>
 ( one_cos_statement )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CosCodeBlock2Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlock2Sub">
<Description>
 one_cos_statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneCosStatement(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockSql">
<Description>
 cos_code_block_sql ::= one_cos_Statement_sql ( one_cos_statement_sql)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneCosStatementSql(subElement,.addedElement)  {
		if ..CosCodeBlockSql3RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockSql3RepZero">
<Description>
 ( one_cos_statement_sql)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CosCodeBlockSql4Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockSql4Sub">
<Description>
 one_cos_statement_sql</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneCosStatementSql(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockSqlStorage">
<Description>
 cos_code_block_sql_storage ::= one_cos_Statement_sql ( one_cos_statement_sql)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneCosStatementSql(subElement,.addedElement)  {
		if ..CosCodeBlockSqlStorage5RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockSqlStorage5RepZero">
<Description>
 ( one_cos_statement_sql)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CosCodeBlockSqlStorage6Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockSqlStorage6Sub">
<Description>
 one_cos_statement_sql</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneCosStatementSql(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockTrigger">
<Description>
 cos_code_block_trigger ::= one_cos_statement ( one_cos_statement )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneCosStatement(subElement,.addedElement)  {
		if ..CosCodeBlockTrigger7RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockTrigger7RepZero">
<Description>
 ( one_cos_statement )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CosCodeBlockTrigger8Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockTrigger8Sub">
<Description>
 one_cos_statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneCosStatement(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCommand">
<Description>
 cos_command ::= set_command | if_command | quit_command | do_command | for_command | kill_command | break_command | continue_command | goto_command | else_command | hang_command | halt_command | job_command | sql_command | js_command | lock_command | merge_command | new_command | open_command | close_command | return_command | read_command | tcommit_command | throw_command | trollback_command | try_command | tstart_command | use_command | view_command | while_command | write_command | xecute_command | macrocall | cos_directive | zallocate_command | zbreak_command | zdeallocate_command | zinsert_command | zkill_command | zload_command | znspace_command | zprint_command | zquit_command | zremove_command | zsave_command | zsync_command | ztrap_command | zwrite_command | zzdump_command | zzwrite_command | html_command | print_command | mpv_command</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IfCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..QuitCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DoCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ForCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..KillCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BreakCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ContinueCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GotoCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ElseCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..HangCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..HaltCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JobCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JsCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..LockCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MergeCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NewCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OpenCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CloseCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ReturnCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ReadCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TcommitCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ThrowCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TrollbackCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TryCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TstartCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..UseCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ViewCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..WhileCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..WriteCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..XecuteCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Macrocall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirective(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZallocateCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZbreakCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZdeallocateCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZinsertCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZkillCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZloadCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZnspaceCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZprintCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZquitCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZremoveCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZsaveCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZsyncCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZtrapCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZwriteCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZzdumpCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZzwriteCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..HtmlCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PrintCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MpvCommand(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirective">
<Description>
 cos_directive ::= '#' ( cos_directive_define | cos_directive_dim | cos_directive_ifdef | cos_directive_ifndef | cos_directive_if | cos_directive_else | cos_directive_elseif | cos_directive_endif | cos_directive_defonearg | cos_directive_include | cos_directive_undef | cos_directive_execute | cos_directive_sqlcompile )
summary values:#</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("#",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"#")  {
		if ..CosDirective25Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirective25Sub">
<Description>
 cos_directive_define | cos_directive_dim | cos_directive_ifdef | cos_directive_ifndef | cos_directive_if | cos_directive_else | cos_directive_elseif | cos_directive_endif | cos_directive_defonearg | cos_directive_include | cos_directive_undef | cos_directive_execute | cos_directive_sqlcompile</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosDirectiveDefine(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveDim(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveIfdef(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveIfndef(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveIf(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveElse(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveElseif(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveEndif(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveDefonearg(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveInclude(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveUndef(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveExecute(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveSqlcompile(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDefine">
<Description>
 cos_directive_define ::= 'define' cos_directive_define_name [ array_parameter_list ] [cos_directive_define_subst]
summary values:DEFINE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("DEFINE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DEFINE")  {
		if ..CosDirectiveDefineName(subElement,.addedElement)  {
			if $S(..ArrayParameterList(subElement,.addedElement) :1,1:1) {
				if $S(..CosDirectiveDefineSubst(subElement,.addedElement) :1,1:1) {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDefineName">
<Description>
 cos_directive_define_name ::= macro_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MacroIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDefineSubst">
<Description>
 cos_directive_define_subst ::= [command_list_eol | expression_list ] text_to_eol_continue</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosDirectiveDefineSubst26OptGrp(subElement,.addedElement)  {
		if ..TextToEolContinue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDefineSubst26OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CommandListEol(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ExpressionList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDefonearg">
<Description>
 cos_directive_defonearg ::= 'def1arg' cos_directive_define_name [ array_parameter_list ] [cos_directive_define_subst]
summary values:DEF1ARG</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("DEF1ARG"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DEF1ARG")  {
		if ..CosDirectiveDefineName(subElement,.addedElement)  {
			if $S(..ArrayParameterList(subElement,.addedElement) :1,1:1) {
				if $S(..CosDirectiveDefineSubst(subElement,.addedElement) :1,1:1) {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDim">
<Description>
 cos_directive_dim ::= 'dim' cos_directive_dim_item (',' cos_directive_dim_item )*
summary values:DIM</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&(?4?)*
	; first rule summary K
	if '(..isKeywordInList($lb("DIM"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DIM")  {
		if ..CosDirectiveDimItem(subElement,.addedElement)  {
			if ..CosDirectiveDim27RepZero(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDim27RepZero">
<Description>
 (',' cos_directive_dim_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CosDirectiveDim28Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDim28Sub">
<Description>
',' cos_directive_dim_item
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..CosDirectiveDimItem(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDimItem">
<Description>
 cos_directive_dim_item ::= variable_set [(',' variable_set )*] [ 'as' [('array' | 'list') 'of'] class_reference ] [ '=' dim_expression ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..VariableSet(subElement,.addedElement)  {
		if $S(..CosDirectiveDimItem29RepZero(subElement,.addedElement) :1,1:1) {
			if ..CosDirectiveDimItem31OptGrp(subElement,.addedElement)  {
				if ..CosDirectiveDimItem34OptGrp(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDimItem29RepZero">
<Description>
(',' variable_set )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CosDirectiveDimItem30Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDimItem30Sub">
<Description>
',' variable_set
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..VariableSet(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDimItem31OptGrp">
<Description>

summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..CosDirectiveDimItem32OptGrp(subElement,.addedElement)  {
			if ..ClassReference(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDimItem32OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosDirectiveDimItem33Sub(subElement,.addedElement)  {
		if ..addKeyword(subElement,"OF")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDimItem33Sub">
<Description>
'array' | 'list'
summary values:ARRAY,LIST</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("ARRAY","LIST"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"ARRAY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LIST")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDimItem34OptGrp">
<Description>

summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("=",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		if ..DimExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveElse">
<Description>
 cos_directive_else ::= 'else'
summary values:ELSE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("ELSE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ELSE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveElseif">
<Description>
 cos_directive_elseif ::= 'elseif' expression
summary values:ELSEIF</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ELSEIF"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ELSEIF")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveEndif">
<Description>
 cos_directive_endif ::= 'endif'
summary values:ENDIF</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("ENDIF"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ENDIF")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveExecute">
<Description>
 cos_directive_execute ::= 'execute' command_list_eol
summary values:EXECUTE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("EXECUTE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"EXECUTE")  {
		if ..CommandListEol(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveIf">
<Description>
 cos_directive_if ::= 'if' expression
summary values:IF</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("IF"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IF")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveIfdef">
<Description>
 cos_directive_ifdef ::= 'ifdef' macro_identifier
summary values:IFDEF</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("IFDEF"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IFDEF")  {
		if ..MacroIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveIfndef">
<Description>
 cos_directive_ifndef ::= 'ifndef' macro_identifier
summary values:IFNDEF</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("IFNDEF"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IFNDEF")  {
		if ..MacroIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveInclude">
<Description>
 cos_directive_include ::= 'include' (cos_directive_include_list | cos_directive_include_name)
summary values:INCLUDE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("INCLUDE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INCLUDE")  {
		if ..CosDirectiveInclude35Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveInclude35Sub">
<Description>
cos_directive_include_list | cos_directive_include_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosDirectiveIncludeList(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveIncludeName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveIncludeList">
<Description>
 cos_directive_include_list ::= '(' cos_directive_include_name ( ',' cos_directive_include_name )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..CosDirectiveIncludeName(subElement,.addedElement)  {
			if ..CosDirectiveIncludeList41RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveIncludeList41RepZero">
<Description>
 ( ',' cos_directive_include_name )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CosDirectiveIncludeList42Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveIncludeList42Sub">
<Description>
 ',' cos_directive_include_name
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..CosDirectiveIncludeName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveIncludeName">
<Description>
 cos_directive_include_name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveSqlcompile">
<Description>
 cos_directive_sqlcompile ::= 'sqlcompile' ( ( 'select' '=' ('display' | 'logical' | 'odbc' | 'runtime' | 'text' | 'FDBMS') ) | ( 'mode' '=' ('deferred') ) )
summary values:SQLCOMPILE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SQLCOMPILE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLCOMPILE")  {
		if ..CosDirectiveSqlcompile36Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveSqlcompile36Sub">
<Description>
 ( 'select' '=' ('display' | 'logical' | 'odbc' | 'runtime' | 'text' | 'FDBMS') ) | ( 'mode' '=' ('deferred') )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosDirectiveSqlcompile37Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosDirectiveSqlcompile39Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveSqlcompile37Sub">
<Description>
 'select' '=' ('display' | 'logical' | 'odbc' | 'runtime' | 'text' | 'FDBMS')
summary values:SELECT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SELECT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SELECT")  {
		if ..addPunctuation(subElement,"=")  {
			if ..CosDirectiveSqlcompile38Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveSqlcompile38Sub">
<Description>
'display' | 'logical' | 'odbc' | 'runtime' | 'text' | 'FDBMS'
summary values:DISPLAY,LOGICAL,ODBC,RUNTIME,TEXT,FDBMS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K|K
	if '(..isKeywordInList($lb("DISPLAY","LOGICAL","ODBC","RUNTIME","TEXT","FDBMS"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"DISPLAY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LOGICAL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ODBC")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"RUNTIME")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TEXT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FDBMS")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveSqlcompile39Sub">
<Description>
 'mode' '=' ('deferred')
summary values:MODE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("MODE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"MODE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..CosDirectiveSqlcompile40Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveSqlcompile40Sub">
<Description>
'deferred'
summary values:DEFERRED</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("DEFERRED"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"DEFERRED")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveUndef">
<Description>
 cos_directive_undef ::= 'undef' macro_identifier
summary values:UNDEF</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("UNDEF"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"UNDEF")  {
		if ..MacroIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosJson">
<Description>
 cos_json ::= cos_json_object | cos_json_array | cos_json_prim</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosJsonObject(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosJsonArray(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosJsonPrim(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosJsonArray">
<Description>
 cos_json_array ::= '[' [ cos_json (',' cos_json)* ] ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..CosJsonArray364OptGrp(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"]")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosJsonArray364OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosJson(subElement,.addedElement)  {
		if ..CosJsonArray365RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosJsonArray365RepZero">
<Description>
 (',' cos_json)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CosJsonArray366Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CosJsonArray366Sub">
<Description>
',' cos_json
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..CosJson(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosJsonObject">
<Description>
 cos_json_object ::= '{' [ cos_json_pair ( ',' cos_json_pair )*] '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..CosJsonObject360OptGrp(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosJsonObject360OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosJsonPair(subElement,.addedElement)  {
		if ..CosJsonObject361RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosJsonObject361RepZero">
<Description>
 ( ',' cos_json_pair )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CosJsonObject362Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CosJsonObject362Sub">
<Description>
 ',' cos_json_pair
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..CosJsonPair(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosJsonPair">
<Description>
 cos_json_pair ::= json_string ':' cos_json</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..JsonString(subElement,.addedElement)  {
		if ..addPunctuation(subElement,":")  {
			if ..CosJson(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosJsonPrim">
<Description>
 cos_json_prim ::= number | json_string | 'true' | 'false' | 'null' | ( '(' expression ')' )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|K|K|K|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JsonString(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TRUE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FALSE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NULL")  {
		set done=1 ; or
	} elseif ..CosJsonPrim363Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosJsonPrim363Sub">
<Description>
 '(' expression ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..Expression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeviceParameterList">
<Description>
 device_parameter_list ::= ( one_device_parameter ( ':' one_device_parameter )* )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DeviceParameterList125Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeviceParameterList125Sub">
<Description>
 one_device_parameter ( ':' one_device_parameter )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneDeviceParameter(subElement,.addedElement)  {
		if ..DeviceParameterList126RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeviceParameterList126RepZero">
<Description>
 ( ':' one_device_parameter )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..DeviceParameterList127Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="DeviceParameterList127Sub">
<Description>
 ':' one_device_parameter
summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..OneDeviceParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeviceParameters">
<Description>
 device_parameters ::= ( '(' device_parameter_list ')' ) | one_device_parameter</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DeviceParameters124Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OneDeviceParameter(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeviceParameters124Sub">
<Description>
 '(' device_parameter_list ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..DeviceParameterList(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DimExpression">
<Description>
 dim_expression ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoCommand">
<Description>
 do_command ::= ('do' | 'd') ( do_while | do_label )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DoCommand128Sub(subElement,.addedElement)  {
		if ..DoCommand129Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoCommand128Sub">
<Description>
'do' | 'd'
summary values:DO,D</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("DO","D"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"DO")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"D")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="DoCommand129Sub">
<Description>
 do_while | do_label</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DoWhile(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DoLabel(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoItem">
<Description>
 do_item ::= (object_variable) | this_object | simple_indirection | ( label_reference [ function_parameter_list ] ) | system_object | macrocall | intrinsicfncall | classexpr | ( '(' expression ')' [ object_chain ])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DoItem133Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ThisObject(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SimpleIndirection(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DoItem134Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SystemObject(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Macrocall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Intrinsicfncall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Classexpr(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DoItem135Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoItem133Sub">
<Description>
object_variable</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ObjectVariable(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoItem134Sub">
<Description>
 label_reference [ function_parameter_list ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LabelReference(subElement,.addedElement)  {
		if $S(..FunctionParameterList(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoItem135Sub">
<Description>
 '(' expression ')' [ object_chain ]
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P&?4?
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..Expression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoItemList">
<Description>
 do_item_list ::= do_item ( ',' do_item)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DoItem(subElement,.addedElement)  {
		if ..DoItemList131RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoItemList131RepZero">
<Description>
 ( ',' do_item)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..DoItemList132Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="DoItemList132Sub">
<Description>
 ',' do_item
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..DoItem(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoLabel">
<Description>
 do_label ::= [ post_conditional ] ( naked | do_item_list)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
		if ..DoLabel130Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoLabel130Sub">
<Description>
 naked | do_item_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Naked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DoItemList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoWhile">
<Description>
 do_while ::= '{' [ cos_code_block ] '}' 'while' expression_list
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P&K&?1Rule?
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if $S(..CosCodeBlock(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,"}")  {
				if ..addKeyword(subElement,"WHILE")  {
					if ..ExpressionList(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoWhileCommand">
<Description>
 do_while_command ::= ('do' | 'd') '{' [ cos_code_block ] '}' 'while' expression_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?4?&P&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DoWhileCommand136Sub(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"{")  {
			if $S(..CosCodeBlock(subElement,.addedElement) :1,1:1) {
				if ..addPunctuation(subElement,"}")  {
					if ..addKeyword(subElement,"WHILE")  {
						if ..ExpressionList(subElement,.addedElement)  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoWhileCommand136Sub">
<Description>
'do' | 'd'
summary values:DO,D</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("DO","D"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"DO")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"D")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Dyadicop">
<Description><![CDATA[
 dyadicop ::= "+" | "-" | "\\" | "/" | "\" | ">=" | ">" | "'>=" | "'>" | "<=" | "<" | "'<=" | "'<" | "=" | "'=" | "**" | "*" | "&&" | "']]" | "]]" | "']" | "]" | "'[" | "[" | "!" | "||" | "_" | hash_op | amp_op]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"\\")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"/")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"\")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'>=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'>")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'<=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'<")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"**")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"&&")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"']]")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"]]")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"']")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"]")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'[")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"[")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"!")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"||")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"_")  {
		set done=1 ; or
	} elseif ..HashOp(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AmpOp(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElseBlock">
<Description>
 else_block ::= 'else' ( ( '{' [ cos_code_block ] '}' ) | command_list_eol )
summary values:ELSE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ELSE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ELSE")  {
		if ..ElseBlock162Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElseBlock162Sub">
<Description>
 ( '{' [ cos_code_block ] '}' ) | command_list_eol</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ElseBlock163Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CommandListEol(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElseBlock163Sub">
<Description>
 '{' [ cos_code_block ] '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if $S(..CosCodeBlock(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElseCommand">
<Description>
 else_command ::= ('else' | 'e') naked</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ElseCommand164Sub(subElement,.addedElement)  {
		if ..Naked(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElseCommand164Sub">
<Description>
'else' | 'e'
summary values:ELSE,E</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("ELSE","E"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"ELSE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ElseifBlock">
<Description>
 elseif_block ::= 'elseif' expression_list ( ( '{' [ cos_code_block ] '}' ) | command_list_eol )
summary values:ELSEIF</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ELSEIF"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ELSEIF")  {
		if ..ExpressionList(subElement,.addedElement)  {
			if ..ElseifBlock160Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElseifBlock160Sub">
<Description>
 ( '{' [ cos_code_block ] '}' ) | command_list_eol</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ElseifBlock161Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CommandListEol(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElseifBlock161Sub">
<Description>
 '{' [ cos_code_block ] '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if $S(..CosCodeBlock(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElseifBlockList">
<Description>
 elseif_block_list ::= elseif_block ( elseif_block )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ElseifBlock(subElement,.addedElement)  {
		if ..ElseifBlockList158RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElseifBlockList158RepZero">
<Description>
 ( elseif_block )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ElseifBlockList159Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ElseifBlockList159Sub">
<Description>
 elseif_block</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ElseifBlock(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Expression">
<Description>
 expression ::= factor ( pattern_match | (dyadicop factor ))*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Factor(subElement,.addedElement)  {
		if ..Expression50RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Expression50RepZero">
<Description>
 ( pattern_match | (dyadicop factor ))*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Expression51Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Expression51Sub">
<Description>
 pattern_match | (dyadicop factor )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PatternMatch(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression52Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Expression52Sub">
<Description>
dyadicop factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Dyadicop(subElement,.addedElement)  {
		if ..Factor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExpressionFunctionCall">
<Description>
 expression_function_call ::= '##expression' function_parameter_list
summary values:##EXPRESSION</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("##EXPRESSION",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"##expression")  {
		if ..FunctionParameterList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExpressionList">
<Description>
 expression_list ::= expression ( ',' expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		if ..ExpressionList115RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExpressionList115RepZero">
<Description>
 ( ',' expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ExpressionList116Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ExpressionList116Sub">
<Description>
 ',' expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtractFunctionCall">
<Description>
 extract_function_call ::= ('extract' | 'e') open_bracket expression [ ',' star_parameter [ ',' star_parameter ] ] close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExtractFunctionCall321Sub(subElement,.addedElement)  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..Expression(subElement,.addedElement)  {
				if ..ExtractFunctionCall322OptGrp(subElement,.addedElement)  {
					if ..CloseBracket(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtractFunctionCall321Sub">
<Description>
'extract' | 'e'
summary values:EXTRACT,E</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("EXTRACT","E"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"EXTRACT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ExtractFunctionCall322OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..StarParameter(subElement,.addedElement)  {
			if ..ExtractFunctionCall323OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtractFunctionCall323OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..StarParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtractFunctionCallSet">
<Description>
 extract_function_call_set ::= ('extract' | 'e') open_bracket set_value_expression [ ',' star_parameter [ ',' star_parameter ] ] close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExtractFunctionCallSet324Sub(subElement,.addedElement)  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..SetValueExpression(subElement,.addedElement)  {
				if ..ExtractFunctionCallSet325OptGrp(subElement,.addedElement)  {
					if ..CloseBracket(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtractFunctionCallSet324Sub">
<Description>
'extract' | 'e'
summary values:EXTRACT,E</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("EXTRACT","E"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"EXTRACT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ExtractFunctionCallSet325OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..StarParameter(subElement,.addedElement)  {
			if ..ExtractFunctionCallSet326OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtractFunctionCallSet326OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..StarParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Extrinsicfncall">
<Description>
 extrinsicfncall ::= '$$' label_reference [extrinsicfncall_parameter_list ]
summary values:$$</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle("$$",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"$$")  {
		if ..LabelReference(subElement,.addedElement)  {
			if $S(..ExtrinsicfncallParameterList(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtrinsicfncallParameter">
<Description>
 extrinsicfncall_parameter ::= ('.' (this_object_direct_property | simple_indirection | variable )) | expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExtrinsicfncallParameter73Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtrinsicfncallParameter73Sub">
<Description>
'.' (this_object_direct_property | simple_indirection | variable )
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..ExtrinsicfncallParameter74Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtrinsicfncallParameter74Sub">
<Description>
this_object_direct_property | simple_indirection | variable</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ThisObjectDirectProperty(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SimpleIndirection(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Variable(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtrinsicfncallParameterList">
<Description>
 extrinsicfncall_parameter_list ::= open_bracket [ [extrinsicfncall_parameter] ( ',' [extrinsicfncall_parameter] )* ] ['...'] close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OpenBracket(subElement,.addedElement)  {
		if ..ExtrinsicfncallParameterList70OptGrp(subElement,.addedElement)  {
			if $S(..addPunctuation(subElement,"...") :1,1:1) {
				if ..CloseBracket(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtrinsicfncallParameterList70OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..ExtrinsicfncallParameter(subElement,.addedElement) :1,1:1) {
		if ..ExtrinsicfncallParameterList71RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtrinsicfncallParameterList71RepZero">
<Description>
 ( ',' [extrinsicfncall_parameter] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ExtrinsicfncallParameterList72Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ExtrinsicfncallParameterList72Sub">
<Description>
 ',' [extrinsicfncall_parameter]
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if $S(..ExtrinsicfncallParameter(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Factor">
<Description>
 factor ::= ( monadicop )* primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Factor53RepZero(subElement,.addedElement)  {
		if ..Primary(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Factor53RepZero">
<Description>
 ( monadicop )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Factor54Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Factor54Sub">
<Description>
 monadicop</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Monadicop(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForCommand">
<Description>
 for_command ::= ('for' | 'f') [ for_parameters ] for_loop_statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ForCommand137Sub(subElement,.addedElement)  {
		if $S(..ForParameters(subElement,.addedElement) :1,1:1) {
			if ..ForLoopStatement(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForCommand137Sub">
<Description>
'for' | 'f'
summary values:FOR,F</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("FOR","F"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"FOR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"F")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ForEndLoopValue">
<Description>
 for_end_loop_value ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForIncrementValue">
<Description>
 for_increment_value ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForLoopSpecifier">
<Description>
 for_loop_specifier ::= for_start_value [ ':' for_increment_value [ ':' for_end_loop_value ] ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ForStartValue(subElement,.addedElement)  {
		if ..ForLoopSpecifier144OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForLoopSpecifier144OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..ForIncrementValue(subElement,.addedElement)  {
			if ..ForLoopSpecifier145OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForLoopSpecifier145OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..ForEndLoopValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForLoopSpecifierList">
<Description>
 for_loop_specifier_list ::= for_loop_specifier ( ',' for_loop_specifier )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ForLoopSpecifier(subElement,.addedElement)  {
		if ..ForLoopSpecifierList142RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForLoopSpecifierList142RepZero">
<Description>
 ( ',' for_loop_specifier )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ForLoopSpecifierList143Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ForLoopSpecifierList143Sub">
<Description>
 ',' for_loop_specifier
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ForLoopSpecifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForLoopStatement">
<Description>
 for_loop_statement ::= ( '{' [ cos_command] [ cos_code_block ] '}' ) | (naked | command_list_eol )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ForLoopStatement138Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ForLoopStatement139Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForLoopStatement138Sub">
<Description>
 '{' [ cos_command] [ cos_code_block ] '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?4?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if $S(..CosCommand(subElement,.addedElement) :1,1:1) {
			if $S(..CosCodeBlock(subElement,.addedElement) :1,1:1) {
				if ..addPunctuation(subElement,"}")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForLoopStatement139Sub">
<Description>
naked | command_list_eol</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Naked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CommandListEol(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForParameter">
<Description>
 for_parameter ::= lvalue_expression '=' for_loop_specifier_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LvalueExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"=")  {
			if ..ForLoopSpecifierList(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForParameters">
<Description>
 for_parameters ::= for_parameter ( ',' for_parameter )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ForParameter(subElement,.addedElement)  {
		if ..ForParameters140RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForParameters140RepZero">
<Description>
 ( ',' for_parameter )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ForParameters141Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ForParameters141Sub">
<Description>
 ',' for_parameter
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ForParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForStartValue">
<Description>
 for_start_value ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionParameter">
<Description>
 function_parameter ::= ( '.' ( this_object_direct_property | simple_indirection | variable )) | expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..FunctionParameter82Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionParameter82Sub">
<Description>
 '.' ( this_object_direct_property | simple_indirection | variable )
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..FunctionParameter83Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionParameter83Sub">
<Description>
 this_object_direct_property | simple_indirection | variable</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ThisObjectDirectProperty(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SimpleIndirection(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Variable(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionParameterList">
<Description>
 function_parameter_list ::= open_bracket [ [function_parameter] ( ',' [function_parameter] )* ] ['...'] close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OpenBracket(subElement,.addedElement)  {
		if ..FunctionParameterList79OptGrp(subElement,.addedElement)  {
			if $S(..addPunctuation(subElement,"...") :1,1:1) {
				if ..CloseBracket(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionParameterList79OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..FunctionParameter(subElement,.addedElement) :1,1:1) {
		if ..FunctionParameterList80RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionParameterList80RepZero">
<Description>
 ( ',' [function_parameter] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..FunctionParameterList81Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionParameterList81Sub">
<Description>
 ',' [function_parameter]
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if $S(..FunctionParameter(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GeneralIntrinsic">
<Description>
 general_intrinsic ::= any_keyword function_parameter_list [ object_chain ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AnyKeyword(subElement,.addedElement)  {
		if ..FunctionParameterList(subElement,.addedElement)  {
			if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GeneralIntrinsicSet">
<Description>
 general_intrinsic_set ::= any_keyword function_parameter_list [ object_chain ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AnyKeyword(subElement,.addedElement)  {
		if ..FunctionParameterList(subElement,.addedElement)  {
			if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalIdentifier">
<Description>
 global_identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
summary values:REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalName">
<Description>
 global_name ::= global_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..GlobalIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalRef">
<Description>
 global_ref ::= global_ref_naked | global_ref_full</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..GlobalRefNaked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GlobalRefFull(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalRefEnv">
<Description>
 global_ref_env ::= '|' [ expression ] '|'
summary values:|</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("|",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"|")  {
		if $S(..Expression(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,"|")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalRefEnvTwo">
<Description>
 global_ref_env_two ::= '[' primary [ ',' primary ] ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..Primary(subElement,.addedElement)  {
			if ..GlobalRefEnvTwo98OptGrp(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"]")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalRefEnvTwo98OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Primary(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalRefFull">
<Description>
 global_ref_full ::= '^' [ global_ref_env | global_ref_env_two ] (macrocall | global_name ) [subscript_parameter_list]
summary values:^</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle("^",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"^")  {
		if ..GlobalRefFull96OptGrp(subElement,.addedElement)  {
			if ..GlobalRefFull97Sub(subElement,.addedElement)  {
				if $S(..SubscriptParameterList(subElement,.addedElement) :1,1:1) {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalRefFull96OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..GlobalRefEnv(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GlobalRefEnvTwo(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalRefFull97Sub">
<Description>
macrocall | global_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Macrocall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GlobalName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalRefNaked">
<Description>
 global_ref_naked ::= '^' subscript_parameter_list
summary values:^</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("^",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"^")  {
		if ..SubscriptParameterList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalRefSet">
<Description>
 global_ref_set ::= global_ref_naked | global_ref_full</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..GlobalRefNaked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GlobalRefFull(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoCaseClause">
<Description>
 goto_case_clause ::= goto_case_clause_case ':' goto_case_clause_value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..GotoCaseClauseCase(subElement,.addedElement)  {
		if ..addPunctuation(subElement,":")  {
			if ..GotoCaseClauseValue(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoCaseClauseCase">
<Description>
 goto_case_clause_case ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoCaseClauseDefault">
<Description>
 goto_case_clause_default ::= ',' ':' label_reference
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..addPunctuation(subElement,":")  {
			if ..LabelReference(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoCaseClauseValue">
<Description>
 goto_case_clause_value ::= label_reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LabelReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoCaseClauses">
<Description>
 goto_case_clauses ::= (( ',' goto_case_clause ))*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..GotoCaseClauses318RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoCaseClauses318RepZero">
<Description>
 (( ',' goto_case_clause ))*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..GotoCaseClauses319Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="GotoCaseClauses319Sub">
<Description>
( ',' goto_case_clause )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..GotoCaseClauses320Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoCaseClauses320Sub">
<Description>
 ',' goto_case_clause
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..GotoCaseClause(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoCaseFunctionCall">
<Description>
 goto_case_function_call ::= '$case' open_bracket expression [ goto_case_clauses ] [ goto_case_clause_default ] close_bracket
summary values:$CASE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?1Rule?&?4?&?4?&?1Rule?
	; first rule summary P
	if '(..isStringSingle("$CASE",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"$case")  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..Expression(subElement,.addedElement)  {
				if $S(..GotoCaseClauses(subElement,.addedElement) :1,1:1) {
					if $S(..GotoCaseClauseDefault(subElement,.addedElement) :1,1:1) {
						if ..CloseBracket(subElement,.addedElement)  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoCommand">
<Description>
 goto_command ::= ('goto' | 'g') [ post_conditional ] goto_dest_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..GotoCommand146Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..GotoDestList(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoCommand146Sub">
<Description>
'goto' | 'g'
summary values:GOTO,G</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("GOTO","G"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"GOTO")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"G")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="GotoDest">
<Description>
 goto_dest ::= goto_case_function_call | ( label_reference [ post_conditional ] )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..GotoCaseFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GotoDest149Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoDest149Sub">
<Description>
 label_reference [ post_conditional ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LabelReference(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoDestList">
<Description>
 goto_dest_list ::= goto_dest ( ',' goto_dest )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..GotoDest(subElement,.addedElement)  {
		if ..GotoDestList147RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoDestList147RepZero">
<Description>
 ( ',' goto_dest )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..GotoDestList148Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="GotoDestList148Sub">
<Description>
 ',' goto_dest
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..GotoDest(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HaltCommand">
<Description>
 halt_command ::= ('halt' | 'h') [ post_conditional ] naked</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..HaltCommand150Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..Naked(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HaltCommand150Sub">
<Description>
'halt' | 'h'
summary values:HALT,H</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("HALT","H"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"HALT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"H")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="HangCommand">
<Description>
 hang_command ::= ('hang' | 'h') [ post_conditional ] hangtime</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..HangCommand151Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..Hangtime(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HangCommand151Sub">
<Description>
'hang' | 'h'
summary values:HANG,H</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("HANG","H"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"HANG")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"H")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="HangValue">
<Description>
 hang_value ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Hangtime">
<Description>
 hangtime ::= hang_value ( ',' hang_value )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..HangValue(subElement,.addedElement)  {
		if ..Hangtime152RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Hangtime152RepZero">
<Description>
 ( ',' hang_value )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Hangtime153Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Hangtime153Sub">
<Description>
 ',' hang_value
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..HangValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HashOp">
<Description>
 hash_op ::= '#'
summary values:#</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("#",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"#")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HtmlBody">
<Description>
 html_body ::= 'NEED HTML BODY'
summary values:NEED HTML BODY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED HTML BODY",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED HTML BODY")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HtmlCommand">
<Description><![CDATA[
 html_command ::= '&html<' html_body '>'
summary values:&HTML<]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("&HTML<",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"&html<")  {
		if ..HtmlBody(subElement,.addedElement)  {
			if ..addPunctuation(subElement,">")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<Description>
 identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
summary values:REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IfCommand">
<Description>
 if_command ::= ('if' | 'i') ( naked | expression_list) ( naked | [then_block] ) [ elseif_block_list ] [ else_block ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IfCommand154Sub(subElement,.addedElement)  {
		if ..IfCommand155Sub(subElement,.addedElement)  {
			if ..IfCommand156Sub(subElement,.addedElement)  {
				if $S(..ElseifBlockList(subElement,.addedElement) :1,1:1) {
					if $S(..ElseBlock(subElement,.addedElement) :1,1:1) {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IfCommand154Sub">
<Description>
'if' | 'i'
summary values:IF,I</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("IF","I"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"IF")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"I")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="IfCommand155Sub">
<Description>
 naked | expression_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Naked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ExpressionList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IfCommand156Sub">
<Description>
 naked | [then_block]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Naked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif $S(..ThenBlock(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IncrementFunctionCall">
<Description>
 increment_function_call ::= ('increment' | '$i') '(' variable_set [',' expression ] ')'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?&?4?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IncrementFunctionCall355Sub(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"(")  {
			if ..VariableSet(subElement,.addedElement)  {
				if ..IncrementFunctionCall356OptGrp(subElement,.addedElement)  {
					if ..addPunctuation(subElement,")")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IncrementFunctionCall355Sub">
<Description>
'increment' | '$i'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INCREMENT")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"$i")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IncrementFunctionCall356OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Indirection">
<Description>
 Indirection ::= Subscript_Indirection | Simple_Indirection</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SubscriptIndirection(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SimpleIndirection(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Intrinsicfncall">
<Description>
 intrinsicfncall ::= '$' (special_intrinsic | general_intrinsic )
summary values:$</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("$",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"$")  {
		if ..Intrinsicfncall76Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Intrinsicfncall76Sub">
<Description>
special_intrinsic | general_intrinsic</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SpecialIntrinsic(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GeneralIntrinsic(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntrinsicfncallParameter">
<Description>
 intrinsicfncall_parameter ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntrinsicfncallParameterList">
<Description>
 intrinsicfncall_parameter_list ::= open_bracket [expression] ( ',' [expression] )* close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&(?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OpenBracket(subElement,.addedElement)  {
		if $S(..Expression(subElement,.addedElement) :1,1:1) {
			if ..IntrinsicfncallParameterList77RepZero(subElement,.addedElement)  {
				if ..CloseBracket(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntrinsicfncallParameterList77RepZero">
<Description>
 ( ',' [expression] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..IntrinsicfncallParameterList78Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="IntrinsicfncallParameterList78Sub">
<Description>
 ',' [expression]
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if $S(..Expression(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntrinsicfncallSet">
<Description>
 intrinsicfncall_set ::= '$' (special_intrinsic_set | general_intrinsic_set )
summary values:$</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("$",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"$")  {
		if ..IntrinsicfncallSet84Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntrinsicfncallSet84Sub">
<Description>
special_intrinsic_set | general_intrinsic_set</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SpecialIntrinsicSet(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GeneralIntrinsicSet(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobArgument">
<Description>
 job_argument ::= job_call [ job_process_parameters ] [ job_timeout_spec ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..JobCall(subElement,.addedElement)  {
		if $S(..JobProcessParameters(subElement,.addedElement) :1,1:1) {
			if $S(..JobTimeoutSpec(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobArguments">
<Description>
 job_arguments ::= job_argument ( ',' job_argument )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..JobArgument(subElement,.addedElement)  {
		if ..JobArguments166RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobArguments166RepZero">
<Description>
 ( ',' job_argument )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..JobArguments167Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="JobArguments167Sub">
<Description>
 ',' job_argument
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..JobArgument(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobCall">
<Description>
 job_call ::= job_routine_call | job_class_method_call | job_instanceMethod_call | job_classmethodfn_call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..JobRoutineCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JobClassMethodCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JobInstancemethodCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JobClassmethodfnCall(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobClassMethodCall">
<Description>
 job_class_method_call ::= class_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobClassmethodfnCall">
<Description>
 job_classmethodfn_call ::= '$classmethod' '(' expression ',' expression ( ',' expression )* ')'
summary values:$CLASSMETHOD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("$CLASSMETHOD",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"$classmethod")  {
		if ..addPunctuation(subElement,"(")  {
			if ..Expression(subElement,.addedElement)  {
				if ..addPunctuation(subElement,",")  {
					if ..Expression(subElement,.addedElement)  {
						if ..JobClassmethodfnCall177RepZero(subElement,.addedElement)  {
							if ..addPunctuation(subElement,")")  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobClassmethodfnCall177RepZero">
<Description>
 ( ',' expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..JobClassmethodfnCall178Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="JobClassmethodfnCall178Sub">
<Description>
 ',' expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobCommand">
<Description>
 job_command ::= ('job' | 'j') [ post_conditional ] job_arguments</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..JobCommand165Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..JobArguments(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobCommand165Sub">
<Description>
'job' | 'j'
summary values:JOB,J</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("JOB","J"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"JOB")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"J")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="JobInstancemethodCall">
<Description>
 job_instanceMethod_call ::= '..' identifier function_parameter_list
summary values:..</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?1Rule?
	; first rule summary P
	if '(..isStringSingle("..",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"..")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..FunctionParameterList(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobNspaceParam">
<Description>
 job_nspace_param ::= [ expression ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Expression(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobOsdirectory">
<Description>
 job_os-directory ::= [ expression ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Expression(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobPrincipalinput">
<Description>
 job_principal-input ::= [ expression ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Expression(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobPrincipaloutput">
<Description>
 job_principal-output ::= [ expression ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Expression(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobPriority">
<Description>
 job_priority ::= [ expression ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Expression(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobProcessParameters">
<Description>
 job_process_parameters ::= ':' ( job_process_parameters_inbrackets | job_process_parameters_nobrackets )
summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..JobProcessParameters168Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobProcessParameters168Sub">
<Description>
 job_process_parameters_inbrackets | job_process_parameters_nobrackets</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..JobProcessParametersInbrackets(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JobProcessParametersNobrackets(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobProcessParametersInbrackets">
<Description>
 job_process_parameters_inbrackets ::= '(' ( job_nspace_param [ ':' [ job_switch_param] [ ':' [ job_principal-input] [ ':' [ job_principal-output] [ ':' [ job_priority] [ ':' [ job_os-directory] [ ':' [job_process-name] ] ] ] ] ] ] ) ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..JobProcessParametersInbrackets169Sub(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobProcessParametersInbrackets169Sub">
<Description>
 job_nspace_param [ ':' [ job_switch_param] [ ':' [ job_principal-input] [ ':' [ job_principal-output] [ ':' [ job_priority] [ ':' [ job_os-directory] [ ':' [job_process-name] ] ] ] ] ] ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..JobNspaceParam(subElement,.addedElement)  {
		if ..JobProcessParametersInbrackets170OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobProcessParametersInbrackets170OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?4?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if $S(..JobSwitchParam(subElement,.addedElement) :1,1:1) {
			if ..JobProcessParametersInbrackets171OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobProcessParametersInbrackets171OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?4?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if $S(..JobPrincipalinput(subElement,.addedElement) :1,1:1) {
			if ..JobProcessParametersInbrackets172OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobProcessParametersInbrackets172OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?4?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if $S(..JobPrincipaloutput(subElement,.addedElement) :1,1:1) {
			if ..JobProcessParametersInbrackets173OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobProcessParametersInbrackets173OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?4?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if $S(..JobPriority(subElement,.addedElement) :1,1:1) {
			if ..JobProcessParametersInbrackets174OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobProcessParametersInbrackets174OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?4?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if $S(..JobOsdirectory(subElement,.addedElement) :1,1:1) {
			if ..JobProcessParametersInbrackets175OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobProcessParametersInbrackets175OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if $S(..JobProcessname(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobProcessParametersNobrackets">
<Description>
 job_process_parameters_nobrackets ::= [ job_nspace_param ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..JobNspaceParam(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobProcessname">
<Description>
 job_process-name ::= [ expression ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Expression(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobRoutineCall">
<Description>
 job_routine_call ::= identifier [ '^' identifier ] [ parameter_list]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		if ..JobRoutineCall176OptGrp(subElement,.addedElement)  {
			if $S(..ParameterList(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobRoutineCall176OptGrp">
<Description>

summary values:^</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("^",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"^")  {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobSwitchParam">
<Description>
 job_switch_param ::= [ expression ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Expression(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JobTimeoutSpec">
<Description>
 job_timeout_spec ::= ':' expression
summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JsBody">
<Description>
 js_body ::= 'NEED JS BODY'
summary values:NEED JS BODY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED JS BODY",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED JS BODY")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JsCommand">
<Description><![CDATA[
 js_command ::= ('&javascript<' | '&js<') js_body '>']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..JsCommand314Sub(subElement,.addedElement)  {
		if ..JsBody(subElement,.addedElement)  {
			if ..addPunctuation(subElement,">")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JsCommand314Sub">
<Description><![CDATA[
'&javascript<' | '&js<'
summary values:&JAVASCRIPT<,&JS<]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("&JAVASCRIPT<","&JS<"),12,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"&javascript<")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"&js<")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="JsonString">
<Description>
 json_string ::= 'NEEDS JSON STRING'
summary values:NEEDS JSON STRING</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS JSON STRING",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS JSON STRING")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KillCommand">
<Description>
 kill_command ::= ( 'kill' | 'k') [ post_conditional ] ( naked | kill_parameter_list )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..KillCommand179Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..KillCommand180Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KillCommand179Sub">
<Description>
 'kill' | 'k'
summary values:KILL,K</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("KILL","K"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"KILL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"K")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="KillCommand180Sub">
<Description>
 naked | kill_parameter_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Naked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..KillParameterList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KillExclusiveList">
<Description>
 kill_exclusive_list ::= '(' kill_item_list ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..KillItemList(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KillItem">
<Description>
 kill_item ::= set_item_single</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetItemSingle(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KillItemList">
<Description>
 kill_item_list ::= kill_item ( ',' kill_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..KillItem(subElement,.addedElement)  {
		if ..KillItemList183RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KillItemList183RepZero">
<Description>
 ( ',' kill_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..KillItemList184Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="KillItemList184Sub">
<Description>
 ',' kill_item
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..KillItem(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KillParameter">
<Description>
 kill_parameter ::= kill_exclusive_list | kill_item</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..KillExclusiveList(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..KillItem(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KillParameterList">
<Description>
 kill_parameter_list ::= kill_parameter ( ',' kill_parameter )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..KillParameter(subElement,.addedElement)  {
		if ..KillParameterList181RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KillParameterList181RepZero">
<Description>
 ( ',' kill_parameter )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..KillParameterList182Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="KillParameterList182Sub">
<Description>
 ',' kill_parameter
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..KillParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Label">
<Description>
 label ::= 'regexp:[0-9A-Za-z]+'
summary values:REGEXP:[0-9A-ZA-Z]+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:[0-9A-ZA-Z]+",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:[0-9A-Za-z]+")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelDefinition">
<Description>
 label_definition ::= label_identifier [ label_formal_specification ] [ label_scope ] [ '{' cos_code_block '}']</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LabelIdentifier(subElement,.addedElement)  {
		if $S(..LabelFormalSpecification(subElement,.addedElement) :1,1:1) {
			if $S(..LabelScope(subElement,.addedElement) :1,1:1) {
				if ..LabelDefinition13OptGrp(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelDefinition13OptGrp">
<Description>

summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..CosCodeBlock(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelFormalSpecification">
<Description>
 label_formal_specification ::= '(' [ label-formal-param-list ] ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if $S(..Labelformalparamlist(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelIdentifier">
<Description>
 label_identifier ::= [ '%' ] 'regexp:[0-9A-Za-z]+'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addPunctuation(subElement,"%") :1,1:1) {
		if ..addPunctuation(subElement,"regexp:[0-9A-Za-z]+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelPublicVars">
<Description>
 label_public_vars ::= '[' variable ( ',' variable )* ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..Variable(subElement,.addedElement)  {
			if ..LabelPublicVars17RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"]")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelPublicVars17RepZero">
<Description>
 ( ',' variable )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..LabelPublicVars18Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LabelPublicVars18Sub">
<Description>
 ',' variable
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Variable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelReference">
<Description>
 label_reference ::= (( label_identifier | simple_indirection ) [ '^' [routine_env] ( routine_identifier | simple_indirection) ]) | ('^' [routine_env] (routine_identifier | simple_indirection) )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LabelReference19Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..LabelReference23Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelReference19Sub">
<Description>
( label_identifier | simple_indirection ) [ '^' [routine_env] ( routine_identifier | simple_indirection) ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LabelReference20Sub(subElement,.addedElement)  {
		if ..LabelReference21OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelReference20Sub">
<Description>
 label_identifier | simple_indirection</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LabelIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SimpleIndirection(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelReference21OptGrp">
<Description>

summary values:^</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?1Rule?
	; first rule summary P
	if '(..isStringSingle("^",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"^")  {
		if $S(..RoutineEnv(subElement,.addedElement) :1,1:1) {
			if ..LabelReference22Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelReference22Sub">
<Description>
 routine_identifier | simple_indirection</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RoutineIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SimpleIndirection(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelReference23Sub">
<Description>
'^' [routine_env] (routine_identifier | simple_indirection)
summary values:^</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?1Rule?
	; first rule summary P
	if '(..isStringSingle("^",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"^")  {
		if $S(..RoutineEnv(subElement,.addedElement) :1,1:1) {
			if ..LabelReference24Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelReference24Sub">
<Description>
routine_identifier | simple_indirection</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..RoutineIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SimpleIndirection(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelScope">
<Description>
 label_scope ::= ( [ label_public_vars ] 'public' | 'private' | 'methodimpl' )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LabelScope16Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelScope16Sub">
<Description>
 [ label_public_vars ] 'public' | 'private' | 'methodimpl'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&K|K|K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..LabelPublicVars(subElement,.addedElement) :1,1:1) {
		if ..addKeyword(subElement,"PUBLIC")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PRIVATE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"METHODIMPL")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Labelformalparamlist">
<Description>
 label-formal-param-list ::= label-one-formal-param ( ',' label-one-formal-param )* ['...']</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Labeloneformalparam(subElement,.addedElement)  {
		if ..Labelformalparamlist14RepZero(subElement,.addedElement)  {
			if $S(..addPunctuation(subElement,"...") :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Labelformalparamlist14RepZero">
<Description>
 ( ',' label-one-formal-param )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Labelformalparamlist15Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Labelformalparamlist15Sub">
<Description>
 ',' label-one-formal-param
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Labeloneformalparam(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Labeloneformalparam">
<Description><![CDATA[
 label-one-formal-param ::= [ '&' ] label-param-name [ label-param-default-value ]]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addPunctuation(subElement,"&") :1,1:1) {
		if ..Labelparamname(subElement,.addedElement)  {
			if $S(..Labelparamdefaultvalue(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Labelparamdefaultvalue">
<Description>
 label-param-default-value ::= '=' expression
summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Labelparamname">
<Description>
 label-param-name ::= variable_set</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..VariableSet(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LineComment">
<Description>
 line_comment ::= ';' text_to_eol | '//' text_to_eol | '#;' text_to_eol | '##;' text_to_eol
summary values:;</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?|P&?1Rule?|P&?1Rule?|P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(";",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,";")  {
		if ..TextToEol(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"//")  {
			if ..TextToEol(subElement,.addedElement)  {
				set done=1 ; or
			} elseif ..addPunctuation(subElement,"#;")  {
				if ..TextToEol(subElement,.addedElement)  {
					set done=1 ; or
				} elseif ..addPunctuation(subElement,"##;")  {
					if ..TextToEol(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LineReference">
<Description>
 line_reference ::= [ label ] [ [ offset_sign ] offset ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Label(subElement,.addedElement) :1,1:1) {
		if ..LineReference221OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LineReference221OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..OffsetSign(subElement,.addedElement) :1,1:1) {
		if ..Offset(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Lineref1">
<Description>
 lineref1 ::= line_reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LineReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Lineref2">
<Description>
 lineref2 ::= line_reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LineReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ListbuildFunctionCall">
<Description>
 listbuild_function_call ::= ('listbuild' | 'lb') open_bracket expression (',' expression)* close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?&(?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ListbuildFunctionCall333Sub(subElement,.addedElement)  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..Expression(subElement,.addedElement)  {
				if ..ListbuildFunctionCall334RepZero(subElement,.addedElement)  {
					if ..CloseBracket(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ListbuildFunctionCall333Sub">
<Description>
'listbuild' | 'lb'
summary values:LISTBUILD,LB</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("LISTBUILD","LB"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"LISTBUILD")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LB")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ListbuildFunctionCall334RepZero">
<Description>
 (',' expression)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ListbuildFunctionCall335Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ListbuildFunctionCall335Sub">
<Description>
',' expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ListbuildFunctionCallSet">
<Description>
 listbuild_function_call_set ::= ('listbuild' | 'lb') open_bracket set_value_expression (',' variable_set)* close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?&(?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ListbuildFunctionCallSet336Sub(subElement,.addedElement)  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..SetValueExpression(subElement,.addedElement)  {
				if ..ListbuildFunctionCallSet337RepZero(subElement,.addedElement)  {
					if ..CloseBracket(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ListbuildFunctionCallSet336Sub">
<Description>
'listbuild' | 'lb'
summary values:LISTBUILD,LB</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("LISTBUILD","LB"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"LISTBUILD")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LB")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ListbuildFunctionCallSet337RepZero">
<Description>
 (',' variable_set)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ListbuildFunctionCallSet338Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ListbuildFunctionCallSet338Sub">
<Description>
',' variable_set
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..VariableSet(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ListitemFunctionCall">
<Description>
 listitem_function_call ::= ('listget' | 'list' | 'li' |'lg' ) open_bracket expression [ ',' star_parameter [ ',' star_parameter ] ] close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ListitemFunctionCall342Sub(subElement,.addedElement)  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..Expression(subElement,.addedElement)  {
				if ..ListitemFunctionCall343OptGrp(subElement,.addedElement)  {
					if ..CloseBracket(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ListitemFunctionCall342Sub">
<Description>
'listget' | 'list' | 'li' |'lg'
summary values:LISTGET,LIST,LI,LG</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K
	if '(..isKeywordInList($lb("LISTGET","LIST","LI","LG"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"LISTGET")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LIST")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LI")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LG")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ListitemFunctionCall343OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..StarParameter(subElement,.addedElement)  {
			if ..ListitemFunctionCall344OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ListitemFunctionCall344OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..StarParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ListitemFunctionCallSet">
<Description>
 listitem_function_call_set ::= ('list' | 'li') open_bracket set_value_expression [ ',' star_parameter [ ',' star_parameter ] ] close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ListitemFunctionCallSet345Sub(subElement,.addedElement)  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..SetValueExpression(subElement,.addedElement)  {
				if ..ListitemFunctionCallSet346OptGrp(subElement,.addedElement)  {
					if ..CloseBracket(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ListitemFunctionCallSet345Sub">
<Description>
'list' | 'li'
summary values:LIST,LI</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("LIST","LI"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"LIST")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LI")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ListitemFunctionCallSet346OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..StarParameter(subElement,.addedElement)  {
			if ..ListitemFunctionCallSet347OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ListitemFunctionCallSet347OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..StarParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ListupdateFunctionCall">
<Description>
 listupdate_function_call ::= ('listupdate' | 'lu') open_bracket expression ',' expression (',' expression ':' expression)* close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?&P&?1Rule?&(?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ListupdateFunctionCall339Sub(subElement,.addedElement)  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..Expression(subElement,.addedElement)  {
				if ..addPunctuation(subElement,",")  {
					if ..Expression(subElement,.addedElement)  {
						if ..ListupdateFunctionCall340RepZero(subElement,.addedElement)  {
							if ..CloseBracket(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ListupdateFunctionCall339Sub">
<Description>
'listupdate' | 'lu'
summary values:LISTUPDATE,LU</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("LISTUPDATE","LU"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"LISTUPDATE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LU")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ListupdateFunctionCall340RepZero">
<Description>
 (',' expression ':' expression)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ListupdateFunctionCall341Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ListupdateFunctionCall341Sub">
<Description>
',' expression ':' expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Expression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,":")  {
				if ..Expression(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LockCommand">
<Description>
 lock_command ::= ('lock' | 'l') [post_conditional ] ( naked | ( [ lock_parameter ( ',' lock_parameter)* ] [ else_block ] ) )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LockCommand185Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..LockCommand186Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LockCommand185Sub">
<Description>
'lock' | 'l'
summary values:LOCK,L</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("LOCK","L"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"LOCK")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"L")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LockCommand186Sub">
<Description>
 naked | ( [ lock_parameter ( ',' lock_parameter)* ] [ else_block ] )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Naked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..LockCommand187Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LockCommand187Sub">
<Description>
 [ lock_parameter ( ',' lock_parameter)* ] [ else_block ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LockCommand188OptGrp(subElement,.addedElement)  {
		if $S(..ElseBlock(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LockCommand188OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LockParameter(subElement,.addedElement)  {
		if ..LockCommand189RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LockCommand189RepZero">
<Description>
 ( ',' lock_parameter)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..LockCommand190Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LockCommand190Sub">
<Description>
 ',' lock_parameter
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..LockParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LockParameter">
<Description>
 lock_parameter ::= [ '+' | '-' ] (lockname_list | lockname_list_item) [ lock_timeout ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LockParameter191OptGrp(subElement,.addedElement)  {
		if ..LockParameter192Sub(subElement,.addedElement)  {
			if $S(..LockTimeout(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LockParameter191OptGrp">
<Description>

summary values:+,-</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("+","-"),1,.value)) { quit 1 /* not found is OK */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=1 /* failure rollsback but returns OK */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LockParameter192Sub">
<Description>
lockname_list | lockname_list_item</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LocknameList(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..LocknameListItem(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LockTimeout">
<Description>
 lock_timeout ::= ':' expression
summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LockType">
<Description>
 lock_type ::= hash_op expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..HashOp(subElement,.addedElement)  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Lockname">
<Description>
 lockname ::= global_ref | variable | macrocall | indirection</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..GlobalRef(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Variable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Macrocall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Indirection(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LocknameList">
<Description>
 lockname_list ::= '(' lockname_list_item ( ',' lockname_list_item )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..LocknameListItem(subElement,.addedElement)  {
			if ..LocknameList193RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LocknameList193RepZero">
<Description>
 ( ',' lockname_list_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..LocknameList194Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LocknameList194Sub">
<Description>
 ',' lockname_list_item
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..LocknameListItem(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LocknameListItem">
<Description>
 lockname_list_item ::= lockname [ lock_type ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Lockname(subElement,.addedElement)  {
		if $S(..LockType(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LvalueExpression">
<Description>
 lvalue_expression ::= this_object_set | variable_set | intrinsicfncall_set | special_variable | macrocall | Indirection | global_ref_set</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ThisObjectSet(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..VariableSet(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IntrinsicfncallSet(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SpecialVariable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Macrocall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Indirection(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GlobalRefSet(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroExpression">
<Description>
 macro_expression ::= expression_function_call | safeexpression_function_call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExpressionFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SafeexpressionFunctionCall(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroIdentifier">
<Description>
 macro_identifier ::= [ '%' ] 'regexp:[0-9A-Za-z]+'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addPunctuation(subElement,"%") :1,1:1) {
		if ..addPunctuation(subElement,"regexp:[0-9A-Za-z]+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameter">
<Description>
 macro_parameter ::= ('.' variable_set ) | expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MacroParameter69Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameter69Sub">
<Description>
'.' variable_set
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..VariableSet(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameterList">
<Description>
 macro_parameter_list ::= '(' [ [macro_parameter] ( ',' [macro_parameter] )* ] ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..MacroParameterList66OptGrp(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameterList66OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..MacroParameter(subElement,.addedElement) :1,1:1) {
		if ..MacroParameterList67RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameterList67RepZero">
<Description>
 ( ',' [macro_parameter] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..MacroParameterList68Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameterList68Sub">
<Description>
 ',' [macro_parameter]
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if $S(..MacroParameter(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameterText">
<Description>
 macro_parameter_text ::= '(' any_text_upto_close_bracket ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..AnyTextUptoCloseBracket(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Macrocall">
<Description>
 macrocall ::= '$$$' macro_identifier [ macro_parameter_list | macro_parameter_text ] [ macro_parameter_list ] [ object_chain ]
summary values:$$$</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?&?4?&?4?
	; first rule summary P
	if '(..isStringSingle("$$$",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"$$$")  {
		if ..MacroIdentifier(subElement,.addedElement)  {
			if ..Macrocall65OptGrp(subElement,.addedElement)  {
				if $S(..MacroParameterList(subElement,.addedElement) :1,1:1) {
					if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Macrocall65OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MacroParameterList(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MacroParameterText(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MemberRef">
<Description>
 member_ref ::= identifier | string</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..String(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MergeCommand">
<Description>
 merge_command ::= ('merge' | 'm') [ post_conditional ] merge_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MergeCommand197Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..MergeList(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MergeCommand197Sub">
<Description>
'merge' | 'm'
summary values:MERGE,M</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("MERGE","M"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"MERGE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"M")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="MergeItem">
<Description>
 merge_item ::= lvalue_expression '=' expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LvalueExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"=")  {
			if ..Expression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MergeList">
<Description>
 merge_list ::= merge_item ( ',' merge_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MergeItem(subElement,.addedElement)  {
		if ..MergeList198RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MergeList198RepZero">
<Description>
 ( ',' merge_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..MergeList199Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="MergeList199Sub">
<Description>
 ',' merge_item
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..MergeItem(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MethodFunctionCall">
<Description>
 method_function_call ::= 'method' function_parameter_list [ object_chain ]
summary values:METHOD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("METHOD"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"METHOD")  {
		if ..FunctionParameterList(subElement,.addedElement)  {
			if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MnemonicArguments">
<Description>
 mnemonic_arguments ::= expression ( ',' expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		if ..MnemonicArguments264RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MnemonicArguments264RepZero">
<Description>
 ( ',' expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..MnemonicArguments265Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="MnemonicArguments265Sub">
<Description>
 ',' expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Monadicop">
<Description>
 monadicop ::= "+" | "-" | "'" | "~"
summary values:+,-,',~</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P
	if '(..isStringInList($lb("+","-","'","~"),1,.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"~")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MpvCommand">
<Description>
 mpv_command ::= ('mvprint' | 'mvp') [ post_conditional ] [ write_argument_list ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MpvCommand266Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if $S(..WriteArgumentList(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MpvCommand266Sub">
<Description>
'mvprint' | 'mvp'
summary values:MVPRINT,MVP</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("MVPRINT","MVP"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"MVPRINT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MVP")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="MyOneXecuteArg">
<Description>
 my_one_xecute_arg ::= expression [ post_conditional]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Naked">
<Description>
 naked ::= ' '
summary values: </Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(" ",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement," ")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NewCommand">
<Description>
 new_command ::= ('new' | 'n') [ post_conditional ] ( naked | new_item_list )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NewCommand200Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..NewCommand201Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NewCommand200Sub">
<Description>
'new' | 'n'
summary values:NEW,N</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("NEW","N"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"NEW")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"N")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="NewCommand201Sub">
<Description>
 naked | new_item_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Naked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NewItemList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NewItem">
<Description>
 new_item ::= new_item_single | new_item_varlist</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NewItemSingle(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NewItemVarlist(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NewItemList">
<Description>
 new_item_list ::= new_item ( ',' new_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NewItem(subElement,.addedElement)  {
		if ..NewItemList202RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NewItemList202RepZero">
<Description>
 ( ',' new_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..NewItemList203Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="NewItemList203Sub">
<Description>
 ',' new_item
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..NewItem(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NewItemSingle">
<Description>
 new_item_single ::= lvalue_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LvalueExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NewItemSingleList">
<Description>
 new_item_single_list ::= new_item_single ( ',' new_item_single )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NewItemSingle(subElement,.addedElement)  {
		if ..NewItemSingleList204RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NewItemSingleList204RepZero">
<Description>
 ( ',' new_item_single )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..NewItemSingleList205Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="NewItemSingleList205Sub">
<Description>
 ',' new_item_single
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..NewItemSingle(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NewItemVarlist">
<Description>
 new_item_varlist ::= '(' new_item_single_list ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..NewItemSingleList(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number">
<Description>
 number ::= ('regexp:[0-9]*' [ '.' 'regexp:[0-9]+'] [ ('e' | 'E' ) 'regexp:[0-9]+']) | ('.' 'regexp:[0-9]+' [ ('e' | 'E') 'regexp:[0-9]+'])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number107Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Number111Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number107Sub">
<Description>
'regexp:[0-9]*' [ '.' 'regexp:[0-9]+'] [ ('e' | 'E' ) 'regexp:[0-9]+']
summary values:REGEXP:[0-9]*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?4?
	; first rule summary P
	if '(..isStringSingle("REGEXP:[0-9]*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:[0-9]*")  {
		if ..Number108OptGrp(subElement,.addedElement)  {
			if ..Number109OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number108OptGrp">
<Description>

summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..addPunctuation(subElement,"regexp:[0-9]+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number109OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number110Sub(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"regexp:[0-9]+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number110Sub">
<Description>
'e' | 'E'
summary values:E,E</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("E","E"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"E")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Number111Sub">
<Description>
'.' 'regexp:[0-9]+' [ ('e' | 'E') 'regexp:[0-9]+']
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?4?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..addPunctuation(subElement,"regexp:[0-9]+")  {
			if ..Number112OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number112OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number113Sub(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"regexp:[0-9]+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number113Sub">
<Description>
'e' | 'E'
summary values:E,E</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("E","E"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"E")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectChain">
<Description>
 object_chain ::= '.' object_member_identifier [ function_parameter_list ] [ object_chain ]
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?&?4?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..ObjectMemberIdentifier(subElement,.addedElement)  {
			if $S(..FunctionParameterList(subElement,.addedElement) :1,1:1) {
				if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectChain99">
<Description>
 object_chain99 ::= '.' object_chain_item ( '.' object_chain_item )*
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..ObjectChainItem(subElement,.addedElement)  {
			if ..ObjectChain99105RepZero(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectChain99105RepZero">
<Description>
 ( '.' object_chain_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ObjectChain99106Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectChain99106Sub">
<Description>
 '.' object_chain_item
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..ObjectChainItem(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectChainItem">
<Description>
 object_chain_item ::= object_member_identifier [ function_parameter_list ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ObjectMemberIdentifier(subElement,.addedElement)  {
		if $S(..FunctionParameterList(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectChainNoDot">
<Description>
 object_chain_no_dot ::= object_member_identifier [ function_parameter_list ] [ object_chain ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ObjectMemberIdentifier(subElement,.addedElement)  {
		if $S(..FunctionParameterList(subElement,.addedElement) :1,1:1) {
			if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectDot">
<Description>
 object_dot ::= '.'
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectMemberIdentifier">
<Description>
 object_member_identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
summary values:REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectVariable">
<Description>
 object_variable ::= variable_identifier [ array_parameter_list ] object_chain</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..VariableIdentifier(subElement,.addedElement)  {
		if $S(..ArrayParameterList(subElement,.addedElement) :1,1:1) {
			if ..ObjectChain(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Offset">
<Description>
 offset ::= 'regexp:[0-9]+'
summary values:REGEXP:[0-9]+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:[0-9]+",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:[0-9]+")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OffsetSign">
<Description>
 offset_sign ::= '+' | '-'
summary values:+,-</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("+","-"),1,.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Oldintrinsicfncall">
<Description>
 OLDintrinsicfncall ::= case_function_call | select_function_call | extract_function_call | piece_function_call | listitem_function_call | listupdate_function_call | increment_function_call | method_function_call | classmethod_function_call | zobjmethod_function_call | zobjclassmethod_function_call | text_function_call | bitlogic_function_call | expression_function_call | ('$' identifier function_parameter_list [ object_chain ])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CaseFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SelectFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ExtractFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PieceFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ListitemFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ListupdateFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IncrementFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MethodFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassmethodFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZobjmethodFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZobjclassmethodFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TextFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BitlogicFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ExpressionFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Oldintrinsicfncall75Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Oldintrinsicfncall75Sub">
<Description>
'$' identifier function_parameter_list [ object_chain ]
summary values:$</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle("$",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"$")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..FunctionParameterList(subElement,.addedElement)  {
				if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldlockType">
<Description>
 OLDlock_type ::= '#' '"' ( 'S' | 'E' | 'I' | 'D' )* '"'
summary values:#</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("#",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"#")  {
		if ..addPunctuation(subElement,"""")  {
			if ..OldlockType195RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"""")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldlockType195RepZero">
<Description>
 ( 'S' | 'E' | 'I' | 'D' )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..OldlockType196Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OldlockType196Sub">
<Description>
 'S' | 'E' | 'I' | 'D'
summary values:S,E,I,D</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K
	if '(..isKeywordInList($lb("S","E","I","D"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"S")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"I")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"D")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OldthisObject">
<Description>
 oldthis_object ::= ('..' | 'i%' | 'r%' | '$this' | '##this') object_chain_item [ object_chain]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OldthisObject90Sub(subElement,.addedElement)  {
		if ..ObjectChainItem(subElement,.addedElement)  {
			if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldthisObject90Sub">
<Description>
'..' | 'i%' | 'r%' | '$this' | '##this'
summary values:..,I%,R%,$THIS,##THIS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P
	if '(..isStringInList($lb("..","I%","R%","$THIS","##THIS"),6,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"..")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"i%")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"r%")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"$this")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"##this")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OldthisObjectSet">
<Description>
 oldthis_object_set ::= ('..' | 'i%' | 'r%' | '$this' | '##this' ) object_chain_item [ object_chain]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OldthisObjectSet91Sub(subElement,.addedElement)  {
		if ..ObjectChainItem(subElement,.addedElement)  {
			if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldthisObjectSet91Sub">
<Description>
'..' | 'i%' | 'r%' | '$this' | '##this'
summary values:..,I%,R%,$THIS,##THIS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P
	if '(..isStringInList($lb("..","I%","R%","$THIS","##THIS"),6,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"..")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"i%")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"r%")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"$this")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"##this")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OneCosStatement">
<Description>
 one_cos_statement ::= [ label_definition ] ('.')* cos_command</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&(?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..LabelDefinition(subElement,.addedElement) :1,1:1) {
		if ..OneCosStatement9RepZero(subElement,.addedElement)  {
			if ..CosCommand(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneCosStatement10Sub">
<Description>
'.'
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,".")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OneCosStatement9RepZero">
<Description>
 ('.')*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..OneCosStatement10Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OneCosStatementSql">
<Description>
 one_cos_statement_sql ::= ('.')* cos_command</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneCosStatementSql11RepZero(subElement,.addedElement)  {
		if ..CosCommand(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneCosStatementSql11RepZero">
<Description>
 ('.')*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..OneCosStatementSql12Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OneCosStatementSql12Sub">
<Description>
'.'
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,".")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OneDeviceParameter">
<Description>
 one_device_parameter ::= text</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Text(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneOpenArgument">
<Description>
 one_open_argument ::= open_device [ ':' [ ( '(' open_device_parameters ')' ) | expression ] ] [ ':' open_timeout ] [ ':' open_mnemonic_space ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OpenDevice(subElement,.addedElement)  {
		if ..OneOpenArgument209OptGrp(subElement,.addedElement)  {
			if ..OneOpenArgument212OptGrp(subElement,.addedElement)  {
				if ..OneOpenArgument213OptGrp(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneOpenArgument209OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..OneOpenArgument210OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneOpenArgument210OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneOpenArgument211Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneOpenArgument211Sub">
<Description>
 '(' open_device_parameters ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..OpenDeviceParameters(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneOpenArgument212OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..OpenTimeout(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneOpenArgument213OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..OpenMnemonicSpace(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneOpenDeviceParameter">
<Description>
 one_open_device_parameter ::= ('/' identifier [ '=' open_expression_list ] ) | expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneOpenDeviceParameter216Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneOpenDeviceParameter216Sub">
<Description>
'/' identifier [ '=' open_expression_list ]
summary values:/</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle("/",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"/")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..OneOpenDeviceParameter217OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneOpenDeviceParameter217OptGrp">
<Description>

summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("=",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		if ..OpenExpressionList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneParameterValue">
<Description>
 one_parameter_value ::= ( [ '.' ] identifier ) | ( identifier '...' ) | expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneParameterValue87Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OneParameterValue88Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneParameterValue87Sub">
<Description>
 [ '.' ] identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addPunctuation(subElement,".") :1,1:1) {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneParameterValue88Sub">
<Description>
 identifier '...'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"...")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneUseArgument">
<Description>
 one_use_argument ::= use_device [ ':' ( use_device_parameters_inbrackets | use_device_parameters) ] [ ':' use_mnemonic_space ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UseDevice(subElement,.addedElement)  {
		if ..OneUseArgument248OptGrp(subElement,.addedElement)  {
			if ..OneUseArgument250OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneUseArgument248OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..OneUseArgument249Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneUseArgument249Sub">
<Description>
 use_device_parameters_inbrackets | use_device_parameters</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UseDeviceParametersInbrackets(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..UseDeviceParameters(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneUseArgument250OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..UseMnemonicSpace(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneUseDeviceParameter">
<Description>
 one_use_device_parameter ::= ('/' identifier [ '=' expression ] ) | expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneUseDeviceParameter253Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneUseDeviceParameter253Sub">
<Description>
'/' identifier [ '=' expression ]
summary values:/</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle("/",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"/")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..OneUseDeviceParameter254OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneUseDeviceParameter254OptGrp">
<Description>

summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("=",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneWriteArgument">
<Description>
 one_write_argument ::= expression | write_control_expression_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..WriteControlExpressionList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneXecuteArg">
<Description>
 one_xecute_arg ::= ( xecute_arg_with_params | xecute_arg_no_params ) [ post_conditional ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneXecuteArg282Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneXecuteArg282Sub">
<Description>
 xecute_arg_with_params | xecute_arg_no_params</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XecuteArgWithParams(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..XecuteArgNoParams(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneZallocatename">
<Description>
 one_zallocatename ::= zallocatename [ zallocate_type ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Zallocatename(subElement,.addedElement)  {
		if $S(..ZallocateType(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneZdeallocatename">
<Description>
 one_zdeallocatename ::= zdeallocatename [ zdeallocate_type ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Zdeallocatename(subElement,.addedElement)  {
		if $S(..ZdeallocateType(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenArguments">
<Description>
 open_arguments ::= one_open_argument ( ',' one_open_argument )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneOpenArgument(subElement,.addedElement)  {
		if ..OpenArguments207RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenArguments207RepZero">
<Description>
 ( ',' one_open_argument )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..OpenArguments208Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OpenArguments208Sub">
<Description>
 ',' one_open_argument
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..OneOpenArgument(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenBracket">
<Description>
 open_bracket ::= '('
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenCommand">
<Description>
 open_command ::= ('open' | 'o') [ post_conditional ] open_arguments</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OpenCommand206Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..OpenArguments(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenCommand206Sub">
<Description>
'open' | 'o'
summary values:OPEN,O</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("OPEN","O"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"OPEN")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"O")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OpenDevice">
<Description>
 open_device ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenDeviceParameters">
<Description>
 open_device_parameters ::= [one_open_device_parameter] ( ':'[ one_open_device_parameter] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..OneOpenDeviceParameter(subElement,.addedElement) :1,1:1) {
		if ..OpenDeviceParameters214RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenDeviceParameters214RepZero">
<Description>
 ( ':'[ one_open_device_parameter] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..OpenDeviceParameters215Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OpenDeviceParameters215Sub">
<Description>
 ':'[ one_open_device_parameter]
summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if $S(..OneOpenDeviceParameter(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenExpressionList">
<Description>
 open_expression_list ::= (variable '...') | expression_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OpenExpressionList218Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ExpressionList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenExpressionList218Sub">
<Description>
variable '...'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Variable(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"...")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenMnemonicSpace">
<Description>
 open_mnemonic_space ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenTimeout">
<Description>
 open_timeout ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterList">
<Description>
 parameter_list ::= '(' [ parameter_values ] ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if $S(..ParameterValues(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterValues">
<Description>
 parameter_values ::= one_parameter_value ( ',' [ one_parameter_value ] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneParameterValue(subElement,.addedElement)  {
		if ..ParameterValues85RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterValues85RepZero">
<Description>
 ( ',' [ one_parameter_value ] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ParameterValues86Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterValues86Sub">
<Description>
 ',' [ one_parameter_value ]
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if $S(..OneParameterValue(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatch">
<Description>
 pattern_match ::= ( "?" | "'?" ) (pattern_match_combo )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PatternMatch55Sub(subElement,.addedElement)  {
		if ..PatternMatch56RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatch55Sub">
<Description>
 "?" | "'?"
summary values:?,'?</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("?","'?"),2,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"?")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'?")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatch56RepZero">
<Description>
 (pattern_match_combo )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..PatternMatch57Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatch57Sub">
<Description>
pattern_match_combo</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PatternMatchCombo(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatchAlternating">
<Description>
 pattern_match_alternating ::= '(' ( pattern_match_combo ( ',' pattern_match_combo )* )')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..PatternMatchAlternating59Sub(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatchAlternating59Sub">
<Description>
 pattern_match_combo ( ',' pattern_match_combo )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PatternMatchCombo(subElement,.addedElement)  {
		if ..PatternMatchAlternating60RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatchAlternating60RepZero">
<Description>
 ( ',' pattern_match_combo )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..PatternMatchAlternating61Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatchAlternating61Sub">
<Description>
 ',' pattern_match_combo
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..PatternMatchCombo(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatchCode">
<Description>
 pattern_match_code ::= 'a' | 'c' | 'e' | 'l' | 'n' | 'p' | 'u' | 'b' | 'm' | 'ZFWCHARZ' | 'ZHWKATAZ' | string</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K|K|K|K|K|K|K|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"A")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"C")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"L")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"N")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"P")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"U")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"B")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"M")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZFWCHARZ")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZHWKATAZ")  {
		set done=1 ; or
	} elseif ..String(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatchCombo">
<Description>
 pattern_match_combo ::= pattern_match_repeat ( pattern_match_code | pattern_match_alternating )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PatternMatchRepeat(subElement,.addedElement)  {
		if ..PatternMatchCombo58Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatchCombo58Sub">
<Description>
 pattern_match_code | pattern_match_alternating</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PatternMatchCode(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PatternMatchAlternating(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatchRepeat">
<Description>
 pattern_match_repeat ::= ('regexp:[0-9]*' [ '.' [ 'regexp:[0-9]*' ] ]) | ('.' ['regexp:[0-9]*'])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PatternMatchRepeat62Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PatternMatchRepeat64Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatchRepeat62Sub">
<Description>
'regexp:[0-9]*' [ '.' [ 'regexp:[0-9]*' ] ]
summary values:REGEXP:[0-9]*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle("REGEXP:[0-9]*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:[0-9]*")  {
		if ..PatternMatchRepeat63OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatchRepeat63OptGrp">
<Description>

summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if $S(..addPunctuation(subElement,"regexp:[0-9]*") :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternMatchRepeat64Sub">
<Description>
'.' ['regexp:[0-9]*']
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if $S(..addPunctuation(subElement,"regexp:[0-9]*") :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PieceFunctionCall">
<Description>
 piece_function_call ::= ('piece' | 'p') open_bracket expression ',' expression [ ',' star_parameter [ ',' star_parameter ] ] close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?&P&?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PieceFunctionCall327Sub(subElement,.addedElement)  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..Expression(subElement,.addedElement)  {
				if ..addPunctuation(subElement,",")  {
					if ..Expression(subElement,.addedElement)  {
						if ..PieceFunctionCall328OptGrp(subElement,.addedElement)  {
							if ..CloseBracket(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PieceFunctionCall327Sub">
<Description>
'piece' | 'p'
summary values:PIECE,P</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("PIECE","P"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"PIECE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"P")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="PieceFunctionCall328OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..StarParameter(subElement,.addedElement)  {
			if ..PieceFunctionCall329OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PieceFunctionCall329OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..StarParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PieceFunctionCallSet">
<Description>
 piece_function_call_set ::= ('piece' | 'p') open_bracket set_value_expression ',' expression [ ',' star_parameter [ ',' star_parameter ] ] close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?&P&?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PieceFunctionCallSet330Sub(subElement,.addedElement)  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..SetValueExpression(subElement,.addedElement)  {
				if ..addPunctuation(subElement,",")  {
					if ..Expression(subElement,.addedElement)  {
						if ..PieceFunctionCallSet331OptGrp(subElement,.addedElement)  {
							if ..CloseBracket(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PieceFunctionCallSet330Sub">
<Description>
'piece' | 'p'
summary values:PIECE,P</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("PIECE","P"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"PIECE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"P")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="PieceFunctionCallSet331OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..StarParameter(subElement,.addedElement)  {
			if ..PieceFunctionCallSet332OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PieceFunctionCallSet332OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..StarParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PostConditional">
<Description>
 post_conditional ::= ':' expression
summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary">
<Description>
 primary ::= number | string | macrocall | macro_expression | this_object | extrinsicfncall | intrinsicfncall | classexpr | variable | special_variable | Indirection | global_ref | ( sub_expression [ object_chain ] ) | (cos_json [ object_chain ])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Macrocall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MacroExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ThisObject(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Extrinsicfncall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Intrinsicfncall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Classexpr(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Variable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SpecialVariable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Indirection(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GlobalRef(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary99Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary100Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary100Sub">
<Description>
cos_json [ object_chain ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosJson(subElement,.addedElement)  {
		if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary99Sub">
<Description>
 sub_expression [ object_chain ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SubExpression(subElement,.addedElement)  {
		if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PrintCommand">
<Description>
 print_command ::= 'print' [ post_conditional ] [ lineref1 [ ':' lineref2 ] ]
summary values:PRINT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("PRINT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PRINT")  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..PrintCommand219OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PrintCommand219OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Lineref1(subElement,.addedElement)  {
		if ..PrintCommand220OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PrintCommand220OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..Lineref2(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PythonImport">
<Description>
 python_import ::= 'system' '.' 'python' '.' 'import' '(' string ')'
summary values:SYSTEM</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&K&P&K&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("SYSTEM"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SYSTEM")  {
		if ..addPunctuation(subElement,".")  {
			if ..addKeyword(subElement,"PYTHON")  {
				if ..addPunctuation(subElement,".")  {
					if ..addKeyword(subElement,"IMPORT")  {
						if ..addPunctuation(subElement,"(")  {
							if ..String(subElement,.addedElement)  {
								if ..addPunctuation(subElement,")")  {
									set done=1 ; end compileRules
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QuitCommand">
<Description>
 quit_command ::= ('quit' | 'q') [ post_conditional ] ( naked | [ quit_expression ])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..QuitCommand222Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..QuitCommand223Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QuitCommand222Sub">
<Description>
'quit' | 'q'
summary values:QUIT,Q</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("QUIT","Q"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"QUIT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"Q")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="QuitCommand223Sub">
<Description>
 naked | [ quit_expression ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Naked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif $S(..QuitExpression(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QuitExpression">
<Description>
 quit_expression ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadArgument">
<Description>
 read_argument ::= read_format_character | read_prompt | read_single_char | read_length</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ReadFormatCharacter(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ReadPrompt(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ReadSingleChar(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ReadLength(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadCommand">
<Description>
 read_command ::= ('read' | 'r') [ post_conditional ] read_argument ( ',' read_argument )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ReadCommand267Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..ReadArgument(subElement,.addedElement)  {
				if ..ReadCommand268RepZero(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadCommand267Sub">
<Description>
'read' | 'r'
summary values:READ,R</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("READ","R"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"READ")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"R")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ReadCommand268RepZero">
<Description>
 ( ',' read_argument )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ReadCommand269Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ReadCommand269Sub">
<Description>
 ',' read_argument
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ReadArgument(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadFormatCharacter">
<Description>
 read_format_character ::= '!' | '#' | ('?' expression) | ('/' read_keyword [ '(' read_keyword_parameters ')' ])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"!")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"#")  {
		set done=1 ; or
	} elseif ..ReadFormatCharacter271Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ReadFormatCharacter272Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadFormatCharacter271Sub">
<Description>
'?' expression
summary values:?</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("?",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"?")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadFormatCharacter272Sub">
<Description>
'/' read_keyword [ '(' read_keyword_parameters ')' ]
summary values:/</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle("/",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"/")  {
		if ..ReadKeyword(subElement,.addedElement)  {
			if ..ReadFormatCharacter273OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadFormatCharacter273OptGrp">
<Description>

summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..ReadKeywordParameters(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadFormatCharacterSet">
<Description>
 read_format_character_set ::= read_format_character+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)+
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ReadFormatCharacterSet270RepOne(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadFormatCharacterSet270RepOne">
<Description>
 read_format_character+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ReadFormatCharacter(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ReadKeyword">
<Description>
 read_keyword ::= text</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Text(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadKeywordParameter">
<Description>
 read_keyword_parameter ::= text</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Text(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadKeywordParameters">
<Description>
 read_keyword_parameters ::= read_keyword_parameter ( ',' read_keyword_parameter )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ReadKeywordParameter(subElement,.addedElement)  {
		if ..ReadKeywordParameters274RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadKeywordParameters274RepZero">
<Description>
 ( ',' read_keyword_parameter )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ReadKeywordParameters275Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ReadKeywordParameters275Sub">
<Description>
 ',' read_keyword_parameter
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ReadKeywordParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadLength">
<Description>
 read_length ::= lvalue_expression [ '#' expression ] [ ':' expression ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LvalueExpression(subElement,.addedElement)  {
		if ..ReadLength277OptGrp(subElement,.addedElement)  {
			if ..ReadLength278OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadLength277OptGrp">
<Description>

summary values:#</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("#",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"#")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadLength278OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadPrompt">
<Description>
 read_prompt ::= string</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadSingleChar">
<Description>
 read_single_char ::= '*' lvalue_expression [ ':' expression ]
summary values:*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle("*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		if ..LvalueExpression(subElement,.addedElement)  {
			if ..ReadSingleChar276OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReadSingleChar276OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReturnCommand">
<Description>
 return_command ::= 'return' [ post_conditional ] [ naked | expression ]
summary values:RETURN</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("RETURN"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"RETURN")  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..ReturnCommand224OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReturnCommand224OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Naked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RoutineEnv">
<Description>
 routine_env ::= '|' [ expression ] '|'
summary values:|</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("|",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"|")  {
		if $S(..Expression(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,"|")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RoutineIdentifier">
<Description>
 routine_identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
summary values:REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SafeexpressionFunctionCall">
<Description>
 safeexpression_function_call ::= '##safeexpression' function_parameter_list
summary values:##SAFEEXPRESSION</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("##SAFEEXPRESSION",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"##safeexpression")  {
		if ..FunctionParameterList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectClause">
<Description>
 select_clause ::= expression ':' expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,":")  {
			if ..Expression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectClauseDefault">
<Description>
 select_clause_default ::= '1' ':' expression
summary values:1</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("1",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"1")  {
		if ..addPunctuation(subElement,":")  {
			if ..Expression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectClauses">
<Description>
 select_clauses ::= select_clause ( ',' select_clause )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SelectClause(subElement,.addedElement)  {
		if ..SelectClauses358RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectClauses358RepZero">
<Description>
 ( ',' select_clause )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SelectClauses359Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SelectClauses359Sub">
<Description>
 ',' select_clause
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SelectClause(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectFunctionCall">
<Description>
 select_function_call ::= ('select' | 's') '(' select_clauses ')' [ object_chain ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?&P&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SelectFunctionCall357Sub(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"(")  {
			if ..SelectClauses(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectFunctionCall357Sub">
<Description>
'select' | 's'
summary values:SELECT,S</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("SELECT","S"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"SELECT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"S")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SetCommand">
<Description>
 set_command ::= ('set' | 's') [ post_conditional ] set_item_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetCommand225Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..SetItemList(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetCommand225Sub">
<Description>
'set' | 's'
summary values:SET,S</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("SET","S"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"SET")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"S")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SetExpression">
<Description>
 set_expression ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItem">
<Description>
 set_item ::= (( set_value_expression | ('(' set_value_expression ( ',' set_value_expression )* ')' )) '=' set_expression) | simple_indirection</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetItem230Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SimpleIndirection(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItem230Sub">
<Description>
( set_value_expression | ('(' set_value_expression ( ',' set_value_expression )* ')' )) '=' set_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetItem231Sub(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"=")  {
			if ..SetExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItem231Sub">
<Description>
 set_value_expression | ('(' set_value_expression ( ',' set_value_expression )* ')' )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetValueExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SetItem232Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItem232Sub">
<Description>
'(' set_value_expression ( ',' set_value_expression )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..SetValueExpression(subElement,.addedElement)  {
			if ..SetItem233RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItem233RepZero">
<Description>
 ( ',' set_value_expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SetItem234Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SetItem234Sub">
<Description>
 ',' set_value_expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SetValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItemList">
<Description>
 set_item_list ::= set_item ( ',' set_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetItem(subElement,.addedElement)  {
		if ..SetItemList226RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItemList226RepZero">
<Description>
 ( ',' set_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SetItemList227Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SetItemList227Sub">
<Description>
 ',' set_item
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SetItem(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItemOld">
<Description>
 set_item_old ::= (( set_item_single | set_item_varlist ) '=' expression) | simple_indirection</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetItemOld228Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SimpleIndirection(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItemOld228Sub">
<Description>
( set_item_single | set_item_varlist ) '=' expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetItemOld229Sub(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"=")  {
			if ..Expression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItemOld229Sub">
<Description>
 set_item_single | set_item_varlist</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetItemSingle(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SetItemVarlist(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItemSingle">
<Description>
 set_item_single ::= lvalue_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LvalueExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItemSingleList">
<Description>
 set_item_single_list ::= set_item_single ( ',' set_item_single )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetItemSingle(subElement,.addedElement)  {
		if ..SetItemSingleList235RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItemSingleList235RepZero">
<Description>
 ( ',' set_item_single )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SetItemSingleList236Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SetItemSingleList236Sub">
<Description>
 ',' set_item_single
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SetItemSingle(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItemVarlist">
<Description>
 set_item_varlist ::= '(' set_item_single_list ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..SetItemSingleList(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetValueExpression">
<Description>
 set_value_expression ::= this_object_set | variable_set | macrocall | Indirection | global_ref_set | intrinsicfncall_set | special_variable | ( '(' set_value_expression ')' [ object_chain ] )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ThisObjectSet(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..VariableSet(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Macrocall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Indirection(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GlobalRefSet(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IntrinsicfncallSet(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SpecialVariable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SetValueExpression237Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetValueExpression237Sub">
<Description>
 '(' set_value_expression ')' [ object_chain ]
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P&?4?
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..SetValueExpression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleIndirection">
<Description>
 Simple_Indirection ::= '@' term
summary values:@</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("@",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"@")  {
		if ..Term(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SpecialIntrinsic">
<Description>
 special_intrinsic ::= case_function_call | select_function_call | extract_function_call | piece_function_call | listitem_function_call | listupdate_function_call | increment_function_call | method_function_call | classmethod_function_call | zobjmethod_function_call | zobjclassmethod_function_call | text_function_call | bitlogic_function_call</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CaseFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SelectFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ExtractFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PieceFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ListitemFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ListupdateFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IncrementFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MethodFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassmethodFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZobjmethodFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ZobjclassmethodFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TextFunctionCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BitlogicFunctionCall(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SpecialIntrinsicSet">
<Description>
 special_intrinsic_set ::= extract_function_call_set | piece_function_call_set | listitem_function_call_set | listbuild_function_call_set</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExtractFunctionCallSet(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PieceFunctionCallSet(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ListitemFunctionCallSet(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ListbuildFunctionCallSet(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SpecialVariable">
<Description>
 special_variable ::= '$' ('DEVICE' | 'ECODE' | 'EC' | 'ESTACK' | 'ES' | 'ETRAP' | 'ET' | 'HALT' | 'HOROLOG' | 'H' | 'IO' | 'I' | 'JOB' | 'J' | 'KEY' | 'NAMESPACE' | 'PRINCIPAL' | 'P' | 'QUIT' | 'ROLES' | 'STACK' | 'STORAGE' | python_import | ('SYSTEM' [ object_chain ]) | 'S' | 'TEST' | 'THIS' | 'THROWOBJ' | 'TLEVEL' | 'Tl' | 'T' | 'USERNAME' | 'X' | 'Y' | 'ZA' | 'ZB' | 'ZCHILD' | 'ZEOF' | 'ZEOS' | 'ZERROR' | 'ZE' | 'ZHOROLOG' | 'ZH' | 'ZIO' | 'ZJOB' | 'ZMODE' | 'ZNAME' | 'ZNSPACE' | 'ZN' | 'ZORDER' | 'ZPARENT' | 'ZPI' | 'ZPOS' | 'ZREFERENCE' | 'ZR' | 'ZSTORAGE' | 'ZS' | 'ZTIMESTAMP' | 'ZTS' | 'ZTIMEZONE' | 'ZTRAP' | 'ZT' | 'ZUTIL' | 'ZU' | 'ZVERSION' | 'ZV' )
summary values:$</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("$",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"$")  {
		if ..SpecialVariable101Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SpecialVariable101Sub">
<Description>
'DEVICE' | 'ECODE' | 'EC' | 'ESTACK' | 'ES' | 'ETRAP' | 'ET' | 'HALT' | 'HOROLOG' | 'H' | 'IO' | 'I' | 'JOB' | 'J' | 'KEY' | 'NAMESPACE' | 'PRINCIPAL' | 'P' | 'QUIT' | 'ROLES' | 'STACK' | 'STORAGE' | python_import | ('SYSTEM' [ object_chain ]) | 'S' | 'TEST' | 'THIS' | 'THROWOBJ' | 'TLEVEL' | 'Tl' | 'T' | 'USERNAME' | 'X' | 'Y' | 'ZA' | 'ZB' | 'ZCHILD' | 'ZEOF' | 'ZEOS' | 'ZERROR' | 'ZE' | 'ZHOROLOG' | 'ZH' | 'ZIO' | 'ZJOB' | 'ZMODE' | 'ZNAME' | 'ZNSPACE' | 'ZN' | 'ZORDER' | 'ZPARENT' | 'ZPI' | 'ZPOS' | 'ZREFERENCE' | 'ZR' | 'ZSTORAGE' | 'ZS' | 'ZTIMESTAMP' | 'ZTS' | 'ZTIMEZONE' | 'ZTRAP' | 'ZT' | 'ZUTIL' | 'ZU' | 'ZVERSION' | 'ZV'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|?1Rule?|?1Rule?|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DEVICE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ECODE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"EC")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ESTACK")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ES")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ETRAP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ET")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"HALT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"HOROLOG")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"H")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"IO")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"I")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"JOB")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"J")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"KEY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NAMESPACE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"PRINCIPAL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"P")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"QUIT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ROLES")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"STACK")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"STORAGE")  {
		set done=1 ; or
	} elseif ..PythonImport(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SpecialVariable102Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"S")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TEST")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"THIS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"THROWOBJ")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TLEVEL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"T")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"USERNAME")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"X")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"Y")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZA")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZB")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZCHILD")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZEOF")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZEOS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZERROR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZHOROLOG")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZH")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZIO")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZJOB")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZMODE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZNAME")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZNSPACE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZN")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZORDER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZPARENT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZPI")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZPOS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZREFERENCE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZSTORAGE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZTIMESTAMP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZTS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZTIMEZONE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZTRAP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZUTIL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZU")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZVERSION")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZV")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SpecialVariable102Sub">
<Description>
'SYSTEM' [ object_chain ]
summary values:SYSTEM</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("SYSTEM"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SYSTEM")  {
		if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlBody">
<Description>
 sql_body ::= 'NEED SQL BODY'
summary values:NEED SQL BODY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED SQL BODY",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED SQL BODY")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlCommand">
<Description><![CDATA[
 sql_command ::= '&sql(' sql_body ')'
summary values:&SQL(]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("&SQL(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"&sql(")  {
		if ..SqlBody(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarParameter">
<Description>
 star_parameter ::= ('*' [expression]) | expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StarParameter354Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarParameter354Sub">
<Description>
'*' [expression]
summary values:*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle("*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		if $S(..Expression(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="String">
<Description>
 string ::= '""' | ('"' 'regexp:[^\"\r\n]*' '"')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"""""")  {
		set done=1 ; or
	} elseif ..String114Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="String114Sub">
<Description>
'"' 'regexp:[^\"\r\n]*' '"'
summary values:""</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&P
	; first rule summary P
	if '(..isStringSingle("""",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"""")  {
		if ..addPunctuation(subElement,"regexp:[^\""\r\n]*")  {
			if ..addPunctuation(subElement,"""")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SubExpression">
<Description>
 sub_expression ::= '(' expression ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..Expression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SubscriptIndirection">
<Description>
 Subscript_Indirection ::= '@' term '@' subscript_parameter_list
summary values:@</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("@",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"@")  {
		if ..Term(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"@")  {
				if ..SubscriptParameterList(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SubscriptParameterList">
<Description>
 subscript_parameter_list ::= '(' expression ( ',' expression )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..Expression(subElement,.addedElement)  {
			if ..SubscriptParameterList94RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SubscriptParameterList94RepZero">
<Description>
 ( ',' expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SubscriptParameterList95Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SubscriptParameterList95Sub">
<Description>
 ',' expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SuperExpression">
<Description>
 super_expression ::= '##super' function_parameter_list
summary values:##SUPER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("##SUPER",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"##super")  {
		if ..FunctionParameterList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SystemObject">
<Description>
 system_object ::='$system.' object_chain_item [ object_chain ]
summary values:$SYSTEM.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle("$SYSTEM.",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"$system.")  {
		if ..ObjectChainItem(subElement,.addedElement)  {
			if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TcommitCommand">
<Description>
 tcommit_command ::= ('tcommit' | 'tc') [ post_conditional ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TcommitCommand238Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TcommitCommand238Sub">
<Description>
'tcommit' | 'tc'
summary values:TCOMMIT,TC</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("TCOMMIT","TC"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"TCOMMIT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TC")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Term">
<Description>
 term ::= primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Primary(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Text">
<Description>
 text ::= 'regexp:.*'
summary values:REGEXP:.*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:.*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:.*")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TextFunctionCall">
<Description>
 text_function_call ::= ('text') open_bracket label_reference close_bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TextFunctionCall353Sub(subElement,.addedElement)  {
		if ..OpenBracket(subElement,.addedElement)  {
			if ..LabelReference(subElement,.addedElement)  {
				if ..CloseBracket(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TextFunctionCall353Sub">
<Description>
'text'
summary values:TEXT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("TEXT"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"TEXT")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="TextToEol">
<Description>
 text_to_eol ::= 'regexp:[^\r\n]*'
summary values:REGEXP:[^\R\N]*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:[^\R\N]*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:[^\r\n]*")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TextToEolContinue">
<Description>
 text_to_eol_continue ::= 'regexp:[^\r\n]*'
summary values:REGEXP:[^\R\N]*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:[^\R\N]*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:[^\r\n]*")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ThenBlock">
<Description>
 then_block ::= ( '{' [ cos_code_block ] '}' ) | command_list_eol</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ThenBlock157Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CommandListEol(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ThenBlock157Sub">
<Description>
 '{' [ cos_code_block ] '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if $S(..CosCodeBlock(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ThisObject">
<Description>
 this_object ::= this_object_self | this_object_this</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ThisObjectSelf(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ThisObjectThis(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ThisObjectDirectProperty">
<Description>
 this_object_direct_property ::= 'i%' object_chain_item
summary values:I%</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("I%",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"i%")  {
		if ..ObjectChainItem(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ThisObjectSelf">
<Description>
 this_object_self ::= ('..' | 'i%' | 'r%' | 'm%' | 's%') [object_chain_no_dot]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ThisObjectSelf92Sub(subElement,.addedElement)  {
		if $S(..ObjectChainNoDot(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ThisObjectSelf92Sub">
<Description>
'..' | 'i%' | 'r%' | 'm%' | 's%'
summary values:..,I%,R%,M%,S%</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P
	if '(..isStringInList($lb("..","I%","R%","M%","S%"),2,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"..")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"i%")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"r%")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"m%")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"s%")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ThisObjectSet">
<Description>
 this_object_set ::= this_object_self | this_object_this</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ThisObjectSelf(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ThisObjectThis(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ThisObjectThis">
<Description>
 this_object_this ::= ('$this' | '##this') [ object_chain]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ThisObjectThis93Sub(subElement,.addedElement)  {
		if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ThisObjectThis93Sub">
<Description>
'$this' | '##this'
summary values:$THIS,##THIS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("$THIS","##THIS"),6,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"$this")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"##this")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ThrowCommand">
<Description>
 throw_command ::= 'throw' [ post_conditional ] [ naked | expression ]
summary values:THROW</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("THROW"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"THROW")  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..ThrowCommand239OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ThrowCommand239OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Naked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TrollbackCommand">
<Description>
 trollback_command ::= 'trollback' [ post_conditional ] [ '1' ]
summary values:TROLLBACK</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("TROLLBACK"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"TROLLBACK")  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if $S(..addPunctuation(subElement,"1") :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TryCommand">
<Description>
 try_command ::= 'try' '{' [ cos_code_block ] '}' (cos_directive)* 'catch' [ identifier | ( '(' identifier ')' ) ] '{' [ cos_code_block ] '}'
summary values:TRY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?4?&P&(?4?)*&K&?4?&P&?4?&P
	; first rule summary K
	if '(..isKeywordInList($lb("TRY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"TRY")  {
		if ..addPunctuation(subElement,"{")  {
			if $S(..CosCodeBlock(subElement,.addedElement) :1,1:1) {
				if ..addPunctuation(subElement,"}")  {
					if ..TryCommand240RepZero(subElement,.addedElement)  {
						if ..addKeyword(subElement,"CATCH")  {
							if ..TryCommand242OptGrp(subElement,.addedElement)  {
								if ..addPunctuation(subElement,"{")  {
									if $S(..CosCodeBlock(subElement,.addedElement) :1,1:1) {
										if ..addPunctuation(subElement,"}")  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TryCommand240RepZero">
<Description>
 (cos_directive)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..TryCommand241Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="TryCommand241Sub">
<Description>
cos_directive</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosDirective(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TryCommand242OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TryCommand243Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TryCommand243Sub">
<Description>
 '(' identifier ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TstartCommand">
<Description>
 tstart_command ::= ('tstart' | 'ts' ) [ post_conditional ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TstartCommand244Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TstartCommand244Sub">
<Description>
'tstart' | 'ts'
summary values:TSTART,TS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("TSTART","TS"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"TSTART")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TS")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UseArguments">
<Description>
 use_arguments ::= one_use_argument ( ',' one_use_argument )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneUseArgument(subElement,.addedElement)  {
		if ..UseArguments246RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UseArguments246RepZero">
<Description>
 ( ',' one_use_argument )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..UseArguments247Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UseArguments247Sub">
<Description>
 ',' one_use_argument
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..OneUseArgument(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UseCommand">
<Description>
 use_command ::= ('use' | 'u') [ post_conditional ] use_arguments</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UseCommand245Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..UseArguments(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UseCommand245Sub">
<Description>
'use' | 'u'
summary values:USE,U</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("USE","U"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"USE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"U")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UseDevice">
<Description>
 use_device ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UseDeviceParameters">
<Description>
 use_device_parameters ::= [one_use_device_parameter] ( ':' [one_use_device_parameter] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..OneUseDeviceParameter(subElement,.addedElement) :1,1:1) {
		if ..UseDeviceParameters251RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UseDeviceParameters251RepZero">
<Description>
 ( ':' [one_use_device_parameter] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..UseDeviceParameters252Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UseDeviceParameters252Sub">
<Description>
 ':' [one_use_device_parameter]
summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if $S(..OneUseDeviceParameter(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UseDeviceParametersInbrackets">
<Description>
 use_device_parameters_inbrackets ::= '(' use_device_parameters ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..UseDeviceParameters(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UseMnemonicSpace">
<Description>
 use_mnemonic_space ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Variable">
<Description>
 variable ::= variable_identifier [ array_parameter_list ] [ object_chain ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..VariableIdentifier(subElement,.addedElement)  {
		if $S(..ArrayParameterList(subElement,.addedElement) :1,1:1) {
			if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="VariableIdentifier">
<Description>
 variable_identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
summary values:REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="VariableSet">
<Description>
 variable_set ::= variable_identifier [ array_parameter_list ] [ object_chain ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..VariableIdentifier(subElement,.addedElement)  {
		if $S(..ArrayParameterList(subElement,.addedElement) :1,1:1) {
			if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ViewBlockForm">
<Description>
 view_block_form ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ViewCommand">
<Description>
 view_command ::= ('view' | 'v') [ post_conditional ] ( view_offset_form | view_block_form )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ViewCommand255Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..ViewCommand256Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ViewCommand255Sub">
<Description>
'view' | 'v'
summary values:VIEW,V</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("VIEW","V"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"VIEW")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"V")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ViewCommand256Sub">
<Description>
 view_offset_form | view_block_form</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ViewOffsetForm(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ViewBlockForm(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ViewLength">
<Description>
 view_length ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ViewMode">
<Description>
 view_mode ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ViewNewvalue">
<Description>
 view_newvalue ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ViewOffset">
<Description>
 view_offset ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ViewOffsetForm">
<Description>
 view_offset_form ::= view_offset ':' view_mode ':' view_length ':' view_newvalue</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?&P&?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ViewOffset(subElement,.addedElement)  {
		if ..addPunctuation(subElement,":")  {
			if ..ViewMode(subElement,.addedElement)  {
				if ..addPunctuation(subElement,":")  {
					if ..ViewLength(subElement,.addedElement)  {
						if ..addPunctuation(subElement,":")  {
							if ..ViewNewvalue(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WhileCommand">
<Description>
 while_command ::= 'while' expression_list '{' [ cos_code_block ] '}'
summary values:WHILE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&P&?4?&P
	; first rule summary K
	if '(..isKeywordInList($lb("WHILE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WHILE")  {
		if ..ExpressionList(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"{")  {
				if $S(..CosCodeBlock(subElement,.addedElement) :1,1:1) {
					if ..addPunctuation(subElement,"}")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Whitespace">
<Description>
 whitespace ::= ( [ comment ] [ ( ' ' | '\t' | '\r') ] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Whitespace47RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Whitespace47RepZero">
<Description>
 ( [ comment ] [ ( ' ' | '\t' | '\r') ] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Whitespace48Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Whitespace48Sub">
<Description>
 [ comment ] [ ( ' ' | '\t' | '\r') ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Comment(subElement,.addedElement) :1,1:1) {
		if $S(..Whitespace49Sub(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Whitespace49Sub">
<Description>
 ' ' | '\t' | '\r'
summary values: ,\T,\R</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P
	if '(..isStringInList($lb(" ","\T","\R"),2,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement," ")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"\t")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"\r")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="WriteArgumentList">
<Description>
 write_argument_list ::= one_write_argument ( ',' one_write_argument)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneWriteArgument(subElement,.addedElement)  {
		if ..WriteArgumentList258RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteArgumentList258RepZero">
<Description>
 ( ',' one_write_argument)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..WriteArgumentList259Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="WriteArgumentList259Sub">
<Description>
 ',' one_write_argument
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..OneWriteArgument(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteBangExpression">
<Description>
 write_bang_expression ::= '!'
summary values:!</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("!",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"!")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteCommand">
<Description>
 write_command ::= ('write' | 'w') [ post_conditional ] [ write_argument_list ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..WriteCommand257Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if $S(..WriteArgumentList(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteCommand257Sub">
<Description>
'write' | 'w'
summary values:WRITE,W</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("WRITE","W"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"WRITE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"W")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="WriteControlExpression">
<Description>
 write_control_expression ::= write_format_expression | write_device_expression | write_escape_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..WriteFormatExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..WriteDeviceExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..WriteEscapeExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteControlExpressionList">
<Description>
 write_control_expression_list ::= write_control_expression (write_control_expression)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..WriteControlExpression(subElement,.addedElement)  {
		if ..WriteControlExpressionList260RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteControlExpressionList260RepZero">
<Description>
 (write_control_expression)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..WriteControlExpressionList261Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="WriteControlExpressionList261Sub">
<Description>
write_control_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..WriteControlExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteDeviceExpression">
<Description>
 write_device_expression ::= '*-' expression
summary values:*-</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("*-",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*-")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteEscapeExpression">
<Description>
 write_escape_expression ::= '*' expression
summary values:*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteFormatExpression">
<Description>
 write_format_expression ::= write_bang_expression | write_hash_expression | write_pos_expression | write_mnemonic_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..WriteBangExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..WriteHashExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..WritePosExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..WriteMnemonicExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteHashExpression">
<Description>
 write_hash_expression ::= '#'
summary values:#</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("#",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"#")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteMnemonicExpression">
<Description>
 write_mnemonic_expression ::= '/' identifier [ '(' mnemonic_arguments* ')' ]
summary values:/</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle("/",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"/")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..WriteMnemonicExpression262OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteMnemonicExpression262OptGrp">
<Description>

summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..WriteMnemonicExpression263RepZero(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WriteMnemonicExpression263RepZero">
<Description>
 mnemonic_arguments*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..MnemonicArguments(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="WritePosExpression">
<Description>
 write_pos_expression ::= '?' expression
summary values:?</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("?",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"?")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteArgNoParams">
<Description>
 xecute_arg_no_params ::= xecute_command_text</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XecuteCommandText(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteArgWithParams">
<Description>
 xecute_arg_with_params ::= '(' xecute_command_text ',' xecute_param_list ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..XecuteCommandText(subElement,.addedElement)  {
			if ..addPunctuation(subElement,",")  {
				if ..XecuteParamList(subElement,.addedElement)  {
					if ..addPunctuation(subElement,")")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteArgs">
<Description>
 xecute_args ::= one_xecute_arg ( ',' one_xecute_arg )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneXecuteArg(subElement,.addedElement)  {
		if ..XecuteArgs280RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteArgs280RepZero">
<Description>
 ( ',' one_xecute_arg )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..XecuteArgs281Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteArgs281Sub">
<Description>
 ',' one_xecute_arg
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..OneXecuteArg(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteCommand">
<Description>
 xecute_command ::= ( 'xecute' | 'x') [ post_conditional ] xecute_args</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XecuteCommand279Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..XecuteArgs(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteCommand279Sub">
<Description>
 'xecute' | 'x'
summary values:XECUTE,X</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("XECUTE","X"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"XECUTE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"X")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteCommandText">
<Description>
 xecute_command_text ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteParamList">
<Description>
 xecute_param_list ::= xecute_parameter ( ',' xecute_parameter )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XecuteParameter(subElement,.addedElement)  {
		if ..XecuteParamList283RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteParamList283RepZero">
<Description>
 ( ',' xecute_parameter )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..XecuteParamList284Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteParamList284Sub">
<Description>
 ',' xecute_parameter
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..XecuteParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteParameter">
<Description>
 xecute_parameter ::= ('.' variable ) | expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XecuteParameter285Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XecuteParameter285Sub">
<Description>
'.' variable
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..Variable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocateCommand">
<Description>
 zallocate_command ::= 'zallocate' [post_conditional ] [ zallocate_parameter ( ',' zallocate_parameter)* ] [ else_block ]
summary values:ZALLOCATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?4?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("ZALLOCATE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZALLOCATE")  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..ZallocateCommand286OptGrp(subElement,.addedElement)  {
				if $S(..ElseBlock(subElement,.addedElement) :1,1:1) {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocateCommand286OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ZallocateParameter(subElement,.addedElement)  {
		if ..ZallocateCommand287RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocateCommand287RepZero">
<Description>
 ( ',' zallocate_parameter)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ZallocateCommand288Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocateCommand288Sub">
<Description>
 ',' zallocate_parameter
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ZallocateParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocateParameter">
<Description>
 zallocate_parameter ::= [ '+' | '-' ] zallocatename_list [ zallocate_timeout ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ZallocateParameter289OptGrp(subElement,.addedElement)  {
		if ..ZallocatenameList(subElement,.addedElement)  {
			if $S(..ZallocateTimeout(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocateParameter289OptGrp">
<Description>

summary values:+,-</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("+","-"),1,.value)) { quit 1 /* not found is OK */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=1 /* failure rollsback but returns OK */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocateTimeout">
<Description>
 zallocate_timeout ::= ':' expression
summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocateType">
<Description>
 zallocate_type ::= '#' '"' ( 'S' | 'E' | 'I' | 'D' )+ '"'
summary values:#</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&(?4?)+&P
	; first rule summary P
	if '(..isStringSingle("#",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"#")  {
		if ..addPunctuation(subElement,"""")  {
			if ..ZallocateType292RepOne(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"""")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocateType292RepOne">
<Description>
 ( 'S' | 'E' | 'I' | 'D' )+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ZallocateType293Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocateType293Sub">
<Description>
 'S' | 'E' | 'I' | 'D'
summary values:S,E,I,D</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K
	if '(..isKeywordInList($lb("S","E","I","D"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"S")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"I")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"D")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Zallocatename">
<Description>
 zallocatename ::= text</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Text(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocatenameList">
<Description>
 zallocatename_list ::= one_zallocatename ( ',' one_zallocatename )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneZallocatename(subElement,.addedElement)  {
		if ..ZallocatenameList290RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocatenameList290RepZero">
<Description>
 ( ',' one_zallocatename )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ZallocatenameList291Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZallocatenameList291Sub">
<Description>
 ',' one_zallocatename
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..OneZallocatename(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZbreakCommand">
<Description>
 zbreak_command ::= ('zbreak' | 'zb') [ post_conditional ] [ '/' identifier [ ':' identifier ] ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ZbreakCommand294Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..ZbreakCommand295OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZbreakCommand294Sub">
<Description>
'zbreak' | 'zb'
summary values:ZBREAK,ZB</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("ZBREAK","ZB"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"ZBREAK")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZB")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZbreakCommand295OptGrp">
<Description>

summary values:/</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle("/",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"/")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..ZbreakCommand296OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZbreakCommand296OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocateCommand">
<Description>
 zdeallocate_command ::= 'zdeallocate' [post_conditional ] [ zdeallocate_parameter ( ',' zdeallocate_parameter)* ] [ else_block ]
summary values:ZDEALLOCATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?4?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("ZDEALLOCATE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZDEALLOCATE")  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..ZdeallocateCommand297OptGrp(subElement,.addedElement)  {
				if $S(..ElseBlock(subElement,.addedElement) :1,1:1) {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocateCommand297OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ZdeallocateParameter(subElement,.addedElement)  {
		if ..ZdeallocateCommand298RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocateCommand298RepZero">
<Description>
 ( ',' zdeallocate_parameter)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ZdeallocateCommand299Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocateCommand299Sub">
<Description>
 ',' zdeallocate_parameter
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ZdeallocateParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocateParameter">
<Description>
 zdeallocate_parameter ::= [ '+' | '-' ] zdeallocatename_list [ zdeallocate_timeout ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ZdeallocateParameter300OptGrp(subElement,.addedElement)  {
		if ..ZdeallocatenameList(subElement,.addedElement)  {
			if $S(..ZdeallocateTimeout(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocateParameter300OptGrp">
<Description>

summary values:+,-</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("+","-"),1,.value)) { quit 1 /* not found is OK */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=1 /* failure rollsback but returns OK */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocateTimeout">
<Description>
 zdeallocate_timeout ::= ':' expression
summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocateType">
<Description>
 zdeallocate_type ::= '#' '"' ( 'S' | 'E' | 'I' | 'D' )+ '"'
summary values:#</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&(?4?)+&P
	; first rule summary P
	if '(..isStringSingle("#",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"#")  {
		if ..addPunctuation(subElement,"""")  {
			if ..ZdeallocateType303RepOne(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"""")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocateType303RepOne">
<Description>
 ( 'S' | 'E' | 'I' | 'D' )+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ZdeallocateType304Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocateType304Sub">
<Description>
 'S' | 'E' | 'I' | 'D'
summary values:S,E,I,D</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K
	if '(..isKeywordInList($lb("S","E","I","D"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"S")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"I")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"D")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Zdeallocatename">
<Description>
 zdeallocatename ::= text</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Text(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocatenameList">
<Description>
 zdeallocatename_list ::= one_zdeallocatename ( ',' one_zdeallocatename )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneZdeallocatename(subElement,.addedElement)  {
		if ..ZdeallocatenameList301RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocatenameList301RepZero">
<Description>
 ( ',' one_zdeallocatename )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ZdeallocatenameList302Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZdeallocatenameList302Sub">
<Description>
 ',' one_zdeallocatename
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..OneZdeallocatename(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZinsertCommand">
<Description>
 zinsert_command ::= 'zinsert'
summary values:ZINSERT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("ZINSERT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZINSERT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZkillCommand">
<Description>
 zkill_command ::= ('zkill' | 'zk') [ post_conditional ] [ kill_parameter_list ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ZkillCommand305Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if $S(..KillParameterList(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZkillCommand305Sub">
<Description>
'zkill' | 'zk'
summary values:ZKILL,ZK</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("ZKILL","ZK"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"ZKILL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZK")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZloadCommand">
<Description>
 zload_command ::= 'zload'
summary values:ZLOAD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("ZLOAD"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZLOAD")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZnspaceCommand">
<Description>
 znspace_command ::= ('znspace'|'zn') [ post_conditional ] expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ZnspaceCommand306Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..Expression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZnspaceCommand306Sub">
<Description>
'znspace'|'zn'
summary values:ZNSPACE,ZN</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("ZNSPACE","ZN"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"ZNSPACE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZN")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZobjclassmethodFunctionCall">
<Description>
 zobjclassmethod_function_call ::= 'zobjclassmethod' function_parameter_list [ object_chain ]
summary values:ZOBJCLASSMETHOD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("ZOBJCLASSMETHOD"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZOBJCLASSMETHOD")  {
		if ..FunctionParameterList(subElement,.addedElement)  {
			if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZobjmethodFunctionCall">
<Description>
 zobjmethod_function_call ::= 'zobjmethod' function_parameter_list [ object_chain ]
summary values:ZOBJMETHOD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("ZOBJMETHOD"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZOBJMETHOD")  {
		if ..FunctionParameterList(subElement,.addedElement)  {
			if $S(..ObjectChain(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZprintCommand">
<Description>
 zprint_command ::= 'zprint' [ post_conditional ] [ lineref1 [ ':' lineref2 ] ]
summary values:ZPRINT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("ZPRINT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZPRINT")  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..ZprintCommand307OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZprintCommand307OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Lineref1(subElement,.addedElement)  {
		if ..ZprintCommand308OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZprintCommand308OptGrp">
<Description>

summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..Lineref2(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZquitCommand">
<Description>
 zquit_command ::= 'zquit'
summary values:ZQUIT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("ZQUIT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZQUIT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZremoveCommand">
<Description>
 zremove_command ::= 'zremove'
summary values:ZREMOVE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("ZREMOVE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZREMOVE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZsaveCommand">
<Description>
 zsave_command ::= 'zsave'
summary values:ZSAVE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("ZSAVE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZSAVE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZsyncCommand">
<Description>
 zsync_command ::= 'zsync' [ post_conditional ]
summary values:ZSYNC</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("ZSYNC"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZSYNC")  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZtrapCommand">
<Description>
 ztrap_command ::= ('ztrap' | 'zt') [post_conditional ] [naked | expression]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ZtrapCommand309Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..ZtrapCommand310OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZtrapCommand309Sub">
<Description>
'ztrap' | 'zt'
summary values:ZTRAP,ZT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("ZTRAP","ZT"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"ZTRAP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZT")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZtrapCommand310OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Naked(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZwriteArgument">
<Description>
 zwrite_argument ::= expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZwriteArgumentList">
<Description>
 zwrite_argument_list ::= zwrite_argument ( ',' zwrite_argument )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ZwriteArgument(subElement,.addedElement)  {
		if ..ZwriteArgumentList312RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZwriteArgumentList312RepZero">
<Description>
 ( ',' zwrite_argument )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ZwriteArgumentList313Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZwriteArgumentList313Sub">
<Description>
 ',' zwrite_argument
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ZwriteArgument(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZwriteCommand">
<Description>
 zwrite_command ::= ( 'zwrite' | 'zw' ) [ post_conditional ] [ zwrite_argument_list ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ZwriteCommand311Sub(subElement,.addedElement)  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if $S(..ZwriteArgumentList(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZwriteCommand311Sub">
<Description>
 'zwrite' | 'zw'
summary values:ZWRITE,ZW</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("ZWRITE","ZW"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"ZWRITE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ZW")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ZzdumpCommand">
<Description>
 zzdump_command ::= 'zzdump' [post_conditional] expression
summary values:ZZDUMP</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ZZDUMP"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZZDUMP")  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..Expression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ZzwriteCommand">
<Description>
 zzwrite_command ::= 'zzwrite' [post_conditional] expression
summary values:ZZWRITE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ZZWRITE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZZWRITE")  {
		if $S(..PostConditional(subElement,.addedElement) :1,1:1) {
			if ..Expression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Elements.COS</ReturnType>
<Implementation><![CDATA[	quit ##class(PXW.DEV.BNF.Elements.COS).%New(Type)
]]></Implementation>
</Method>

<Parameter name="KeywordPattern">
<Default>1A.AN</Default>
</Parameter>

<Parameter name="Keywords">
<Default>A,ARRAY,AS,B,BITLOGIC,BREAK,C,CASE,CATCH,CLASSMETHOD,CLOSE,CONTINUE,D,DEF1ARG,DEFERRED,DEFINE,DEVICE,DIM,DISPLAY,DO,E,EC,ECODE,ELSE,ELSEIF,ENDIF,ES,ESTACK,ET,ETRAP,EXECUTE,EXTRACT,F,FALSE,FDBMS,FOR,G,GOTO,H,HALT,HANG,HOROLOG,I,IF,IFDEF,IFNDEF,IMPORT,INCLUDE,INCREMENT,IO,J,JOB,K,KEY,KILL,L,LB,LG,LI,LIST,LISTBUILD,LISTGET,LISTUPDATE,LOCK,LOGICAL,LU,M,MERGE,METHOD,METHODIMPL,MODE,MVP,MVPRINT,N,NAMESPACE,NEW,NULL,O,ODBC,OF,OPEN,P,PIECE,PRINCIPAL,PRINT,PRIVATE,PUBLIC,PYTHON,Q,QUIT,R,READ,RETURN,ROLES,RUNTIME,S,SELECT,SET,SQLCOMPILE,STACK,STORAGE,SYSTEM,T,TC,TCOMMIT,TEST,TEXT,THIS,THROW,THROWOBJ,TL,TLEVEL,TROLLBACK,TRUE,TRY,TS,TSTART,U,UNDEF,USE,USERNAME,V,VIEW,W,WHILE,WRITE,X,XECUTE,Y,ZA,ZALLOCATE,ZB,ZBREAK,ZCHILD,ZDEALLOCATE,ZE,ZEOF,ZEOS,ZERROR,ZFWCHARZ,ZH,ZHOROLOG,ZHWKATAZ,ZINSERT,ZIO,ZJOB,ZK,ZKILL,ZLOAD,ZMODE,ZN,ZNAME,ZNSPACE,ZOBJCLASSMETHOD,ZOBJMETHOD,ZORDER,ZPARENT,ZPI,ZPOS,ZPRINT,ZQUIT,ZR,ZREFERENCE,ZREMOVE,ZS,ZSAVE,ZSTORAGE,ZSYNC,ZT,ZTIMESTAMP,ZTIMEZONE,ZTRAP,ZTS,ZU,ZUTIL,ZV,ZVERSION,ZW,ZWRITE,ZZDUMP,ZZWRITE</Default>
</Parameter>
</Class>


<Class name="PXW.DEV.BNF.GEN.CSP">
<Description>
Created: 2024-10-17 15:58:55 PXW.DEV.BNF.Compilers.Compiler1</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>PXW.DEV.BNF.super</Super>
<TimeChanged>67130,57535.489822445</TimeChanged>
<TimeCreated>67125,77562.752457632</TimeCreated>

<Method name="CosExpression">
<Description>
 cos_expression ::= cos_expression_compiletime | cos_expression_runtime | cos_expression_other</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosExpressionCompiletime(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosExpressionRuntime(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosExpressionOther(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosExpressionBody">
<Description>
 cos_expression_body ::= 'NEEDS COS EXPRESSION BODY'
summary values:NEEDS COS EXPRESSION BODY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS COS EXPRESSION BODY",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS COS EXPRESSION BODY")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosExpressionCompiletime">
<Description>
 cos_expression_compiletime ::= '##(' cos_expression_body ')##'
summary values:##(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("##(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"##(")  {
		if ..CosExpressionBody(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")##")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosExpressionOther">
<Description><![CDATA[
 cos_expression_other ::= '<%=' cos_expression_body '%>'
summary values:<%=]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("<%=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<%=")  {
		if ..CosExpressionBody(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"%>")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosExpressionRuntime">
<Description>
 cos_expression_runtime ::= '#(' cos_expression_body ')#'
summary values:#(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("#(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"#(")  {
		if ..CosExpressionBody(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")#")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspAttribute">
<Description>
 csp_attribute ::= ( [ csp_schema ':' ] csp_identifier ['=' ( string | ( number ['%'] )| cos_expression | ('#' [text_no_space] ) | csp_identifier | text_no_space) ] ) | cos_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspAttribute11Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspAttribute11Sub">
<Description>
 [ csp_schema ':' ] csp_identifier ['=' ( string | ( number ['%'] )| cos_expression | ('#' [text_no_space] ) | csp_identifier | text_no_space) ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspAttribute12OptGrp(subElement,.addedElement)  {
		if ..CspIdentifier(subElement,.addedElement)  {
			if ..CspAttribute13OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspAttribute12OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspSchema(subElement,.addedElement)  {
		if ..addPunctuation(subElement,":")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspAttribute13OptGrp">
<Description>

summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("=",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		if ..CspAttribute14Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspAttribute14Sub">
<Description>
 string | ( number ['%'] )| cos_expression | ('#' [text_no_space] ) | csp_identifier | text_no_space</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspAttribute15Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspAttribute16Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TextNoSpace(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspAttribute15Sub">
<Description>
 number ['%']</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number(subElement,.addedElement)  {
		if $S(..addPunctuation(subElement,"%") :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspAttribute16Sub">
<Description>
'#' [text_no_space]
summary values:#</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle("#",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"#")  {
		if $S(..TextNoSpace(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspContent">
<Description>
 csp_content ::= text</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Text(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspDoctype">
<Description><![CDATA[
 csp_doctype ::= '<!DOCTYPE' csp_attribute ['PUBLIC' string string]'>'
summary values:<!DOCTYPE]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?&P
	; first rule summary P
	if '(..isStringSingle("<!DOCTYPE",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<!DOCTYPE")  {
		if ..CspAttribute(subElement,.addedElement)  {
			if ..CspDoctype20OptGrp(subElement,.addedElement)  {
				if ..addPunctuation(subElement,">")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspDoctype20OptGrp">
<Description>

summary values:PUBLIC</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("PUBLIC"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PUBLIC")  {
		if ..String(subElement,.addedElement)  {
			if ..String(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspElement">
<Description>
 csp_element ::= csp_special_tag | (csp_start_tag ( csp_element | csp_content)* [csp_end_tag]) | csp_empty_tag</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspSpecialTag(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspElement3Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspEmptyTag(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspElement3Sub">
<Description>
csp_start_tag ( csp_element | csp_content)* [csp_end_tag]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspStartTag(subElement,.addedElement)  {
		if ..CspElement4RepZero(subElement,.addedElement)  {
			if $S(..CspEndTag(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspElement4RepZero">
<Description>
 ( csp_element | csp_content)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CspElement5Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CspElement5Sub">
<Description>
 csp_element | csp_content</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspElement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspContent(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspEmptyTag">
<Description>
 csp_empty_tag ::= csp_tag_s_a csp_tag_ns_name (csp_attribute )* csp_tag_s_c</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&(?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspTagSA(subElement,.addedElement)  {
		if ..CspTagNsName(subElement,.addedElement)  {
			if ..CspEmptyTag8RepZero(subElement,.addedElement)  {
				if ..CspTagSC(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspEmptyTag8RepZero">
<Description>
 (csp_attribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CspEmptyTag9Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CspEmptyTag9Sub">
<Description>
csp_attribute</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspAttribute(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspEndTag">
<Description>
 csp_end_tag ::= csp_tag_e_a csp_tag_ns_name csp_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspTagEA(subElement,.addedElement)  {
		if ..CspTagNsName(subElement,.addedElement)  {
			if ..CspTagEB(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspIdentifier">
<Description>
 csp_identifier ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspJavascript">
<Description>
 csp_javascript ::= csp_tag_s_a 'script' 'language' '=' ('javascript' | '"javascript"' ) csp_tag_s_b javascript_body csp_tag_e_a 'script' csp_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"SCRIPT")  {
			if ..addKeyword(subElement,"LANGUAGE")  {
				if ..addPunctuation(subElement,"=")  {
					if ..CspJavascript21Sub(subElement,.addedElement)  {
						if ..CspTagSB(subElement,.addedElement)  {
							if ..JavascriptBody(subElement,.addedElement)  {
								if ..CspTagEA(subElement,.addedElement)  {
									if ..addKeyword(subElement,"SCRIPT")  {
										if ..CspTagEB(subElement,.addedElement)  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspJavascript21Sub">
<Description>
'javascript' | '"javascript"'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"JAVASCRIPT")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"""javascript""")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspJavascriptBoth">
<Description>
 csp_javascript_both ::= csp_tag_s_a 'script' 'language' '=' ('javascript' | '"javascript"' ) 'type' '=' ('"text/javascript"') csp_tag_s_b javascript_body csp_tag_e_a 'script' csp_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&K&P&?1Rule?&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"SCRIPT")  {
			if ..addKeyword(subElement,"LANGUAGE")  {
				if ..addPunctuation(subElement,"=")  {
					if ..CspJavascriptBoth23Sub(subElement,.addedElement)  {
						if ..addKeyword(subElement,"TYPE")  {
							if ..addPunctuation(subElement,"=")  {
								if ..CspJavascriptBoth24Sub(subElement,.addedElement)  {
									if ..CspTagSB(subElement,.addedElement)  {
										if ..JavascriptBody(subElement,.addedElement)  {
											if ..CspTagEA(subElement,.addedElement)  {
												if ..addKeyword(subElement,"SCRIPT")  {
													if ..CspTagEB(subElement,.addedElement)  {
														set done=1 ; end compileRules
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspJavascriptBoth23Sub">
<Description>
'javascript' | '"javascript"'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"JAVASCRIPT")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"""javascript""")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspJavascriptBoth24Sub">
<Description>
'"text/javascript"'
summary values:""TEXT/JAVASCRIPT""</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("""TEXT/JAVASCRIPT""",.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"""text/javascript""")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CspJavascriptBothopp">
<Description>
 csp_javascript_bothopp ::= csp_tag_s_a 'script' 'type' '=' ('"text/javascript"') 'language' '=' ('javascript' | '"javascript"' ) csp_tag_s_b javascript_body csp_tag_e_a 'script' csp_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&K&P&?1Rule?&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"SCRIPT")  {
			if ..addKeyword(subElement,"TYPE")  {
				if ..addPunctuation(subElement,"=")  {
					if ..CspJavascriptBothopp25Sub(subElement,.addedElement)  {
						if ..addKeyword(subElement,"LANGUAGE")  {
							if ..addPunctuation(subElement,"=")  {
								if ..CspJavascriptBothopp26Sub(subElement,.addedElement)  {
									if ..CspTagSB(subElement,.addedElement)  {
										if ..JavascriptBody(subElement,.addedElement)  {
											if ..CspTagEA(subElement,.addedElement)  {
												if ..addKeyword(subElement,"SCRIPT")  {
													if ..CspTagEB(subElement,.addedElement)  {
														set done=1 ; end compileRules
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspJavascriptBothopp25Sub">
<Description>
'"text/javascript"'
summary values:""TEXT/JAVASCRIPT""</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("""TEXT/JAVASCRIPT""",.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"""text/javascript""")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CspJavascriptBothopp26Sub">
<Description>
'javascript' | '"javascript"'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"JAVASCRIPT")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"""javascript""")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspJavascriptText">
<Description>
 csp_javascript_text ::= csp_tag_s_a 'script' 'type' '=' ('"text/javascript"') csp_tag_s_b javascript_body csp_tag_e_a 'script' csp_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"SCRIPT")  {
			if ..addKeyword(subElement,"TYPE")  {
				if ..addPunctuation(subElement,"=")  {
					if ..CspJavascriptText22Sub(subElement,.addedElement)  {
						if ..CspTagSB(subElement,.addedElement)  {
							if ..JavascriptBody(subElement,.addedElement)  {
								if ..CspTagEA(subElement,.addedElement)  {
									if ..addKeyword(subElement,"SCRIPT")  {
										if ..CspTagEB(subElement,.addedElement)  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspJavascriptText22Sub">
<Description>
'"text/javascript"'
summary values:""TEXT/JAVASCRIPT""</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("""TEXT/JAVASCRIPT""",.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"""text/javascript""")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CspPage">
<Description>
 csp_page ::= (csp_xml | csp_element | csp_end_tag | csp_content )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspPage1RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspPage1RepZero">
<Description>
 (csp_xml | csp_element | csp_end_tag | csp_content )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CspPage2Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CspPage2Sub">
<Description>
csp_xml | csp_element | csp_end_tag | csp_content</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspXml(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspElement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspEndTag(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspContent(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspSchema">
<Description>
 csp_schema ::= csp_identifier | cos_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspSpecialTag">
<Description>
 csp_special_tag ::= csp_doctype | csp_javascript | csp_javascript_text | csp_javascript_both | csp_javascript_bothopp | cos_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspDoctype(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspJavascript(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspJavascriptText(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspJavascriptBoth(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CspJavascriptBothopp(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspStartTag">
<Description>
 csp_start_tag ::= csp_tag_s_a csp_tag_ns_name (csp_attribute )* csp_tag_s_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&(?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspTagSA(subElement,.addedElement)  {
		if ..CspTagNsName(subElement,.addedElement)  {
			if ..CspStartTag6RepZero(subElement,.addedElement)  {
				if ..CspTagSB(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspStartTag6RepZero">
<Description>
 (csp_attribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CspStartTag7Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CspStartTag7Sub">
<Description>
csp_attribute</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspAttribute(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspTagEA">
<Description><![CDATA[
 csp_tag_e_a ::= '</'
summary values:</]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("</",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"</")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspTagEB">
<Description><![CDATA[
 csp_tag_e_b ::= '>'
summary values:>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(">",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,">")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspTagName">
<Description>
 csp_tag_name ::= csp_identifier | cos_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspTagNsName">
<Description>
 csp_tag_ns_name ::= [ csp_schema ':'] csp_tag_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspTagNsName10OptGrp(subElement,.addedElement)  {
		if ..CspTagName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspTagNsName10OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspSchema(subElement,.addedElement)  {
		if ..addPunctuation(subElement,":")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspTagSA">
<Description><![CDATA[
 csp_tag_s_a ::= '<'
summary values:<]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("<",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspTagSB">
<Description><![CDATA[
 csp_tag_s_b ::= '>'
summary values:>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(">",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,">")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspTagSC">
<Description><![CDATA[
 csp_tag_s_c ::= '/>'
summary values:/>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("/>",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"/>")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspXml">
<Description>
 csp_xml ::= csp_tag_s_a '?xml' ['-' 'stylesheet'] (csp_attribute)* '?' csp_tag_s_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?4?&(?4?)*&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspTagSA(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"?xml")  {
			if ..CspXml17OptGrp(subElement,.addedElement)  {
				if ..CspXml18RepZero(subElement,.addedElement)  {
					if ..addPunctuation(subElement,"?")  {
						if ..CspTagSB(subElement,.addedElement)  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspXml17OptGrp">
<Description>

summary values:-</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&K
	; first rule summary P
	if '(..isStringSingle("-",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"-")  {
		if ..addKeyword(subElement,"STYLESHEET")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CspXml18RepZero">
<Description>
 (csp_attribute)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CspXml19Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CspXml19Sub">
<Description>
csp_attribute</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CspAttribute(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<Description>
 identifier ::= 'NEEDS IDENTIFIER'
summary values:NEEDS IDENTIFIER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS IDENTIFIER",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS IDENTIFIER")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JavascriptBody">
<Description>
 javascript_body ::= 'NEEDS JS BODY'
summary values:NEEDS JS BODY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS JS BODY",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS JS BODY")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number">
<Description>
 number ::= 'NEEDS NUMBER'
summary values:NEEDS NUMBER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS NUMBER",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS NUMBER")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="String">
<Description>
 string ::= 'NEEDS STRING'
summary values:NEEDS STRING</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS STRING",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS STRING")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Text">
<Description>
 text ::= 'NEEDS TEXT'
summary values:NEEDS TEXT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS TEXT",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS TEXT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TextNoSpace">
<Description>
 text_no_space ::= 'NEEDS TEXT'
summary values:NEEDS TEXT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS TEXT",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS TEXT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Element</ReturnType>
<Implementation><![CDATA[	quit ##class(PXW.DEV.BNF.Element).%New(Type)
]]></Implementation>
</Method>

<Parameter name="KeywordPattern">
<Default>1.A</Default>
</Parameter>

<Parameter name="Keywords">
<Default>JAVASCRIPT,LANGUAGE,PUBLIC,SCRIPT,STYLESHEET,TYPE</Default>
</Parameter>
</Class>


<Class name="PXW.DEV.BNF.GEN.ClassDefinition">
<Description>
Created: 2024-10-17 15:58:57 PXW.DEV.BNF.Compilers.Compiler1</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>PXW.DEV.BNF.super</Super>
<TimeChanged>67130,57545.350615672</TimeChanged>
<TimeCreated>67125,77562.862444305</TimeCreated>

<Method name="AliasIdentifier">
<Description>
 alias_identifier ::= 'NEED ALIAS IDENT'
summary values:NEED ALIAS IDENT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED ALIAS IDENT",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED ALIAS IDENT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AsTypeClassReference">
<Description>
 as_type_class_reference ::= 'as' type_class_reference
summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..TypeClassReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeAbstract">
<Description>
 attribute_Abstract ::= 'abstract'
summary values:ABSTRACT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("ABSTRACT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ABSTRACT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeAliases">
<Description>
 attribute_Aliases ::= 'aliases' '=' '{' attribute_AliasList '}'
summary values:ALIASES</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("ALIASES"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ALIASES")  {
		if ..addPunctuation(subElement,"=")  {
			if ..addPunctuation(subElement,"{")  {
				if ..AttributeAliaslist(subElement,.addedElement)  {
					if ..addPunctuation(subElement,"}")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeAliaslist">
<Description>
 attribute_AliasList ::= attribute_OneAlias ( ',' attribute_OneAlias )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeOnealias(subElement,.addedElement)  {
		if ..AttributeAliaslist122RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeAliaslist122RepZero">
<Description>
 ( ',' attribute_OneAlias )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..AttributeAliaslist123Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeAliaslist123Sub">
<Description>
 ',' attribute_OneAlias
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..AttributeOnealias(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeCalculated">
<Description>
 attribute_Calculated ::= 'calculated'
summary values:CALCULATED</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("CALCULATED"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CALCULATED")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeCardinality">
<Description>
 attribute_Cardinality ::= 'cardinality' '=' attribute_Cardinality_type
summary values:CARDINALITY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CARDINALITY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CARDINALITY")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeCardinalityType(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeCardinalityType">
<Description>
 attribute_Cardinality_type ::= 'one' | 'many' | 'parent' | 'children'
summary values:ONE,MANY,PARENT,CHILDREN</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K
	if '(..isKeywordInList($lb("ONE","MANY","PARENT","CHILDREN"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ONE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MANY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"PARENT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"CHILDREN")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeClasstype">
<Description>
 attribute_ClassType ::= 'classtype' '=' class_type_name
summary values:CLASSTYPE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CLASSTYPE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CLASSTYPE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..ClassTypeName(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeClientdatatype">
<Description>
 attribute_ClientDataType ::= 'clientdatatype' '=' client_data_type_name
summary values:CLIENTDATATYPE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CLIENTDATATYPE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CLIENTDATATYPE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..ClientDataTypeName(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeClientname">
<Description>
 attribute_ClientName ::= 'clientname' '=' attribute_ClientName_value
summary values:CLIENTNAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CLIENTNAME"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CLIENTNAME")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeClientnameValue(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeClientnameValue">
<Description>
 attribute_ClientName_value ::= client_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClientIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeCodemode">
<Description>
 attribute_CodeMode ::= 'codemode' '=' attribute_CodeModeType
summary values:CODEMODE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CODEMODE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CODEMODE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeCodemodetype(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeCodemodetype">
<Description>
 attribute_CodeModeType ::= 'call' | 'code' | 'expression' | 'objectgenerator' | 'generator'
summary values:CALL,CODE,EXPRESSION,OBJECTGENERATOR,GENERATOR</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K
	if '(..isKeywordInList($lb("CALL","CODE","EXPRESSION","OBJECTGENERATOR","GENERATOR"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CALL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"CODE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"EXPRESSION")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"OBJECTGENERATOR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"GENERATOR")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeCompileafter">
<Description>
 attribute_CompileAfter ::= 'compileafter' '=' [class_reference_list | class_reference]
summary values:COMPILEAFTER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("COMPILEAFTER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"COMPILEAFTER")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeCompileafter125OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeCompileafter125OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassReferenceList(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeCondition">
<Description>
 attribute_Condition ::= 'condition' '=' '{' expression '}'
summary values:CONDITION</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("CONDITION"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CONDITION")  {
		if ..addPunctuation(subElement,"=")  {
			if ..addPunctuation(subElement,"{")  {
				if ..Expression(subElement,.addedElement)  {
					if ..addPunctuation(subElement,"}")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeConstraint">
<Description>
 attribute_Constraint ::= 'constraint' '=' (number | string | identifier)
summary values:CONSTRAINT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CONSTRAINT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CONSTRAINT")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeConstraint124Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeConstraint124Sub">
<Description>
number | string | identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeData">
<Description>
 attribute_Data ::= 'data' '=' ( one_data_attribute_value | ( '(' one_data_attribute_value ( ',' one_data_attribute_value )* ')' ) )
summary values:DATA</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("DATA"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DATA")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeData126Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeData126Sub">
<Description>
 one_data_attribute_value | ( '(' one_data_attribute_value ( ',' one_data_attribute_value )* ')' )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneDataAttributeValue(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeData127Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeData127Sub">
<Description>
 '(' one_data_attribute_value ( ',' one_data_attribute_value )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..OneDataAttributeValue(subElement,.addedElement)  {
			if ..AttributeData128RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeData128RepZero">
<Description>
 ( ',' one_data_attribute_value )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..AttributeData129Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeData129Sub">
<Description>
 ',' one_data_attribute_value
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..OneDataAttributeValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeDdlallowed">
<Description>
 attribute_DDLAllowed ::= 'ddlallowed'
summary values:DDLALLOWED</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("DDLALLOWED"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DDLALLOWED")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeDependson">
<Description>
 attribute_DependsOn ::= 'dependson' '=' ( class_reference_list | class_reference )
summary values:DEPENDSON</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("DEPENDSON"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DEPENDSON")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeDependson131Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeDependson131Sub">
<Description>
 class_reference_list | class_reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassReferenceList(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeDeprecated">
<Description>
 attribute_Deprecated ::= 'deprecated'
summary values:DEPRECATED</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("DEPRECATED"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DEPRECATED")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeEmbeddedclass">
<Description>
 attribute_EmbeddedClass ::= 'EmbeddedClass' '=' class_reference
summary values:EMBEDDEDCLASS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("EMBEDDEDCLASS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"EMBEDDEDCLASS")  {
		if ..addPunctuation(subElement,"=")  {
			if ..ClassReference(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeEvent">
<Description>
 attribute_Event ::= 'event' '=' event_keyword
summary values:EVENT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("EVENT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"EVENT")  {
		if ..addPunctuation(subElement,"=")  {
			if ..EventKeyword(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeExtent">
<Description>
 attribute_Extent ::= 'extent'
summary values:EXTENT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("EXTENT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"EXTENT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeExternalprocname">
<Description>
 attribute_ExternalProcName ::= 'externalprocname' '=' text
summary values:EXTERNALPROCNAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("EXTERNALPROCNAME"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"EXTERNALPROCNAME")  {
		if ..addPunctuation(subElement,"=")  {
			if ..Text(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeFinal">
<Description>
 attribute_Final ::= 'final'
summary values:FINAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("FINAL"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FINAL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeFlags">
<Description>
 attribute_Flags ::= 'flags' '=' ( 'enumedit' | 'enum' | 'list' )
summary values:FLAGS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("FLAGS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FLAGS")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeFlags132Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeFlags132Sub">
<Description>
 'enumedit' | 'enum' | 'list'
summary values:ENUMEDIT,ENUM,LIST</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K
	if '(..isKeywordInList($lb("ENUMEDIT","ENUM","LIST"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"ENUMEDIT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ENUM")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LIST")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeForcegenerate">
<Description>
 attribute_ForceGenerate ::= 'forcegenerate'
summary values:FORCEGENERATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("FORCEGENERATE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FORCEGENERATE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeForeach">
<Description>
 attribute_ForEach ::= 'foreach' '=' foreach_type
summary values:FOREACH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("FOREACH"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FOREACH")  {
		if ..addPunctuation(subElement,"=")  {
			if ..ForeachType(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeGenerateafter">
<Description>
 attribute_GenerateAfter ::= 'generateafter' '=' ( method_reference | ( '(' method_reference ( ',' method_reference )* ')' ) )
summary values:GENERATEAFTER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("GENERATEAFTER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"GENERATEAFTER")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeGenerateafter133Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeGenerateafter133Sub">
<Description>
 method_reference | ( '(' method_reference ( ',' method_reference )* ')' )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MethodReference(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeGenerateafter134Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeGenerateafter134Sub">
<Description>
 '(' method_reference ( ',' method_reference )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..MethodReference(subElement,.addedElement)  {
			if ..AttributeGenerateafter135RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeGenerateafter135RepZero">
<Description>
 ( ',' method_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..AttributeGenerateafter136Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeGenerateafter136Sub">
<Description>
 ',' method_reference
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..MethodReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeGeneratedby">
<Description>
 attribute_GeneratedBy ::= 'generatedby' '=' (class_reference | string | filename)
summary values:GENERATEDBY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("GENERATEDBY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"GENERATEDBY")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeGeneratedby137Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeGeneratedby137Sub">
<Description>
class_reference | string | filename</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassReference(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Filename(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeHidden">
<Description>
 attribute_Hidden ::= 'hidden'
summary values:HIDDEN</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("HIDDEN"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"HIDDEN")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeIdentity">
<Description>
 attribute_Identity ::= 'identity'
summary values:IDENTITY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("IDENTITY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IDENTITY")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeIdkey">
<Description>
 attribute_IdKey ::= 'idkey'
summary values:IDKEY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("IDKEY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IDKEY")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeInheritance">
<Description>
 attribute_Inheritance ::= 'inheritance' '=' inheritance_direction
summary values:INHERITANCE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("INHERITANCE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INHERITANCE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..InheritanceDirection(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeInitialexpression">
<Description>
 attribute_InitialExpression ::= 'initialexpression' '=' initialexpression_value
summary values:INITIALEXPRESSION</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("INITIALEXPRESSION"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INITIALEXPRESSION")  {
		if ..addPunctuation(subElement,"=")  {
			if ..InitialexpressionValue(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeInternal">
<Description>
 attribute_Internal ::= 'internal'
summary values:INTERNAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("INTERNAL"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INTERNAL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeInverse">
<Description>
 attribute_Inverse ::= 'inverse' '=' identifier
summary values:INVERSE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("INVERSE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INVERSE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..Identifier(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeLanguage">
<Description>
 attribute_Language ::= 'language' '=' class_language_name
summary values:LANGUAGE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("LANGUAGE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"LANGUAGE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..ClassLanguageName(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeLegacyinstancecontext">
<Description>
 attribute_LegacyInstanceContext ::= 'legacyinstancecontext'
summary values:LEGACYINSTANCECONTEXT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("LEGACYINSTANCECONTEXT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"LEGACYINSTANCECONTEXT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeMembersuper">
<Description>
 attribute_MemberSuper ::= 'MemberSuper' '=' ( ( '(' class_reference ( ',' class_reference )*')' ) | class_reference )
summary values:MEMBERSUPER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("MEMBERSUPER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"MEMBERSUPER")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeMembersuper138Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeMembersuper138Sub">
<Description>
 ( '(' class_reference ( ',' class_reference )*')' ) | class_reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeMembersuper139Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeMembersuper139Sub">
<Description>
 '(' class_reference ( ',' class_reference )*')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..ClassReference(subElement,.addedElement)  {
			if ..AttributeMembersuper140RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeMembersuper140RepZero">
<Description>
 ( ',' class_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..AttributeMembersuper141Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeMembersuper141Sub">
<Description>
 ',' class_reference
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ClassReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeMimetype">
<Description>
 attribute_MimeType ::= 'mimetype' '=' identifier ('/' identifier)*
summary values:MIMETYPE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&(?4?)*
	; first rule summary K
	if '(..isKeywordInList($lb("MIMETYPE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"MIMETYPE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..Identifier(subElement,.addedElement)  {
				if ..AttributeMimetype142RepZero(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeMimetype142RepZero">
<Description>
 ('/' identifier)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..AttributeMimetype143Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeMimetype143Sub">
<Description>
'/' identifier
summary values:/</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("/",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"/")  {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeMultidimensional">
<Description>
 attribute_MultiDimensional ::= 'multidimensional'
summary values:MULTIDIMENSIONAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("MULTIDIMENSIONAL"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"MULTIDIMENSIONAL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeNewtable">
<Description>
 attribute_NewTable ::= 'newtable' '=' tablename
summary values:NEWTABLE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("NEWTABLE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NEWTABLE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..Tablename(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeNocheck">
<Description>
 attribute_NoCheck ::= 'nocheck'
summary values:NOCHECK</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("NOCHECK"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NOCHECK")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeNocontext">
<Description>
 attribute_NoContext ::= 'nocontext'
summary values:NOCONTEXT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("NOCONTEXT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NOCONTEXT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeNoextent">
<Description>
 attribute_NoExtent ::= 'noextent'
summary values:NOEXTENT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("NOEXTENT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NOEXTENT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeNot">
<Description>
 attribute_Not ::= 'not' ( attribute_Abstract | attribute_DDLAllowed | attribute_Deprecated | attribute_Final | attribute_Hidden | attribute_Internal | attribute_LegacyInstanceContext | attribute_NoExtent | attribute_Private | attribute_ProcedureBlock | attribute_ReadOnly | attribute_Required | attribute_ServerOnly | attribute_SQLComputed | attribute_Transient | attribute_Unique )
summary values:NOT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("NOT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NOT")  {
		if ..AttributeNot29Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeNot29Sub">
<Description>
 attribute_Abstract | attribute_DDLAllowed | attribute_Deprecated | attribute_Final | attribute_Hidden | attribute_Internal | attribute_LegacyInstanceContext | attribute_NoExtent | attribute_Private | attribute_ProcedureBlock | attribute_ReadOnly | attribute_Required | attribute_ServerOnly | attribute_SQLComputed | attribute_Transient | attribute_Unique</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeAbstract(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeDdlallowed(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeDeprecated(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeFinal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeHidden(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeInternal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeLegacyinstancecontext(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeNoextent(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributePrivate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeProcedureblock(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeReadonly(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeRequired(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeServeronly(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlcomputed(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeTransient(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeUnique(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeNotinheritable">
<Description>
 attribute_NotInheritable ::= 'notinheritable'
summary values:NOTINHERITABLE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("NOTINHERITABLE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NOTINHERITABLE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeOdbctype">
<Description>
 attribute_ODBCType ::= 'odbctype' '=' ( 'bigint' | 'bit' | 'date' | 'double' | 'integer' | 'longvarbinary' | 'longvarchar' | 'numeric' | 'resultset' | 'smallint' | 'struct' | 'time' | 'timestamp' | 'tinyint' | 'varbinary' | 'varchar' | 'guid' | 'POSIXTIME')
summary values:ODBCTYPE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ODBCTYPE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ODBCTYPE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeOdbctype144Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeOdbctype144Sub">
<Description>
 'bigint' | 'bit' | 'date' | 'double' | 'integer' | 'longvarbinary' | 'longvarchar' | 'numeric' | 'resultset' | 'smallint' | 'struct' | 'time' | 'timestamp' | 'tinyint' | 'varbinary' | 'varchar' | 'guid' | 'POSIXTIME'
summary values:BIGINT,BIT,DATE,DOUBLE,INTEGER,LONGVARBINARY,LONGVARCHAR,NUMERIC,RESULTSET,SMALLINT,STRUCT,TIME,TIMESTAMP,TINYINT,VARBINARY,VARCHAR,GUID,POSIXTIME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K
	if '(..isKeywordInList($lb("BIGINT","BIT","DATE","DOUBLE","INTEGER","LONGVARBINARY","LONGVARCHAR","NUMERIC","RESULTSET","SMALLINT","STRUCT","TIME","TIMESTAMP","TINYINT","VARBINARY","VARCHAR","GUID","POSIXTIME"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"BIGINT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"BIT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DATE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DOUBLE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INTEGER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LONGVARBINARY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LONGVARCHAR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NUMERIC")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"RESULTSET")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SMALLINT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"STRUCT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TIME")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TIMESTAMP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TINYINT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"VARBINARY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"VARCHAR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"GUID")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"POSIXTIME")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeOldtable">
<Description>
 attribute_OldTable ::= 'oldtable' '=' tablename
summary values:OLDTABLE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("OLDTABLE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"OLDTABLE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..Tablename(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeOnactionType">
<Description>
 attribute_OnAction_type ::= 'cascade' | 'noaction' | 'setdefault' | 'setnull'
summary values:CASCADE,NOACTION,SETDEFAULT,SETNULL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K
	if '(..isKeywordInList($lb("CASCADE","NOACTION","SETDEFAULT","SETNULL"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CASCADE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NOACTION")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SETDEFAULT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SETNULL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeOndelete">
<Description>
 attribute_OnDelete ::= 'ondelete' '=' attribute_OnAction_type
summary values:ONDELETE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ONDELETE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ONDELETE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeOnactionType(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeOnealias">
<Description>
 attribute_OneAlias ::= alias_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AliasIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeOnupdate">
<Description>
 attribute_OnUpdate ::= 'onupdate' '=' attribute_OnAction_type
summary values:ONUPDATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ONUPDATE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ONUPDATE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeOnactionType(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeOrder">
<Description>
 attribute_Order ::= 'order' '=' expression
summary values:ORDER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ORDER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ORDER")  {
		if ..addPunctuation(subElement,"=")  {
			if ..Expression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeOwner">
<Description>
 attribute_Owner ::= 'owner' '=' ( string | number | '{' text_in_curly '}' )
summary values:OWNER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("OWNER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"OWNER")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeOwner145Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeOwner145Sub">
<Description>
 string | number | '{' text_in_curly '}'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|P&?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Number(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"{")  {
		if ..TextInCurly(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePlaceafter">
<Description>
 attribute_PlaceAfter ::= 'placeafter' '=' method_reference ('(' ',' method_reference ')')*
summary values:PLACEAFTER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&(?4?)*
	; first rule summary K
	if '(..isKeywordInList($lb("PLACEAFTER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PLACEAFTER")  {
		if ..addPunctuation(subElement,"=")  {
			if ..MethodReference(subElement,.addedElement)  {
				if ..AttributePlaceafter146RepZero(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePlaceafter146RepZero">
<Description>
 ('(' ',' method_reference ')')*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..AttributePlaceafter147Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePlaceafter147Sub">
<Description>
'(' ',' method_reference ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..addPunctuation(subElement,",")  {
			if ..MethodReference(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePrimarykey">
<Description>
 attribute_PrimaryKey ::= 'primarykey'
summary values:PRIMARYKEY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("PRIMARYKEY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PRIMARYKEY")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePrivate">
<Description>
 attribute_Private ::= 'private'
summary values:PRIVATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("PRIVATE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PRIVATE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeProcedureblock">
<Description>
 attribute_ProcedureBlock ::= 'procedureblock' [ '=' ( '0' | '1' ) ]
summary values:PROCEDUREBLOCK</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("PROCEDUREBLOCK"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PROCEDUREBLOCK")  {
		if ..AttributeProcedureblock148OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeProcedureblock148OptGrp">
<Description>

summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("=",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		if ..AttributeProcedureblock149Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeProcedureblock149Sub">
<Description>
 '0' | '1'
summary values:0,1</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("0","1"),1,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"1")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePropertyclass">
<Description>
 attribute_PropertyClass ::= 'propertyclass' '=' class_reference ('(' ',' class_reference ')')*
summary values:PROPERTYCLASS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&(?4?)*
	; first rule summary K
	if '(..isKeywordInList($lb("PROPERTYCLASS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PROPERTYCLASS")  {
		if ..addPunctuation(subElement,"=")  {
			if ..ClassReference(subElement,.addedElement)  {
				if ..AttributePropertyclass150RepZero(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePropertyclass150RepZero">
<Description>
 ('(' ',' class_reference ')')*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..AttributePropertyclass151Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePropertyclass151Sub">
<Description>
'(' ',' class_reference ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..addPunctuation(subElement,",")  {
			if ..ClassReference(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePubliclist">
<Description>
 attribute_PublicList ::= 'publiclist' '=' ( ('(' identifier (',' identifier )* ')' ) | identifier)
summary values:PUBLICLIST</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("PUBLICLIST"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PUBLICLIST")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributePubliclist152Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePubliclist152Sub">
<Description>
 ('(' identifier (',' identifier )* ')' ) | identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributePubliclist153Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePubliclist153Sub">
<Description>
'(' identifier (',' identifier )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..AttributePubliclist154RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePubliclist154RepZero">
<Description>
 (',' identifier )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..AttributePubliclist155Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributePubliclist155Sub">
<Description>
',' identifier
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeReadonly">
<Description>
 attribute_ReadOnly ::= 'readonly'
summary values:READONLY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("READONLY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"READONLY")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeRequired">
<Description>
 attribute_Required ::= 'required'
summary values:REQUIRED</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("REQUIRED"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"REQUIRED")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeReturnresultsets">
<Description>
 attribute_ReturnResultSets ::= 'returnresultsets'
summary values:RETURNRESULTSETS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("RETURNRESULTSETS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"RETURNRESULTSETS")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSchemaspec">
<Description>
 attribute_SchemaSpec ::= 'schemaspec' '=' string
summary values:SCHEMASPEC</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SCHEMASPEC"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SCHEMASPEC")  {
		if ..addPunctuation(subElement,"=")  {
			if ..String(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeServeronly">
<Description>
 attribute_ServerOnly ::= 'serveronly' '=' ( '0' | '1' )
summary values:SERVERONLY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SERVERONLY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SERVERONLY")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeServeronly156Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeServeronly156Sub">
<Description>
 '0' | '1'
summary values:0,1</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("0","1"),1,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"1")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoapaction">
<Description>
 attribute_SOAPAction ::= 'soapaction' '=' (identifier | string)
summary values:SOAPACTION</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SOAPACTION"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SOAPACTION")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSoapaction157Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoapaction157Sub">
<Description>
identifier | string</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..String(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoapbindingstyle">
<Description>
 attribute_SOAPBindingStyle ::= 'SoapBindingStyle' '=' ( 'document' | 'rcp' )
summary values:SOAPBINDINGSTYLE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SOAPBINDINGSTYLE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SOAPBINDINGSTYLE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSoapbindingstyle158Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoapbindingstyle158Sub">
<Description>
 'document' | 'rcp'
summary values:DOCUMENT,RCP</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("DOCUMENT","RCP"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"DOCUMENT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"RCP")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoapbodyuse">
<Description>
 attribute_SOAPBodyuse ::= 'soapbodyuse' '=' ( 'literal' | 'encoded' )
summary values:SOAPBODYUSE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SOAPBODYUSE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SOAPBODYUSE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSoapbodyuse159Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoapbodyuse159Sub">
<Description>
 'literal' | 'encoded'
summary values:LITERAL,ENCODED</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("LITERAL","ENCODED"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"LITERAL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ENCODED")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoapmessagename">
<Description>
 attribute_SOAPMessageName ::= 'soapmessagename' '=' ( string | soap_identifier )
summary values:SOAPMESSAGENAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SOAPMESSAGENAME"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SOAPMESSAGENAME")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSoapmessagename160Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoapmessagename160Sub">
<Description>
 string | soap_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SoapIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoapnamespace">
<Description>
 attribute_SOAPNameSpace ::= 'soapnamespace' '=' ( string | soap_identifier)
summary values:SOAPNAMESPACE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SOAPNAMESPACE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SOAPNAMESPACE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSoapnamespace161Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoapnamespace161Sub">
<Description>
 string | soap_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SoapIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoaprequestmessage">
<Description>
 attribute_SOAPRequestMessage ::= 'soaprequestmessage' '=' ( string | soap_identifier )
summary values:SOAPREQUESTMESSAGE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SOAPREQUESTMESSAGE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SOAPREQUESTMESSAGE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSoaprequestmessage162Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoaprequestmessage162Sub">
<Description>
 string | soap_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SoapIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoaptypenamespace">
<Description>
 attribute_SOAPTypeNamespace ::= 'soaptypenamespace' '=' ( string | soap_identifier )
summary values:SOAPTYPENAMESPACE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SOAPTYPENAMESPACE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SOAPTYPENAMESPACE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSoaptypenamespace163Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSoaptypenamespace163Sub">
<Description>
 string | soap_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SoapIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlcategory">
<Description>
 attribute_SQLCategory ::= 'sqlcategory' '=' ( 'date' | 'double' | 'fmdate' | 'fmtimestamp' | 'integer' | 'mvdate' | 'name' | 'numeric' | 'string' | 'time' | 'timestamp' | 'POSIXTS' )
summary values:SQLCATEGORY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SQLCATEGORY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLCATEGORY")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSqlcategory164Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlcategory164Sub">
<Description>
 'date' | 'double' | 'fmdate' | 'fmtimestamp' | 'integer' | 'mvdate' | 'name' | 'numeric' | 'string' | 'time' | 'timestamp' | 'POSIXTS'
summary values:DATE,DOUBLE,FMDATE,FMTIMESTAMP,INTEGER,MVDATE,NAME,NUMERIC,STRING,TIME,TIMESTAMP,POSIXTS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K|K|K|K|K|K|K|K
	if '(..isKeywordInList($lb("DATE","DOUBLE","FMDATE","FMTIMESTAMP","INTEGER","MVDATE","NAME","NUMERIC","STRING","TIME","TIMESTAMP","POSIXTS"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"DATE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DOUBLE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FMDATE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FMTIMESTAMP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INTEGER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MVDATE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NAME")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NUMERIC")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"STRING")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TIME")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TIMESTAMP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"POSIXTS")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlcolumnnumber">
<Description>
 attribute_SQLColumnNumber ::= 'SqlColumnNumber' '=' number
summary values:SQLCOLUMNNUMBER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SQLCOLUMNNUMBER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLCOLUMNNUMBER")  {
		if ..addPunctuation(subElement,"=")  {
			if ..Number(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlcomputecode">
<Description>
 attribute_SQLComputeCode ::= 'sqlcomputecode' '=' '{' cos_code_block_sql '}'
summary values:SQLCOMPUTECODE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("SQLCOMPUTECODE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLCOMPUTECODE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..addPunctuation(subElement,"{")  {
				if ..CosCodeBlockSql(subElement,.addedElement)  {
					if ..addPunctuation(subElement,"}")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlcomputed">
<Description>
 attribute_SQLComputed ::= 'sqlcomputed'
summary values:SQLCOMPUTED</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("SQLCOMPUTED"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLCOMPUTED")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlcomputeonchange">
<Description>
 attribute_SQLComputeOnChange ::= 'sqlcomputeonchange' '=' property_reference | ('(' property_reference (',' property_reference )* ')')
summary values:SQLCOMPUTEONCHANGE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?|?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SQLCOMPUTEONCHANGE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLCOMPUTEONCHANGE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..PropertyReference(subElement,.addedElement)  {
				set done=1 ; or
			} elseif ..AttributeSqlcomputeonchange165Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlcomputeonchange165Sub">
<Description>
'(' property_reference (',' property_reference )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..PropertyReference(subElement,.addedElement)  {
			if ..AttributeSqlcomputeonchange166RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlcomputeonchange166RepZero">
<Description>
 (',' property_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..AttributeSqlcomputeonchange167Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlcomputeonchange167Sub">
<Description>
',' property_reference
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..PropertyReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlfieldname">
<Description>
 attribute_SQLFieldname ::= 'sqlfieldname' '=' sql_field_name
summary values:SQLFIELDNAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SQLFIELDNAME"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLFIELDNAME")  {
		if ..addPunctuation(subElement,"=")  {
			if ..SqlFieldName(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqllistdelimiter">
<Description>
 attribute_SQLListDelimiter ::= 'sqllistdelimiter' '=' expression
summary values:SQLLISTDELIMITER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SQLLISTDELIMITER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLLISTDELIMITER")  {
		if ..addPunctuation(subElement,"=")  {
			if ..Expression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqllisttype">
<Description>
 attribute_SQLListType ::= 'sqllisttype' '=' ( 'list' | 'delimited' | 'subnode' )
summary values:SQLLISTTYPE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SQLLISTTYPE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLLISTTYPE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSqllisttype168Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqllisttype168Sub">
<Description>
 'list' | 'delimited' | 'subnode'
summary values:LIST,DELIMITED,SUBNODE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K
	if '(..isKeywordInList($lb("LIST","DELIMITED","SUBNODE"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"LIST")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DELIMITED")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SUBNODE")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlname">
<Description>
 attribute_SQLName ::= 'sqlname' '=' (sql_table_name | string )
summary values:SQLNAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SQLNAME"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLNAME")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSqlname169Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlname169Sub">
<Description>
sql_table_name | string</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlTableName(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..String(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlproc">
<Description>
 attribute_SQLProc ::= 'sqlproc'
summary values:SQLPROC</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("SQLPROC"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLPROC")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlrowidname">
<Description>
 attribute_SQLRowidName ::= 'sqlrowidname' '=' ( '""' | string | sql_table_name )
summary values:SQLROWIDNAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SQLROWIDNAME"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLROWIDNAME")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSqlrowidname170Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlrowidname170Sub">
<Description>
 '""' | string | sql_table_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"""""")  {
		set done=1 ; or
	} elseif ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlTableName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlrowidprivate">
<Description>
 attribute_SQLRowidPrivate ::= 'sqlrowidprivate'
summary values:SQLROWIDPRIVATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("SQLROWIDPRIVATE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLROWIDPRIVATE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqltablename">
<Description>
 attribute_SQLTableName ::= 'sqltablename' '=' ( '""' | sql_table_name )
summary values:SQLTABLENAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SQLTABLENAME"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLTABLENAME")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSqltablename171Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqltablename171Sub">
<Description>
 '""' | sql_table_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"""""")  {
		set done=1 ; or
	} elseif ..SqlTableName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlview">
<Description>
 attribute_SQLView ::= 'sqlview'
summary values:SQLVIEW</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("SQLVIEW"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLVIEW")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlviewname">
<Description>
 attribute_SQLViewname ::= 'sqlviewname' '=' ( string | sql_table_name )
summary values:SQLVIEWNAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SQLVIEWNAME"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLVIEWNAME")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSqlviewname172Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSqlviewname172Sub">
<Description>
 string | sql_table_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlTableName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeStoragestrategy">
<Description>
 attribute_StorageStrategy ::= 'storagestrategy' '=' ('""' | class_item_identifier)
summary values:STORAGESTRATEGY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("STORAGESTRATEGY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"STORAGESTRATEGY")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeStoragestrategy173Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeStoragestrategy173Sub">
<Description>
'""' | class_item_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"""""")  {
		set done=1 ; or
	} elseif ..ClassItemIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSystem">
<Description>
 attribute_System ::= 'system' '=' ( '0' | '1' | '2' | '3' | '4' )
summary values:SYSTEM</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SYSTEM"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SYSTEM")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeSystem174Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeSystem174Sub">
<Description>
 '0' | '1' | '2' | '3' | '4'
summary values:0,1,2,3,4</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P
	if '(..isStringInList($lb("0","1","2","3","4"),1,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"1")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"2")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"3")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"4")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeTime">
<Description>
 attribute_Time ::= 'time' '=' time_value
summary values:TIME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("TIME"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"TIME")  {
		if ..addPunctuation(subElement,"=")  {
			if ..TimeValue(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeTransient">
<Description>
 attribute_Transient ::= 'transient'
summary values:TRANSIENT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("TRANSIENT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"TRANSIENT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeType">
<Description>
 attribute_Type ::= 'type' '=' ( 'bitmap' | 'bitslice' | 'index' |'key' | 'collatedkey' )
summary values:TYPE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("TYPE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"TYPE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeType175Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeType175Sub">
<Description>
 'bitmap' | 'bitslice' | 'index' |'key' | 'collatedkey'
summary values:BITMAP,BITSLICE,INDEX,KEY,COLLATEDKEY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K
	if '(..isKeywordInList($lb("BITMAP","BITSLICE","INDEX","KEY","COLLATEDKEY"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"BITMAP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"BITSLICE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INDEX")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"KEY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"COLLATEDKEY")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeUnique">
<Description>
 attribute_Unique ::= 'unique'
summary values:UNIQUE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("UNIQUE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"UNIQUE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeUpdatecolumnlist">
<Description>
 attribute_UpdateColumnList ::= 'updatecolumnlist' '=' ( one_column_name | ( '(' one_column_name ( ',' one_column_name )* ')' ) )
summary values:UPDATECOLUMNLIST</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("UPDATECOLUMNLIST"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"UPDATECOLUMNLIST")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeUpdatecolumnlist176Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeUpdatecolumnlist176Sub">
<Description>
 one_column_name | ( '(' one_column_name ( ',' one_column_name )* ')' )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneColumnName(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeUpdatecolumnlist177Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeUpdatecolumnlist177Sub">
<Description>
 '(' one_column_name ( ',' one_column_name )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..OneColumnName(subElement,.addedElement)  {
			if ..AttributeUpdatecolumnlist178RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeUpdatecolumnlist178RepZero">
<Description>
 ( ',' one_column_name )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..AttributeUpdatecolumnlist179Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeUpdatecolumnlist179Sub">
<Description>
 ',' one_column_name
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..OneColumnName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeViewquery">
<Description>
 attribute_ViewQuery ::= 'viewquery' '=' '{' class_query_body '}'
summary values:VIEWQUERY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("VIEWQUERY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"VIEWQUERY")  {
		if ..addPunctuation(subElement,"=")  {
			if ..addPunctuation(subElement,"{")  {
				if ..ClassQueryBody(subElement,.addedElement)  {
					if ..addPunctuation(subElement,"}")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeWebmethod">
<Description>
 attribute_WebMethod ::= 'webmethod'
summary values:WEBMETHOD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("WEBMETHOD"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WEBMETHOD")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeXmlnamespace">
<Description>
 attribute_XMLNamespace ::= 'xmlnamespace' '=' (string | identifier)
summary values:XMLNAMESPACE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("XMLNAMESPACE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"XMLNAMESPACE")  {
		if ..addPunctuation(subElement,"=")  {
			if ..AttributeXmlnamespace180Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeXmlnamespace180Sub">
<Description>
string | identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AttributeZenmethod">
<Description>
 attribute_ZenMethod ::= 'zenmethod'
summary values:ZENMETHOD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("ZENMETHOD"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ZENMETHOD")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassAttribute">
<Description>
 class_attribute ::= attribute_Abstract | attribute_ClassType | attribute_ClientDataType | attribute_ClientName | attribute_CompileAfter | attribute_DDLAllowed | attribute_DependsOn | attribute_Deprecated | attribute_Embeddedclass | attribute_Final | attribute_GeneratedBy | attribute_Hidden | attribute_Inheritance | attribute_Language | attribute_LegacyInstanceContext | attribute_MemberSuper | attribute_NoContext | attribute_NoExtent | attribute_Not | attribute_ODBCType | attribute_Owner | attribute_ProcedureBlock | attribute_PropertyClass | attribute_ServerOnly | attribute_SOAPBindingStyle | attribute_SOAPBodyuse | attribute_SQLCategory | attribute_SQLRowidName | attribute_SQLRowidPrivate | attribute_SQLTableName | attribute_StorageStrategy | attribute_System | attribute_ViewQuery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeAbstract(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeClasstype(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeClientdatatype(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeClientname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeCompileafter(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeDdlallowed(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeDependson(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeDeprecated(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeEmbeddedclass(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeFinal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeGeneratedby(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeHidden(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeInheritance(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeLanguage(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeLegacyinstancecontext(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeMembersuper(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeNocontext(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeNoextent(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeNot(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeOdbctype(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeOwner(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeProcedureblock(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributePropertyclass(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeServeronly(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSoapbindingstyle(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSoapbodyuse(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlcategory(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlrowidname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlrowidprivate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqltablename(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeStoragestrategy(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSystem(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeViewquery(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassAttributeList">
<Description>
 class_attribute_list ::= class_attribute ( ',' class_attribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassAttribute(subElement,.addedElement)  {
		if ..ClassAttributeList15RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassAttributeList15RepZero">
<Description>
 ( ',' class_attribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ClassAttributeList16Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ClassAttributeList16Sub">
<Description>
 ',' class_attribute
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ClassAttribute(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassAttributes">
<Description>
 class_attributes ::= '[' class_attribute_list ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..ClassAttributeList(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"]")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassClassMethod">
<Description>
 class_class_method ::= 'classmethod' method_name '(' [ formal_spec_list ] ')' [ 'as' return_type_class_reference ] [ method_attribute_list ] '{' method_body '}'
summary values:CLASSMETHOD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&P&?4?&P&?4?&?4?&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("CLASSMETHOD"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CLASSMETHOD")  {
		if ..MethodName(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"(")  {
				if $S(..FormalSpecList(subElement,.addedElement) :1,1:1) {
					if ..addPunctuation(subElement,")")  {
						if ..ClassClassMethod30OptGrp(subElement,.addedElement)  {
							if $S(..MethodAttributeList(subElement,.addedElement) :1,1:1) {
								if ..addPunctuation(subElement,"{")  {
									if ..MethodBody(subElement,.addedElement)  {
										if ..addPunctuation(subElement,"}")  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassClassMethod30OptGrp">
<Description>

summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..ReturnTypeClassReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassClientMethod">
<Description>
 class_client_method ::= 'clientmethod' method_name '(' [ formal_spec_list ] ')' [ 'as' type_class_reference ] [ method_attribute_list ] '{' javascript_code_block '}'
summary values:CLIENTMETHOD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&P&?4?&P&?4?&?4?&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("CLIENTMETHOD"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CLIENTMETHOD")  {
		if ..MethodName(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"(")  {
				if $S(..FormalSpecList(subElement,.addedElement) :1,1:1) {
					if ..addPunctuation(subElement,")")  {
						if ..ClassClientMethod36OptGrp(subElement,.addedElement)  {
							if $S(..MethodAttributeList(subElement,.addedElement) :1,1:1) {
								if ..addPunctuation(subElement,"{")  {
									if ..JavascriptCodeBlock(subElement,.addedElement)  {
										if ..addPunctuation(subElement,"}")  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassClientMethod36OptGrp">
<Description>

summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..TypeClassReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassDefinition">
<Description>
 class_definition ::= 'class' class_name [ 'extends' ( class_reference_list | class_reference ) ] [class_attributes] class_member_section
summary values:CLASS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CLASS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CLASS")  {
		if ..ClassName(subElement,.addedElement)  {
			if ..ClassDefinition11OptGrp(subElement,.addedElement)  {
				if $S(..ClassAttributes(subElement,.addedElement) :1,1:1) {
					if ..ClassMemberSection(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassDefinition11OptGrp">
<Description>

summary values:EXTENDS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("EXTENDS"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"EXTENDS")  {
		if ..ClassDefinition12Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassDefinition12Sub">
<Description>
 class_reference_list | class_reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassReferenceList(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassForeignkey">
<Description>
 class_ForeignKey ::= 'foreignkey' foreignkey_name [ '(' key_props ')' ] 'references' class_reference [ '(' [ref_props] ')' ] [ foreignKey_attribute_list ] ';'
summary values:FOREIGNKEY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?&K&?1Rule?&?4?&?4?&P
	; first rule summary K
	if '(..isKeywordInList($lb("FOREIGNKEY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FOREIGNKEY")  {
		if ..ForeignkeyName(subElement,.addedElement)  {
			if ..ClassForeignkey38OptGrp(subElement,.addedElement)  {
				if ..addKeyword(subElement,"REFERENCES")  {
					if ..ClassReference(subElement,.addedElement)  {
						if ..ClassForeignkey39OptGrp(subElement,.addedElement)  {
							if $S(..ForeignkeyAttributeList(subElement,.addedElement) :1,1:1) {
								if ..addPunctuation(subElement,";")  {
									set done=1 ; end compileRules
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassForeignkey38OptGrp">
<Description>

summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..KeyProps(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassForeignkey39OptGrp">
<Description>

summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if $S(..RefProps(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassIdentifier">
<Description>
 class_identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
summary values:REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassIndex">
<Description>
 class_index ::= 'index' index_name [ 'on' index_property_expression_list ] [ index_attributes ] [ 'as' type_class_reference ]';'
summary values:INDEX</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?&?4?&?4?&P
	; first rule summary K
	if '(..isKeywordInList($lb("INDEX"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INDEX")  {
		if ..IndexName(subElement,.addedElement)  {
			if ..ClassIndex112OptGrp(subElement,.addedElement)  {
				if $S(..IndexAttributes(subElement,.addedElement) :1,1:1) {
					if ..ClassIndex113OptGrp(subElement,.addedElement)  {
						if ..addPunctuation(subElement,";")  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassIndex112OptGrp">
<Description>

summary values:ON</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ON"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ON")  {
		if ..IndexPropertyExpressionList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassIndex113OptGrp">
<Description>

summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..TypeClassReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassItemIdentifier">
<Description>
 class_item_identifier ::= string | identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassLanguageName">
<Description>
 class_language_name ::= 'cache' | 'basic' | 'javascript' | 'java' | 'mvbasic' | 'tsql' | 'cpp' | 'objectscript' | 'python'
summary values:CACHE,BASIC,JAVASCRIPT,JAVA,MVBASIC,TSQL,CPP,OBJECTSCRIPT,PYTHON</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K|K|K|K|K
	if '(..isKeywordInList($lb("CACHE","BASIC","JAVASCRIPT","JAVA","MVBASIC","TSQL","CPP","OBJECTSCRIPT","PYTHON"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CACHE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"BASIC")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"JAVASCRIPT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"JAVA")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MVBASIC")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TSQL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"CPP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"OBJECTSCRIPT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"PYTHON")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassMemberList">
<Description>
 class_member_list ::= one_classMember ( one_classMember )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneClassmember(subElement,.addedElement)  {
		if ..ClassMemberList17RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassMemberList17RepZero">
<Description>
 ( one_classMember )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ClassMemberList18Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ClassMemberList18Sub">
<Description>
 one_classMember</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneClassmember(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassMemberSection">
<Description>
 class_member_section ::= '{' class_member_list? '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if $s(..ClassMemberList(subElement,.addedElement) :1,1:1)  {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassMethod">
<Description>
 class_method ::= 'method' method_name '(' [ formal_spec_list ] ')' [ 'as' return_type_class_reference ] [ method_attribute_list ] '{' method_body '}'
summary values:METHOD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&P&?4?&P&?4?&?4?&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("METHOD"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"METHOD")  {
		if ..MethodName(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"(")  {
				if $S(..FormalSpecList(subElement,.addedElement) :1,1:1) {
					if ..addPunctuation(subElement,")")  {
						if ..ClassMethod31OptGrp(subElement,.addedElement)  {
							if $S(..MethodAttributeList(subElement,.addedElement) :1,1:1) {
								if ..addPunctuation(subElement,"{")  {
									if ..MethodBody(subElement,.addedElement)  {
										if ..addPunctuation(subElement,"}")  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassMethod31OptGrp">
<Description>

summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..ReturnTypeClassReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassName">
<Description>
 class_name ::= class_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassParameter">
<Description>
 class_parameter ::= 'parameter' class_parameter_name [ 'as' class_parameter_type ] [ class_parameter_attribute_list ] [ '=' class_parameter_value ] ';'
summary values:PARAMETER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?&?4?&?4?&P
	; first rule summary K
	if '(..isKeywordInList($lb("PARAMETER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PARAMETER")  {
		if ..ClassParameterName(subElement,.addedElement)  {
			if ..ClassParameter45OptGrp(subElement,.addedElement)  {
				if $S(..ClassParameterAttributeList(subElement,.addedElement) :1,1:1) {
					if ..ClassParameter46OptGrp(subElement,.addedElement)  {
						if ..addPunctuation(subElement,";")  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassParameter45OptGrp">
<Description>

summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..ClassParameterType(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassParameter46OptGrp">
<Description>

summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("=",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		if ..ClassParameterValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassParameterAttribute">
<Description>
 class_parameter_attribute ::= attribute_Abstract | attribute_Constraint | attribute_Final | attribute_Flags | attribute_Internal | attribute_Deprecated</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeAbstract(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeConstraint(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeFinal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeFlags(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeInternal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeDeprecated(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassParameterAttributeList">
<Description>
 class_parameter_attribute_list ::= '[' class_parameter_attribute ( ',' class_parameter_attribute )* ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..ClassParameterAttribute(subElement,.addedElement)  {
			if ..ClassParameterAttributeList48RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"]")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassParameterAttributeList48RepZero">
<Description>
 ( ',' class_parameter_attribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ClassParameterAttributeList49Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ClassParameterAttributeList49Sub">
<Description>
 ',' class_parameter_attribute
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ClassParameterAttribute(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassParameterName">
<Description>
 class_parameter_name ::= class_item_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassParameterType">
<Description>
 class_parameter_type ::= class_reference | 'COSEXPRESSION'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassReference(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"COSEXPRESSION")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassParameterValue">
<Description>
 class_parameter_value ::= string | number | ( '{' expression '}' )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Number(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassParameterValue47Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassParameterValue47Sub">
<Description>
 '{' expression '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..Expression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassProjection">
<Description>
 class_projection ::= 'projection' projection_name [ class_projection_type ] [ class_property_attributes ] ';'
summary values:PROJECTION</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?&?4?&P
	; first rule summary K
	if '(..isKeywordInList($lb("PROJECTION"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PROJECTION")  {
		if ..ProjectionName(subElement,.addedElement)  {
			if $S(..ClassProjectionType(subElement,.addedElement) :1,1:1) {
				if $S(..ClassPropertyAttributes(subElement,.addedElement) :1,1:1) {
					if ..addPunctuation(subElement,";")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassProjectionType">
<Description>
 class_projection_type ::= 'as' type_class_reference
summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..TypeClassReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassProperty">
<Description>
 class_property ::= 'property' property_name [ class_property_type ] [ class_property_attributes ] ';'
summary values:PROPERTY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?&?4?&P
	; first rule summary K
	if '(..isKeywordInList($lb("PROPERTY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PROPERTY")  {
		if ..PropertyName(subElement,.addedElement)  {
			if $S(..ClassPropertyType(subElement,.addedElement) :1,1:1) {
				if $S(..ClassPropertyAttributes(subElement,.addedElement) :1,1:1) {
					if ..addPunctuation(subElement,";")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassPropertyAttribute">
<Description>
 class_property_attribute ::= attribute_Aliases | attribute_Calculated | attribute_Cardinality | attribute_ClientName | attribute_Deprecated | attribute_Final | attribute_Identity | attribute_InitialExpression | attribute_Internal | attribute_Inverse | attribute_MultiDimensional | attribute_OnDelete | attribute_Private | attribute_ReadOnly | attribute_Required | attribute_ServerOnly | attribute_SQLColumnNumber | attribute_SQLComputeCode | attribute_SQLComputed | attribute_SQLComputeOnChange | attribute_SQLFieldname | attribute_SQLListDelimiter | attribute_SQLListType | attribute_Transient | attribute_Not</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeAliases(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeCalculated(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeCardinality(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeClientname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeDeprecated(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeFinal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeIdentity(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeInitialexpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeInternal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeInverse(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeMultidimensional(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeOndelete(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributePrivate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeReadonly(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeRequired(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeServeronly(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlcolumnnumber(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlcomputecode(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlcomputed(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlcomputeonchange(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlfieldname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqllistdelimiter(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqllisttype(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeTransient(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeNot(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassPropertyAttributeList">
<Description>
 class_property_attribute_list ::= class_property_attribute ( ',' class_property_attribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassPropertyAttribute(subElement,.addedElement)  {
		if ..ClassPropertyAttributeList25RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassPropertyAttributeList25RepZero">
<Description>
 ( ',' class_property_attribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ClassPropertyAttributeList26Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ClassPropertyAttributeList26Sub">
<Description>
 ',' class_property_attribute
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ClassPropertyAttribute(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassPropertyAttributes">
<Description>
 class_property_attributes ::= '[' class_property_attribute_list ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..ClassPropertyAttributeList(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"]")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassPropertyType">
<Description>
 class_property_type ::= ('as' [ ( 'array' | 'list' ) 'of' ] type_class_reference ) | type_parameters</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassPropertyType22Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TypeParameters(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassPropertyType22Sub">
<Description>
'as' [ ( 'array' | 'list' ) 'of' ] type_class_reference
summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..ClassPropertyType23OptGrp(subElement,.addedElement)  {
			if ..TypeClassReference(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassPropertyType23OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassPropertyType24Sub(subElement,.addedElement)  {
		if ..addKeyword(subElement,"OF")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassPropertyType24Sub">
<Description>
 'array' | 'list'
summary values:ARRAY,LIST</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("ARRAY","LIST"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"ARRAY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LIST")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ClassQuery">
<Description>
 class_query ::= 'query' query_name '(' [ formal_spec_list ] ')' [ 'as' type_class_reference ] [ class_query_attributes ] '{' class_query_body '}'
summary values:QUERY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&P&?4?&P&?4?&?4?&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("QUERY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"QUERY")  {
		if ..QueryName(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"(")  {
				if $S(..FormalSpecList(subElement,.addedElement) :1,1:1) {
					if ..addPunctuation(subElement,")")  {
						if ..ClassQuery87OptGrp(subElement,.addedElement)  {
							if $S(..ClassQueryAttributes(subElement,.addedElement) :1,1:1) {
								if ..addPunctuation(subElement,"{")  {
									if ..ClassQueryBody(subElement,.addedElement)  {
										if ..addPunctuation(subElement,"}")  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassQuery87OptGrp">
<Description>

summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..TypeClassReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassQueryAttribute">
<Description>
 class_query_attribute ::= attribute_ClientName | attribute_Deprecated | attribute_Final | attribute_Internal | attribute_Private | attribute_SOAPBindingStyle | attribute_SOAPBodyuse | attribute_SOAPNameSpace | attribute_SQLName | attribute_SQLProc | attribute_SQLView | attribute_SQLViewname | attribute_WebMethod</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeClientname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeDeprecated(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeFinal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeInternal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributePrivate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSoapbindingstyle(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSoapbodyuse(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSoapnamespace(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlproc(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlview(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlviewname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeWebmethod(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassQueryAttributes">
<Description>
 class_query_attributes ::= '[' class_query_attribute ( ',' class_query_attribute )* ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..ClassQueryAttribute(subElement,.addedElement)  {
			if ..ClassQueryAttributes88RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"]")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassQueryAttributes88RepZero">
<Description>
 ( ',' class_query_attribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ClassQueryAttributes89Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ClassQueryAttributes89Sub">
<Description>
 ',' class_query_attribute
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ClassQueryAttribute(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassQueryBody">
<Description>
 class_query_body ::= text_brace_block</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TextBraceBlock(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassReference">
<Description>
 class_reference ::= class_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassReferenceList">
<Description>
 class_reference_list ::= '(' [class_reference] ( ',' class_reference )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if $S(..ClassReference(subElement,.addedElement) :1,1:1) {
			if ..ClassReferenceList13RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassReferenceList13RepZero">
<Description>
 ( ',' class_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ClassReferenceList14Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ClassReferenceList14Sub">
<Description>
 ',' class_reference
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ClassReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassRelationship">
<Description>
 class_relationship ::= 'relationship' property_name [ class_property_type ] class_property_attributes ';'
summary values:RELATIONSHIP</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("RELATIONSHIP"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"RELATIONSHIP")  {
		if ..PropertyName(subElement,.addedElement)  {
			if $S(..ClassPropertyType(subElement,.addedElement) :1,1:1) {
				if ..ClassPropertyAttributes(subElement,.addedElement)  {
					if ..addPunctuation(subElement,";")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassStorage">
<Description>
 class_storage ::= 'storage' storage_name '{' storage_xml '}'
summary values:STORAGE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("STORAGE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"STORAGE")  {
		if ..StorageName(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"{")  {
				if ..StorageXml(subElement,.addedElement)  {
					if ..addPunctuation(subElement,"}")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassTrigger">
<Description>
 class_trigger ::= 'trigger' trigger_name [ trigger_attribute_list ] '{' [ trigger_code_block ] '}'
summary values:TRIGGER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?&P&?4?&P
	; first rule summary K
	if '(..isKeywordInList($lb("TRIGGER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"TRIGGER")  {
		if ..TriggerName(subElement,.addedElement)  {
			if $S(..TriggerAttributeList(subElement,.addedElement) :1,1:1) {
				if ..addPunctuation(subElement,"{")  {
					if $S(..TriggerCodeBlock(subElement,.addedElement) :1,1:1) {
						if ..addPunctuation(subElement,"}")  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassTypeName">
<Description>
 class_type_name ::= 'datatype' | 'persistent' | 'serial' | 'stream' | 'view' | 'index' | 'donotuse' | 'dynamic' | '""'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K|K|K|K|P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DATATYPE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"PERSISTENT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SERIAL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"STREAM")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"VIEW")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INDEX")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DONOTUSE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DYNAMIC")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"""""")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassXdata">
<Description>
 class_xdata ::= 'xdata' xdata_name [ '[' (xdata_attributes)* ']' ] '{' (xdata_text | xdata_xml | xdata_json ) '}'
summary values:XDATA</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("XDATA"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"XDATA")  {
		if ..XdataName(subElement,.addedElement)  {
			if ..ClassXdata90OptGrp(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"{")  {
					if ..ClassXdata93Sub(subElement,.addedElement)  {
						if ..addPunctuation(subElement,"}")  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassXdata90OptGrp">
<Description>

summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..ClassXdata91RepZero(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"]")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassXdata91RepZero">
<Description>
 (xdata_attributes)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ClassXdata92Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ClassXdata92Sub">
<Description>
xdata_attributes</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XdataAttributes(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassXdata93Sub">
<Description>
xdata_text | xdata_xml | xdata_json</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XdataText(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..XdataXml(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..XdataJson(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClientDataTypeName">
<Description>
 client_data_type_name ::= 'bigint' | 'binary' | 'binarystream' | 'boolean' | 'characterstream' | 'currency' | 'date' | 'decimal' | 'double' | 'fdate' | 'ftimestamp' | 'handle' | 'integer' | 'list' | 'longvarchar' | 'numeric' | 'status' | 'timestamp' | 'time' | 'varchar' | 'MVDATE'
summary values:BIGINT,BINARY,BINARYSTREAM,BOOLEAN,CHARACTERSTREAM,CURRENCY,DATE,DECIMAL,DOUBLE,FDATE,FTIMESTAMP,HANDLE,INTEGER,LIST,LONGVARCHAR,NUMERIC,STATUS,TIMESTAMP,TIME,VARCHAR,MVDATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K
	if '(..isKeywordInList($lb("BIGINT","BINARY","BINARYSTREAM","BOOLEAN","CHARACTERSTREAM","CURRENCY","DATE","DECIMAL","DOUBLE","FDATE","FTIMESTAMP","HANDLE","INTEGER","LIST","LONGVARCHAR","NUMERIC","STATUS","TIMESTAMP","TIME","VARCHAR","MVDATE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BIGINT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"BINARY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"BINARYSTREAM")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"BOOLEAN")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"CHARACTERSTREAM")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"CURRENCY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DATE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DECIMAL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DOUBLE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FDATE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FTIMESTAMP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"HANDLE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INTEGER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LIST")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LONGVARCHAR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NUMERIC")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"STATUS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TIMESTAMP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TIME")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"VARCHAR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MVDATE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClientIdentifier">
<Description>
 client_identifier ::= 'NEEDS CLIENT IDENTIFIER'
summary values:NEEDS CLIENT IDENTIFIER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS CLIENT IDENTIFIER",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS CLIENT IDENTIFIER")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CollationType">
<Description>
 collation_type ::= 'exact' | 'mvr' | 'sqlstring' | ('sqlupper' [ '(' number ')' ] )| 'truncate' | 'plus' | 'minus' | 'alphaup' | 'string' | 'upper' | 'space'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|?1Rule?|K|K|K|K|K|K|K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"EXACT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MVR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SQLSTRING")  {
		set done=1 ; or
	} elseif ..CollationType118Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TRUNCATE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"PLUS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MINUS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ALPHAUP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"STRING")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"UPPER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SPACE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CollationType118Sub">
<Description>
'sqlupper' [ '(' number ')' ]
summary values:SQLUPPER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("SQLUPPER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SQLUPPER")  {
		if ..CollationType119OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CollationType119OptGrp">
<Description>

summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..Number(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlock">
<Description>
 cos_code_block ::= 'NEEDS COS CODE BLOCK'
summary values:NEEDS COS CODE BLOCK</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS COS CODE BLOCK",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS COS CODE BLOCK")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockSql">
<Description>
 cos_code_block_sql ::= 'NEEDS COS SQL CODE BLOCK'
summary values:NEEDS COS SQL CODE BLOCK</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS COS SQL CODE BLOCK",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS COS SQL CODE BLOCK")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockSqlStorage">
<Description>
 cos_code_block_sql_storage ::= 'NEEDS COS SQL CODE BLOCK'
summary values:NEEDS COS SQL CODE BLOCK</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS COS SQL CODE BLOCK",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS COS SQL CODE BLOCK")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockStorage">
<Description><![CDATA[
 cos_code_block_storage ::= ('<!' '[CDATA[' cos_code_block_sql_storage ']]' '>') | cos_code_block_sql_storage]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosCodeBlockStorage190Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosCodeBlockSqlStorage(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockStorage190Sub">
<Description><![CDATA[
'<!' '[CDATA[' cos_code_block_sql_storage ']]' '>'
summary values:<!]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P&P
	; first rule summary P
	if '(..isStringSingle("<!",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<!")  {
		if ..addPunctuation(subElement,"[CDATA[")  {
			if ..CosCodeBlockSqlStorage(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"]]")  {
					if ..addPunctuation(subElement,">")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockTrigger">
<Description>
 cos_code_block_trigger ::= 'NEEDS COS SQL CODE BLOCK'
summary values:NEEDS COS SQL CODE BLOCK</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS COS SQL CODE BLOCK",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS COS SQL CODE BLOCK")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosExpressionSql">
<Description>
 cos_expression_sql ::= 'NEEDS COS EXPRESSION SQL'
summary values:NEEDS COS EXPRESSION SQL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS COS EXPRESSION SQL",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS COS EXPRESSION SQL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosExpressionStorage">
<Description><![CDATA[
 cos_expression_storage ::= ('<!' '[CDATA[' cos_expression_sql ']]' '>') | cos_expression_sql]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosExpressionStorage189Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CosExpressionSql(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosExpressionStorage189Sub">
<Description><![CDATA[
'<!' '[CDATA[' cos_expression_sql ']]' '>'
summary values:<!]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P&P
	; first rule summary P
	if '(..isStringSingle("<!",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<!")  {
		if ..addPunctuation(subElement,"[CDATA[")  {
			if ..CosExpressionSql(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"]]")  {
					if ..addPunctuation(subElement,">")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EventKeyword">
<Description>
 event_keyword ::= 'insert/update/delete' | 'insert/update' | 'insert/delete' | 'update/delete' | 'delete' | 'insert' | 'update'
summary values:INSERT/UPDATE/DELETE,INSERT/UPDATE,INSERT/DELETE,UPDATE/DELETE,DELETE,INSERT,UPDATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K|K|K
	if '(..isKeywordInList($lb("INSERT/UPDATE/DELETE","INSERT/UPDATE","INSERT/DELETE","UPDATE/DELETE","DELETE","INSERT","UPDATE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INSERT/UPDATE/DELETE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INSERT/UPDATE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INSERT/DELETE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"UPDATE/DELETE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DELETE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INSERT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"UPDATE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Expression">
<Description>
 expression ::= 'NEEDS EXPRESSION'
summary values:NEEDS EXPRESSION</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS EXPRESSION",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS EXPRESSION")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Fieldname">
<Description>
 fieldname ::= property_reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PropertyReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Filename">
<Description>
 filename ::= 'NEEDS FILE NAME'
summary values:NEEDS FILE NAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS FILE NAME",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS FILE NAME")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForeachType">
<Description>
 foreach_type ::= 'row' | 'row/object' | 'statement'
summary values:ROW,ROW/OBJECT,STATEMENT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K
	if '(..isKeywordInList($lb("ROW","ROW/OBJECT","STATEMENT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ROW")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ROW/OBJECT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"STATEMENT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForeignkeyAttributeList">
<Description>
 foreignKey_attribute_list ::= '[' one_foreignkey_atttribute ( ',' one_foreignkey_atttribute )* ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..OneForeignkeyAtttribute(subElement,.addedElement)  {
			if ..ForeignkeyAttributeList43RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"]")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForeignkeyAttributeList43RepZero">
<Description>
 ( ',' one_foreignkey_atttribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ForeignkeyAttributeList44Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ForeignkeyAttributeList44Sub">
<Description>
 ',' one_foreignkey_atttribute
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..OneForeignkeyAtttribute(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForeignkeyName">
<Description>
 foreignkey_name ::= class_item_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormalSpecItem">
<Description>
 formal_spec_item ::= [ formal_spec_mode ] variable_set ['...'] [ as_type_class_reference ] [ parameter_default_value ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&?4?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..FormalSpecMode(subElement,.addedElement) :1,1:1) {
		if ..VariableSet(subElement,.addedElement)  {
			if $S(..addPunctuation(subElement,"...") :1,1:1) {
				if $S(..AsTypeClassReference(subElement,.addedElement) :1,1:1) {
					if $S(..ParameterDefaultValue(subElement,.addedElement) :1,1:1) {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormalSpecList">
<Description>
 formal_spec_list ::= formal_spec_item( ',' formal_spec_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..FormalSpecItem(subElement,.addedElement)  {
		if ..FormalSpecList32RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormalSpecList32RepZero">
<Description>
( ',' formal_spec_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..FormalSpecList33Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="FormalSpecList33Sub">
<Description>
 ',' formal_spec_item
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..FormalSpecItem(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormalSpecMode">
<Description>
 formal_spec_mode ::= 'byref' | 'output' | 'byval'
summary values:BYREF,OUTPUT,BYVAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K
	if '(..isKeywordInList($lb("BYREF","OUTPUT","BYVAL"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BYREF")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"OUTPUT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"BYVAL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Global">
<Description>
 global ::= cos_expression_sql</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosExpressionSql(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<Description>
 identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
summary values:REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportDefinition">
<Description>
 import_definition ::= 'import' ( package_name | ( '(' package_list ')' ) )
summary values:IMPORT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("IMPORT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IMPORT")  {
		if ..ImportDefinition3Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportDefinition3Sub">
<Description>
 package_name | ( '(' package_list ')' )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PackageName(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ImportDefinition4Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportDefinition4Sub">
<Description>
 '(' package_list ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..PackageList(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IncludeDefinition">
<Description>
 include_definition ::= 'include' ( include_list | include_name )
summary values:INCLUDE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("INCLUDE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INCLUDE")  {
		if ..IncludeDefinition6Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IncludeDefinition6Sub">
<Description>
 include_list | include_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IncludeList(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IncludeName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IncludeGeneratorDefinition">
<Description>
 include_generator_definition ::= 'includegenerator' ( include_list | include_name )
summary values:INCLUDEGENERATOR</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("INCLUDEGENERATOR"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INCLUDEGENERATOR")  {
		if ..IncludeGeneratorDefinition5Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IncludeGeneratorDefinition5Sub">
<Description>
 include_list | include_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IncludeList(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IncludeName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IncludeList">
<Description>
 include_list ::= '(' include_name ( ',' include_name )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..IncludeName(subElement,.addedElement)  {
			if ..IncludeList9RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IncludeList10Sub">
<Description>
 ',' include_name
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..IncludeName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IncludeList9RepZero">
<Description>
 ( ',' include_name )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..IncludeList10Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="IncludeName">
<Description>
 include_name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexAttribute">
<Description>
 index_attribute ::= attribute_Condition | attribute_Data | attribute_Extent | attribute_IdKey | attribute_Internal | attribute_PrimaryKey | attribute_SQLName | attribute_Type | attribute_Unique</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeCondition(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeData(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeExtent(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeIdkey(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeInternal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributePrimarykey(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeType(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeUnique(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexAttributes">
<Description>
 index_attributes ::= '[' index_attribute ( ',' index_attribute )* ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..IndexAttribute(subElement,.addedElement)  {
			if ..IndexAttributes120RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"]")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexAttributes120RepZero">
<Description>
 ( ',' index_attribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..IndexAttributes121Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="IndexAttributes121Sub">
<Description>
 ',' index_attribute
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..IndexAttribute(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexName">
<Description>
 index_name ::= class_item_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexProperty">
<Description>
 index_property ::= fieldname ['(ELEMENTS)' | '(KEYS)' ] [ 'as' collation_type]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Fieldname(subElement,.addedElement)  {
		if ..IndexProperty116OptGrp(subElement,.addedElement)  {
			if ..IndexProperty117OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexProperty116OptGrp">
<Description>

summary values:(ELEMENTS),(KEYS)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("(ELEMENTS)","(KEYS)"),10,.value)) { quit 1 /* not found is OK */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"(ELEMENTS)")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"(KEYS)")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=1 /* failure rollsback but returns OK */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="IndexProperty117OptGrp">
<Description>

summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..CollationType(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexPropertyExpressionList">
<Description>
 index_property_expression_list ::= index_property | index_property_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IndexProperty(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IndexPropertyList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexPropertyList">
<Description>
 index_property_list ::= '(' index_property ( ',' index_property )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..IndexProperty(subElement,.addedElement)  {
			if ..IndexPropertyList114RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexPropertyList114RepZero">
<Description>
 ( ',' index_property )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..IndexPropertyList115Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="IndexPropertyList115Sub">
<Description>
 ',' index_property
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..IndexProperty(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InheritanceDirection">
<Description>
 inheritance_direction ::= 'left' | 'right'
summary values:LEFT,RIGHT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("LEFT","RIGHT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"LEFT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"RIGHT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InitialExpressionComplex">
<Description>
 initial_expression_complex ::= '{' expression '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..Expression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InitialExpressionSimple">
<Description>
 initial_expression_simple ::= string | number</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Number(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InitialexpressionValue">
<Description>
 initialexpression_value ::= initial_expression_complex | initial_expression_simple</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..InitialExpressionComplex(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..InitialExpressionSimple(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JavascriptCodeBlock">
<Description>
 javascript_code_block ::= 'NEEDS JS CODE BLOCK'
summary values:NEEDS JS CODE BLOCK</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS JS CODE BLOCK",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS JS CODE BLOCK")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JsonString">
<Description>
 json_string ::= 'NEED JSON STRING'
summary values:NEED JSON STRING</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED JSON STRING",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED JSON STRING")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KeyProps">
<Description>
 key_props ::= name_value_pair_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NameValuePairList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MethodAttribute">
<Description>
 method_attribute ::= attribute_Abstract | attribute_ClientName | attribute_CodeMode | attribute_Deprecated | attribute_ExternalProcName | attribute_Final | attribute_ForceGenerate | attribute_GenerateAfter | attribute_Internal | attribute_Language | attribute_NoContext | attribute_NotInheritable | attribute_PlaceAfter | attribute_Private | attribute_ProcedureBlock | attribute_PublicList | attribute_ReturnResultSets | attribute_ServerOnly | attribute_SOAPAction | attribute_SOAPBindingStyle | attribute_SOAPBodyuse | attribute_SOAPMessageName | attribute_SOAPNameSpace | attribute_SOAPRequestMessage | attribute_SOAPTypeNamespace | attribute_SQLName | attribute_SQLProc | attribute_WebMethod | attribute_ZenMethod</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeAbstract(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeClientname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeCodemode(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeDeprecated(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeExternalprocname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeFinal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeForcegenerate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeGenerateafter(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeInternal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeLanguage(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeNocontext(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeNotinheritable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributePlaceafter(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributePrivate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeProcedureblock(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributePubliclist(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeReturnresultsets(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeServeronly(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSoapaction(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSoapbindingstyle(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSoapbodyuse(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSoapmessagename(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSoapnamespace(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSoaprequestmessage(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSoaptypenamespace(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlproc(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeWebmethod(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeZenmethod(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MethodAttributeList">
<Description>
 method_attribute_list ::= '[' method_attribute ( ',' method_attribute )* ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..MethodAttribute(subElement,.addedElement)  {
			if ..MethodAttributeList34RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"]")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MethodAttributeList34RepZero">
<Description>
 ( ',' method_attribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..MethodAttributeList35Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="MethodAttributeList35Sub">
<Description>
 ',' method_attribute
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..MethodAttribute(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MethodBody">
<Description>
 method_body ::= cos_code_block</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosCodeBlock(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MethodName">
<Description>
 method_name ::= class_item_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MethodReference">
<Description>
 method_reference ::= class_item_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MimeType">
<Description>
 mime_type ::= 'regex:[a-zA-Z][a-zA-Z0-9]*\/[a-zA-Z][a-zA-Z0-9]*'
summary values:REGEX:[A-ZA-Z][A-ZA-Z0-9]*\/[A-ZA-Z][A-ZA-Z0-9]*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEX:[A-ZA-Z][A-ZA-Z0-9]*\/[A-ZA-Z][A-ZA-Z0-9]*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regex:[a-zA-Z][a-zA-Z0-9]*\/[a-zA-Z][a-zA-Z0-9]*")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NameValuePairList">
<Description>
 name_value_pair_list ::= one_name_value_pair ( ',' one_name_value_pair )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OneNameValuePair(subElement,.addedElement)  {
		if ..NameValuePairList40RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NameValuePairList40RepZero">
<Description>
 ( ',' one_name_value_pair )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..NameValuePairList41Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="NameValuePairList41Sub">
<Description>
 ',' one_name_value_pair
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..OneNameValuePair(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number">
<Description>
 number ::= ['-'] ('regexp:[0-9]*' [ '.' 'regexp:[0-9]+'] [ ('e' | 'E') 'regexp:[0-9]+']) | ('.' 'regexp:[0-9]+' [ ('e' | 'E') 'regexp:[0-9]+'])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addPunctuation(subElement,"-") :1,1:1) {
		if ..Number181Sub(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Number185Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number181Sub">
<Description>
'regexp:[0-9]*' [ '.' 'regexp:[0-9]+'] [ ('e' | 'E') 'regexp:[0-9]+']
summary values:REGEXP:[0-9]*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?4?
	; first rule summary P
	if '(..isStringSingle("REGEXP:[0-9]*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:[0-9]*")  {
		if ..Number182OptGrp(subElement,.addedElement)  {
			if ..Number183OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number182OptGrp">
<Description>

summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..addPunctuation(subElement,"regexp:[0-9]+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number183OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number184Sub(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"regexp:[0-9]+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number184Sub">
<Description>
'e' | 'E'
summary values:E,E</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("E","E"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"E")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Number185Sub">
<Description>
'.' 'regexp:[0-9]+' [ ('e' | 'E') 'regexp:[0-9]+']
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?4?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..addPunctuation(subElement,"regexp:[0-9]+")  {
			if ..Number186OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number186OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number187Sub(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"regexp:[0-9]+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number187Sub">
<Description>
'e' | 'E'
summary values:E,E</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("E","E"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"E")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OneClassmember">
<Description>
 one_classMember ::= class_class_method | class_ForeignKey | class_index | class_method | class_property | class_parameter | class_projection | class_query | class_relationship | class_storage | class_trigger | class_xdata | class_client_method</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassClassMethod(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassForeignkey(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassIndex(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassMethod(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassProperty(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassParameter(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassProjection(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassQuery(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassRelationship(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassStorage(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassTrigger(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassXdata(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassClientMethod(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneColumnName">
<Description>
 one_column_name ::= string | text</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Text(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneDataAttributeValue">
<Description>
 one_data_attribute_value ::= property_reference ['(ELEMENTS)' | '(KEYS)' ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PropertyReference(subElement,.addedElement)  {
		if ..OneDataAttributeValue130OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneDataAttributeValue130OptGrp">
<Description>

summary values:(ELEMENTS),(KEYS)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("(ELEMENTS)","(KEYS)"),10,.value)) { quit 1 /* not found is OK */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"(ELEMENTS)")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"(KEYS)")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=1 /* failure rollsback but returns OK */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OneForeignkeyAtttribute">
<Description>
 one_foreignkey_atttribute ::= attribute_Internal | attribute_NoCheck | attribute_OnDelete | attribute_OnUpdate | attribute_SQLName</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeInternal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeNocheck(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeOndelete(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeOnupdate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlname(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneNameValuePair">
<Description>
 one_name_value_pair ::= class_item_identifier [ '=' expression ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		if ..OneNameValuePair42OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OneNameValuePair42OptGrp">
<Description>

summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("=",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		if ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PackageList">
<Description>
 package_list ::= package_name ( ',' package_name )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PackageName(subElement,.addedElement)  {
		if ..PackageList7RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PackageList7RepZero">
<Description>
 ( ',' package_name )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..PackageList8Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="PackageList8Sub">
<Description>
 ',' package_name
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..PackageName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PackageName">
<Description>
 package_name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterDefaultExpression">
<Description>
 parameter_default_expression ::= '{' expression '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..Expression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterDefaultSimple">
<Description>
 parameter_default_simple ::= [ '+' ] number | string</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addPunctuation(subElement,"+") :1,1:1) {
		if ..Number(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..String(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterDefaultValue">
<Description>
 parameter_default_value ::= '=' ( 'NULL' | parameter_default_simple | parameter_default_expression )
summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		if ..ParameterDefaultValue37Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterDefaultValue37Sub">
<Description>
 'NULL' | parameter_default_simple | parameter_default_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NULL")  {
		set done=1 ; or
	} elseif ..ParameterDefaultSimple(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ParameterDefaultExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ProjectionName">
<Description>
 projection_name ::= string | identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PropertyName">
<Description>
 property_name ::= class_item_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PropertyReference">
<Description>
 property_reference ::= class_item_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QueryName">
<Description>
 query_name ::= class_item_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RefProps">
<Description>
 ref_props ::= name_value_pair_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NameValuePairList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RelationshipAttribute">
<Description>
 relationship_attribute ::= attribute_Cardinality | attribute_Final | attribute_Internal | attribute_Inverse | attribute_Required | attribute_SQLFieldname | attribute_Private | attribute_OnDelete</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeCardinality(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeFinal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeInternal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeInverse(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeRequired(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlfieldname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributePrivate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeOndelete(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RelationshipAttributes">
<Description>
 relationship_attributes ::= '[' relationship_attribute ( ',' relationship_attribute )* ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..RelationshipAttribute(subElement,.addedElement)  {
			if ..RelationshipAttributes27RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"]")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RelationshipAttributes27RepZero">
<Description>
 ( ',' relationship_attribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..RelationshipAttributes28Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="RelationshipAttributes28Sub">
<Description>
 ',' relationship_attribute
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..RelationshipAttribute(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReturnTypeClassReference">
<Description>
 return_type_class_reference ::= class_reference [ type_parameters ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassReference(subElement,.addedElement)  {
		if $S(..TypeParameters(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SoapIdentifier">
<Description>
 soap_identifier ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFieldName">
<Description>
 sql_field_name ::= text</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Text(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlTableName">
<Description>
 sql_table_name ::= 'NEEDS SQL TABLE NAME'
summary values:NEEDS SQL TABLE NAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS SQL TABLE NAME",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS SQL TABLE NAME")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageName">
<Description>
 storage_name ::= class_item_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXml">
<Description>
 storage_xml ::= (xml_data)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXml50RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXml50RepZero">
<Description>
 (xml_data)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..StorageXml51Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXml51Sub">
<Description>
xml_data</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlData(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlAttribute">
<Description>
 storage_xml_attribute ::= xml_tag_s_a 'Attribute' xml_tag_s_b identifier xml_tag_e_a 'Attribute' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"ATTRIBUTE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Identifier(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"ATTRIBUTE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlComplex">
<Description>
 storage_xml_complex ::= ( storage_xml_data | storage_xml_data_location | storage_xml_default_data | storage_xml_description | storage_xml_extent_location | storage_xml_extent_size | storage_xml_id_function | storage_xml_id_location | storage_xml_index_location | storage_xml_index | storage_xml_stream_location | storage_xml_state | storage_xml_type | storage_xml_property | storage_xml_sqlmap | storage_xml_counterlocation )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlComplex52RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlComplex52RepZero">
<Description>
 ( storage_xml_data | storage_xml_data_location | storage_xml_default_data | storage_xml_description | storage_xml_extent_location | storage_xml_extent_size | storage_xml_id_function | storage_xml_id_location | storage_xml_index_location | storage_xml_index | storage_xml_stream_location | storage_xml_state | storage_xml_type | storage_xml_property | storage_xml_sqlmap | storage_xml_counterlocation )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..StorageXmlComplex53Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlComplex53Sub">
<Description>
 storage_xml_data | storage_xml_data_location | storage_xml_default_data | storage_xml_description | storage_xml_extent_location | storage_xml_extent_size | storage_xml_id_function | storage_xml_id_location | storage_xml_index_location | storage_xml_index | storage_xml_stream_location | storage_xml_state | storage_xml_type | storage_xml_property | storage_xml_sqlmap | storage_xml_counterlocation</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlData(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlDataLocation(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlDefaultData(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlDescription(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlExtentLocation(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlExtentSize(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlIdFunction(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlIdLocation(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlIndexLocation(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlIndex(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlStreamLocation(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlState(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlType(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlProperty(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmap(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlCounterlocation(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlCounterlocation">
<Description>
 storage_xml_counterlocation ::= xml_tag_s_a 'CounterLocation' xml_tag_s_b global xml_tag_e_a 'CounterLocation' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"COUNTERLOCATION")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Global(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"COUNTERLOCATION")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlData">
<Description>
 storage_xml_data ::= xml_tag_s_a 'Data' 'name' '=' string ( xml_tag_s_c | (xml_tag_s_b (storage_xml_dataelement)* xml_tag_e_a 'Data' xml_tag_e_b) )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"DATA")  {
			if ..addKeyword(subElement,"NAME")  {
				if ..addPunctuation(subElement,"=")  {
					if ..String(subElement,.addedElement)  {
						if ..StorageXmlData54Sub(subElement,.addedElement)  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlData54Sub">
<Description>
 xml_tag_s_c | (xml_tag_s_b (storage_xml_dataelement)* xml_tag_e_a 'Data' xml_tag_e_b)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSC(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlData55Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlData55Sub">
<Description>
xml_tag_s_b (storage_xml_dataelement)* xml_tag_e_a 'Data' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSB(subElement,.addedElement)  {
		if ..StorageXmlData56RepZero(subElement,.addedElement)  {
			if ..XmlTagEA(subElement,.addedElement)  {
				if ..addKeyword(subElement,"DATA")  {
					if ..XmlTagEB(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlData56RepZero">
<Description>
 (storage_xml_dataelement)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..StorageXmlData57Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlData57Sub">
<Description>
storage_xml_dataelement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlDataelement(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataDelimiter">
<Description>
 storage_xml_data_delimiter ::= xml_tag_s_a 'Delimiter' xml_tag_s_b cos_expression_storage xml_tag_e_a 'Delimiter' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"DELIMITER")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..CosExpressionStorage(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"DELIMITER")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataLocation">
<Description>
 storage_xml_data_location ::= xml_tag_s_a 'DataLocation'xml_tag_s_b (expression | ('{%%PARENT}' ['(' string ')'])) xml_tag_e_a 'DataLocation' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"DATALOCATION")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..StorageXmlDataLocation64Sub(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"DATALOCATION")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataLocation64Sub">
<Description>
expression | ('{%%PARENT}' ['(' string ')'])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlDataLocation65Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataLocation65Sub">
<Description>
'{%%PARENT}' ['(' string ')']
summary values:{%%PARENT}</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle("{%%PARENT}",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{%%PARENT}")  {
		if ..StorageXmlDataLocation66OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataLocation66OptGrp">
<Description>

summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..String(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataNode">
<Description>
 storage_xml_data_node ::= xml_tag_s_a 'Node' xml_tag_s_b (number | string) xml_tag_e_a 'Node' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"NODE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..StorageXmlDataNode68Sub(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"NODE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataNode68Sub">
<Description>
number | string</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..String(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataPiece">
<Description>
 storage_xml_data_piece ::= xml_tag_s_a 'Piece' xml_tag_s_b number [ ',' number ] xml_tag_e_a 'Piece' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?4?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"PIECE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Number(subElement,.addedElement)  {
					if ..StorageXmlDataPiece67OptGrp(subElement,.addedElement)  {
						if ..XmlTagEA(subElement,.addedElement)  {
							if ..addKeyword(subElement,"PIECE")  {
								if ..XmlTagEB(subElement,.addedElement)  {
									set done=1 ; end compileRules
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataPiece67OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Number(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataPosition">
<Description>
 storage_xml_data_position ::= xml_tag_s_a 'Value' 'name' '=' string xml_tag_s_b (storage_xml_data_position_field)* xml_tag_e_a 'Value' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&?1Rule?&(?4?)*&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"VALUE")  {
			if ..addKeyword(subElement,"NAME")  {
				if ..addPunctuation(subElement,"=")  {
					if ..String(subElement,.addedElement)  {
						if ..XmlTagSB(subElement,.addedElement)  {
							if ..StorageXmlDataPosition61RepZero(subElement,.addedElement)  {
								if ..XmlTagEA(subElement,.addedElement)  {
									if ..addKeyword(subElement,"VALUE")  {
										if ..XmlTagEB(subElement,.addedElement)  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataPosition61RepZero">
<Description>
 (storage_xml_data_position_field)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..StorageXmlDataPosition62Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataPosition62Sub">
<Description>
storage_xml_data_position_field</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlDataPositionField(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataPositionField">
<Description>
 storage_xml_data_position_field ::= xml_tag_s_a 'Value' xml_tag_s_b (identifier) xml_tag_e_a 'Value' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"VALUE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..StorageXmlDataPositionField63Sub(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"VALUE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataPositionField63Sub">
<Description>
identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataRetrievalCode">
<Description>
 storage_xml_data_retrieval_code ::= xml_tag_s_a 'RetrievalCode' xml_tag_s_b cos_code_block_storage xml_tag_e_a 'RetrievalCode' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"RETRIEVALCODE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..CosCodeBlockStorage(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"RETRIEVALCODE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDataelement">
<Description>
 storage_xml_dataelement ::= storage_xml_attribute | storage_xml_structure | storage_xml_subscript | storage_xml_data_position | storage_xml_data_piece | storage_xml_data_node | storage_xml_data_delimiter | storage_xml_data_retrieval_code</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlAttribute(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlStructure(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSubscript(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlDataPosition(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlDataPiece(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlDataNode(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlDataDelimiter(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlDataRetrievalCode(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDefaultData">
<Description>
 storage_xml_default_data ::= xml_tag_s_a 'DefaultData' xml_tag_s_b cos_expression_storage xml_tag_e_a 'DefaultData' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"DEFAULTDATA")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..CosExpressionStorage(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"DEFAULTDATA")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDescription">
<Description>
 storage_xml_description ::= xml_tag_s_a 'Description' xml_tag_s_b (xml_cdata | xml_content) xml_tag_e_a 'Description' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"DESCRIPTION")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..StorageXmlDescription58Sub(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"DESCRIPTION")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlDescription58Sub">
<Description>
xml_cdata | xml_content</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlCdata(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..XmlContent(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlExtentLocation">
<Description>
 storage_xml_extent_location ::= xml_tag_s_a 'ExtentLocation' xml_tag_s_b global xml_tag_e_a 'ExtentLocation' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"EXTENTLOCATION")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Global(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"EXTENTLOCATION")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlExtentSize">
<Description>
 storage_xml_extent_size ::= xml_tag_s_a 'ExtentSize' xml_tag_s_b number xml_tag_e_a 'ExtentSize' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"EXTENTSIZE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Number(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"EXTENTSIZE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlGlobal">
<Description>
 storage_xml_global ::= xml_tag_s_a 'Global' xml_tag_s_b global xml_tag_e_a 'Global' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"GLOBAL")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Global(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"GLOBAL")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIdFunction">
<Description>
 storage_xml_id_function ::= xml_tag_s_a 'IdFunction' xml_tag_s_b ( 'sequence' )xml_tag_e_a 'IdFunction' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"IDFUNCTION")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..StorageXmlIdFunction69Sub(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"IDFUNCTION")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIdFunction69Sub">
<Description>
 'sequence'
summary values:SEQUENCE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("SEQUENCE"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"SEQUENCE")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIdLocation">
<Description>
 storage_xml_id_location ::= xml_tag_s_a 'IdLocation' xml_tag_s_b ( ('{%%PARENT}' ['(' string ')']) | (expression [ '(' string ')' ]) ) xml_tag_e_a 'IdLocation' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"IDLOCATION")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..StorageXmlIdLocation70Sub(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"IDLOCATION")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIdLocation70Sub">
<Description>
 ('{%%PARENT}' ['(' string ')']) | (expression [ '(' string ')' ])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlIdLocation71Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlIdLocation73Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIdLocation71Sub">
<Description>
'{%%PARENT}' ['(' string ')']
summary values:{%%PARENT}</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle("{%%PARENT}",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{%%PARENT}")  {
		if ..StorageXmlIdLocation72OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIdLocation72OptGrp">
<Description>

summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..String(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIdLocation73Sub">
<Description>
expression [ '(' string ')' ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		if ..StorageXmlIdLocation74OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIdLocation74OptGrp">
<Description>

summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..String(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIndex">
<Description>
 storage_xml_index ::= xml_tag_s_a 'Index' 'name' '=' string xml_tag_s_b (storage_xml_index_sublocation)* xml_tag_e_a 'Index' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&?1Rule?&(?4?)*&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"INDEX")  {
			if ..addKeyword(subElement,"NAME")  {
				if ..addPunctuation(subElement,"=")  {
					if ..String(subElement,.addedElement)  {
						if ..XmlTagSB(subElement,.addedElement)  {
							if ..StorageXmlIndex75RepZero(subElement,.addedElement)  {
								if ..XmlTagEA(subElement,.addedElement)  {
									if ..addKeyword(subElement,"INDEX")  {
										if ..XmlTagEB(subElement,.addedElement)  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIndex75RepZero">
<Description>
 (storage_xml_index_sublocation)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..StorageXmlIndex76Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIndex76Sub">
<Description>
storage_xml_index_sublocation</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlIndexSublocation(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIndexLocation">
<Description>
 storage_xml_index_location ::= xml_tag_s_a 'IndexLocation' xml_tag_s_b expression xml_tag_e_a 'IndexLocation' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"INDEXLOCATION")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Expression(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"INDEXLOCATION")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIndexSublocation">
<Description>
 storage_xml_index_sublocation ::= xml_tag_s_a 'Location' xml_tag_s_b (expression)xml_tag_e_a 'Location' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"LOCATION")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..StorageXmlIndexSublocation77Sub(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"LOCATION")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlIndexSublocation77Sub">
<Description>
expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlProperty">
<Description>
 storage_xml_property ::= storage_xml_property_empty | storage_xml_property_full</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlPropertyEmpty(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlPropertyFull(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlPropertyEmpty">
<Description>
 storage_xml_property_empty ::= xml_tag_s_a 'Property' 'name' '=' string xml_tag_s_b (storage_xml_property_selectivity | storage_xml_property_outlier_selectivity | storage_xml_property_fieldsize | storage_xml_property_histogram)* xml_tag_e_a 'Property' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&?1Rule?&(?4?)*&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"PROPERTY")  {
			if ..addKeyword(subElement,"NAME")  {
				if ..addPunctuation(subElement,"=")  {
					if ..String(subElement,.addedElement)  {
						if ..XmlTagSB(subElement,.addedElement)  {
							if ..StorageXmlPropertyEmpty78RepZero(subElement,.addedElement)  {
								if ..XmlTagEA(subElement,.addedElement)  {
									if ..addKeyword(subElement,"PROPERTY")  {
										if ..XmlTagEB(subElement,.addedElement)  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlPropertyEmpty78RepZero">
<Description>
 (storage_xml_property_selectivity | storage_xml_property_outlier_selectivity | storage_xml_property_fieldsize | storage_xml_property_histogram)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..StorageXmlPropertyEmpty79Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlPropertyEmpty79Sub">
<Description>
storage_xml_property_selectivity | storage_xml_property_outlier_selectivity | storage_xml_property_fieldsize | storage_xml_property_histogram</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlPropertySelectivity(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlPropertyOutlierSelectivity(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlPropertyFieldsize(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlPropertyHistogram(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlPropertyFieldsize">
<Description>
 storage_xml_property_fieldsize ::= xml_tag_s_a 'AverageFieldSize' xml_tag_s_b number xml_tag_e_a 'AverageFieldSize' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"AVERAGEFIELDSIZE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Number(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"AVERAGEFIELDSIZE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlPropertyFull">
<Description>
 storage_xml_property_full ::= xml_tag_s_a 'Property' 'name' '=' string xml_tag_s_c</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"PROPERTY")  {
			if ..addKeyword(subElement,"NAME")  {
				if ..addPunctuation(subElement,"=")  {
					if ..String(subElement,.addedElement)  {
						if ..XmlTagSC(subElement,.addedElement)  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlPropertyHistogram">
<Description>
 storage_xml_property_histogram ::= xml_tag_s_a 'Histogram' xml_tag_s_b expression xml_tag_e_a 'Histogram' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"HISTOGRAM")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Expression(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"HISTOGRAM")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlPropertyOutlierSelectivity">
<Description>
 storage_xml_property_outlier_selectivity ::= xml_tag_s_a 'OutlierSelectivity' xml_tag_s_b number ':' number xml_tag_e_a 'OutlierSelectivity' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&P&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"OUTLIERSELECTIVITY")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Number(subElement,.addedElement)  {
					if ..addPunctuation(subElement,":")  {
						if ..Number(subElement,.addedElement)  {
							if ..XmlTagEA(subElement,.addedElement)  {
								if ..addKeyword(subElement,"OUTLIERSELECTIVITY")  {
									if ..XmlTagEB(subElement,.addedElement)  {
										set done=1 ; end compileRules
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlPropertySelectivity">
<Description>
 storage_xml_property_selectivity ::= xml_tag_s_a 'Selectivity' xml_tag_s_b number ['%'] xml_tag_e_a 'Selectivity' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?4?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"SELECTIVITY")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Number(subElement,.addedElement)  {
					if $S(..addPunctuation(subElement,"%") :1,1:1) {
						if ..XmlTagEA(subElement,.addedElement)  {
							if ..addKeyword(subElement,"SELECTIVITY")  {
								if ..XmlTagEB(subElement,.addedElement)  {
									set done=1 ; end compileRules
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmap">
<Description>
 storage_xml_sqlmap ::= xml_tag_s_a 'SQLMap' 'name' '=' string xml_tag_s_b (storage_xml_sqlmap_blockcount | storage_xml_data | storage_xml_global | storage_xml_sqlmap_condition | storage_xml_sqlmap_population | storage_xml_sqlmap_type | storage_xml_sqlmap_structure | storage_xml_sqlmap_subscript | storage_xml_sqlmap_rowidspec )* xml_tag_e_a 'SQLMap' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&?1Rule?&(?4?)*&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"SQLMAP")  {
			if ..addKeyword(subElement,"NAME")  {
				if ..addPunctuation(subElement,"=")  {
					if ..String(subElement,.addedElement)  {
						if ..XmlTagSB(subElement,.addedElement)  {
							if ..StorageXmlSqlmap80RepZero(subElement,.addedElement)  {
								if ..XmlTagEA(subElement,.addedElement)  {
									if ..addKeyword(subElement,"SQLMAP")  {
										if ..XmlTagEB(subElement,.addedElement)  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmap80RepZero">
<Description>
 (storage_xml_sqlmap_blockcount | storage_xml_data | storage_xml_global | storage_xml_sqlmap_condition | storage_xml_sqlmap_population | storage_xml_sqlmap_type | storage_xml_sqlmap_structure | storage_xml_sqlmap_subscript | storage_xml_sqlmap_rowidspec )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..StorageXmlSqlmap81Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmap81Sub">
<Description>
storage_xml_sqlmap_blockcount | storage_xml_data | storage_xml_global | storage_xml_sqlmap_condition | storage_xml_sqlmap_population | storage_xml_sqlmap_type | storage_xml_sqlmap_structure | storage_xml_sqlmap_subscript | storage_xml_sqlmap_rowidspec</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlSqlmapBlockcount(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlData(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlGlobal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapCondition(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapPopulation(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapType(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapStructure(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapSubscript(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapRowidspec(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapBlockcount">
<Description>
 storage_xml_sqlmap_blockcount ::= xml_tag_s_a 'BlockCount' xml_tag_s_b number xml_tag_e_a 'BlockCount' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"BLOCKCOUNT")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Number(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"BLOCKCOUNT")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapCondition">
<Description>
 storage_xml_sqlmap_condition ::= xml_tag_s_a 'Condition' xml_tag_s_b cos_expression_storage xml_tag_e_a 'Condition' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"CONDITION")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..CosExpressionStorage(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"CONDITION")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapPopulation">
<Description>
 storage_xml_sqlmap_population ::= xml_tag_s_a 'PopulationType' xml_tag_s_b identifier xml_tag_e_a 'PopulationType' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"POPULATIONTYPE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Identifier(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"POPULATIONTYPE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapRowExpression">
<Description>
 storage_xml_sqlmap_row_expression ::= xml_tag_s_a 'Expression' xml_tag_s_b cos_expression_storage xml_tag_e_a 'Expression' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"EXPRESSION")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..CosExpressionStorage(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"EXPRESSION")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapRowField">
<Description>
 storage_xml_sqlmap_row_field ::= xml_tag_s_a 'Field' xml_tag_s_b identifier xml_tag_e_a 'Field' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"FIELD")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Identifier(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"FIELD")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapRowidspec">
<Description>
 storage_xml_sqlmap_rowidspec ::= xml_tag_s_a 'RowIdSpec' 'name' '=' string xml_tag_s_b (storage_xml_sqlmap_row_expression | storage_xml_sqlmap_row_field)* xml_tag_e_a 'RowIdSpec' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&?1Rule?&(?4?)*&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"ROWIDSPEC")  {
			if ..addKeyword(subElement,"NAME")  {
				if ..addPunctuation(subElement,"=")  {
					if ..String(subElement,.addedElement)  {
						if ..XmlTagSB(subElement,.addedElement)  {
							if ..StorageXmlSqlmapRowidspec85RepZero(subElement,.addedElement)  {
								if ..XmlTagEA(subElement,.addedElement)  {
									if ..addKeyword(subElement,"ROWIDSPEC")  {
										if ..XmlTagEB(subElement,.addedElement)  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapRowidspec85RepZero">
<Description>
 (storage_xml_sqlmap_row_expression | storage_xml_sqlmap_row_field)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..StorageXmlSqlmapRowidspec86Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapRowidspec86Sub">
<Description>
storage_xml_sqlmap_row_expression | storage_xml_sqlmap_row_field</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlSqlmapRowExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapRowField(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapStructure">
<Description>
 storage_xml_sqlmap_structure ::= xml_tag_s_a 'Structure' xml_tag_s_b identifier xml_tag_e_a 'Structure' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"STRUCTURE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Identifier(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"STRUCTURE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubAccesstype">
<Description>
 storage_xml_sqlmap_sub_accesstype ::= xml_tag_s_a 'AccessType' xml_tag_s_b identifier xml_tag_e_a 'AccessType' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"ACCESSTYPE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Identifier(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"ACCESSTYPE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubAccessvar">
<Description>
 storage_xml_sqlmap_sub_accessvar ::= xml_tag_s_a 'Accessvar' 'name' '=' string xml_tag_s_b (storage_xml_sqlmap_sub_code storage_xml_sqlmap_sub_variable) xml_tag_e_a 'Accessvar' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"ACCESSVAR")  {
			if ..addKeyword(subElement,"NAME")  {
				if ..addPunctuation(subElement,"=")  {
					if ..String(subElement,.addedElement)  {
						if ..XmlTagSB(subElement,.addedElement)  {
							if ..StorageXmlSqlmapSubAccessvar84Sub(subElement,.addedElement)  {
								if ..XmlTagEA(subElement,.addedElement)  {
									if ..addKeyword(subElement,"ACCESSVAR")  {
										if ..XmlTagEB(subElement,.addedElement)  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubAccessvar84Sub">
<Description>
storage_xml_sqlmap_sub_code storage_xml_sqlmap_sub_variable</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlSqlmapSubCode(subElement,.addedElement)  {
		if ..StorageXmlSqlmapSubVariable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubCode">
<Description>
 storage_xml_sqlmap_sub_code ::= xml_tag_s_a 'Code' xml_tag_s_b cos_code_block_storage xml_tag_e_a 'Code' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"CODE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..CosCodeBlockStorage(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"CODE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubDataaccess">
<Description>
 storage_xml_sqlmap_sub_dataaccess ::= xml_tag_s_a 'DataAccess' xml_tag_s_b cos_expression_storage xml_tag_e_a 'DataAccess' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"DATAACCESS")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..CosExpressionStorage(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"DATAACCESS")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubExpression">
<Description>
 storage_xml_sqlmap_sub_expression ::= xml_tag_s_a 'Expression' xml_tag_s_b cos_expression_storage xml_tag_e_a 'Expression' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"EXPRESSION")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..CosExpressionStorage(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"EXPRESSION")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubInvcond">
<Description>
 storage_xml_sqlmap_sub_invcond ::= xml_tag_s_a 'InvalidCondition' 'name' '=' string xml_tag_s_b storage_xml_sqlmap_sub_expression xml_tag_e_a 'Invalidcondition' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"INVALIDCONDITION")  {
			if ..addKeyword(subElement,"NAME")  {
				if ..addPunctuation(subElement,"=")  {
					if ..String(subElement,.addedElement)  {
						if ..XmlTagSB(subElement,.addedElement)  {
							if ..StorageXmlSqlmapSubExpression(subElement,.addedElement)  {
								if ..XmlTagEA(subElement,.addedElement)  {
									if ..addKeyword(subElement,"INVALIDCONDITION")  {
										if ..XmlTagEB(subElement,.addedElement)  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubLoopinitval">
<Description>
 storage_xml_sqlmap_sub_loopinitval ::= xml_tag_s_a 'LoopInitValue' xml_tag_s_b cos_expression_storage xml_tag_e_a 'LoopInitValue' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"LOOPINITVALUE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..CosExpressionStorage(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"LOOPINITVALUE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubNextCode">
<Description>
 storage_xml_sqlmap_sub_next_code ::= xml_tag_s_a 'NextCode' xml_tag_s_b cos_code_block_storage xml_tag_e_a 'NextCode' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"NEXTCODE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..CosCodeBlockStorage(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"NEXTCODE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubVariable">
<Description>
 storage_xml_sqlmap_sub_variable ::= xml_tag_s_a 'Variable' xml_tag_s_b cos_expression_storage xml_tag_e_a 'Variable' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"VARIABLE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..CosExpressionStorage(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"VARIABLE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubscript">
<Description>
 storage_xml_sqlmap_subscript ::= xml_tag_s_a 'Subscript' 'name' '=' string xml_tag_s_b (storage_xml_sqlmap_sub_expression | storage_xml_sqlmap_sub_accessvar | storage_xml_sqlmap_sub_accesstype | storage_xml_sqlmap_sub_invcond | storage_xml_data_delimiter | storage_xml_sqlmap_sub_loopinitval | storage_xml_sqlmap_sub_dataaccess | storage_xml_sqlmap_sub_next_code )* xml_tag_e_a 'Subscript' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&P&?1Rule?&?1Rule?&(?4?)*&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"SUBSCRIPT")  {
			if ..addKeyword(subElement,"NAME")  {
				if ..addPunctuation(subElement,"=")  {
					if ..String(subElement,.addedElement)  {
						if ..XmlTagSB(subElement,.addedElement)  {
							if ..StorageXmlSqlmapSubscript82RepZero(subElement,.addedElement)  {
								if ..XmlTagEA(subElement,.addedElement)  {
									if ..addKeyword(subElement,"SUBSCRIPT")  {
										if ..XmlTagEB(subElement,.addedElement)  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubscript82RepZero">
<Description>
 (storage_xml_sqlmap_sub_expression | storage_xml_sqlmap_sub_accessvar | storage_xml_sqlmap_sub_accesstype | storage_xml_sqlmap_sub_invcond | storage_xml_data_delimiter | storage_xml_sqlmap_sub_loopinitval | storage_xml_sqlmap_sub_dataaccess | storage_xml_sqlmap_sub_next_code )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..StorageXmlSqlmapSubscript83Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapSubscript83Sub">
<Description>
storage_xml_sqlmap_sub_expression | storage_xml_sqlmap_sub_accessvar | storage_xml_sqlmap_sub_accesstype | storage_xml_sqlmap_sub_invcond | storage_xml_data_delimiter | storage_xml_sqlmap_sub_loopinitval | storage_xml_sqlmap_sub_dataaccess | storage_xml_sqlmap_sub_next_code</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StorageXmlSqlmapSubExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapSubAccessvar(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapSubAccesstype(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapSubInvcond(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlDataDelimiter(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapSubLoopinitval(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapSubDataaccess(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StorageXmlSqlmapSubNextCode(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSqlmapType">
<Description>
 storage_xml_sqlmap_type ::= xml_tag_s_a 'Type' xml_tag_s_b identifier xml_tag_e_a 'Type' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"TYPE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Identifier(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"TYPE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlState">
<Description>
 storage_xml_state ::= xml_tag_s_a 'State' xml_tag_s_b identifier xml_tag_e_a 'State' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"STATE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Identifier(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"STATE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlStreamLocation">
<Description>
 storage_xml_stream_location ::= xml_tag_s_a 'StreamLocation' xml_tag_s_b expression xml_tag_e_a 'StreamLocation' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"STREAMLOCATION")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..Expression(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"STREAMLOCATION")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlStructure">
<Description>
 storage_xml_structure ::= xml_tag_s_a 'Structure' xml_tag_s_b ( 'subnode' | 'node') xml_tag_e_a 'Structure' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"STRUCTURE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..StorageXmlStructure59Sub(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"STRUCTURE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlStructure59Sub">
<Description>
 'subnode' | 'node'
summary values:SUBNODE,NODE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("SUBNODE","NODE"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"SUBNODE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NODE")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSubscript">
<Description>
 storage_xml_subscript ::= xml_tag_s_a 'Subscript' xml_tag_s_b (string | number) xml_tag_e_a 'Subscript' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"SUBSCRIPT")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..StorageXmlSubscript60Sub(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"SUBSCRIPT")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlSubscript60Sub">
<Description>
string | number</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Number(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StorageXmlType">
<Description>
 storage_xml_type ::= xml_tag_s_a 'Type' xml_tag_s_b class_reference xml_tag_e_a 'Type' xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?&?1Rule?&?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addKeyword(subElement,"TYPE")  {
			if ..XmlTagSB(subElement,.addedElement)  {
				if ..ClassReference(subElement,.addedElement)  {
					if ..XmlTagEA(subElement,.addedElement)  {
						if ..addKeyword(subElement,"TYPE")  {
							if ..XmlTagEB(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="String">
<Description>
 string ::= '""' | ('"' 'regexp:[^\"\r\n]*' '"')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"""""")  {
		set done=1 ; or
	} elseif ..String188Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="String188Sub">
<Description>
'"' 'regexp:[^\"\r\n]*' '"'
summary values:""</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&P
	; first rule summary P
	if '(..isStringSingle("""",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"""")  {
		if ..addPunctuation(subElement,"regexp:[^\""\r\n]*")  {
			if ..addPunctuation(subElement,"""")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Tablename">
<Description>
 tablename ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Text">
<Description>
 text ::= 'regexp:.*'
summary values:REGEXP:.*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:.*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:.*")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TextBraceBlock">
<Description>
 text_brace_block ::= '{' text '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..Text(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TextInCurly">
<Description>
 text_in_curly ::= 'NEEDS TEXT IN CURLY'
summary values:NEEDS TEXT IN CURLY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS TEXT IN CURLY",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS TEXT IN CURLY")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeValue">
<Description>
 time_value ::= 'after' | 'before'
summary values:AFTER,BEFORE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("AFTER","BEFORE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AFTER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"BEFORE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TriggerAttribute">
<Description>
 trigger_attribute ::= attribute_CodeMode | attribute_Event | attribute_Final | attribute_ForEach | attribute_Internal | attribute_Language | attribute_NewTable | attribute_OldTable | attribute_Order | attribute_SQLName | attribute_Time | attribute_UpdateColumnList</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeCodemode(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeEvent(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeFinal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeForeach(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeInternal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeLanguage(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeNewtable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeOldtable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeOrder(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSqlname(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeTime(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeUpdatecolumnlist(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TriggerAttributeList">
<Description>
 trigger_attribute_list ::= '[' trigger_attribute ( ',' trigger_attribute )* ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..TriggerAttribute(subElement,.addedElement)  {
			if ..TriggerAttributeList110RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"]")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TriggerAttributeList110RepZero">
<Description>
 ( ',' trigger_attribute )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..TriggerAttributeList111Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="TriggerAttributeList111Sub">
<Description>
 ',' trigger_attribute
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..TriggerAttribute(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TriggerCodeBlock">
<Description>
 trigger_code_block ::= cos_code_block_trigger</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosCodeBlockTrigger(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TriggerName">
<Description>
 trigger_name ::= class_item_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeClassReference">
<Description>
 type_class_reference ::= class_reference [ type_parameters ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassReference(subElement,.addedElement)  {
		if $S(..TypeParameters(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeParameterItem">
<Description>
 type_parameter_item ::= class_item_identifier '=' ( string | number )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"=")  {
			if ..TypeParameterItem21Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeParameterItem21Sub">
<Description>
 string | number</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Number(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeParameters">
<Description>
 type_parameters ::= '(' type_parameters_list ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..TypeParametersList(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeParametersList">
<Description>
 type_parameters_list ::= type_parameter_item (',' type_parameter_item)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TypeParameterItem(subElement,.addedElement)  {
		if ..TypeParametersList19RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeParametersList19RepZero">
<Description>
 (',' type_parameter_item)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..TypeParametersList20Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="TypeParametersList20Sub">
<Description>
',' type_parameter_item
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..TypeParameterItem(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UdlProgram">
<Description>
 udl_program ::= udl_statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UdlStatement(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UdlStatement">
<Description>
 udl_statement ::= ( import_definition | include_generator_definition | include_definition )* class_definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UdlStatement1RepZero(subElement,.addedElement)  {
		if ..ClassDefinition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UdlStatement1RepZero">
<Description>
 ( import_definition | include_generator_definition | include_definition )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..UdlStatement2Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UdlStatement2Sub">
<Description>
 import_definition | include_generator_definition | include_definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ImportDefinition(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IncludeGeneratorDefinition(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IncludeDefinition(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Variable">
<Description>
 variable ::= variable_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..VariableIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="VariableIdentifier">
<Description>
 variable_identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
summary values:REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="VariableSet">
<Description>
 variable_set ::= variable_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..VariableIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataAttributes">
<Description>
 xdata_attributes ::= attribute_Internal | attribute_MimeType | attribute_SchemaSpec | attribute_XMLNamespace</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AttributeInternal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeMimetype(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeSchemaspec(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AttributeXmlnamespace(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataJson">
<Description>
 xdata_json ::= xdata_json_object | xdata_json_array | xdata_json_prim</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XdataJsonObject(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..XdataJsonArray(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..XdataJsonPrim(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataJsonArray">
<Description>
 xdata_json_array ::= '[' [ xdata_json_array_items ] ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if $S(..XdataJsonArrayItems(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,"]")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataJsonArrayItems">
<Description>
 xdata_json_array_items ::= xdata_json (',' xdata_json)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XdataJson(subElement,.addedElement)  {
		if ..XdataJsonArrayItems108RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataJsonArrayItems108RepZero">
<Description>
 (',' xdata_json)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..XdataJsonArrayItems109Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="XdataJsonArrayItems109Sub">
<Description>
',' xdata_json
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..XdataJson(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataJsonObject">
<Description>
 xdata_json_object ::= '{' [ xdata_json_pair ( ',' xdata_json_pair )*] '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..XdataJsonObject105OptGrp(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataJsonObject105OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XdataJsonPair(subElement,.addedElement)  {
		if ..XdataJsonObject106RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataJsonObject106RepZero">
<Description>
 ( ',' xdata_json_pair )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..XdataJsonObject107Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="XdataJsonObject107Sub">
<Description>
 ',' xdata_json_pair
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..XdataJsonPair(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataJsonPair">
<Description>
 xdata_json_pair ::= json_string ':' xdata_json</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..JsonString(subElement,.addedElement)  {
		if ..addPunctuation(subElement,":")  {
			if ..XdataJson(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataJsonPrim">
<Description>
 xdata_json_prim ::= number | json_string | 'true' | 'false' | 'null'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|K|K|K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JsonString(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TRUE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FALSE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NULL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataName">
<Description>
 xdata_name ::= class_item_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassItemIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataText">
<Description>
 xdata_text ::= text</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Text(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XdataXml">
<Description>
 xdata_xml ::= [xml_xml] xml_data</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..XmlXml(subElement,.addedElement) :1,1:1) {
		if ..XmlData(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlAttribute">
<Description>
 xml_attribute ::= [ xml_schema ':' ] xml_attribute_name '=' xml_attribute_value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlAttribute102OptGrp(subElement,.addedElement)  {
		if ..XmlAttributeName(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"=")  {
				if ..XmlAttributeValue(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlAttribute102OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlSchema(subElement,.addedElement)  {
		if ..addPunctuation(subElement,":")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlAttributeName">
<Description>
 xml_attribute_name ::= xml_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlAttributeValue">
<Description>
 xml_attribute_value ::= string | number</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Number(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlCdata">
<Description><![CDATA[
 xml_cdata ::= '<' '!' '[CDATA[' xml_cdata_text ']]' '>'
summary values:<]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&P&?1Rule?&P&P
	; first rule summary P
	if '(..isStringSingle("<",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<")  {
		if ..addPunctuation(subElement,"!")  {
			if ..addPunctuation(subElement,"[CDATA[")  {
				if ..XmlCdataText(subElement,.addedElement)  {
					if ..addPunctuation(subElement,"]]")  {
						if ..addPunctuation(subElement,">")  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlCdataText">
<Description>
 xml_cdata_text ::= 'NEED XML CDATA TEXT THAT READS UP TO END OF CDATA'
summary values:NEED XML CDATA TEXT THAT READS UP TO END OF CDATA</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED XML CDATA TEXT THAT READS UP TO END OF CDATA",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED XML CDATA TEXT THAT READS UP TO END OF CDATA")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlContent">
<Description>
 xml_content ::= text</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Text(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlData">
<Description>
 xml_data ::= xml_cdata | ( xml_start_tag ( xml_data | xml_content)* xml_end_tag) | xml_empty_tag</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlCdata(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..XmlData94Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..XmlEmptyTag(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlData94Sub">
<Description>
 xml_start_tag ( xml_data | xml_content)* xml_end_tag</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlStartTag(subElement,.addedElement)  {
		if ..XmlData95RepZero(subElement,.addedElement)  {
			if ..XmlEndTag(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlData95RepZero">
<Description>
 ( xml_data | xml_content)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..XmlData96Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="XmlData96Sub">
<Description>
 xml_data | xml_content</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlData(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..XmlContent(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlEmptyTag">
<Description>
 xml_empty_tag ::= xml_tag_s_a xml_tag_ns_name (xml_attribute)* xml_tag_s_c</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&(?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..XmlTagNsName(subElement,.addedElement)  {
			if ..XmlEmptyTag99RepZero(subElement,.addedElement)  {
				if ..XmlTagSC(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlEmptyTag100Sub">
<Description>
xml_attribute</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlAttribute(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlEmptyTag99RepZero">
<Description>
 (xml_attribute)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..XmlEmptyTag100Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="XmlEndTag">
<Description>
 xml_end_tag ::= xml_tag_e_a xml_tag_ns_name xml_tag_e_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagEA(subElement,.addedElement)  {
		if ..XmlTagNsName(subElement,.addedElement)  {
			if ..XmlTagEB(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlIdentifier">
<Description>
 xml_identifier ::= 'NEEDS XML identifier'
summary values:NEEDS XML IDENTIFIER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEEDS XML IDENTIFIER",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEEDS XML identifier")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlSchema">
<Description>
 xml_schema ::= xml_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlStartTag">
<Description>
 xml_start_tag ::= xml_tag_s_a xml_tag_ns_name (xml_attribute)* xml_tag_s_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&(?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..XmlTagNsName(subElement,.addedElement)  {
			if ..XmlStartTag97RepZero(subElement,.addedElement)  {
				if ..XmlTagSB(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlStartTag97RepZero">
<Description>
 (xml_attribute)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..XmlStartTag98Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="XmlStartTag98Sub">
<Description>
xml_attribute</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlAttribute(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlTagEA">
<Description><![CDATA[
 xml_tag_e_a ::= '</'
summary values:</]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("</",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"</")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlTagEB">
<Description><![CDATA[
 xml_tag_e_b ::= '>'
summary values:>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(">",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,">")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlTagName">
<Description>
 xml_tag_name ::= xml_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlTagNsName">
<Description>
 xml_tag_ns_name ::= [ xml_schema ':'] xml_tag_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagNsName101OptGrp(subElement,.addedElement)  {
		if ..XmlTagName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlTagNsName101OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlSchema(subElement,.addedElement)  {
		if ..addPunctuation(subElement,":")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlTagSA">
<Description><![CDATA[
 xml_tag_s_a ::= '<'
summary values:<]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("<",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlTagSB">
<Description><![CDATA[
 xml_tag_s_b ::= '>'
summary values:>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(">",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,">")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlTagSC">
<Description><![CDATA[
 xml_tag_s_c ::= '/>'
summary values:/>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("/>",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"/>")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlXml">
<Description>
 xml_xml ::= xml_tag_s_a '?xml' (xml_attribute)* '?' xml_tag_s_b</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&(?4?)*&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlTagSA(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"?xml")  {
			if ..XmlXml103RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"?")  {
					if ..XmlTagSB(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="XmlXml103RepZero">
<Description>
 (xml_attribute)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..XmlXml104Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="XmlXml104Sub">
<Description>
xml_attribute</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..XmlAttribute(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Elements.ClassDefinition</ReturnType>
<Implementation><![CDATA[	quit ##class(PXW.DEV.BNF.Elements.ClassDefinition).%New(Type)
]]></Implementation>
</Method>

<Parameter name="KeywordPattern">
<Default>1.A.(1"/".A)</Default>
</Parameter>

<Parameter name="Keywords">
<Default>ABSTRACT,ACCESSTYPE,ACCESSVAR,AFTER,ALIASES,ALPHAUP,ARRAY,AS,ATTRIBUTE,AVERAGEFIELDSIZE,BASIC,BEFORE,BIGINT,BINARY,BINARYSTREAM,BIT,BITMAP,BITSLICE,BLOCKCOUNT,BOOLEAN,BYREF,BYVAL,CACHE,CALCULATED,CALL,CARDINALITY,CASCADE,CHARACTERSTREAM,CHILDREN,CLASS,CLASSMETHOD,CLASSTYPE,CLIENTDATATYPE,CLIENTMETHOD,CLIENTNAME,CODE,CODEMODE,COLLATEDKEY,COMPILEAFTER,CONDITION,CONSTRAINT,COSEXPRESSION,COUNTERLOCATION,CPP,CURRENCY,DATA,DATAACCESS,DATALOCATION,DATATYPE,DATE,DDLALLOWED,DECIMAL,DEFAULTDATA,DELETE,DELIMITED,DELIMITER,DEPENDSON,DEPRECATED,DESCRIPTION,DOCUMENT,DONOTUSE,DOUBLE,DYNAMIC,E,EMBEDDEDCLASS,ENCODED,ENUM,ENUMEDIT,EVENT,EXACT,EXPRESSION,EXTENDS,EXTENT,EXTENTLOCATION,EXTENTSIZE,EXTERNALPROCNAME,FALSE,FDATE,FIELD,FINAL,FLAGS,FMDATE,FMTIMESTAMP,FORCEGENERATE,FOREACH,FOREIGNKEY,FTIMESTAMP,GENERATEAFTER,GENERATEDBY,GENERATOR,GLOBAL,GUID,HANDLE,HIDDEN,HISTOGRAM,IDENTITY,IDFUNCTION,IDKEY,IDLOCATION,IMPORT,INCLUDE,INCLUDEGENERATOR,INDEX,INDEXLOCATION,INHERITANCE,INITIALEXPRESSION,INSERT,INSERT/DELETE,INSERT/UPDATE,INSERT/UPDATE/DELETE,INTEGER,INTERNAL,INVALIDCONDITION,INVERSE,JAVA,JAVASCRIPT,KEY,LANGUAGE,LEFT,LEGACYINSTANCECONTEXT,LIST,LITERAL,LOCATION,LONGVARBINARY,LONGVARCHAR,LOOPINITVALUE,MANY,MEMBERSUPER,METHOD,MIMETYPE,MINUS,MULTIDIMENSIONAL,MVBASIC,MVDATE,MVR,NAME,NEWTABLE,NEXTCODE,NOACTION,NOCHECK,NOCONTEXT,NODE,NOEXTENT,NOT,NOTINHERITABLE,NULL,NUMERIC,OBJECTGENERATOR,OBJECTSCRIPT,ODBCTYPE,OF,OLDTABLE,ON,ONDELETE,ONE,ONUPDATE,ORDER,OUTLIERSELECTIVITY,OUTPUT,OWNER,PARAMETER,PARENT,PERSISTENT,PIECE,PLACEAFTER,PLUS,POPULATIONTYPE,POSIXTIME,POSIXTS,PRIMARYKEY,PRIVATE,PROCEDUREBLOCK,PROJECTION,PROPERTY,PROPERTYCLASS,PUBLICLIST,PYTHON,QUERY,RCP,READONLY,REFERENCES,RELATIONSHIP,REQUIRED,RESULTSET,RETRIEVALCODE,RETURNRESULTSETS,RIGHT,ROW,ROW/OBJECT,ROWIDSPEC,SCHEMASPEC,SELECTIVITY,SEQUENCE,SERIAL,SERVERONLY,SETDEFAULT,SETNULL,SMALLINT,SOAPACTION,SOAPBINDINGSTYLE,SOAPBODYUSE,SOAPMESSAGENAME,SOAPNAMESPACE,SOAPREQUESTMESSAGE,SOAPTYPENAMESPACE,SPACE,SQLCATEGORY,SQLCOLUMNNUMBER,SQLCOMPUTECODE,SQLCOMPUTED,SQLCOMPUTEONCHANGE,SQLFIELDNAME,SQLLISTDELIMITER,SQLLISTTYPE,SQLMAP,SQLNAME,SQLPROC,SQLROWIDNAME,SQLROWIDPRIVATE,SQLSTRING,SQLTABLENAME,SQLUPPER,SQLVIEW,SQLVIEWNAME,STATE,STATEMENT,STATUS,STORAGE,STORAGESTRATEGY,STREAM,STREAMLOCATION,STRING,STRUCT,STRUCTURE,SUBNODE,SUBSCRIPT,SYSTEM,TIME,TIMESTAMP,TINYINT,TRANSIENT,TRIGGER,TRUE,TRUNCATE,TSQL,TYPE,UNIQUE,UPDATE,UPDATE/DELETE,UPDATECOLUMNLIST,UPPER,VALUE,VARBINARY,VARCHAR,VARIABLE,VIEW,VIEWQUERY,WEBMETHOD,XDATA,XMLNAMESPACE,ZENMETHOD</Default>
</Parameter>
</Class>


<Class name="PXW.DEV.BNF.GEN.JS">
<Description>
Created: 2024-10-17 15:59:07 PXW.DEV.BNF.Compilers.Compiler1</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>PXW.DEV.BNF.super</Super>
<TimeChanged>67130,57550.54023423</TimeChanged>
<TimeCreated>67125,77562.915765373</TimeCreated>

<Method name="AliasName">
<Description>
 alias_Name ::= identifier_Name ["As" identifier_Name]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IdentifierName(subElement,.addedElement)  {
		if ..AliasName8OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AliasName8OptGrp">
<Description>

summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..IdentifierName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="And">
<Description><![CDATA[
 And ::= '&&'
summary values:&&]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("&&",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"&&")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AnonymousFunction">
<Description><![CDATA[
 anonymous_Function ::= (["Async"] "Function" ['*'] '(' [formal_Parameter_List] ')' function_Body) | (["Async"] arrow_Function_Parameters '=>' arrow_Function_Body )]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AnonymousFunction150Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..AnonymousFunction151Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AnonymousFunction150Sub">
<Description>
["Async"] "Function" ['*'] '(' [formal_Parameter_List] ')' function_Body</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&K&?4?&P&?4?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addKeyword(subElement,"ASYNC") :1,1:1) {
		if ..addKeyword(subElement,"FUNCTION")  {
			if $S(..addPunctuation(subElement,"*") :1,1:1) {
				if ..addPunctuation(subElement,"(")  {
					if $S(..FormalParameterList(subElement,.addedElement) :1,1:1) {
						if ..addPunctuation(subElement,")")  {
							if ..FunctionBody(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AnonymousFunction151Sub">
<Description><![CDATA[
["Async"] arrow_Function_Parameters '=>' arrow_Function_Body]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addKeyword(subElement,"ASYNC") :1,1:1) {
		if ..ArrowFunctionParameters(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"=>")  {
				if ..ArrowFunctionBody(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Argument">
<Description>
 argument ::= [Ellipsis] (single_Expression | identifier)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Ellipsis(subElement,.addedElement) :1,1:1) {
		if ..Argument64Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Argument64Sub">
<Description>
single_Expression | identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Arguments">
<Description>
 arguments ::= '(' [argument (',' argument)*] ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..Arguments61OptGrp(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Arguments61OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Argument(subElement,.addedElement)  {
		if ..Arguments62RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Arguments62RepZero">
<Description>
 (',' argument)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Arguments63Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Arguments63Sub">
<Description>
',' argument
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..Argument(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ArrayElement">
<Description>
 array_Element ::= [Ellipsis] single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Ellipsis(subElement,.addedElement) :1,1:1) {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ArrayLiteral">
<Description>
 array_Literal ::= '[' element_List ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..ElementList(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"]")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Arrow">
<Description><![CDATA[
 ARROW ::= '=>'
summary values:=>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("=>",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=>")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ArrowFunctionBody">
<Description>
 arrow_Function_Body ::= single_Expression | function_Body</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..FunctionBody(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ArrowFunctionParameters">
<Description>
 arrow_Function_Parameters ::= identifier | ('(' [formal_Parameter_List] ')')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ArrowFunctionParameters152Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ArrowFunctionParameters152Sub">
<Description>
'(' [formal_Parameter_List] ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if $S(..FormalParameterList(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Assign">
<Description>
 Assign ::= '='
summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Assignable">
<Description>
 assignable ::= identifier | array_Literal | object_Literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ArrayLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ObjectLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AssignmentOperator">
<Description><![CDATA[
 assignment_Operator ::= '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=' | '**=' | '??='
summary values:*=,/=,%=,+=,-=,<<=,>>=,>>>=,&=,^=,|=,**=,??=]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P|P|P|P|P|P|P|P|P
	if '(..isStringInList($lb("*=","/=","%=","+=","-=","<<=",">>=",">>>=","&=","^=","|=","**=","??="),4,.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"/=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"+=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<<=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">>=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">>>=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"&=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"^=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"|=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"**=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"??=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BigBinaryIntegerLiteral">
<Description>
 Big_Binary_Integer_Literal::= ('0b' | '0B') ('0' | '1' )* 'n'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*&K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BigBinaryIntegerLiteral168Sub(subElement,.addedElement)  {
		if ..BigBinaryIntegerLiteral169RepZero(subElement,.addedElement)  {
			if ..addKeyword(subElement,"N")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BigBinaryIntegerLiteral168Sub">
<Description>
'0b' | '0B'
summary values:0B,0B</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("0B","0B"),2,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0b")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"0B")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BigBinaryIntegerLiteral169RepZero">
<Description>
 ('0' | '1' )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..BigBinaryIntegerLiteral170Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BigBinaryIntegerLiteral170Sub">
<Description>
'0' | '1'
summary values:0,1</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("0","1"),1,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"1")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BigDecimalIntegerLiteral">
<Description>
 Big_Decimal_Integer_Literal ::= decimal_integer_literal 'n'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DecimalIntegerLiteral(subElement,.addedElement)  {
		if ..addKeyword(subElement,"N")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BigHexIntegerLiteral">
<Description>
 Big_Hex_Integer_Literal ::= ('0x' | '0X') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' )* 'n'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*&K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BigHexIntegerLiteral162Sub(subElement,.addedElement)  {
		if ..BigHexIntegerLiteral163RepZero(subElement,.addedElement)  {
			if ..addKeyword(subElement,"N")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BigHexIntegerLiteral162Sub">
<Description>
'0x' | '0X'
summary values:0X,0X</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("0X","0X"),2,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0x")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"0X")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BigHexIntegerLiteral163RepZero">
<Description>
 ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..BigHexIntegerLiteral164Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BigHexIntegerLiteral164Sub">
<Description>
'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P|P|P|P|P|P|K|K|K|K|K|K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"0")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"1")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"2")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"3")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"4")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"5")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"6")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"7")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"8")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"9")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"A")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"B")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"C")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"D")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"F")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BigOctalIntegerLiteral">
<Description>
 Big_Octal_Integer_Literal ::= ('0o' | '0O') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' )* 'n'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*&K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BigOctalIntegerLiteral165Sub(subElement,.addedElement)  {
		if ..BigOctalIntegerLiteral166RepZero(subElement,.addedElement)  {
			if ..addKeyword(subElement,"N")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BigOctalIntegerLiteral165Sub">
<Description>
'0o' | '0O'
summary values:0O,0O</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("0O","0O"),2,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0o")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"0O")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BigOctalIntegerLiteral166RepZero">
<Description>
 ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..BigOctalIntegerLiteral167Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BigOctalIntegerLiteral167Sub">
<Description>
'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
summary values:0,1,2,3,4,5,6,7</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P|P|P|P
	if '(..isStringInList($lb("0","1","2","3","4","5","6","7"),1,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"1")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"2")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"3")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"4")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"5")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"6")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"7")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BigintLiteral">
<Description>
 bigint_Literal ::= Big_Decimal_Integer_Literal | Big_Hex_Integer_Literal | Big_Octal_Integer_Literal | Big_Binary_Integer_Literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BigDecimalIntegerLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BigHexIntegerLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BigOctalIntegerLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BigBinaryIntegerLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BinaryIntegerLiteral">
<Description>
 Binary_Integer_Literal::= ('0b' | '0B') ('0' | '1' )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BinaryIntegerLiteral159Sub(subElement,.addedElement)  {
		if ..BinaryIntegerLiteral160RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BinaryIntegerLiteral159Sub">
<Description>
'0b' | '0B'
summary values:0B,0B</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("0B","0B"),2,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0b")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"0B")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BinaryIntegerLiteral160RepZero">
<Description>
 ('0' | '1' )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..BinaryIntegerLiteral161Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BinaryIntegerLiteral161Sub">
<Description>
'0' | '1'
summary values:0,1</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("0","1"),1,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"1")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Bitand">
<Description><![CDATA[
 BitAnd ::= '&'
summary values:&]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("&",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"&")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Bitandassign">
<Description><![CDATA[
 BitAndAssign ::= '&='
summary values:&=]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("&=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"&=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Bitnot">
<Description>
 BitNot ::= '~'
summary values:~</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("~",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"~")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Bitor">
<Description>
 BitOr ::= '|'
summary values:|</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("|",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"|")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Bitorassign">
<Description>
 BitOrAssign ::= '|='
summary values:|=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("|=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"|=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Bitxor">
<Description>
 BitXOr ::= '^'
summary values:^</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("^",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"^")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Bitxorassign">
<Description>
 BitXorAssign ::= '^='
summary values:^=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("^=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"^=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Block">
<Description>
 block ::= '{' [statement_List] '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if $S(..StatementList(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BooleanLiteral">
<Description>
 boolean_literal ::= 'true' | 'false'
summary values:TRUE,FALSE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("TRUE","FALSE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"TRUE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FALSE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BreakStatement">
<Description>
 break_Statement ::= "Break" [ identifier] eos
summary values:BREAK</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("BREAK"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BREAK")  {
		if $S(..Identifier(subElement,.addedElement) :1,1:1) {
			if ..Eos(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseBlock">
<Description>
 case_Block ::= '{' [case_Clauses] [default_Clause [case_Clauses]] '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?4?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if $S(..CaseClauses(subElement,.addedElement) :1,1:1) {
			if ..CaseBlock30OptGrp(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"}")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseBlock30OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DefaultClause(subElement,.addedElement)  {
		if $S(..CaseClauses(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseClause">
<Description>
 case_Clause ::= "Case" expression_Sequence ':' [statement_List]
summary values:CASE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&P&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("CASE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CASE")  {
		if ..ExpressionSequence(subElement,.addedElement)  {
			if ..addPunctuation(subElement,":")  {
				if $S(..StatementList(subElement,.addedElement) :1,1:1) {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseClauses">
<Description>
 case_Clauses ::= case_Clause*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CaseClauses31RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseClauses31RepZero">
<Description>
 case_Clause*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CaseClause(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CatchProduction">
<Description>
 catch_Production ::= "Catch" ['(' assignable? ')'] block
summary values:CATCH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CATCH"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CATCH")  {
		if ..CatchProduction34OptGrp(subElement,.addedElement)  {
			if ..Block(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CatchProduction34OptGrp">
<Description>

summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if $s(..Assignable(subElement,.addedElement) :1,1:1)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassDeclaration">
<Description>
 class_Declaration ::= "Class" identifier class_Tail
summary values:CLASS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CLASS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CLASS")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..ClassTail(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassElement">
<Description>
 class_Element ::= ([["Static"] identifier] method_Definition) | ([["Static"] identifier] field_Definition) | ([["Static"] identifier] block) | empty_Statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassElement37Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassElement39Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassElement41Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..EmptyStatement(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassElement37Sub">
<Description>
[["Static"] identifier] method_Definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassElement38OptGrp(subElement,.addedElement)  {
		if ..MethodDefinition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassElement38OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addKeyword(subElement,"STATIC") :1,1:1) {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassElement39Sub">
<Description>
[["Static"] identifier] field_Definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassElement40OptGrp(subElement,.addedElement)  {
		if ..FieldDefinition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassElement40OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addKeyword(subElement,"STATIC") :1,1:1) {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassElement41Sub">
<Description>
[["Static"] identifier] block</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassElement42OptGrp(subElement,.addedElement)  {
		if ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassElement42OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addKeyword(subElement,"STATIC") :1,1:1) {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassElementName">
<Description>
 class_Element_Name ::= property_Name | private_Identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PropertyName(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PrivateIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassTail">
<Description>
 class_Tail ::= ["Extends" single_Expression] '{' class_Element* '}'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&P&(?4?)*&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassTail35OptGrp(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"{")  {
			if ..ClassTail36RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"}")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassTail35OptGrp">
<Description>

summary values:EXTENDS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("EXTENDS"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"EXTENDS")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassTail36RepZero">
<Description>
 class_Element*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ClassElement(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Closebrace">
<Description>
 CloseBrace ::= '}'
summary values:}</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("}",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"}")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Closebracket">
<Description>
 CloseBracket ::=']'
summary values:]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("]",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"]")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Closeparen">
<Description>
 CloseParen ::= ')'
summary values:)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(")",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,")")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Colon">
<Description>
 Colon ::= ':'
summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(":",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Comma">
<Description>
 Comma ::= ','
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ContinueStatement">
<Description>
 continue_Statement ::= "Continue" [ identifier] eos
summary values:CONTINUE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CONTINUE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CONTINUE")  {
		if $S(..Identifier(subElement,.addedElement) :1,1:1) {
			if ..Eos(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DebuggerStatement">
<Description>
 debugger_Statement ::= "Debugger" eos
summary values:DEBUGGER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("DEBUGGER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DEBUGGER")  {
		if ..Eos(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DecimalIntegerLiteral">
<Description>
 decimal_integer_literal ::= 'NEED decimal_integer_literal'
summary values:NEED DECIMAL_INTEGER_LITERAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED DECIMAL_INTEGER_LITERAL",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED decimal_integer_literal")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DecimalLiteral">
<Description>
 Decimal_literal ::= 'NEED decimal_literal'
summary values:NEED DECIMAL_LITERAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED DECIMAL_LITERAL",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED decimal_literal")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Declaration">
<Description>
 declaration ::= variable_Statement | class_Declaration | function_Declaration</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..VariableStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassDeclaration(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..FunctionDeclaration(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DefaultClause">
<Description>
 default_Clause ::= "Default" ':' [ statement_List ]
summary values:DEFAULT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("DEFAULT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DEFAULT")  {
		if ..addPunctuation(subElement,":")  {
			if $S(..StatementList(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Divide">
<Description>
 Divide ::= '/'
summary values:/</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("/",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"/")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Divideassign">
<Description>
 DivideAssign ::= '/='
summary values:/=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("/=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"/=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Dot">
<Description>
 Dot ::= '.'
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Dyadicop">
<Description><![CDATA[
 dyadicop ::= ('?' primary ':') | '++' | '--' | '**' | '*' | '/' | '%' | '+' | '-' |'??' | '<<' | '>>' | '>>>' | '<' | '>' | '<=' | '>=' | '==' | '!=' | '===' | '!==' | '&' | '^' | '|' | '&&' | '||' | '=' | "InstanceOf" | "In"]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|K|K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Dyadicop117Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"++")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"--")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"**")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"/")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"??")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<<")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">>")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">>>")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"==")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"!=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"===")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"!==")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"&")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"^")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"|")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"&&")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"||")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"=")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INSTANCEOF")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"IN")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Dyadicop117Sub">
<Description>
'?' primary ':'
summary values:?</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("?",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"?")  {
		if ..Primary(subElement,.addedElement)  {
			if ..addPunctuation(subElement,":")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElementList">
<Description>
 element_List ::= [array_Element] (',' array_Element)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..ArrayElement(subElement,.addedElement) :1,1:1) {
		if ..ElementList52RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElementList52RepZero">
<Description>
 (',' array_Element)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ElementList53Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ElementList53Sub">
<Description>
',' array_Element
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ArrayElement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Ellipsis">
<Description>
 Ellipsis ::= '...'
summary values:...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("...",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"...")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmptyStatement">
<Description>
 empty_Statement ::= ';'
summary values:;</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(";",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,";")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EndOfFile">
<Description>
 end_of_file ::= 'NEED end_of_file'
summary values:NEED END_OF_FILE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED END_OF_FILE",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED end_of_file")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Eos">
<Description>
 eos ::= SemiColon | end_of_file</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Semicolon(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..EndOfFile(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Equals">
<Description>
 Equals ::= '=='
summary values:==</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("==",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"==")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExportAliasName">
<Description>
 export_Alias_name ::= module_Export_Name [("As" module_Export_Name)]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ModuleExportName(subElement,.addedElement)  {
		if $S(..ExportAliasName16Sub(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExportAliasName16Sub">
<Description>
"As" module_Export_Name
summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..ModuleExportName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExportFromBlock">
<Description>
 export_From_Block ::= (import_Namespace import_From eos) | (export_Module_Items [import_From] eos)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExportFromBlock12Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ExportFromBlock13Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExportFromBlock12Sub">
<Description>
import_Namespace import_From eos</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ImportNamespace(subElement,.addedElement)  {
		if ..ImportFrom(subElement,.addedElement)  {
			if ..Eos(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExportFromBlock13Sub">
<Description>
export_Module_Items [import_From] eos</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExportModuleItems(subElement,.addedElement)  {
		if $S(..ImportFrom(subElement,.addedElement) :1,1:1) {
			if ..Eos(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExportModuleItems">
<Description>
 export_Module_Items ::= '{' export_Alias_Name (',' export_Alias_Name )* '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..ExportAliasName(subElement,.addedElement)  {
			if ..ExportModuleItems14RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"}")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExportModuleItems14RepZero">
<Description>
 (',' export_Alias_Name )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ExportModuleItems15Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ExportModuleItems15Sub">
<Description>
',' export_Alias_Name
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ExportAliasName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExportStatement">
<Description>
 export_Statement ::= ("Export" ["Default"] (export_From_Block | declaration) eos) | ("Export" "Default" single_Expression eos)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExportStatement9Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ExportStatement11Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExportStatement10Sub">
<Description>
export_From_Block | declaration</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExportFromBlock(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Declaration(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExportStatement11Sub">
<Description>
"Export" "Default" single_Expression eos
summary values:EXPORT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&K&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("EXPORT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"EXPORT")  {
		if ..addKeyword(subElement,"DEFAULT")  {
			if ..SingleExpression(subElement,.addedElement)  {
				if ..Eos(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExportStatement9Sub">
<Description>
"Export" ["Default"] (export_From_Block | declaration) eos
summary values:EXPORT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("EXPORT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"EXPORT")  {
		if $S(..addKeyword(subElement,"DEFAULT") :1,1:1) {
			if ..ExportStatement10Sub(subElement,.addedElement)  {
				if ..Eos(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExpressionSequence">
<Description>
 expression_Sequence ::= single_Expression (',' single_Expression)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..ExpressionSequence65RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExpressionSequence65RepZero">
<Description>
 (',' single_Expression)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ExpressionSequence66Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ExpressionSequence66Sub">
<Description>
',' single_Expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExpressionStatement">
<Description>
 expression_Statement ::= expression_Sequence eos</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExpressionSequence(subElement,.addedElement)  {
		if ..Eos(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Factor">
<Description>
 factor ::= ( monadicop )* primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Factor115RepZero(subElement,.addedElement)  {
		if ..Primary(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Factor115RepZero">
<Description>
 ( monadicop )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Factor116Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Factor116Sub">
<Description>
 monadicop</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Monadicop(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FieldDefinition">
<Description>
 field_Definition ::= class_Element_Name [initializer]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ClassElementName(subElement,.addedElement)  {
		if $S(..Initializer(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FinallyProduction">
<Description>
 finally_Production ::= "Finally" block
summary values:FINALLY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("FINALLY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FINALLY")  {
		if ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormalParameterArg">
<Description>
 formal_Parameter_Arg ::= assignable ['=' single_Expression]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Assignable(subElement,.addedElement)  {
		if ..FormalParameterArg50OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormalParameterArg50OptGrp">
<Description>

summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("=",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormalParameterList">
<Description>
 formal_Parameter_List ::= (formal_Parameter_Arg (',' formal_Parameter_Arg)* [',' last_Formal_Parameter_Arg]) | last_Formal_Parameter_Arg</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..FormalParameterList46Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..LastFormalParameterArg(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormalParameterList46Sub">
<Description>
formal_Parameter_Arg (',' formal_Parameter_Arg)* [',' last_Formal_Parameter_Arg]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..FormalParameterArg(subElement,.addedElement)  {
		if ..FormalParameterList47RepZero(subElement,.addedElement)  {
			if ..FormalParameterList49OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormalParameterList47RepZero">
<Description>
 (',' formal_Parameter_Arg)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..FormalParameterList48Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="FormalParameterList48Sub">
<Description>
',' formal_Parameter_Arg
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..FormalParameterArg(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormalParameterList49OptGrp">
<Description>

summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..LastFormalParameterArg(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Function">
<Description>
 function ::= identifier '(' expression_sequence ')'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"(")  {
			if ..ExpressionSequence(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionBody">
<Description>
 function_Body ::= '{' [source_Elements] '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if $S(..SourceElements(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionDeclaration">
<Description>
 function_Declaration ::= ["Async"] "Function" ['*'] identifier '(' [formal_Parameter_List] ')' function_Body</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&K&?4?&?1Rule?&P&?4?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addKeyword(subElement,"ASYNC") :1,1:1) {
		if ..addKeyword(subElement,"FUNCTION")  {
			if $S(..addPunctuation(subElement,"*") :1,1:1) {
				if ..Identifier(subElement,.addedElement)  {
					if ..addPunctuation(subElement,"(")  {
						if $S(..FormalParameterList(subElement,.addedElement) :1,1:1) {
							if ..addPunctuation(subElement,")")  {
								if ..FunctionBody(subElement,.addedElement)  {
									set done=1 ; end compileRules
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Getter">
<Description>
 getter ::= "get" identifier class_Element_Name
summary values:GET</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("GET"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"GET")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..ClassElementName(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Greaterthanequals">
<Description><![CDATA[
 GreaterThanEquals ::= '>='
summary values:>=]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(">=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,">=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Hashtag">
<Description>
 Hashtag ::= '#'
summary values:#</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("#",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"#")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HexIntegerLiteral">
<Description>
 Hex_Integer_Literal ::= ('0x' | '0X') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..HexIntegerLiteral153Sub(subElement,.addedElement)  {
		if ..HexIntegerLiteral154RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HexIntegerLiteral153Sub">
<Description>
'0x' | '0X'
summary values:0X,0X</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("0X","0X"),2,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0x")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"0X")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="HexIntegerLiteral154RepZero">
<Description>
 ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..HexIntegerLiteral155Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="HexIntegerLiteral155Sub">
<Description>
'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P|P|P|P|P|P|K|K|K|K|K|K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"0")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"1")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"2")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"3")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"4")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"5")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"6")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"7")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"8")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"9")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"A")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"B")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"C")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"D")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"F")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<Description>
 identifier ::= "NEED IDENTIFIER"
summary values:NEED IDENTIFIER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED IDENTIFIER",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED IDENTIFIER")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IdentifierName">
<Description>
 identifier_Name ::= identifier | reserved_Word</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ReservedWord(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Identityequals">
<Description>
 IdentityEquals ::= '==='
summary values:===</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("===",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"===")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Identitynotequals">
<Description>
 IdentityNotEquals ::= '!=='
summary values:!==</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("!==",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"!==")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IfStatement">
<Description>
 if_Statement ::= "If" '(' expression_Sequence ')' statement [("Else" statement)]
summary values:IF</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P&?1Rule?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("IF"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IF")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ExpressionSequence(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					if ..Statement(subElement,.addedElement)  {
						if $S(..IfStatement20Sub(subElement,.addedElement) :1,1:1) {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IfStatement20Sub">
<Description>
"Else" statement
summary values:ELSE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ELSE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ELSE")  {
		if ..Statement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportAliasName">
<Description>
 import_Alias_Name ::= module_Export_Name [("As" imported_Binding)]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ModuleExportName(subElement,.addedElement)  {
		if $S(..ImportAliasName5Sub(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportAliasName5Sub">
<Description>
"As" imported_Binding
summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..ImportedBinding(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportDefault">
<Description>
 import_Default ::= alias_Name ','</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AliasName(subElement,.addedElement)  {
		if ..addPunctuation(subElement,",")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFrom">
<Description>
 import_From ::= "From" String_Literal
summary values:FROM</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("FROM"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FROM")  {
		if ..StringLiteral(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFromBlock">
<Description>
 import_From_Block ::= [import_Default] (import_Namespace | import_Module_Items) import_From eos | String_Literal eos</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&?1Rule?&?1Rule?|?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..ImportDefault(subElement,.addedElement) :1,1:1) {
		if ..ImportFromBlock2Sub(subElement,.addedElement)  {
			if ..ImportFrom(subElement,.addedElement)  {
				if ..Eos(subElement,.addedElement)  {
					set done=1 ; or
				} elseif ..StringLiteral(subElement,.addedElement)  {
					if ..Eos(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFromBlock2Sub">
<Description>
import_Namespace | import_Module_Items</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ImportNamespace(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ImportModuleItems(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportModuleItems">
<Description>
 import_Module_Items ::= '{' import_Alias_Name (',' import_Alias_Name )* '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..ImportAliasName(subElement,.addedElement)  {
			if ..ImportModuleItems3RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"}")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportModuleItems3RepZero">
<Description>
 (',' import_Alias_Name )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ImportModuleItems4Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ImportModuleItems4Sub">
<Description>
',' import_Alias_Name
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ImportAliasName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportNamespace">
<Description>
 import_Namespace ::= ('*' | identifier_Name) [("As" identifier_Name)]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ImportNamespace6Sub(subElement,.addedElement)  {
		if $S(..ImportNamespace7Sub(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportNamespace6Sub">
<Description>
'*' | identifier_Name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..IdentifierName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportNamespace7Sub">
<Description>
"As" identifier_Name
summary values:AS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  {
		if ..IdentifierName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportStatement">
<Description>
 import_Statement ::= "Import" import_From_Block
summary values:IMPORT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("IMPORT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IMPORT")  {
		if ..ImportFromBlock(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportedBinding">
<Description>
 imported_Binding ::= Identifier | "Yield" | "Await"</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|K|K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"YIELD")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"AWAIT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Initializer">
<Description>
 initializer ::= '=' single_Expression
summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IterationStatement">
<Description>
 iteration_Statement ::= ("Do" statement "While" '(' expression_Sequence ')' eos) | ("While" '(' expression_Sequence ')' statement ) | ( "for" "(" "var" Variable_Declaration ";" [ single_Expression ] ";" [ single_Expression ] ")" Statement ) | ("For" '(' [expression_Sequence | variable_Declaration_List] ';' [expression_Sequence] ';' [expression_Sequence] ')' statement ) | ("For" '(' (single_Expression | variable_Declaration_List) "In" expression_Sequence ')' statement ) | ("For" ["Await"] '(' (single_Expression | variable_Declaration_List) "Of" expression_Sequence ')' statement )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IterationStatement21Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IterationStatement22Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IterationStatement23Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IterationStatement24Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IterationStatement26Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IterationStatement28Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IterationStatement21Sub">
<Description>
"Do" statement "While" '(' expression_Sequence ')' eos
summary values:DO</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&K&P&?1Rule?&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("DO"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DO")  {
		if ..Statement(subElement,.addedElement)  {
			if ..addKeyword(subElement,"WHILE")  {
				if ..addPunctuation(subElement,"(")  {
					if ..ExpressionSequence(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							if ..Eos(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IterationStatement22Sub">
<Description>
"While" '(' expression_Sequence ')' statement
summary values:WHILE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("WHILE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WHILE")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ExpressionSequence(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					if ..Statement(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IterationStatement23Sub">
<Description>
 "for" "(" "var" Variable_Declaration ";" [ single_Expression ] ";" [ single_Expression ] ")" Statement
summary values:FOR</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&K&?1Rule?&P&?4?&P&?4?&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("FOR"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FOR")  {
		if ..addPunctuation(subElement,"(")  {
			if ..addKeyword(subElement,"VAR")  {
				if ..VariableDeclaration(subElement,.addedElement)  {
					if ..addPunctuation(subElement,";")  {
						if $S(..SingleExpression(subElement,.addedElement) :1,1:1) {
							if ..addPunctuation(subElement,";")  {
								if $S(..SingleExpression(subElement,.addedElement) :1,1:1) {
									if ..addPunctuation(subElement,")")  {
										if ..Statement(subElement,.addedElement)  {
											set done=1 ; end compileRules
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IterationStatement24Sub">
<Description>
"For" '(' [expression_Sequence | variable_Declaration_List] ';' [expression_Sequence] ';' [expression_Sequence] ')' statement
summary values:FOR</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?4?&P&?4?&P&?4?&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("FOR"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FOR")  {
		if ..addPunctuation(subElement,"(")  {
			if ..IterationStatement25OptGrp(subElement,.addedElement)  {
				if ..addPunctuation(subElement,";")  {
					if $S(..ExpressionSequence(subElement,.addedElement) :1,1:1) {
						if ..addPunctuation(subElement,";")  {
							if $S(..ExpressionSequence(subElement,.addedElement) :1,1:1) {
								if ..addPunctuation(subElement,")")  {
									if ..Statement(subElement,.addedElement)  {
										set done=1 ; end compileRules
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IterationStatement25OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExpressionSequence(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..VariableDeclarationList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IterationStatement26Sub">
<Description>
"For" '(' (single_Expression | variable_Declaration_List) "In" expression_Sequence ')' statement
summary values:FOR</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&K&?1Rule?&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("FOR"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FOR")  {
		if ..addPunctuation(subElement,"(")  {
			if ..IterationStatement27Sub(subElement,.addedElement)  {
				if ..addKeyword(subElement,"IN")  {
					if ..ExpressionSequence(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							if ..Statement(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IterationStatement27Sub">
<Description>
single_Expression | variable_Declaration_List</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..VariableDeclarationList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IterationStatement28Sub">
<Description>
"For" ["Await"] '(' (single_Expression | variable_Declaration_List) "Of" expression_Sequence ')' statement
summary values:FOR</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&P&?1Rule?&K&?1Rule?&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("FOR"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FOR")  {
		if $S(..addKeyword(subElement,"AWAIT") :1,1:1) {
			if ..addPunctuation(subElement,"(")  {
				if ..IterationStatement29Sub(subElement,.addedElement)  {
					if ..addKeyword(subElement,"OF")  {
						if ..ExpressionSequence(subElement,.addedElement)  {
							if ..addPunctuation(subElement,")")  {
								if ..Statement(subElement,.addedElement)  {
									set done=1 ; end compileRules
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IterationStatement29Sub">
<Description>
single_Expression | variable_Declaration_List</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..VariableDeclarationList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Keyword">
<Description>
 keyword ::= "Break" | "Do" | "Instanceof" | "Typeof" | "Case" | "Else" | "New" | "Var" | "Catch" | "Finally" | "Return" | "Void" | "Continue" | "For" | "Switch" | "While" | "Debugger" | "Function" | "This" | "With" | "Default" | "If" | "Throw" | "Delete" | "In" | "Try" | "Class" | "Enum" | "Extends" | "Super" | "Const" | "Export" | "Import" | "Implements" | "let" | "Private" | "Public" | "Interface" | "Package" | "Protected" | "Static" | "Yield" | "Async" | "Await" | "From" | "As" | "Of"
summary values:BREAK,DO,INSTANCEOF,TYPEOF,CASE,ELSE,NEW,VAR,CATCH,FINALLY,RETURN,VOID,CONTINUE,FOR,SWITCH,WHILE,DEBUGGER,FUNCTION,THIS,WITH,DEFAULT,IF,THROW,DELETE,IN,TRY,CLASS,ENUM,EXTENDS,SUPER,CONST,EXPORT,IMPORT,IMPLEMENTS,LET,PRIVATE,PUBLIC,INTERFACE,PACKAGE,PROTECTED,STATIC,YIELD,ASYNC,AWAIT,FROM,AS,OF</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K
	if '(..isKeywordInList($lb("BREAK","DO","INSTANCEOF","TYPEOF","CASE","ELSE","NEW","VAR","CATCH","FINALLY","RETURN","VOID","CONTINUE","FOR","SWITCH","WHILE","DEBUGGER","FUNCTION","THIS","WITH","DEFAULT","IF","THROW","DELETE","IN","TRY","CLASS","ENUM","EXTENDS","SUPER","CONST","EXPORT","IMPORT","IMPLEMENTS","LET","PRIVATE","PUBLIC","INTERFACE","PACKAGE","PROTECTED","STATIC","YIELD","ASYNC","AWAIT","FROM","AS","OF"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BREAK")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DO")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INSTANCEOF")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TYPEOF")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"CASE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ELSE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NEW")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"VAR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"CATCH")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FINALLY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"RETURN")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"VOID")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"CONTINUE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FOR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SWITCH")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"WHILE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DEBUGGER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FUNCTION")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"THIS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"WITH")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DEFAULT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"IF")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"THROW")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DELETE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"IN")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TRY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"CLASS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ENUM")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"EXTENDS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SUPER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"CONST")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"EXPORT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"IMPORT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"IMPLEMENTS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LET")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"PRIVATE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"PUBLIC")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INTERFACE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"PACKAGE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"PROTECTED")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"STATIC")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"YIELD")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ASYNC")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"AWAIT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FROM")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"AS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"OF")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LabelledStatement">
<Description>
 labelled_Statement ::= identifier ':' statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		if ..addPunctuation(subElement,":")  {
			if ..Statement(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LastFormalParameterArg">
<Description>
 last_Formal_Parameter_Arg ::= Ellipsis single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Ellipsis(subElement,.addedElement)  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Leftshiftarithmetic">
<Description><![CDATA[
 LeftShiftArithmetic ::= '<<'
summary values:<<]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("<<",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<<")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Leftshiftarithmeticassign">
<Description><![CDATA[
 LeftShiftArithmeticAssign ::= '<<='
summary values:<<=]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("<<=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<<=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Lessthan">
<Description><![CDATA[
 LessThan ::= '<'
summary values:<]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("<",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Lessthanequals">
<Description><![CDATA[
 LessThanEquals ::= '<='
summary values:<=]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("<=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Let">
<Description>
 let ::= "let"
summary values:LET</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("LET"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"LET")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Literal">
<Description>
 literal ::= Null_Literal | Boolean_Literal | String_Literal | Regular_Expression_Literal | numeric_Literal | bigint_Literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NullLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BooleanLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StringLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RegularExpressionLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NumericLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BigintLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Macro">
<Description>
 macro ::= '$$$' identifier ['(' expression_sequence ')']
summary values:$$$</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle("$$$",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"$$$")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..Macro146OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Macro146OptGrp">
<Description>

summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..ExpressionSequence(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MemberExpressionPart">
<Description>
 Member_Expression_Part ::= ( "[" single_Expression "]" ) | ( "." Identifier [( "(" [ expression_Sequence ] ")" )] )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MemberExpressionPart143Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MemberExpressionPart144Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MemberExpressionPart143Sub">
<Description>
 "[" single_Expression "]"
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..SingleExpression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"]")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MemberExpressionPart144Sub">
<Description>
 "." Identifier [( "(" [ expression_Sequence ] ")" )]
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..Identifier(subElement,.addedElement)  {
			if $S(..MemberExpressionPart145Sub(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MemberExpressionPart145Sub">
<Description>
 "(" [ expression_Sequence ] ")"
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if $S(..ExpressionSequence(subElement,.addedElement) :1,1:1) {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MethodDefinition">
<Description>
 method_Definition ::= (["Async"] ['*'] class_Element_Name '(' [formal_Parameter_List ] ')' function_Body) | (['*'] getter '(' ')' function_Body) | (['*'] setter '(' formal_Parameter_List? ')' function_Body)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MethodDefinition43Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MethodDefinition44Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MethodDefinition45Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MethodDefinition43Sub">
<Description>
["Async"] ['*'] class_Element_Name '(' [formal_Parameter_List ] ')' function_Body</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?4?&?1Rule?&P&?4?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addKeyword(subElement,"ASYNC") :1,1:1) {
		if $S(..addPunctuation(subElement,"*") :1,1:1) {
			if ..ClassElementName(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"(")  {
					if $S(..FormalParameterList(subElement,.addedElement) :1,1:1) {
						if ..addPunctuation(subElement,")")  {
							if ..FunctionBody(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MethodDefinition44Sub">
<Description>
['*'] getter '(' ')' function_Body</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&P&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addPunctuation(subElement,"*") :1,1:1) {
		if ..Getter(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"(")  {
				if ..addPunctuation(subElement,")")  {
					if ..FunctionBody(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MethodDefinition45Sub">
<Description>
['*'] setter '(' formal_Parameter_List? ')' function_Body</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&P&?4?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addPunctuation(subElement,"*") :1,1:1) {
		if ..Setter(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"(")  {
				if $s(..FormalParameterList(subElement,.addedElement) :1,1:1)  {
					if ..addPunctuation(subElement,")")  {
						if ..FunctionBody(subElement,.addedElement)  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Minus">
<Description>
 Minus ::= '-'
summary values:-</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("-",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"-")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Minusassign">
<Description>
 MinusAssign ::= '-='
summary values:-=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("-=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"-=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Minusminus">
<Description>
 MinusMinus ::= '--'
summary values:--</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("--",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"--")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ModuleExportName">
<Description>
 module_Export_Name ::= identifier_Name | String_Literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IdentifierName(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StringLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Modulus">
<Description>
 Modulus ::= '%'
summary values:%</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("%",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Modulusassign">
<Description>
 ModulusAssign ::= '%='
summary values:%=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("%=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Monadicop">
<Description>
 monadicop ::= "++" | "--" | "+" | "-" | "~" | "!"
summary values:++,--,+,-,~,!</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P|P
	if '(..isStringInList($lb("++","--","+","-","~","!"),2,.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"++")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"--")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"~")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"!")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Morethan">
<Description><![CDATA[
 MoreThan ::= '>'
summary values:>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(">",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,">")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Multiply">
<Description>
 Multiply ::= '*'
summary values:*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Multiplyassign">
<Description>
 MultiplyAssign ::= '*='
summary values:*=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("*=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Not">
<Description>
 Not ::= '!'
summary values:!</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("!",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"!")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Notequals">
<Description>
 NotEquals ::= '!='
summary values:!=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("!=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"!=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NullLiteral">
<Description>
 null_literal ::= 'null'
summary values:NULL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K
	if '(..isKeywordInList($lb("NULL"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NULL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Nullcoalesce">
<Description>
 NullCoalesce ::= '??'
summary values:??</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("??",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"??")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Nullishcoalescingassign">
<Description>
 NullishCoalescingAssign ::= '??='
summary values:??=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("??=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"??=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericLiteral">
<Description>
 numeric_Literal ::= Decimal_Literal | Hex_Integer_Literal | Octal_Integer_Literal | Octal_Integer_Literal2 | Binary_Integer_Literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DecimalLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..HexIntegerLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OctalIntegerLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OctalIntegerLiteral2(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BinaryIntegerLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectLiteral">
<Description>
 object_Literal ::= '{' [property_Assignment (',' property_Assignment)* ] '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..ObjectLiteral147OptGrp(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectLiteral147OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PropertyAssignment(subElement,.addedElement)  {
		if ..ObjectLiteral148RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectLiteral148RepZero">
<Description>
 (',' property_Assignment)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ObjectLiteral149Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectLiteral149Sub">
<Description>
',' property_Assignment
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..PropertyAssignment(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OctalIntegerLiteral">
<Description>
 Octal_Integer_Literal ::= ('0o' | '0O') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OctalIntegerLiteral156Sub(subElement,.addedElement)  {
		if ..OctalIntegerLiteral157RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OctalIntegerLiteral156Sub">
<Description>
'0o' | '0O'
summary values:0O,0O</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("0O","0O"),2,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0o")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"0O")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OctalIntegerLiteral157RepZero">
<Description>
 ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..OctalIntegerLiteral158Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OctalIntegerLiteral158Sub">
<Description>
'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
summary values:0,1,2,3,4,5,6,7</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P|P|P|P
	if '(..isStringInList($lb("0","1","2","3","4","5","6","7"),1,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"0")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"1")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"2")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"3")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"4")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"5")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"6")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"7")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OctalIntegerLiteral2">
<Description>
 Octal_Integer_Literal2 ::= Octal_Integer_Literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OctalIntegerLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression">
<Description><![CDATA[
 oldsingle_Expression ::= anonymous_Function | ( 'Class' identifier? class_Tail ) | ( single_Expression '?.' single_Expression ) | ( single_Expression ['?.'] '[' expression_Sequence ']') | ( single_Expression ['?'] '.' ['#'] identifier_Name ) | ( "New" identifier arguments) | ( "New" single_Expression arguments) | ( "New" single_Expression) | ( single_Expression arguments) | ( "New" '.' identifier ) | ( single_Expression '++' ) | ( single_Expression '--' ) | ( "Delete" single_Expression ) | ( "Void" single_Expression ) | ( "Typeof" single_Expression ) | ('++' single_Expression ) | ('--' single_Expression ) | ('+' single_Expression ) | ('-' single_Expression ) | ('~' single_Expression ) | ('!' single_Expression ) | ("Await" single_Expression ) | ( single_Expression '**' single_Expression ) | ( single_Expression ('*' | '/' | '%') single_Expression ) | ( single_Expression ('+' | '-') single_Expression ) | ( single_Expression '??' single_Expression ) | ( single_Expression ('<<' | '>>' | '>>>') single_Expression ) | ( single_Expression ('<' | '>' | '<=' | '>=') single_Expression ) | ( single_Expression "Instanceof" single_Expression ) | ( single_Expression "In" single_Expression ) | ( single_Expression ('==' | '!=' | '===' | '!==') single_Expression ) | ( single_Expression '&' single_Expression ) | ( single_Expression '^' single_Expression ) | ( single_Expression '|' single_Expression ) | ( single_Expression '&&' single_Expression ) | ( single_Expression '||' single_Expression ) | ( single_Expression '?' single_Expression ':' single_Expression ) | ( single_Expression '=' single_Expression ) | ( single_Expression assignment_Operator single_Expression ) | ( "Import" '(' single_Expression ')' ) | ( yield_Statement ) | "This" | identifier | "Super" | literal | array_Literal | object_Literal | ('(' expression_Sequence ')')]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|K|?1Rule?|K|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AnonymousFunction(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression67Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression68Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression69Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression70Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression71Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression72Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression73Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression74Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression75Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression76Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression77Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression78Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression79Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression80Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression81Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression82Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression83Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression84Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression85Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression86Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression87Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression88Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression89Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression91Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression93Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression94Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression96Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression98Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression99Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression100Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression102Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression103Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression104Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression105Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression106Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression107Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression108Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression109Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression110Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression111Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"THIS")  {
		set done=1 ; or
	} elseif ..Identifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SUPER")  {
		set done=1 ; or
	} elseif ..Literal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ArrayLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ObjectLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OldsingleExpression112Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression100Sub">
<Description>
 single_Expression ('==' | '!=' | '===' | '!==') single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..OldsingleExpression101Sub(subElement,.addedElement)  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression101Sub">
<Description>
'==' | '!=' | '===' | '!=='
summary values:==,!=,===,!==</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P
	if '(..isStringInList($lb("==","!=","===","!=="),3,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"==")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"!=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"===")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"!==")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression102Sub">
<Description><![CDATA[
 single_Expression '&' single_Expression]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"&")  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression103Sub">
<Description>
 single_Expression '^' single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"^")  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression104Sub">
<Description>
 single_Expression '|' single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"|")  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression105Sub">
<Description><![CDATA[
 single_Expression '&&' single_Expression]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"&&")  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression106Sub">
<Description>
 single_Expression '||' single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"||")  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression107Sub">
<Description>
 single_Expression '?' single_Expression ':' single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"?")  {
			if ..SingleExpression(subElement,.addedElement)  {
				if ..addPunctuation(subElement,":")  {
					if ..SingleExpression(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression108Sub">
<Description>
 single_Expression '=' single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"=")  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression109Sub">
<Description>
 single_Expression assignment_Operator single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..AssignmentOperator(subElement,.addedElement)  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression110Sub">
<Description>
 "Import" '(' single_Expression ')'
summary values:IMPORT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("IMPORT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IMPORT")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SingleExpression(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression111Sub">
<Description>
 yield_Statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..YieldStatement(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression112Sub">
<Description>
'(' expression_Sequence ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..ExpressionSequence(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression67Sub">
<Description>
 'Class' identifier? class_Tail
summary values:CLASS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CLASS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CLASS")  {
		if $s(..Identifier(subElement,.addedElement) :1,1:1)  {
			if ..ClassTail(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression68Sub">
<Description>
 single_Expression '?.' single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"?.")  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression69Sub">
<Description>
 single_Expression ['?.'] '[' expression_Sequence ']'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&P&?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if $S(..addPunctuation(subElement,"?.") :1,1:1) {
			if ..addPunctuation(subElement,"[")  {
				if ..ExpressionSequence(subElement,.addedElement)  {
					if ..addPunctuation(subElement,"]")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression70Sub">
<Description>
 single_Expression ['?'] '.' ['#'] identifier_Name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&P&?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if $S(..addPunctuation(subElement,"?") :1,1:1) {
			if ..addPunctuation(subElement,".")  {
				if $S(..addPunctuation(subElement,"#") :1,1:1) {
					if ..IdentifierName(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression71Sub">
<Description>
 "New" identifier arguments
summary values:NEW</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("NEW"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NEW")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..Arguments(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression72Sub">
<Description>
 "New" single_Expression arguments
summary values:NEW</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("NEW"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NEW")  {
		if ..SingleExpression(subElement,.addedElement)  {
			if ..Arguments(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression73Sub">
<Description>
 "New" single_Expression
summary values:NEW</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("NEW"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NEW")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression74Sub">
<Description>
 single_Expression arguments</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..Arguments(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression75Sub">
<Description>
 "New" '.' identifier
summary values:NEW</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("NEW"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NEW")  {
		if ..addPunctuation(subElement,".")  {
			if ..Identifier(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression76Sub">
<Description>
 single_Expression '++'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"++")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression77Sub">
<Description>
 single_Expression '--'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"--")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression78Sub">
<Description>
 "Delete" single_Expression
summary values:DELETE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("DELETE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DELETE")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression79Sub">
<Description>
 "Void" single_Expression
summary values:VOID</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("VOID"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"VOID")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression80Sub">
<Description>
 "Typeof" single_Expression
summary values:TYPEOF</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("TYPEOF"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"TYPEOF")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression81Sub">
<Description>
'++' single_Expression
summary values:++</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("++",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"++")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression82Sub">
<Description>
'--' single_Expression
summary values:--</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("--",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"--")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression83Sub">
<Description>
'+' single_Expression
summary values:+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("+",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression84Sub">
<Description>
'-' single_Expression
summary values:-</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("-",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"-")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression85Sub">
<Description>
'~' single_Expression
summary values:~</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("~",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"~")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression86Sub">
<Description>
'!' single_Expression
summary values:!</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("!",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"!")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression87Sub">
<Description>
"Await" single_Expression
summary values:AWAIT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AWAIT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AWAIT")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression88Sub">
<Description>
 single_Expression '**' single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"**")  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression89Sub">
<Description>
 single_Expression ('*' | '/' | '%') single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..OldsingleExpression90Sub(subElement,.addedElement)  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression90Sub">
<Description>
'*' | '/' | '%'
summary values:*,/,%</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P
	if '(..isStringInList($lb("*","/","%"),1,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"/")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression91Sub">
<Description>
 single_Expression ('+' | '-') single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..OldsingleExpression92Sub(subElement,.addedElement)  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression92Sub">
<Description>
'+' | '-'
summary values:+,-</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("+","-"),1,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression93Sub">
<Description>
 single_Expression '??' single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"??")  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression94Sub">
<Description><![CDATA[
 single_Expression ('<<' | '>>' | '>>>') single_Expression]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..OldsingleExpression95Sub(subElement,.addedElement)  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression95Sub">
<Description><![CDATA[
'<<' | '>>' | '>>>'
summary values:<<,>>,>>>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P
	if '(..isStringInList($lb("<<",">>",">>>"),3,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"<<")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">>")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">>>")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression96Sub">
<Description><![CDATA[
 single_Expression ('<' | '>' | '<=' | '>=') single_Expression]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..OldsingleExpression97Sub(subElement,.addedElement)  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression97Sub">
<Description><![CDATA[
'<' | '>' | '<=' | '>='
summary values:<,>,<=,>=]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P
	if '(..isStringInList($lb("<",">","<=",">="),2,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"<")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">=")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression98Sub">
<Description>
 single_Expression "Instanceof" single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addKeyword(subElement,"INSTANCEOF")  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OldsingleExpression99Sub">
<Description>
 single_Expression "In" single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SingleExpression(subElement,.addedElement)  {
		if ..addKeyword(subElement,"IN")  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Openbrace">
<Description>
 OpenBrace ::= '{'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Openbracket">
<Description>
 OpenBracket ::='['
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Openparen">
<Description>
 OpenParen ::= '('
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Or">
<Description>
 Or ::= '||'
summary values:||</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("||",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"||")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Plus">
<Description>
 Plus ::= '+'
summary values:+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("+",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Plusassign">
<Description>
 PlusAssign ::= '+='
summary values:+=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("+=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Plusplus">
<Description>
 PlusPlus ::= '++'
summary values:++</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("++",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"++")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Power">
<Description>
 Power ::= '**'
summary values:**</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("**",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"**")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Powerassign">
<Description>
 PowerAssign ::= '**='
summary values:**=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("**=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"**=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary">
<Description>
 primary ::= anonymous_Function | ('[' expression_sequence ']') | ( 'Class' identifier? class_Tail ) | ( "New" identifier arguments) | ( "New" single_Expression arguments) | ( "New" single_Expression) | ( "New" '.' identifier ) | ( "Delete" single_Expression ) | ( "Void" single_Expression ) | ( "Typeof" single_Expression ) | ("Await" single_Expression ) | ( "Import" '(' single_Expression ')' ) | ( yield_Statement ) | ("This" (member_expression_part)* ) | macro | (function (member_expression_part)* ) | (identifier (member_expression_part)* ) | "Super" | literal | (array_Literal (member_expression_part)*) | object_Literal | ('(' expression_Sequence ')')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|K|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AnonymousFunction(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary118Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary119Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary120Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary121Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary122Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary123Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary124Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary125Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary126Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary127Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary128Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary129Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary130Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Macro(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary133Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary136Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SUPER")  {
		set done=1 ; or
	} elseif ..Literal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary139Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ObjectLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary142Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary118Sub">
<Description>
'[' expression_sequence ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..ExpressionSequence(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"]")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary119Sub">
<Description>
 'Class' identifier? class_Tail
summary values:CLASS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CLASS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CLASS")  {
		if $s(..Identifier(subElement,.addedElement) :1,1:1)  {
			if ..ClassTail(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary120Sub">
<Description>
 "New" identifier arguments
summary values:NEW</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("NEW"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NEW")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..Arguments(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary121Sub">
<Description>
 "New" single_Expression arguments
summary values:NEW</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("NEW"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NEW")  {
		if ..SingleExpression(subElement,.addedElement)  {
			if ..Arguments(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary122Sub">
<Description>
 "New" single_Expression
summary values:NEW</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("NEW"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NEW")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary123Sub">
<Description>
 "New" '.' identifier
summary values:NEW</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("NEW"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NEW")  {
		if ..addPunctuation(subElement,".")  {
			if ..Identifier(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary124Sub">
<Description>
 "Delete" single_Expression
summary values:DELETE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("DELETE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DELETE")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary125Sub">
<Description>
 "Void" single_Expression
summary values:VOID</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("VOID"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"VOID")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary126Sub">
<Description>
 "Typeof" single_Expression
summary values:TYPEOF</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("TYPEOF"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"TYPEOF")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary127Sub">
<Description>
"Await" single_Expression
summary values:AWAIT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("AWAIT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AWAIT")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary128Sub">
<Description>
 "Import" '(' single_Expression ')'
summary values:IMPORT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("IMPORT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IMPORT")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SingleExpression(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary129Sub">
<Description>
 yield_Statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..YieldStatement(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary130Sub">
<Description>
"This" (member_expression_part)*
summary values:THIS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&(?4?)*
	; first rule summary K
	if '(..isKeywordInList($lb("THIS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"THIS")  {
		if ..Primary131RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary131RepZero">
<Description>
 (member_expression_part)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Primary132Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Primary132Sub">
<Description>
member_expression_part</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MemberExpressionPart(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary133Sub">
<Description>
function (member_expression_part)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Function(subElement,.addedElement)  {
		if ..Primary134RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary134RepZero">
<Description>
 (member_expression_part)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Primary135Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Primary135Sub">
<Description>
member_expression_part</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MemberExpressionPart(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary136Sub">
<Description>
identifier (member_expression_part)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		if ..Primary137RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary137RepZero">
<Description>
 (member_expression_part)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Primary138Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Primary138Sub">
<Description>
member_expression_part</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MemberExpressionPart(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary139Sub">
<Description>
array_Literal (member_expression_part)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ArrayLiteral(subElement,.addedElement)  {
		if ..Primary140RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary140RepZero">
<Description>
 (member_expression_part)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Primary141Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Primary141Sub">
<Description>
member_expression_part</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MemberExpressionPart(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary142Sub">
<Description>
'(' expression_Sequence ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..ExpressionSequence(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PrivateIdentifier">
<Description>
 private_Identifier ::= '#' identifier_Name
summary values:#</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("#",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"#")  {
		if ..IdentifierName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PropertyAssignment">
<Description>
 property_Assignment ::= (property_Name ':' single_Expression ) | ('[' single_Expression ']' ':' single_Expression) | ([ "Async" ] ['*'] property_Name '(' [formal_Parameter_List] ')' function_Body ) | (getter '(' ')' function_Body ) | (setter '(' formal_Parameter_Arg ')' function_Body ) | ([Ellipsis] single_Expression )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PropertyAssignment54Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PropertyAssignment55Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PropertyAssignment56Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PropertyAssignment57Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PropertyAssignment58Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PropertyAssignment59Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PropertyAssignment54Sub">
<Description>
property_Name ':' single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PropertyName(subElement,.addedElement)  {
		if ..addPunctuation(subElement,":")  {
			if ..SingleExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PropertyAssignment55Sub">
<Description>
'[' single_Expression ']' ':' single_Expression
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P&P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..SingleExpression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"]")  {
				if ..addPunctuation(subElement,":")  {
					if ..SingleExpression(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PropertyAssignment56Sub">
<Description>
[ "Async" ] ['*'] property_Name '(' [formal_Parameter_List] ')' function_Body</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?4?&?1Rule?&P&?4?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addKeyword(subElement,"ASYNC") :1,1:1) {
		if $S(..addPunctuation(subElement,"*") :1,1:1) {
			if ..PropertyName(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"(")  {
					if $S(..FormalParameterList(subElement,.addedElement) :1,1:1) {
						if ..addPunctuation(subElement,")")  {
							if ..FunctionBody(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PropertyAssignment57Sub">
<Description>
getter '(' ')' function_Body</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Getter(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"(")  {
			if ..addPunctuation(subElement,")")  {
				if ..FunctionBody(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PropertyAssignment58Sub">
<Description>
setter '(' formal_Parameter_Arg ')' function_Body</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Setter(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"(")  {
			if ..FormalParameterArg(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					if ..FunctionBody(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PropertyAssignment59Sub">
<Description>
[Ellipsis] single_Expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Ellipsis(subElement,.addedElement) :1,1:1) {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PropertyName">
<Description>
 property_Name ::= identifier_Name | String_Literal | numeric_Literal | ('[' single_Expression ']')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IdentifierName(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StringLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NumericLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PropertyName60Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PropertyName60Sub">
<Description>
'[' single_Expression ']'
summary values:[</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("[",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[")  {
		if ..SingleExpression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"]")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Questionmark">
<Description>
 QuestionMark ::= '?'
summary values:?</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("?",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"?")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Questionmarkdot">
<Description>
 QuestionMarkDot ::= '?.'
summary values:?.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("?.",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"?.")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RegularExpressionLiteral">
<Description>
 regular_expression_literal ::= 'NEED regex literal'
summary values:NEED REGEX LITERAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED REGEX LITERAL",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED regex literal")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReservedWord">
<Description>
 reserved_Word ::= keyword | Null_Literal | Boolean_Literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Keyword(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NullLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BooleanLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReturnStatement">
<Description>
 return_Statement ::= "Return" [ expression_Sequence] eos
summary values:RETURN</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("RETURN"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"RETURN")  {
		if $S(..ExpressionSequence(subElement,.addedElement) :1,1:1) {
			if ..Eos(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rightshiftarithmetic">
<Description><![CDATA[
 RightShiftArithmetic ::= '>>'
summary values:>>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(">>",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,">>")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rightshiftarithmeticassign">
<Description><![CDATA[
 RightShiftArithmeticAssign ::= '>>='
summary values:>>=]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(">>=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,">>=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rightshiftlogical">
<Description><![CDATA[
 RightShiftLogical ::= '>>>'
summary values:>>>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(">>>",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,">>>")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Rightshiftlogicalassign">
<Description><![CDATA[
 RightShiftLogicalAssign ::= '>>>='
summary values:>>>=]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(">>>=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,">>>=")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Semicolon">
<Description>
 SemiColon ::= ';'
summary values:;</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle(";",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,";")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Setter">
<Description>
 setter ::= "set" identifier class_Element_Name
summary values:SET</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SET"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SET")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..ClassElementName(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SingleExpression">
<Description>
 single_expression ::= factor ( dyadicop factor )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Factor(subElement,.addedElement)  {
		if ..SingleExpression113RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SingleExpression113RepZero">
<Description>
 ( dyadicop factor )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SingleExpression114Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SingleExpression114Sub">
<Description>
 dyadicop factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Dyadicop(subElement,.addedElement)  {
		if ..Factor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SourceElement">
<Description>
 source_Element ::= statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Statement(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SourceElements">
<Description>
 source_Elements ::= source_Element*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SourceElements51RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SourceElements51RepZero">
<Description>
 source_Element*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SourceElement(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Statement">
<Description>
 statement ::= block | variable_Statement | import_Statement | export_Statement | empty_Statement | class_Declaration | function_Declaration | expression_Statement | if_Statement | iteration_Statement | continue_Statement | break_Statement | return_Statement | yield_Statement | with_Statement | labelled_Statement | switch_Statement | throw_Statement | try_Statement | debugger_Statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Block(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..VariableStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ImportStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ExportStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..EmptyStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ClassDeclaration(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..FunctionDeclaration(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ExpressionStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IfStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IterationStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ContinueStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BreakStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ReturnStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..YieldStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..WithStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..LabelledStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SwitchStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ThrowStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TryStatement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DebuggerStatement(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatementList">
<Description>
 statement_List ::= statement*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StatementList1RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatementList1RepZero">
<Description>
 statement*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Statement(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StringLiteral">
<Description>
 string_literal ::= 'NEED string literal'
summary values:NEED STRING LITERAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED STRING LITERAL",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED string literal")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SwitchStatement">
<Description>
 switch_Statement ::= "Switch" '(' expression_Sequence ')' case_Block
summary values:SWITCH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("SWITCH"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SWITCH")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ExpressionSequence(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					if ..CaseBlock(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ThrowStatement">
<Description>
 throw_Statement ::= "Throw" expression_Sequence eos
summary values:THROW</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("THROW"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"THROW")  {
		if ..ExpressionSequence(subElement,.addedElement)  {
			if ..Eos(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TryStatement">
<Description>
 try_Statement ::= "Try" block ((catch_Production [finally_Production]) | finally_Production)
summary values:TRY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("TRY"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"TRY")  {
		if ..Block(subElement,.addedElement)  {
			if ..TryStatement32Sub(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TryStatement32Sub">
<Description>
(catch_Production [finally_Production]) | finally_Production</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TryStatement33Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..FinallyProduction(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TryStatement33Sub">
<Description>
catch_Production [finally_Production]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CatchProduction(subElement,.addedElement)  {
		if $S(..FinallyProduction(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="VarModifier">
<Description>
 var_Modifier ::= "Var" | "let" | "Const"
summary values:VAR,LET,CONST</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K
	if '(..isKeywordInList($lb("VAR","LET","CONST"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"VAR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LET")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"CONST")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="VariableDeclaration">
<Description>
 variable_Declaration ::= assignable [('=' single_Expression)]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Assignable(subElement,.addedElement)  {
		if $S(..VariableDeclaration19Sub(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="VariableDeclaration19Sub">
<Description>
'=' single_Expression
summary values:=</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("=",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  {
		if ..SingleExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="VariableDeclarationList">
<Description>
 variable_Declaration_List ::= var_Modifier variable_Declaration (',' variable_Declaration)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..VarModifier(subElement,.addedElement)  {
		if ..VariableDeclaration(subElement,.addedElement)  {
			if ..VariableDeclarationList17RepZero(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="VariableDeclarationList17RepZero">
<Description>
 (',' variable_Declaration)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..VariableDeclarationList18Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="VariableDeclarationList18Sub">
<Description>
',' variable_Declaration
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..VariableDeclaration(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="VariableStatement">
<Description>
 variable_Statement ::= variable_Declaration_List eos</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..VariableDeclarationList(subElement,.addedElement)  {
		if ..Eos(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithStatement">
<Description>
 with_Statement ::= "With" '(' expression_Sequence ')' statement
summary values:WITH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("WITH"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WITH")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ExpressionSequence(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					if ..Statement(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="YieldStatement">
<Description>
 yield_Statement ::= "Yield" [ expression_Sequence] eos
summary values:YIELD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("YIELD"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"YIELD")  {
		if $S(..ExpressionSequence(subElement,.addedElement) :1,1:1) {
			if ..Eos(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Element</ReturnType>
<Implementation><![CDATA[	quit ##class(PXW.DEV.BNF.Element).%New(Type)
]]></Implementation>
</Method>

<Parameter name="KeywordPattern">
<Default>1.A</Default>
</Parameter>

<Parameter name="Keywords">
<Default>A,AS,ASYNC,AWAIT,B,BREAK,C,CASE,CATCH,CLASS,CONST,CONTINUE,D,DEBUGGER,DEFAULT,DELETE,DO,E,ELSE,ENUM,EXPORT,EXTENDS,F,FALSE,FINALLY,FOR,FROM,FUNCTION,GET,IF,IMPLEMENTS,IMPORT,IN,INSTANCEOF,INTERFACE,LET,N,NEW,NULL,OF,PACKAGE,PRIVATE,PROTECTED,PUBLIC,RETURN,SET,STATIC,SUPER,SWITCH,THIS,THROW,TRUE,TRY,TYPEOF,VAR,VOID,WHILE,WITH,YIELD</Default>
</Parameter>
</Class>


<Class name="PXW.DEV.BNF.GEN.Python">
<Description>
Created: 2024-10-17 15:59:11 PXW.DEV.BNF.Compilers.Compiler2</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>PXW.DEV.BNF.super</Super>
<TimeChanged>67130,57560.43013175</TimeChanged>
<TimeCreated>67125,77563.174257839</TimeCreated>

<Method name="AnnotatedRhs">
<Description>
 annotated_rhs: yield_expr | star_expressions</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..YieldExpr(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarExpressions(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Annotation">
<Description>
 annotation: ':' expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,":")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args">
<Description>
 args: | ','.(starred_expression | ( assignment_expression | expression !':=') !'=')+ [',' kwargs ] | kwargs</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Args324Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Kwargs(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args324Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Args325RepSep(subElement,.addedElement)  && ..Args338OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Args325RepSep">
<Description>
 ','.(starred_expression | ( assignment_expression | expression !':=') !'=')+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..Args326Sub(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..Args332Sub(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args326Sub">
<Description>
starred_expression | ( assignment_expression | expression !':=') !'='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StarredExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Args327Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args327Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Args328Sub(subElement,.addedElement)  && ..Args331Not(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args328Sub">
<Description>
 assignment_expression | expression !':='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AssignmentExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Args329Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args329Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  && ..Args330Not(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args330Not">
<Description>
':='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":=")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args331Not">
<Description>
'='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args332Sub">
<Description>
starred_expression | ( assignment_expression | expression !':=') !'='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StarredExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Args333Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args333Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Args334Sub(subElement,.addedElement)  && ..Args337Not(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args334Sub">
<Description>
 assignment_expression | expression !':='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AssignmentExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Args335Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args335Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  && ..Args336Not(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args336Not">
<Description>
':='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":=")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args337Not">
<Description>
'='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Args338OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  && ..Kwargs(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Arguments">
<Description><![CDATA[
 arguments: | args [','] &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Arguments322Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Arguments322Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Args(subElement,.addedElement)  && $S(..addPunctuation(subElement,",") :1,1:1) && ..Arguments323Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Arguments323Peek">
<Description><![CDATA[
 &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :')'
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,")")  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AsPattern">
<Description>
 as_pattern: | or_pattern 'as' pattern_capture_target</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AsPattern134Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AsPattern134Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..OrPattern(subElement,.addedElement)  && ..addKeyword(subElement,"AS")  && ..PatternCaptureTarget(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="AssertStmt">
<Description>
 assert_stmt: 'assert' expression [',' expression ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ASSERT")  && ..Expression(subElement,.addedElement)  && ..AssertStmt29OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AssertStmt29OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  && ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Assignment">
<Description>
 assignment: | NAME ':' expression ['=' annotated_rhs ] | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs ] | (star_targets '=' )+ (yield_expr | star_expressions) !'=' [TYPE_COMMENT] | single_target augassign ~ (yield_expr | star_expressions)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Assignment9Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Assignment11Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Assignment14Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Assignment19Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Assignment10OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  && ..AnnotatedRhs(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Assignment11Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Assignment12Sub(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Expression(subElement,.addedElement)  && ..Assignment13OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Assignment12Sub">
<Description>
'(' single_target ')' | single_subscript_attribute_target</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  && ..SingleTarget(subElement,.addedElement)  && ..addPunctuation(subElement,")")  {
		set done=1 ; or
	} elseif ..SingleSubscriptAttributeTarget(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Assignment13OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  && ..AnnotatedRhs(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Assignment14Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Assignment15RepOne(subElement,.addedElement)  && ..Assignment17Sub(subElement,.addedElement)  && ..Assignment18Not(subElement,.addedElement)  && $S(..TypeComment(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Assignment15RepOne">
<Description>
 (star_targets '=' )+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Assignment16Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Assignment16Sub">
<Description>
star_targets '='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StarTargets(subElement,.addedElement)  && ..addPunctuation(subElement,"=")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Assignment17Sub">
<Description>
yield_expr | star_expressions</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..YieldExpr(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StarExpressions(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Assignment18Not">
<Description>
'='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Assignment19Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SingleTarget(subElement,.addedElement)  && ..Augassign(subElement,.addedElement)  && 1 /* force means? */ && ..Assignment20Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Assignment20Sub">
<Description>
yield_expr | star_expressions</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..YieldExpr(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StarExpressions(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Assignment9Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Name(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Expression(subElement,.addedElement)  && ..Assignment10OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="AssignmentExpression">
<Description>
 assignment_expression: | NAME ':=' ~ expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AssignmentExpression197Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AssignmentExpression197Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Name(subElement,.addedElement)  && ..addPunctuation(subElement,":=")  && 1 /* force means? */ && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Async">
<Description>
 ASYNC : 'async'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ASYNC")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Atom">
<Description>
 atom: | NAME | 'True' | 'False' | 'None' | strings | NUMBER | (tuple | group | genexp) | (list | listcomp) | (dict | set | dictcomp | setcomp) | '...'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Name(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TRUE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FALSE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NONE")  {
			set done=1 ; or
		} elseif ..Strings(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Number(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Atom249Sub(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Atom250Sub(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Atom251Sub(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"...")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Atom249Sub">
<Description>
tuple | group | genexp</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Tuple(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Group(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Genexp(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Atom250Sub">
<Description>
list | listcomp</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..List(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Listcomp(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Atom251Sub">
<Description>
dict | set | dictcomp | setcomp</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Dict(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Set(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Dictcomp(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Setcomp(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Attr">
<Description>
 attr: | name_or_attr '.' NAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Attr153Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Attr153Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..NameOrAttr(subElement,.addedElement)  && ..addPunctuation(subElement,".")  && ..Name(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Augassign">
<Description><![CDATA[
 augassign: | '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//=']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"+=")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"-=")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"*=")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"@=")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"/=")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"%=")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"&=")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"|=")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"^=")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"<<=")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,">>=")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"**=")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"//=")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Await">
<Description>
 AWAIT : 'await'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"AWAIT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AwaitPrimary">
<Description>
 await_primary: | AWAIT primary | primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AwaitPrimary235Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Primary(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AwaitPrimary235Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Await(subElement,.addedElement)  && ..Primary(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="BitwiseAnd">
<Description><![CDATA[
 bitwise_and: | bitwise_and '&' shift_expr | shift_expr]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..BitwiseAnd216Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitwiseAnd216Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..BitwiseAnd217Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ShiftExpr(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitwiseAnd217Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BitwiseAnd(subElement,.addedElement)  && ..addPunctuation(subElement,"&")  && ..ShiftExpr(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitwiseOr">
<Description>
 bitwise_or: | bitwise_or '|' bitwise_xor | bitwise_xor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..BitwiseOr212Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitwiseOr212Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..BitwiseOr213Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BitwiseXor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitwiseOr213Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BitwiseOr(subElement,.addedElement)  && ..addPunctuation(subElement,"|")  && ..BitwiseXor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitwiseXor">
<Description>
 bitwise_xor: | bitwise_xor '^' bitwise_and | bitwise_and</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..BitwiseXor214Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitwiseXor214Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..BitwiseXor215Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BitwiseAnd(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitwiseXor215Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BitwiseXor(subElement,.addedElement)  && ..addPunctuation(subElement,"^")  && ..BitwiseAnd(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Block">
<Description>
 block: | NEWLINE INDENT statements DEDENT | simple_stmts</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Block47Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SimpleStmts(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Block47Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Newline(subElement,.addedElement)  && ..Indent(subElement,.addedElement)  && ..Statements(subElement,.addedElement)  && ..Dedent(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="CapturePattern">
<Description>
 capture_pattern: | pattern_capture_target</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..PatternCaptureTarget(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseBlock">
<Description>
 case_block: | "case" patterns guard? ':' block</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CaseBlock133Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseBlock133Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"CASE")  && ..Patterns(subElement,.addedElement)  && $s(..Guard(subElement,.addedElement) :1,1:1)  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ClassDef">
<Description>
 class_def: | decorators class_def_raw | class_def_raw</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ClassDef50Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ClassDefRaw(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassDef50Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Decorators(subElement,.addedElement)  && ..ClassDefRaw(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ClassDefRaw">
<Description>
 class_def_raw: | 'class' NAME [type_params] ['(' [arguments] ')' ] ':' block</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ClassDefRaw51Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassDefRaw51Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"CLASS")  && ..Name(subElement,.addedElement)  && $S(..TypeParams(subElement,.addedElement) :1,1:1) && ..ClassDefRaw52OptGrp(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ClassDefRaw52OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  && $S(..Arguments(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,")")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassPattern">
<Description>
 class_pattern: | name_or_attr '(' ')' | name_or_attr '(' positional_patterns ','? ')' | name_or_attr '(' keyword_patterns ','? ')' | name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ClassPattern170Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ClassPattern171Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ClassPattern172Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ClassPattern173Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ClassPattern170Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..NameOrAttr(subElement,.addedElement)  && ..addPunctuation(subElement,"(")  && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ClassPattern171Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..NameOrAttr(subElement,.addedElement)  && ..addPunctuation(subElement,"(")  && ..PositionalPatterns(subElement,.addedElement)  && $s(..addPunctuation(subElement,",") :1,1:1)  && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ClassPattern172Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..NameOrAttr(subElement,.addedElement)  && ..addPunctuation(subElement,"(")  && ..KeywordPatterns(subElement,.addedElement)  && $s(..addPunctuation(subElement,",") :1,1:1)  && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ClassPattern173Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..NameOrAttr(subElement,.addedElement)  && ..addPunctuation(subElement,"(")  && ..PositionalPatterns(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && ..KeywordPatterns(subElement,.addedElement)  && $s(..addPunctuation(subElement,",") :1,1:1)  && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ClosedPattern">
<Description>
 closed_pattern: | literal_pattern | capture_pattern | wildcard_pattern | value_pattern | group_pattern | sequence_pattern | mapping_pattern | class_pattern</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LiteralPattern(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CapturePattern(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..WildcardPattern(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ValuePattern(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GroupPattern(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SequencePattern(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..MappingPattern(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ClassPattern(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CompareOpBitwiseOrPair">
<Description>
 compare_op_bitwise_or_pair: | eq_bitwise_or | noteq_bitwise_or | lte_bitwise_or | lt_bitwise_or | gte_bitwise_or | gt_bitwise_or | notin_bitwise_or | in_bitwise_or | isnot_bitwise_or | is_bitwise_or</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..EqBitwiseOr(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NoteqBitwiseOr(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LteBitwiseOr(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LtBitwiseOr(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GteBitwiseOr(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GtBitwiseOr(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NotinBitwiseOr(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..InBitwiseOr(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..IsnotBitwiseOr(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..IsBitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Comparison">
<Description>
 comparison: | bitwise_or compare_op_bitwise_or_pair+ | bitwise_or</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Comparison208Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Comparison208Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..BitwiseOr(subElement,.addedElement)  && ..Comparison209RepOne(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Comparison209RepOne">
<Description>
 compare_op_bitwise_or_pair+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CompareOpBitwiseOrPair(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ComplexNumber">
<Description>
 complex_number: | signed_real_number '+' imaginary_number | signed_real_number '-' imaginary_number</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ComplexNumber142Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ComplexNumber143Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ComplexNumber142Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SignedRealNumber(subElement,.addedElement)  && ..addPunctuation(subElement,"+")  && ..ImaginaryNumber(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ComplexNumber143Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SignedRealNumber(subElement,.addedElement)  && ..addPunctuation(subElement,"-")  && ..ImaginaryNumber(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="CompoundStmt">
<Description>
 compound_stmt: | function_def | if_stmt | class_def | with_stmt | for_stmt | try_stmt | while_stmt | match_stmt</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..FunctionDef(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..IfStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ClassDef(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..WithStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ForStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TryStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..WhileStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..MatchStmt(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Conjunction">
<Description>
 conjunction: | inversion ('and' inversion )+ | inversion</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Conjunction203Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Inversion(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Conjunction203Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Inversion(subElement,.addedElement)  && ..Conjunction204RepOne(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Conjunction204RepOne">
<Description>
 ('and' inversion )+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Conjunction205Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Conjunction205Sub">
<Description>
'and' inversion</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AND")  && ..Inversion(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Decorators">
<Description>
 decorators: ('@' named_expression NEWLINE )+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Decorators48RepOne(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Decorators48RepOne">
<Description>
 ('@' named_expression NEWLINE )+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Decorators49Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Decorators49Sub">
<Description>
'@' named_expression NEWLINE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"@")  && ..NamedExpression(subElement,.addedElement)  && ..Newline(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Dedent">
<Description>
 DEDENT : 'code dedent'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"code dedent")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Default">
<Description>
 default: '=' expression | invalid_default</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"=")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..InvalidDefault(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelStmt">
<Description><![CDATA[
 del_stmt: | 'del' del_targets &(';' | NEWLINE)]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DelStmt26Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelStmt26Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"DEL")  && ..DelTargets(subElement,.addedElement)  && ..DelStmt27Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="DelStmt27Peek">
<Description><![CDATA[
 &(';' | NEWLINE)]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :(';' | NEWLINE)
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DelStmt28Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelStmt28Sub">
<Description>
';' | NEWLINE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,";")  {
		set done=1 ; or
	} elseif ..Newline(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelTAtom">
<Description>
 del_t_atom: | NAME | '(' del_target ')' | '(' [del_targets] ')' | '[' [del_targets] ']'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Name(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DelTAtom390Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DelTAtom391Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DelTAtom392Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelTAtom390Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"(")  && ..DelTarget(subElement,.addedElement)  && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="DelTAtom391Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"(")  && $S(..DelTargets(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="DelTAtom392Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"[")  && $S(..DelTargets(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,"]")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="DelTarget">
<Description>
 del_target: | t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | del_t_atom</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DelTarget386Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DelTarget388Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DelTAtom(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelTarget386Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..TPrimary(subElement,.addedElement)  && ..addPunctuation(subElement,".")  && ..Name(subElement,.addedElement)  && ..DelTarget387Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="DelTarget387Not">
<Description>
t_lookahead</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TLookahead(subElement,.addedElement)  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelTarget388Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..TPrimary(subElement,.addedElement)  && ..addPunctuation(subElement,"[")  && ..Slices(subElement,.addedElement)  && ..addPunctuation(subElement,"]")  && ..DelTarget389Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="DelTarget389Not">
<Description>
t_lookahead</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TLookahead(subElement,.addedElement)  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelTargets">
<Description>
 del_targets: ','.del_target+ [',']</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DelTargets385RepSep(subElement,.addedElement)  && $S(..addPunctuation(subElement,",") :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelTargets385RepSep">
<Description>
 ','.del_target+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..DelTarget(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..DelTarget(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Dict">
<Description>
 dict: | '{' [double_starred_kvpairs] '}'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Dict305Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Dict305Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"{")  && $S(..DoubleStarredKvpairs(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,"}")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Dictcomp">
<Description>
 dictcomp: | '{' kvpair for_if_clauses '}'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Dictcomp321Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Dictcomp321Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"{")  && ..Kvpair(subElement,.addedElement)  && ..ForIfClauses(subElement,.addedElement)  && ..addPunctuation(subElement,"}")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Disjunction">
<Description>
 disjunction: | conjunction ('or' conjunction )+ | conjunction</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Disjunction200Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Conjunction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Disjunction200Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Conjunction(subElement,.addedElement)  && ..Disjunction201RepOne(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Disjunction201RepOne">
<Description>
 ('or' conjunction )+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Disjunction202Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Disjunction202Sub">
<Description>
'or' conjunction</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"OR")  && ..Conjunction(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DottedAsName">
<Description>
 dotted_as_name: | dotted_name ['as' NAME ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DottedAsName43Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DottedAsName43Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..DottedName(subElement,.addedElement)  && ..DottedAsName44OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="DottedAsName44OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  && ..Name(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DottedAsNames">
<Description>
 dotted_as_names: | ','.dotted_as_name+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DottedAsNames42RepSep(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DottedAsNames42RepSep">
<Description>
 ','.dotted_as_name+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..DottedAsName(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..DottedAsName(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DottedName">
<Description>
 dotted_name: | dotted_name '.' NAME | NAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..DottedName45Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DottedName45Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..DottedName46Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Name(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DottedName46Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DottedName(subElement,.addedElement)  && ..addPunctuation(subElement,".")  && ..Name(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoubleStarPattern">
<Description>
 double_star_pattern: | '**' pattern_capture_target</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DoubleStarPattern169Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoubleStarPattern169Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"**")  && ..PatternCaptureTarget(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="DoubleStarredKvpair">
<Description>
 double_starred_kvpair: | '**' bitwise_or | kvpair</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DoubleStarredKvpair307Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Kvpair(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoubleStarredKvpair307Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"**")  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="DoubleStarredKvpairs">
<Description>
 double_starred_kvpairs: ','.double_starred_kvpair+ [',']</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DoubleStarredKvpairs306RepSep(subElement,.addedElement)  && $S(..addPunctuation(subElement,",") :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoubleStarredKvpairs306RepSep">
<Description>
 ','.double_starred_kvpair+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..DoubleStarredKvpair(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..DoubleStarredKvpair(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElifStmt">
<Description>
 elif_stmt: | 'elif' named_expression ':' block elif_stmt | 'elif' named_expression ':' block [else_block]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..ElifStmt101Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElifStmt101Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..ElifStmt102Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ElifStmt103Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElifStmt102Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ELIF")  && ..NamedExpression(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  && ..ElifStmt(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElifStmt103Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ELIF")  && ..NamedExpression(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  && $S(..ElseBlock(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElseBlock">
<Description>
 else_block: | 'else' ':' block</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ElseBlock104Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElseBlock104Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"ELSE")  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Endmarker">
<Description>
 ENDMARKER : 'code endmarker'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"code endmarker")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EqBitwiseOr">
<Description>
 eq_bitwise_or: '==' bitwise_or</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"==")  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Eval">
<Description>
 eval: expressions NEWLINE* ENDMARKER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Expressions(subElement,.addedElement)  && ..Eval1RepZero(subElement,.addedElement)  && ..Endmarker(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Eval1RepZero">
<Description>
 NEWLINE*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..Newline(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ExceptBlock">
<Description>
 except_block: | 'except' expression ['as' NAME ] ':' block | 'except' ':' block</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ExceptBlock124Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ExceptBlock126Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExceptBlock124Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"EXCEPT")  && ..Expression(subElement,.addedElement)  && ..ExceptBlock125OptGrp(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ExceptBlock125OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  && ..Name(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExceptBlock126Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"EXCEPT")  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ExceptStarBlock">
<Description>
 except_star_block: | 'except' '*' expression ['as' NAME ] ':' block</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ExceptStarBlock127Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExceptStarBlock127Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"EXCEPT")  && ..addPunctuation(subElement,"*")  && ..Expression(subElement,.addedElement)  && ..ExceptStarBlock128OptGrp(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ExceptStarBlock128OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  && ..Name(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Expression">
<Description>
 expression: | disjunction 'if' disjunction 'else' expression | disjunction | lambdef</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Expression186Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Expression186Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..Expression187Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Disjunction(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Lambdef(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Expression187Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Disjunction(subElement,.addedElement)  && ..addKeyword(subElement,"IF")  && ..Disjunction(subElement,.addedElement)  && ..addKeyword(subElement,"ELSE")  && ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Expressions">
<Description>
 expressions: | expression (',' expression )+ [','] | expression ',' | expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Expressions182Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Expressions185Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Expressions182Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Expression(subElement,.addedElement)  && ..Expressions183RepOne(subElement,.addedElement)  && $S(..addPunctuation(subElement,",") :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Expressions183RepOne">
<Description>
 (',' expression )+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Expressions184Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Expressions184Sub">
<Description>
',' expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  && ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Expressions185Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Expression(subElement,.addedElement)  && ..addPunctuation(subElement,",")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Factor">
<Description>
 factor: | '+' factor | '-' factor | '~' factor | power</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Factor230Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Factor230Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..Factor231Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Factor232Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Factor233Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Power(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Factor231Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  && ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Factor232Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"-")  && ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Factor233Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"~")  && ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="File">
<Description>
 file: [statements] ENDMARKER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..Statements(subElement,.addedElement) :1,1:1) && ..Endmarker(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FinallyBlock">
<Description>
 finally_block: | 'finally' ':' block</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..FinallyBlock129Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FinallyBlock129Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"FINALLY")  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ForIfClause">
<Description>
 for_if_clause: | ASYNC 'for' star_targets 'in' ~ disjunction ('if' disjunction )* | 'for' star_targets 'in' ~ disjunction ('if' disjunction )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ForIfClause309Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ForIfClause312Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForIfClause309Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Async(subElement,.addedElement)  && ..addKeyword(subElement,"FOR")  && ..StarTargets(subElement,.addedElement)  && ..addKeyword(subElement,"IN")  && 1 /* force means? */ && ..Disjunction(subElement,.addedElement)  && ..ForIfClause310RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ForIfClause310RepZero">
<Description>
 ('if' disjunction )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..ForIfClause311Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ForIfClause311Sub">
<Description>
'if' disjunction</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IF")  && ..Disjunction(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForIfClause312Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"FOR")  && ..StarTargets(subElement,.addedElement)  && ..addKeyword(subElement,"IN")  && 1 /* force means? */ && ..Disjunction(subElement,.addedElement)  && ..ForIfClause313RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ForIfClause313RepZero">
<Description>
 ('if' disjunction )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..ForIfClause314Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ForIfClause314Sub">
<Description>
'if' disjunction</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IF")  && ..Disjunction(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForIfClauses">
<Description>
 for_if_clauses: | for_if_clause+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ForIfClauses308RepOne(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForIfClauses308RepOne">
<Description>
 for_if_clause+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ForIfClause(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ForStmt">
<Description>
 for_stmt: | 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_block] | ASYNC 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_block]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ForStmt106Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ForStmt107Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ForStmt106Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"FOR")  && ..StarTargets(subElement,.addedElement)  && ..addKeyword(subElement,"IN")  && 1 /* force means? */ && ..StarExpressions(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && $S(..TypeComment(subElement,.addedElement) :1,1:1) && ..Block(subElement,.addedElement)  && $S(..ElseBlock(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ForStmt107Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Async(subElement,.addedElement)  && ..addKeyword(subElement,"FOR")  && ..StarTargets(subElement,.addedElement)  && ..addKeyword(subElement,"IN")  && 1 /* force means? */ && ..StarExpressions(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && $S(..TypeComment(subElement,.addedElement) :1,1:1) && ..Block(subElement,.addedElement)  && $S(..ElseBlock(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Fstring">
<Description>
 fstring: | FSTRING_START fstring_middle* FSTRING_END</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Fstring297Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Fstring297Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..FstringStart(subElement,.addedElement)  && ..Fstring298RepZero(subElement,.addedElement)  && ..FstringEnd(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Fstring298RepZero">
<Description>
 fstring_middle*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..FstringMiddle(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="FstringConversion">
<Description>
 fstring_conversion: | "!" NAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..FstringConversion294Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FstringConversion294Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"!")  && ..Name(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="FstringEnd">
<Description>
 FSTRING_END : 'code fstring_end'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"code fstring_end")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FstringFormatSpec">
<Description>
 fstring_format_spec: | FSTRING_MIDDLE | fstring_replacement_field</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..FstringMiddle(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..FstringReplacementField(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FstringFullFormatSpec">
<Description>
 fstring_full_format_spec: | ':' fstring_format_spec*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..FstringFullFormatSpec295Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FstringFullFormatSpec295Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,":")  && ..FstringFullFormatSpec296RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="FstringFullFormatSpec296RepZero">
<Description>
 fstring_format_spec*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..FstringFormatSpec(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="FstringMiddle">
<Description>
 fstring_middle: | fstring_replacement_field | FSTRING_MIDDLE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..FstringMiddle291Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FstringMiddle291Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..FstringReplacementField(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..FstringMiddle(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FstringReplacementField">
<Description>
 fstring_replacement_field: | '{' (yield_expr | star_expressions) '='? [fstring_conversion] [fstring_full_format_spec] '}'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..FstringReplacementField292Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FstringReplacementField292Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"{")  && ..FstringReplacementField293Sub(subElement,.addedElement)  && $s(..addPunctuation(subElement,"=") :1,1:1)  && $S(..FstringConversion(subElement,.addedElement) :1,1:1) && $S(..FstringFullFormatSpec(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,"}")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="FstringReplacementField293Sub">
<Description>
yield_expr | star_expressions</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..YieldExpr(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StarExpressions(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FstringStart">
<Description>
 FSTRING_START : 'code fstring_start'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"code fstring_start")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FuncType">
<Description><![CDATA[
 func_type: '(' [type_expressions] ')' '->' expression NEWLINE* ENDMARKER]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"(")  && $S(..TypeExpressions(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,")")  && ..addPunctuation(subElement,"->")  && ..Expression(subElement,.addedElement)  && ..FuncType2RepZero(subElement,.addedElement)  && ..Endmarker(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FuncType2RepZero">
<Description>
 NEWLINE*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..Newline(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="FuncTypeComment">
<Description><![CDATA[
 func_type_comment: | NEWLINE TYPE_COMMENT &(NEWLINE INDENT) | TYPE_COMMENT]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..FuncTypeComment403Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TypeComment(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FuncTypeComment403Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Newline(subElement,.addedElement)  && ..TypeComment(subElement,.addedElement)  && ..FuncTypeComment404Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="FuncTypeComment404Peek">
<Description><![CDATA[
 &(NEWLINE INDENT)]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :(NEWLINE INDENT)
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..FuncTypeComment405Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FuncTypeComment405Sub">
<Description>
NEWLINE INDENT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Newline(subElement,.addedElement)  && ..Indent(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionDef">
<Description>
 function_def: | decorators function_def_raw | function_def_raw</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..FunctionDef53Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..FunctionDefRaw(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionDef53Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Decorators(subElement,.addedElement)  && ..FunctionDefRaw(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="FunctionDefRaw">
<Description><![CDATA[
 function_def_raw: | 'def' NAME [type_params] '(' [params] ')' ['->' expression ] ':' [func_type_comment] block | ASYNC 'def' NAME [type_params] '(' [params] ')' ['->' expression ] ':' [func_type_comment] block]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..FunctionDefRaw54Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..FunctionDefRaw56Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionDefRaw54Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"DEF")  && ..Name(subElement,.addedElement)  && $S(..TypeParams(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,"(")  && $S(..Params(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,")")  && ..FunctionDefRaw55OptGrp(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && $S(..FuncTypeComment(subElement,.addedElement) :1,1:1) && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="FunctionDefRaw55OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"->")  && ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FunctionDefRaw56Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Async(subElement,.addedElement)  && ..addKeyword(subElement,"DEF")  && ..Name(subElement,.addedElement)  && $S(..TypeParams(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,"(")  && $S(..Params(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,")")  && ..FunctionDefRaw57OptGrp(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && $S(..FuncTypeComment(subElement,.addedElement) :1,1:1) && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="FunctionDefRaw57OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"->")  && ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Genexp">
<Description>
 genexp: | '(' ( assignment_expression | expression !':=') for_if_clauses ')'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Genexp317Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Genexp317Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"(")  && ..Genexp318Sub(subElement,.addedElement)  && ..ForIfClauses(subElement,.addedElement)  && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Genexp318Sub">
<Description>
 assignment_expression | expression !':='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AssignmentExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Genexp319Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Genexp319Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Expression(subElement,.addedElement)  && ..Genexp320Not(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Genexp320Not">
<Description>
':='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":=")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalStmt">
<Description>
 global_stmt: 'global' ','.NAME+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"GLOBAL")  && ..GlobalStmt24RepSep(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GlobalStmt24RepSep">
<Description>
 ','.NAME+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..Name(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..Name(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Group">
<Description>
 group: | '(' (yield_expr | named_expression) ')'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Group252Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Group252Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"(")  && ..Group253Sub(subElement,.addedElement)  && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Group253Sub">
<Description>
yield_expr | named_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..YieldExpr(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NamedExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GroupPattern">
<Description>
 group_pattern: | '(' pattern ')'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..GroupPattern154Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GroupPattern154Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"(")  && ..Pattern(subElement,.addedElement)  && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="GtBitwiseOr">
<Description><![CDATA[
 gt_bitwise_or: '>' bitwise_or]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,">")  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GteBitwiseOr">
<Description><![CDATA[
 gte_bitwise_or: '>=' bitwise_or]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,">=")  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Guard">
<Description>
 guard: 'if' named_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"IF")  && ..NamedExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IfStmt">
<Description>
 if_stmt: | 'if' named_expression ':' block elif_stmt | 'if' named_expression ':' block [else_block]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..IfStmt99Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..IfStmt100Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IfStmt100Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"IF")  && ..NamedExpression(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  && $S(..ElseBlock(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="IfStmt99Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"IF")  && ..NamedExpression(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  && ..ElifStmt(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ImaginaryNumber">
<Description>
 imaginary_number: | NUMBER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Number(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFrom">
<Description>
 import_from: | 'from' ('.' | '...')* dotted_name 'import' import_from_targets | 'from' ('.' | '...')+ 'import' import_from_targets</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ImportFrom30Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ImportFrom33Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFrom30Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"FROM")  && ..ImportFrom31RepZero(subElement,.addedElement)  && ..DottedName(subElement,.addedElement)  && ..addKeyword(subElement,"IMPORT")  && ..ImportFromTargets(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ImportFrom31RepZero">
<Description>
 ('.' | '...')*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..ImportFrom32Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFrom32Sub">
<Description>
'.' | '...'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"...")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFrom33Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"FROM")  && ..ImportFrom34RepOne(subElement,.addedElement)  && ..addKeyword(subElement,"IMPORT")  && ..ImportFromTargets(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ImportFrom34RepOne">
<Description>
 ('.' | '...')+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ImportFrom35Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFrom35Sub">
<Description>
'.' | '...'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"...")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFromAsName">
<Description>
 import_from_as_name: | NAME ['as' NAME ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ImportFromAsName40Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFromAsName40Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Name(subElement,.addedElement)  && ..ImportFromAsName41OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ImportFromAsName41OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  && ..Name(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFromAsNames">
<Description>
 import_from_as_names: | ','.import_from_as_name+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ImportFromAsNames39RepSep(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFromAsNames39RepSep">
<Description>
 ','.import_from_as_name+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..ImportFromAsName(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..ImportFromAsName(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFromTargets">
<Description>
 import_from_targets: | '(' import_from_as_names [','] ')' | import_from_as_names !',' | '*'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ImportFromTargets36Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ImportFromTargets37Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"*")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportFromTargets36Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"(")  && ..ImportFromAsNames(subElement,.addedElement)  && $S(..addPunctuation(subElement,",") :1,1:1) && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ImportFromTargets37Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..ImportFromAsNames(subElement,.addedElement)  && ..ImportFromTargets38Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ImportFromTargets38Not">
<Description>
','</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportName">
<Description>
 import_name: 'import' dotted_as_names</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"IMPORT")  && ..DottedAsNames(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImportStmt">
<Description>
 import_stmt: | import_name | import_from</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ImportName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ImportFrom(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InBitwiseOr">
<Description>
 in_bitwise_or: 'in' bitwise_or</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"IN")  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Indent">
<Description>
 INDENT : 'code indent'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"code indent")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Interactive">
<Description>
 interactive: statement_newline</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StatementNewline(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InvalidDefault">
<Description>
 invalid_default : 'code invalid_default'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"code invalid_default")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Inversion">
<Description>
 inversion: | 'not' inversion | comparison</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Inversion206Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Inversion206Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..Inversion207Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Comparison(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Inversion207Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NOT")  && ..Inversion(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IsBitwiseOr">
<Description>
 is_bitwise_or: 'is' bitwise_or</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"IS")  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IsnotBitwiseOr">
<Description>
 isnot_bitwise_or: 'is' 'not' bitwise_or</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"IS")  && ..addKeyword(subElement,"NOT")  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ItemsPattern">
<Description>
 items_pattern: | ','.key_value_pattern+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ItemsPattern166RepSep(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ItemsPattern166RepSep">
<Description>
 ','.key_value_pattern+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..KeyValuePattern(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..KeyValuePattern(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KeyValuePattern">
<Description>
 key_value_pattern: | (literal_expr | attr) ':' pattern</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..KeyValuePattern167Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KeyValuePattern167Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..KeyValuePattern168Sub(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Pattern(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="KeyValuePattern168Sub">
<Description>
literal_expr | attr</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LiteralExpr(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Attr(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KeywordPattern">
<Description>
 keyword_pattern: | NAME '=' pattern</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..KeywordPattern176Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KeywordPattern176Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Name(subElement,.addedElement)  && ..addPunctuation(subElement,"=")  && ..Pattern(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="KeywordPatterns">
<Description>
 keyword_patterns: | ','.keyword_pattern+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..KeywordPatterns175RepSep(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KeywordPatterns175RepSep">
<Description>
 ','.keyword_pattern+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..KeywordPattern(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..KeywordPattern(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Kvpair">
<Description>
 kvpair: expression ':' expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Expression(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KwargOrDoubleStarred">
<Description>
 kwarg_or_double_starred: | NAME '=' expression | '**' expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..KwargOrDoubleStarred346Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..KwargOrDoubleStarred347Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KwargOrDoubleStarred346Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Name(subElement,.addedElement)  && ..addPunctuation(subElement,"=")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="KwargOrDoubleStarred347Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"**")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="KwargOrStarred">
<Description>
 kwarg_or_starred: | NAME '=' expression | starred_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..KwargOrStarred345Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarredExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KwargOrStarred345Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Name(subElement,.addedElement)  && ..addPunctuation(subElement,"=")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Kwargs">
<Description>
 kwargs: | ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+ | ','.kwarg_or_starred+ | ','.kwarg_or_double_starred+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Kwargs339Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Kwargs342RepSep(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Kwargs343RepSep(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Kwargs339Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Kwargs340RepSep(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && ..Kwargs341RepSep(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Kwargs340RepSep">
<Description>
 ','.kwarg_or_starred+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..KwargOrStarred(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..KwargOrStarred(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Kwargs341RepSep">
<Description>
 ','.kwarg_or_double_starred+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..KwargOrDoubleStarred(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..KwargOrDoubleStarred(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Kwargs342RepSep">
<Description>
 ','.kwarg_or_starred+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..KwargOrStarred(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..KwargOrStarred(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Kwargs343RepSep">
<Description>
 ','.kwarg_or_double_starred+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..KwargOrDoubleStarred(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..KwargOrDoubleStarred(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Kwds">
<Description>
 kwds: | '**' param_no_default</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Kwds86Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Kwds86Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"**")  && ..ParamNoDefault(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaKwds">
<Description>
 lambda_kwds: | '**' lambda_param_no_default</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LambdaKwds281Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaKwds281Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"**")  && ..LambdaParamNoDefault(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaParam">
<Description>
 lambda_param: NAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Name(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParamMaybeDefault">
<Description><![CDATA[
 lambda_param_maybe_default: | lambda_param default? ',' | lambda_param default? &':']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LambdaParamMaybeDefault288Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LambdaParamMaybeDefault289Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParamMaybeDefault288Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaParam(subElement,.addedElement)  && $s(..Default(subElement,.addedElement) :1,1:1)  && ..addPunctuation(subElement,",")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaParamMaybeDefault289Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaParam(subElement,.addedElement)  && $s(..Default(subElement,.addedElement) :1,1:1)  && ..LambdaParamMaybeDefault290Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaParamMaybeDefault290Peek">
<Description><![CDATA[
 &':']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :':'
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParamNoDefault">
<Description><![CDATA[
 lambda_param_no_default: | lambda_param ',' | lambda_param &':']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LambdaParamNoDefault282Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LambdaParamNoDefault283Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParamNoDefault282Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaParam(subElement,.addedElement)  && ..addPunctuation(subElement,",")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaParamNoDefault283Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaParam(subElement,.addedElement)  && ..LambdaParamNoDefault284Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaParamNoDefault284Peek">
<Description><![CDATA[
 &':']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :':'
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParamWithDefault">
<Description><![CDATA[
 lambda_param_with_default: | lambda_param default ',' | lambda_param default &':']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LambdaParamWithDefault285Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LambdaParamWithDefault286Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParamWithDefault285Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaParam(subElement,.addedElement)  && ..Default(subElement,.addedElement)  && ..addPunctuation(subElement,",")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaParamWithDefault286Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaParam(subElement,.addedElement)  && ..Default(subElement,.addedElement)  && ..LambdaParamWithDefault287Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaParamWithDefault287Peek">
<Description><![CDATA[
 &':']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :':'
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParameters">
<Description>
 lambda_parameters: | lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* [lambda_star_etc] | lambda_slash_with_default lambda_param_with_default* [lambda_star_etc] | lambda_param_no_default+ lambda_param_with_default* [lambda_star_etc] | lambda_param_with_default+ [lambda_star_etc] | lambda_star_etc</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LambdaParameters255Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LambdaParameters258Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LambdaParameters260Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LambdaParameters263Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LambdaStarEtc(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParameters255Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaSlashNoDefault(subElement,.addedElement)  && ..LambdaParameters256RepZero(subElement,.addedElement)  && ..LambdaParameters257RepZero(subElement,.addedElement)  && $S(..LambdaStarEtc(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaParameters256RepZero">
<Description>
 lambda_param_no_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..LambdaParamNoDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParameters257RepZero">
<Description>
 lambda_param_with_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..LambdaParamWithDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParameters258Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaSlashWithDefault(subElement,.addedElement)  && ..LambdaParameters259RepZero(subElement,.addedElement)  && $S(..LambdaStarEtc(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaParameters259RepZero">
<Description>
 lambda_param_with_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..LambdaParamWithDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParameters260Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaParameters261RepOne(subElement,.addedElement)  && ..LambdaParameters262RepZero(subElement,.addedElement)  && $S(..LambdaStarEtc(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaParameters261RepOne">
<Description>
 lambda_param_no_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..LambdaParamNoDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParameters262RepZero">
<Description>
 lambda_param_with_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..LambdaParamWithDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParameters263Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaParameters264RepOne(subElement,.addedElement)  && $S(..LambdaStarEtc(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaParameters264RepOne">
<Description>
 lambda_param_with_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..LambdaParamWithDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaParams">
<Description>
 lambda_params: | lambda_parameters</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LambdaParameters(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashNoDefault">
<Description><![CDATA[
 lambda_slash_no_default: | lambda_param_no_default+ '/' ',' | lambda_param_no_default+ '/' &':']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LambdaSlashNoDefault265Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LambdaSlashNoDefault267Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashNoDefault265Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaSlashNoDefault266RepOne(subElement,.addedElement)  && ..addPunctuation(subElement,"/")  && ..addPunctuation(subElement,",")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashNoDefault266RepOne">
<Description>
 lambda_param_no_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..LambdaParamNoDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashNoDefault267Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaSlashNoDefault268RepOne(subElement,.addedElement)  && ..addPunctuation(subElement,"/")  && ..LambdaSlashNoDefault269Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashNoDefault268RepOne">
<Description>
 lambda_param_no_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..LambdaParamNoDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashNoDefault269Peek">
<Description><![CDATA[
 &':']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :':'
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashWithDefault">
<Description><![CDATA[
 lambda_slash_with_default: | lambda_param_no_default* lambda_param_with_default+ '/' ',' | lambda_param_no_default* lambda_param_with_default+ '/' &':']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LambdaSlashWithDefault270Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LambdaSlashWithDefault273Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashWithDefault270Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaSlashWithDefault271RepZero(subElement,.addedElement)  && ..LambdaSlashWithDefault272RepOne(subElement,.addedElement)  && ..addPunctuation(subElement,"/")  && ..addPunctuation(subElement,",")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashWithDefault271RepZero">
<Description>
 lambda_param_no_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..LambdaParamNoDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashWithDefault272RepOne">
<Description>
 lambda_param_with_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..LambdaParamWithDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashWithDefault273Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LambdaSlashWithDefault274RepZero(subElement,.addedElement)  && ..LambdaSlashWithDefault275RepOne(subElement,.addedElement)  && ..addPunctuation(subElement,"/")  && ..LambdaSlashWithDefault276Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashWithDefault274RepZero">
<Description>
 lambda_param_no_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..LambdaParamNoDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashWithDefault275RepOne">
<Description>
 lambda_param_with_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..LambdaParamWithDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaSlashWithDefault276Peek">
<Description><![CDATA[
 &':']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :':'
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaStarEtc">
<Description>
 lambda_star_etc: | '*' lambda_param_no_default lambda_param_maybe_default* [lambda_kwds] | '*' ',' lambda_param_maybe_default+ [lambda_kwds] | lambda_kwds</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LambdaStarEtc277Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LambdaStarEtc279Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LambdaKwds(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaStarEtc277Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..LambdaParamNoDefault(subElement,.addedElement)  && ..LambdaStarEtc278RepZero(subElement,.addedElement)  && $S(..LambdaKwds(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaStarEtc278RepZero">
<Description>
 lambda_param_maybe_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..LambdaParamMaybeDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="LambdaStarEtc279Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..addPunctuation(subElement,",")  && ..LambdaStarEtc280RepOne(subElement,.addedElement)  && $S(..LambdaKwds(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LambdaStarEtc280RepOne">
<Description>
 lambda_param_maybe_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..LambdaParamMaybeDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Lambdef">
<Description>
 lambdef: | 'lambda' [lambda_params] ':' expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Lambdef254Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Lambdef254Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"LAMBDA")  && $S(..LambdaParams(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,":")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="List">
<Description>
 list: | '[' [star_named_expressions] ']'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..List302Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="List302Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"[")  && $S(..StarNamedExpressions(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,"]")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Listcomp">
<Description>
 listcomp: | '[' named_expression for_if_clauses ']'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Listcomp315Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Listcomp315Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"[")  && ..NamedExpression(subElement,.addedElement)  && ..ForIfClauses(subElement,.addedElement)  && ..addPunctuation(subElement,"]")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LiteralExpr">
<Description>
 literal_expr: | signed_number !('+' | '-') | complex_number | strings | 'None' | 'True' | 'False'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LiteralExpr139Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ComplexNumber(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Strings(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NONE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TRUE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FALSE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LiteralExpr139Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SignedNumber(subElement,.addedElement)  && ..LiteralExpr140Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LiteralExpr140Not">
<Description>
('+' | '-')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LiteralExpr141Sub(subElement,.addedElement)  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LiteralExpr141Sub">
<Description>
'+' | '-'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LiteralPattern">
<Description>
 literal_pattern: | signed_number !('+' | '-') | complex_number | strings | 'None' | 'True' | 'False'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LiteralPattern136Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ComplexNumber(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Strings(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NONE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TRUE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FALSE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LiteralPattern136Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SignedNumber(subElement,.addedElement)  && ..LiteralPattern137Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LiteralPattern137Not">
<Description>
('+' | '-')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LiteralPattern138Sub(subElement,.addedElement)  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LiteralPattern138Sub">
<Description>
'+' | '-'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LtBitwiseOr">
<Description><![CDATA[
 lt_bitwise_or: '<' bitwise_or]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"<")  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LteBitwiseOr">
<Description><![CDATA[
 lte_bitwise_or: '<=' bitwise_or]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"<=")  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MappingPattern">
<Description>
 mapping_pattern: | '{' '}' | '{' double_star_pattern ','? '}' | '{' items_pattern ',' double_star_pattern ','? '}' | '{' items_pattern ','? '}'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..MappingPattern162Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..MappingPattern163Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..MappingPattern164Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..MappingPattern165Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MappingPattern162Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"{")  && ..addPunctuation(subElement,"}")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="MappingPattern163Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"{")  && ..DoubleStarPattern(subElement,.addedElement)  && $s(..addPunctuation(subElement,",") :1,1:1)  && ..addPunctuation(subElement,"}")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="MappingPattern164Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"{")  && ..ItemsPattern(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && ..DoubleStarPattern(subElement,.addedElement)  && $s(..addPunctuation(subElement,",") :1,1:1)  && ..addPunctuation(subElement,"}")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="MappingPattern165Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"{")  && ..ItemsPattern(subElement,.addedElement)  && $s(..addPunctuation(subElement,",") :1,1:1)  && ..addPunctuation(subElement,"}")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="MatchStmt">
<Description>
 match_stmt: | "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..MatchStmt130Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MatchStmt130Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"MATCH")  && ..SubjectExpr(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Newline(subElement,.addedElement)  && ..Indent(subElement,.addedElement)  && ..MatchStmt131RepOne(subElement,.addedElement)  && ..Dedent(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="MatchStmt131RepOne">
<Description>
 case_block+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CaseBlock(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="MaybeSequencePattern">
<Description>
 maybe_sequence_pattern: | ','.maybe_star_pattern+ ','?</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..MaybeSequencePattern158Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MaybeSequencePattern158Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..MaybeSequencePattern159RepSep(subElement,.addedElement)  && $s(..addPunctuation(subElement,",") :1,1:1)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="MaybeSequencePattern159RepSep">
<Description>
 ','.maybe_star_pattern+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..MaybeStarPattern(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..MaybeStarPattern(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MaybeStarPattern">
<Description>
 maybe_star_pattern: | star_pattern | pattern</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StarPattern(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Pattern(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Name">
<Description>
 NAME : 'code name'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"code name")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NameOrAttr">
<Description>
 name_or_attr: | attr | NAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Attr(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Name(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NamedExpression">
<Description>
 named_expression: | assignment_expression | expression !':='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AssignmentExpression(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NamedExpression198Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NamedExpression198Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Expression(subElement,.addedElement)  && ..NamedExpression199Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="NamedExpression199Not">
<Description>
':='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":=")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Newline">
<Description>
 NEWLINE : 'code newline'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"code newline")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NonlocalStmt">
<Description>
 nonlocal_stmt: 'nonlocal' ','.NAME+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"NONLOCAL")  && ..NonlocalStmt25RepSep(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NonlocalStmt25RepSep">
<Description>
 ','.NAME+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..Name(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..Name(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NoteqBitwiseOr">
<Description>
 noteq_bitwise_or: | ('!=' ) bitwise_or</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..NoteqBitwiseOr210Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NoteqBitwiseOr210Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..NoteqBitwiseOr211Sub(subElement,.addedElement)  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="NoteqBitwiseOr211Sub">
<Description>
'!='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"!=")  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="NotinBitwiseOr">
<Description>
 notin_bitwise_or: 'not' 'in' bitwise_or</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"NOT")  && ..addKeyword(subElement,"IN")  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number">
<Description>
 NUMBER : 'code number'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"code number")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenSequencePattern">
<Description>
 open_sequence_pattern: | maybe_star_pattern ',' maybe_sequence_pattern?</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..OpenSequencePattern157Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenSequencePattern157Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..MaybeStarPattern(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && $s(..MaybeSequencePattern(subElement,.addedElement) :1,1:1)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="OrPattern">
<Description>
 or_pattern: | '|'.closed_pattern+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..OrPattern135RepSep(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OrPattern135RepSep">
<Description>
 '|'.closed_pattern+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..ClosedPattern(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,"|")  && ..ClosedPattern(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Param">
<Description>
 param: NAME annotation?</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Name(subElement,.addedElement)  && $s(..Annotation(subElement,.addedElement) :1,1:1)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParamMaybeDefault">
<Description><![CDATA[
 param_maybe_default: | param default? ',' TYPE_COMMENT? | param default? TYPE_COMMENT? &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ParamMaybeDefault96Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ParamMaybeDefault97Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParamMaybeDefault96Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Param(subElement,.addedElement)  && $s(..Default(subElement,.addedElement) :1,1:1)  && ..addPunctuation(subElement,",")  && $s(..TypeComment(subElement,.addedElement) :1,1:1)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ParamMaybeDefault97Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Param(subElement,.addedElement)  && $s(..Default(subElement,.addedElement) :1,1:1)  && $s(..TypeComment(subElement,.addedElement) :1,1:1)  && ..ParamMaybeDefault98Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ParamMaybeDefault98Peek">
<Description><![CDATA[
 &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :')'
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,")")  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParamNoDefault">
<Description><![CDATA[
 param_no_default: | param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ParamNoDefault87Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ParamNoDefault88Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParamNoDefault87Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Param(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && $s(..TypeComment(subElement,.addedElement) :1,1:1)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ParamNoDefault88Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Param(subElement,.addedElement)  && $s(..TypeComment(subElement,.addedElement) :1,1:1)  && ..ParamNoDefault89Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ParamNoDefault89Peek">
<Description><![CDATA[
 &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :')'
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,")")  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParamNoDefaultStarAnnotation">
<Description><![CDATA[
 param_no_default_star_annotation: | param_star_annotation ',' TYPE_COMMENT? | param_star_annotation TYPE_COMMENT? &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ParamNoDefaultStarAnnotation90Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ParamNoDefaultStarAnnotation91Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParamNoDefaultStarAnnotation90Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..ParamStarAnnotation(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && $s(..TypeComment(subElement,.addedElement) :1,1:1)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ParamNoDefaultStarAnnotation91Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..ParamStarAnnotation(subElement,.addedElement)  && $s(..TypeComment(subElement,.addedElement) :1,1:1)  && ..ParamNoDefaultStarAnnotation92Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ParamNoDefaultStarAnnotation92Peek">
<Description><![CDATA[
 &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :')'
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,")")  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParamStarAnnotation">
<Description>
 param_star_annotation: NAME star_annotation</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Name(subElement,.addedElement)  && ..StarAnnotation(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParamWithDefault">
<Description><![CDATA[
 param_with_default: | param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ParamWithDefault93Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ParamWithDefault94Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParamWithDefault93Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Param(subElement,.addedElement)  && ..Default(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && $s(..TypeComment(subElement,.addedElement) :1,1:1)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ParamWithDefault94Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Param(subElement,.addedElement)  && ..Default(subElement,.addedElement)  && $s(..TypeComment(subElement,.addedElement) :1,1:1)  && ..ParamWithDefault95Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ParamWithDefault95Peek">
<Description><![CDATA[
 &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :')'
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,")")  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Parameters">
<Description>
 parameters: | slash_no_default param_no_default* param_with_default* [star_etc] | slash_with_default param_with_default* [star_etc] | param_no_default+ param_with_default* [star_etc] | param_with_default+ [star_etc] | star_etc</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Parameters58Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Parameters61Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Parameters63Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Parameters66Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarEtc(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Parameters58Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SlashNoDefault(subElement,.addedElement)  && ..Parameters59RepZero(subElement,.addedElement)  && ..Parameters60RepZero(subElement,.addedElement)  && $S(..StarEtc(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Parameters59RepZero">
<Description>
 param_no_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..ParamNoDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Parameters60RepZero">
<Description>
 param_with_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..ParamWithDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Parameters61Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SlashWithDefault(subElement,.addedElement)  && ..Parameters62RepZero(subElement,.addedElement)  && $S(..StarEtc(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Parameters62RepZero">
<Description>
 param_with_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..ParamWithDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Parameters63Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Parameters64RepOne(subElement,.addedElement)  && ..Parameters65RepZero(subElement,.addedElement)  && $S(..StarEtc(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Parameters64RepOne">
<Description>
 param_no_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ParamNoDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Parameters65RepZero">
<Description>
 param_with_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..ParamWithDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Parameters66Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Parameters67RepOne(subElement,.addedElement)  && $S(..StarEtc(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Parameters67RepOne">
<Description>
 param_with_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ParamWithDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Params">
<Description>
 params: | parameters</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Parameters(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Pattern">
<Description>
 pattern: | as_pattern | or_pattern</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AsPattern(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..OrPattern(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternCaptureTarget">
<Description>
 pattern_capture_target: | !"_" NAME !('.' | '(' | '=')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..PatternCaptureTarget146Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternCaptureTarget146Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..PatternCaptureTarget147Not(subElement,.addedElement)  && ..Name(subElement,.addedElement)  && ..PatternCaptureTarget148Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="PatternCaptureTarget147Not">
<Description>
"_"</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"_")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternCaptureTarget148Not">
<Description>
('.' | '(' | '=')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..PatternCaptureTarget149Sub(subElement,.addedElement)  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PatternCaptureTarget149Sub">
<Description>
'.' | '(' | '='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"(")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"=")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Patterns">
<Description>
 patterns: | open_sequence_pattern | pattern</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..OpenSequencePattern(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Pattern(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PositionalPatterns">
<Description>
 positional_patterns: | ','.pattern+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..PositionalPatterns174RepSep(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PositionalPatterns174RepSep">
<Description>
 ','.pattern+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..Pattern(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..Pattern(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Power">
<Description>
 power: | await_primary '**' factor | await_primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Power234Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..AwaitPrimary(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Power234Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..AwaitPrimary(subElement,.addedElement)  && ..addPunctuation(subElement,"**")  && ..Factor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Primary">
<Description>
 primary: | primary '.' NAME | primary genexp | primary '(' [arguments] ')' | primary '[' slices ']' | atom</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Primary236Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary236Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..Primary237Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary238Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary239Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Primary240Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Atom(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary237Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Primary(subElement,.addedElement)  && ..addPunctuation(subElement,".")  && ..Name(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary238Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Primary(subElement,.addedElement)  && ..Genexp(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary239Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Primary(subElement,.addedElement)  && ..addPunctuation(subElement,"(")  && $S(..Arguments(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,")")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Primary240Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Primary(subElement,.addedElement)  && ..addPunctuation(subElement,"[")  && ..Slices(subElement,.addedElement)  && ..addPunctuation(subElement,"]")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RaiseStmt">
<Description>
 raise_stmt: | 'raise' expression ['from' expression ] | 'raise'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RaiseStmt22Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"RAISE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RaiseStmt22Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"RAISE")  && ..Expression(subElement,.addedElement)  && ..RaiseStmt23OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="RaiseStmt23OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FROM")  && ..Expression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RealNumber">
<Description>
 real_number: | NUMBER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Number(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReturnStmt">
<Description>
 return_stmt: | 'return' [star_expressions]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ReturnStmt21Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReturnStmt21Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"RETURN")  && $S(..StarExpressions(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SequencePattern">
<Description>
 sequence_pattern: | '[' maybe_sequence_pattern? ']' | '(' open_sequence_pattern? ')'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SequencePattern155Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SequencePattern156Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SequencePattern155Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"[")  && $s(..MaybeSequencePattern(subElement,.addedElement) :1,1:1)  && ..addPunctuation(subElement,"]")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SequencePattern156Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"(")  && $s(..OpenSequencePattern(subElement,.addedElement) :1,1:1)  && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Set">
<Description>
 set: '{' star_named_expressions '}'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"{")  && ..StarNamedExpressions(subElement,.addedElement)  && ..addPunctuation(subElement,"}")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Setcomp">
<Description>
 setcomp: | '{' named_expression for_if_clauses '}'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Setcomp316Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Setcomp316Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"{")  && ..NamedExpression(subElement,.addedElement)  && ..ForIfClauses(subElement,.addedElement)  && ..addPunctuation(subElement,"}")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ShiftExpr">
<Description><![CDATA[
 shift_expr: | shift_expr '<<' sum | shift_expr '>>' sum | sum]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..ShiftExpr218Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ShiftExpr218Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..ShiftExpr219Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ShiftExpr220Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Sum(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ShiftExpr219Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ShiftExpr(subElement,.addedElement)  && ..addPunctuation(subElement,"<<")  && ..Sum(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ShiftExpr220Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ShiftExpr(subElement,.addedElement)  && ..addPunctuation(subElement,">>")  && ..Sum(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SignedNumber">
<Description>
 signed_number: | NUMBER | '-' NUMBER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Number(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SignedNumber144Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SignedNumber144Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"-")  && ..Number(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SignedRealNumber">
<Description>
 signed_real_number: | real_number | '-' real_number</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RealNumber(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SignedRealNumber145Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SignedRealNumber145Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"-")  && ..RealNumber(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SimpleStmt">
<Description>
 simple_stmt: | assignment | type_alias | star_expressions | return_stmt | import_stmt | raise_stmt | 'pass' | del_stmt | yield_stmt | assert_stmt | 'break' | 'continue' | global_stmt | nonlocal_stmt</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Assignment(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TypeAlias(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarExpressions(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ReturnStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ImportStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..RaiseStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PASS")  {
			set done=1 ; or
		} elseif ..DelStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..YieldStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..AssertStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"BREAK")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CONTINUE")  {
			set done=1 ; or
		} elseif ..GlobalStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NonlocalStmt(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleStmts">
<Description>
 simple_stmts: | simple_stmt !';' NEWLINE | ';'.simple_stmt+ [';'] NEWLINE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleStmts5Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SimpleStmts7Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleStmts5Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SimpleStmt(subElement,.addedElement)  && ..SimpleStmts6Not(subElement,.addedElement)  && ..Newline(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SimpleStmts6Not">
<Description>
';'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,";")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleStmts7Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SimpleStmts8RepSep(subElement,.addedElement)  && $S(..addPunctuation(subElement,";") :1,1:1) && ..Newline(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SimpleStmts8RepSep">
<Description>
 ';'.simple_stmt+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..SimpleStmt(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,";")  && ..SimpleStmt(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SingleSubscriptAttributeTarget">
<Description>
 single_subscript_attribute_target: | t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SingleSubscriptAttributeTarget370Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SingleSubscriptAttributeTarget372Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SingleSubscriptAttributeTarget370Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..TPrimary(subElement,.addedElement)  && ..addPunctuation(subElement,".")  && ..Name(subElement,.addedElement)  && ..SingleSubscriptAttributeTarget371Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SingleSubscriptAttributeTarget371Not">
<Description>
t_lookahead</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TLookahead(subElement,.addedElement)  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SingleSubscriptAttributeTarget372Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..TPrimary(subElement,.addedElement)  && ..addPunctuation(subElement,"[")  && ..Slices(subElement,.addedElement)  && ..addPunctuation(subElement,"]")  && ..SingleSubscriptAttributeTarget373Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SingleSubscriptAttributeTarget373Not">
<Description>
t_lookahead</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TLookahead(subElement,.addedElement)  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SingleTarget">
<Description>
 single_target: | single_subscript_attribute_target | NAME | '(' single_target ')'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..SingleTarget368Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SingleTarget368Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..SingleSubscriptAttributeTarget(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Name(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SingleTarget369Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SingleTarget369Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  && ..SingleTarget(subElement,.addedElement)  && ..addPunctuation(subElement,")")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SlashNoDefault">
<Description><![CDATA[
 slash_no_default: | param_no_default+ '/' ',' | param_no_default+ '/' &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SlashNoDefault68Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SlashNoDefault70Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SlashNoDefault68Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SlashNoDefault69RepOne(subElement,.addedElement)  && ..addPunctuation(subElement,"/")  && ..addPunctuation(subElement,",")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SlashNoDefault69RepOne">
<Description>
 param_no_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ParamNoDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SlashNoDefault70Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SlashNoDefault71RepOne(subElement,.addedElement)  && ..addPunctuation(subElement,"/")  && ..SlashNoDefault72Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SlashNoDefault71RepOne">
<Description>
 param_no_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ParamNoDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SlashNoDefault72Peek">
<Description><![CDATA[
 &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :')'
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,")")  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SlashWithDefault">
<Description><![CDATA[
 slash_with_default: | param_no_default* param_with_default+ '/' ',' | param_no_default* param_with_default+ '/' &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SlashWithDefault73Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SlashWithDefault76Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SlashWithDefault73Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SlashWithDefault74RepZero(subElement,.addedElement)  && ..SlashWithDefault75RepOne(subElement,.addedElement)  && ..addPunctuation(subElement,"/")  && ..addPunctuation(subElement,",")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SlashWithDefault74RepZero">
<Description>
 param_no_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..ParamNoDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SlashWithDefault75RepOne">
<Description>
 param_with_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ParamWithDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SlashWithDefault76Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SlashWithDefault77RepZero(subElement,.addedElement)  && ..SlashWithDefault78RepOne(subElement,.addedElement)  && ..addPunctuation(subElement,"/")  && ..SlashWithDefault79Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SlashWithDefault77RepZero">
<Description>
 param_no_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..ParamNoDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SlashWithDefault78RepOne">
<Description>
 param_with_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ParamWithDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SlashWithDefault79Peek">
<Description><![CDATA[
 &')']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :')'
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,")")  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Slice">
<Description>
 slice: | [expression] ':' [expression] [':' [expression] ] | named_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Slice247Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NamedExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Slice247Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if $S(..Expression(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,":")  && $S(..Expression(subElement,.addedElement) :1,1:1) && ..Slice248OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Slice248OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  && $S(..Expression(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Slices">
<Description>
 slices: | slice !',' | ','.(slice | starred_expression)+ [',']</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Slices241Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Slices243Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Slices241Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Slice(subElement,.addedElement)  && ..Slices242Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Slices242Not">
<Description>
','</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Slices243Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Slices244RepSep(subElement,.addedElement)  && $S(..addPunctuation(subElement,",") :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Slices244RepSep">
<Description>
 ','.(slice | starred_expression)+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..Slices245Sub(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..Slices246Sub(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Slices245Sub">
<Description>
slice | starred_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Slice(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StarredExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Slices246Sub">
<Description>
slice | starred_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Slice(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StarredExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarAnnotation">
<Description>
 star_annotation: ':' star_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,":")  && ..StarExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarAtom">
<Description>
 star_atom: | NAME | '(' target_with_star_atom ')' | '(' [star_targets_tuple_seq] ')' | '[' [star_targets_list_seq] ']'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Name(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarAtom365Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarAtom366Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarAtom367Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarAtom365Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"(")  && ..TargetWithStarAtom(subElement,.addedElement)  && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarAtom366Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"(")  && $S(..StarTargetsTupleSeq(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarAtom367Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"[")  && $S(..StarTargetsListSeq(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,"]")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarEtc">
<Description>
 star_etc: | '*' param_no_default param_maybe_default* [kwds] | '*' param_no_default_star_annotation param_maybe_default* [kwds] | '*' ',' param_maybe_default+ [kwds] | kwds</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StarEtc80Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarEtc82Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarEtc84Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Kwds(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarEtc80Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..ParamNoDefault(subElement,.addedElement)  && ..StarEtc81RepZero(subElement,.addedElement)  && $S(..Kwds(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarEtc81RepZero">
<Description>
 param_maybe_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..ParamMaybeDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StarEtc82Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..ParamNoDefaultStarAnnotation(subElement,.addedElement)  && ..StarEtc83RepZero(subElement,.addedElement)  && $S(..Kwds(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarEtc83RepZero">
<Description>
 param_maybe_default*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..ParamMaybeDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StarEtc84Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..addPunctuation(subElement,",")  && ..StarEtc85RepOne(subElement,.addedElement)  && $S(..Kwds(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarEtc85RepOne">
<Description>
 param_maybe_default+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ParamMaybeDefault(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StarExpression">
<Description>
 star_expression: | '*' bitwise_or | expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StarExpression194Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarExpression194Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarExpressions">
<Description>
 star_expressions: | star_expression (',' star_expression )+ [','] | star_expression ',' | star_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StarExpressions190Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarExpressions193Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarExpressions190Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..StarExpression(subElement,.addedElement)  && ..StarExpressions191RepOne(subElement,.addedElement)  && $S(..addPunctuation(subElement,",") :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarExpressions191RepOne">
<Description>
 (',' star_expression )+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..StarExpressions192Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StarExpressions192Sub">
<Description>
',' star_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  && ..StarExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarExpressions193Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..StarExpression(subElement,.addedElement)  && ..addPunctuation(subElement,",")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarNamedExpression">
<Description>
 star_named_expression: | '*' bitwise_or | named_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StarNamedExpression196Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NamedExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarNamedExpression196Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..BitwiseOr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarNamedExpressions">
<Description>
 star_named_expressions: ','.star_named_expression+ [',']</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StarNamedExpressions195RepSep(subElement,.addedElement)  && $S(..addPunctuation(subElement,",") :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarNamedExpressions195RepSep">
<Description>
 ','.star_named_expression+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..StarNamedExpression(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..StarNamedExpression(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarPattern">
<Description>
 star_pattern: | '*' pattern_capture_target | '*' wildcard_pattern</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StarPattern160Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarPattern161Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarPattern160Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..PatternCaptureTarget(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarPattern161Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..WildcardPattern(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarTarget">
<Description>
 star_target: | '*' (!'*' star_target) | target_with_star_atom</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StarTarget358Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TargetWithStarAtom(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarTarget358Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..StarTarget359Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarTarget359Sub">
<Description>
!'*' star_target</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StarTarget360Not(subElement,.addedElement)  && ..StarTarget(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarTarget360Not">
<Description>
'*'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarTargets">
<Description>
 star_targets: | star_target !',' | star_target (',' star_target )* [',']</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StarTargets348Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarTargets350Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarTargets348Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..StarTarget(subElement,.addedElement)  && ..StarTargets349Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarTargets349Not">
<Description>
','</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarTargets350Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..StarTarget(subElement,.addedElement)  && ..StarTargets351RepZero(subElement,.addedElement)  && $S(..addPunctuation(subElement,",") :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarTargets351RepZero">
<Description>
 (',' star_target )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	while ..StarTargets352Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StarTargets352Sub">
<Description>
',' star_target</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  && ..StarTarget(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarTargetsListSeq">
<Description>
 star_targets_list_seq: ','.star_target+ [',']</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StarTargetsListSeq353RepSep(subElement,.addedElement)  && $S(..addPunctuation(subElement,",") :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarTargetsListSeq353RepSep">
<Description>
 ','.star_target+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..StarTarget(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..StarTarget(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarTargetsTupleSeq">
<Description>
 star_targets_tuple_seq: | star_target (',' star_target )+ [','] | star_target ','</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StarTargetsTupleSeq354Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarTargetsTupleSeq357Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarTargetsTupleSeq354Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..StarTarget(subElement,.addedElement)  && ..StarTargetsTupleSeq355RepOne(subElement,.addedElement)  && $S(..addPunctuation(subElement,",") :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarTargetsTupleSeq355RepOne">
<Description>
 (',' star_target )+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..StarTargetsTupleSeq356Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StarTargetsTupleSeq356Sub">
<Description>
',' star_target</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  && ..StarTarget(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarTargetsTupleSeq357Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..StarTarget(subElement,.addedElement)  && ..addPunctuation(subElement,",")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="StarredExpression">
<Description>
 starred_expression: | '*' expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StarredExpression344Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StarredExpression344Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Statement">
<Description>
 statement: compound_stmt | simple_stmts</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CompoundStmt(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SimpleStmts(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatementNewline">
<Description>
 statement_newline: | compound_stmt NEWLINE | simple_stmts | NEWLINE | ENDMARKER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StatementNewline4Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SimpleStmts(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Newline(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Endmarker(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatementNewline4Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..CompoundStmt(subElement,.addedElement)  && ..Newline(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Statements">
<Description>
 statements: statement+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Statements3RepOne(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Statements3RepOne">
<Description>
 statement+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Statement(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="String">
<Description>
 string: STRING</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..String299Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="String299Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..String(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Strings">
<Description>
 strings: (fstring|string)+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Strings300RepOne(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Strings300RepOne">
<Description>
 (fstring|string)+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Strings301Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Strings301Sub">
<Description>
fstring|string</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Fstring(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..String(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SubjectExpr">
<Description>
 subject_expr: | star_named_expression ',' star_named_expressions? | named_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SubjectExpr132Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NamedExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SubjectExpr132Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..StarNamedExpression(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && $s(..StarNamedExpressions(subElement,.addedElement) :1,1:1)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Sum">
<Description>
 sum: | sum '+' term | sum '-' term | term</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Sum221Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Sum221Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..Sum222Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Sum223Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Term(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Sum222Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Sum(subElement,.addedElement)  && ..addPunctuation(subElement,"+")  && ..Term(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Sum223Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Sum(subElement,.addedElement)  && ..addPunctuation(subElement,"-")  && ..Term(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TLookahead">
<Description>
 t_lookahead: '(' | '[' | '.'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"(")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"[")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,".")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TPrimary">
<Description><![CDATA[
 t_primary: | t_primary '.' NAME &t_lookahead | t_primary '[' slices ']' &t_lookahead | t_primary genexp &t_lookahead | t_primary '(' [arguments] ')' &t_lookahead | atom &t_lookahead]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..TPrimary374Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TPrimary374Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..TPrimary375Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TPrimary377Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TPrimary379Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TPrimary381Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..TPrimary383Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TPrimary375Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TPrimary(subElement,.addedElement)  && ..addPunctuation(subElement,".")  && ..Name(subElement,.addedElement)  && ..TPrimary376Peek(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TPrimary376Peek">
<Description><![CDATA[
 &t_lookahead]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :t_lookahead
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TLookahead(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TPrimary377Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TPrimary(subElement,.addedElement)  && ..addPunctuation(subElement,"[")  && ..Slices(subElement,.addedElement)  && ..addPunctuation(subElement,"]")  && ..TPrimary378Peek(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TPrimary378Peek">
<Description><![CDATA[
 &t_lookahead]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :t_lookahead
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TLookahead(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TPrimary379Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TPrimary(subElement,.addedElement)  && ..Genexp(subElement,.addedElement)  && ..TPrimary380Peek(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TPrimary380Peek">
<Description><![CDATA[
 &t_lookahead]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :t_lookahead
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TLookahead(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TPrimary381Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TPrimary(subElement,.addedElement)  && ..addPunctuation(subElement,"(")  && $S(..Arguments(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,")")  && ..TPrimary382Peek(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TPrimary382Peek">
<Description><![CDATA[
 &t_lookahead]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :t_lookahead
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TLookahead(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TPrimary383Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Atom(subElement,.addedElement)  && ..TPrimary384Peek(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TPrimary384Peek">
<Description><![CDATA[
 &t_lookahead]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :t_lookahead
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TLookahead(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TargetWithStarAtom">
<Description>
 target_with_star_atom: | t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | star_atom</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TargetWithStarAtom361Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TargetWithStarAtom363Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StarAtom(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TargetWithStarAtom361Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..TPrimary(subElement,.addedElement)  && ..addPunctuation(subElement,".")  && ..Name(subElement,.addedElement)  && ..TargetWithStarAtom362Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TargetWithStarAtom362Not">
<Description>
t_lookahead</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TLookahead(subElement,.addedElement)  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TargetWithStarAtom363Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..TPrimary(subElement,.addedElement)  && ..addPunctuation(subElement,"[")  && ..Slices(subElement,.addedElement)  && ..addPunctuation(subElement,"]")  && ..TargetWithStarAtom364Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TargetWithStarAtom364Not">
<Description>
t_lookahead</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TLookahead(subElement,.addedElement)  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term">
<Description>
 term: | term '*' factor | term '/' factor | term '//' factor | term '%' factor | term '@' factor | factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Term224Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term224Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..Term225Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Term226Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Term227Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Term228Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Term229Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term225Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Term(subElement,.addedElement)  && ..addPunctuation(subElement,"*")  && ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term226Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Term(subElement,.addedElement)  && ..addPunctuation(subElement,"/")  && ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term227Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Term(subElement,.addedElement)  && ..addPunctuation(subElement,"//")  && ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term228Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Term(subElement,.addedElement)  && ..addPunctuation(subElement,"%")  && ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term229Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Term(subElement,.addedElement)  && ..addPunctuation(subElement,"@")  && ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TryStmt">
<Description>
 try_stmt: | 'try' ':' block finally_block | 'try' ':' block except_block+ [else_block] [finally_block] | 'try' ':' block except_star_block+ [else_block] [finally_block]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TryStmt119Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TryStmt120Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TryStmt122Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TryStmt119Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"TRY")  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  && ..FinallyBlock(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TryStmt120Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"TRY")  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  && ..TryStmt121RepOne(subElement,.addedElement)  && $S(..ElseBlock(subElement,.addedElement) :1,1:1) && $S(..FinallyBlock(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TryStmt121RepOne">
<Description>
 except_block+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ExceptBlock(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="TryStmt122Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"TRY")  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  && ..TryStmt123RepOne(subElement,.addedElement)  && $S(..ElseBlock(subElement,.addedElement) :1,1:1) && $S(..FinallyBlock(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TryStmt123RepOne">
<Description>
 except_star_block+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ExceptStarBlock(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Tuple">
<Description>
 tuple: | '(' [star_named_expression ',' [star_named_expressions] ] ')'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Tuple303Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Tuple303Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"(")  && ..Tuple304OptGrp(subElement,.addedElement)  && ..addPunctuation(subElement,")")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Tuple304OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StarNamedExpression(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && $S(..StarNamedExpressions(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeAlias">
<Description>
 type_alias: | "type" NAME [type_params] '=' expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TypeAlias177Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeAlias177Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"TYPE")  && ..Name(subElement,.addedElement)  && $S(..TypeParams(subElement,.addedElement) :1,1:1) && ..addPunctuation(subElement,"=")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TypeComment">
<Description>
 TYPE_COMMENT : 'code type_comment'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"code type_comment")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeExpressions">
<Description>
 type_expressions: | ','.expression+ ',' '*' expression ',' '**' expression | ','.expression+ ',' '*' expression | ','.expression+ ',' '**' expression | '*' expression ',' '**' expression | '*' expression | '**' expression | ','.expression+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TypeExpressions393Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TypeExpressions395Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TypeExpressions397Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TypeExpressions399Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TypeExpressions400Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TypeExpressions401Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TypeExpressions402RepSep(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeExpressions393Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..TypeExpressions394RepSep(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && ..addPunctuation(subElement,"*")  && ..Expression(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && ..addPunctuation(subElement,"**")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TypeExpressions394RepSep">
<Description>
 ','.expression+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..Expression(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..Expression(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeExpressions395Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..TypeExpressions396RepSep(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && ..addPunctuation(subElement,"*")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TypeExpressions396RepSep">
<Description>
 ','.expression+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..Expression(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..Expression(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeExpressions397Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..TypeExpressions398RepSep(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && ..addPunctuation(subElement,"**")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TypeExpressions398RepSep">
<Description>
 ','.expression+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..Expression(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..Expression(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeExpressions399Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..Expression(subElement,.addedElement)  && ..addPunctuation(subElement,",")  && ..addPunctuation(subElement,"**")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TypeExpressions400Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TypeExpressions401Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"**")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TypeExpressions402RepSep">
<Description>
 ','.expression+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..Expression(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..Expression(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeParam">
<Description>
 type_param: | NAME [type_param_bound] | '*' NAME | '**' NAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TypeParam179Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TypeParam180Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TypeParam181Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeParam179Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Name(subElement,.addedElement)  && $S(..TypeParamBound(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TypeParam180Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"*")  && ..Name(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TypeParam181Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"**")  && ..Name(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TypeParamBound">
<Description>
 type_param_bound: ':' expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,":")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeParamSeq">
<Description>
 type_param_seq: ','.type_param+ [',']</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TypeParamSeq178RepSep(subElement,.addedElement)  && $S(..addPunctuation(subElement,",") :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeParamSeq178RepSep">
<Description>
 ','.type_param+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..TypeParam(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..TypeParam(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TypeParams">
<Description>
 type_params: '[' type_param_seq ']'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"[")  && ..TypeParamSeq(subElement,.addedElement)  && ..addPunctuation(subElement,"]")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ValuePattern">
<Description>
 value_pattern: | attr !('.' | '(' | '=')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValuePattern150Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ValuePattern150Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Attr(subElement,.addedElement)  && ..ValuePattern151Not(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ValuePattern151Not">
<Description>
('.' | '(' | '=')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ValuePattern152Sub(subElement,.addedElement)  { set done=1 }
	$$$BNFROLLBACK(subElement)
	if done {
		set ret=0
	} else {
		set ret=1
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ValuePattern152Sub">
<Description>
'.' | '(' | '='</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"(")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"=")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WhileStmt">
<Description>
 while_stmt: | 'while' named_expression ':' block [else_block]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..WhileStmt105Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WhileStmt105Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"WHILE")  && ..NamedExpression(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  && $S(..ElseBlock(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="WildcardPattern">
<Description>
 wildcard_pattern: | "_"</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"_")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithItem">
<Description><![CDATA[
 with_item: | expression 'as' star_target &(',' | ')' | ':') | expression]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..WithItem116Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithItem116Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Expression(subElement,.addedElement)  && ..addKeyword(subElement,"AS")  && ..StarTarget(subElement,.addedElement)  && ..WithItem117Peek(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="WithItem117Peek">
<Description><![CDATA[
 &(',' | ')' | ':')]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; ruleE=LookAheadRule :(',' | ')' | ':')
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..WithItem118Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
		$$$BNFROLLBACK(subElement)
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithItem118Sub">
<Description>
',' | ')' | ':'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,")")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,":")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithStmt">
<Description>
 with_stmt: | 'with' '(' ','.with_item+ ','? ')' ':' block | 'with' ','.with_item+ ':' [TYPE_COMMENT] block | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block | ASYNC 'with' ','.with_item+ ':' [TYPE_COMMENT] block</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..WithStmt108Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..WithStmt110Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..WithStmt112Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..WithStmt114Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithStmt108Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"WITH")  && ..addPunctuation(subElement,"(")  && ..WithStmt109RepSep(subElement,.addedElement)  && $s(..addPunctuation(subElement,",") :1,1:1)  && ..addPunctuation(subElement,")")  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="WithStmt109RepSep">
<Description>
 ','.with_item+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..WithItem(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..WithItem(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithStmt110Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"WITH")  && ..WithStmt111RepSep(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && $S(..TypeComment(subElement,.addedElement) :1,1:1) && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="WithStmt111RepSep">
<Description>
 ','.with_item+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..WithItem(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..WithItem(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithStmt112Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Async(subElement,.addedElement)  && ..addKeyword(subElement,"WITH")  && ..addPunctuation(subElement,"(")  && ..WithStmt113RepSep(subElement,.addedElement)  && $s(..addPunctuation(subElement,",") :1,1:1)  && ..addPunctuation(subElement,")")  && ..addPunctuation(subElement,":")  && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="WithStmt113RepSep">
<Description>
 ','.with_item+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..WithItem(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..WithItem(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithStmt114Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Async(subElement,.addedElement)  && ..addKeyword(subElement,"WITH")  && ..WithStmt115RepSep(subElement,.addedElement)  && ..addPunctuation(subElement,":")  && $S(..TypeComment(subElement,.addedElement) :1,1:1) && ..Block(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="WithStmt115RepSep">
<Description>
 ','.with_item+</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set done=0 ; must be at least 1
	if ..WithItem(subElement,.addedElement) {
		set done=1,ok=1 ; found 1
		do {
			$$$BNFSTART(repElement)
			set ok=(..addPunctuation(repElement,",")  && ..WithItem(repElement,.addedElement) )
			if ok {
				$$$BNFCOMMIT(repElement,subElement)
			} else {
				$$$BNFROLLBACK(repElement)
			}
		} while ok
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="YieldExpr">
<Description>
 yield_expr: | 'yield' 'from' expression | 'yield' [star_expressions]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..YieldExpr188Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..YieldExpr189Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="YieldExpr188Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"YIELD")  && ..addKeyword(subElement,"FROM")  && ..Expression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="YieldExpr189Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"YIELD")  && $S(..StarExpressions(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="YieldStmt">
<Description>
 yield_stmt: yield_expr</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..YieldExpr(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Elements.Python</ReturnType>
<Implementation><![CDATA[	quit ##class(PXW.DEV.BNF.Elements.Python).%New(Type)
]]></Implementation>
</Method>

<Parameter name="KeywordPattern">
<Default>1A.AN</Default>
</Parameter>

<Parameter name="Keywords">
<Default>AND,AS,ASSERT,ASYNC,AWAIT,BREAK,CLASS,CONTINUE,DEF,DEL,ELIF,ELSE,EXCEPT,FALSE,FINALLY,FOR,FROM,GLOBAL,IF,IMPORT,IN,IS,LAMBDA,NONE,NONLOCAL,NOT,OR,PASS,RAISE,RETURN,TRUE,TRY,WHILE,WITH,YIELD</Default>
</Parameter>
</Class>


<Class name="PXW.DEV.BNF.GEN.SQL">
<Description>
Created: 2024-10-17 15:59:23 PXW.DEV.BNF.Compilers.Compiler1</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>PXW.DEV.BNF.super</Super>
<TimeChanged>67130,57566.864808809</TimeChanged>
<TimeCreated>67125,77563.09944349</TimeCreated>

<Method name="AliasName">
<Description>
 alias_name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AnyTextUptoCloseBracket">
<Description>
 any_text_upto_close_bracket ::= 'code this'
summary values:CODE THIS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("CODE THIS",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"code this")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ApproximateNumericLiteral">
<Description>
 approximate_numeric_literal ::= mantissa 'E' exponent</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Mantissa(subElement,.addedElement)  {
		if ..addKeyword(subElement,"E")  {
			if ..Exponent(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AsClause">
<Description>
 as_clause ::= [ 'AS' ] column_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addKeyword(subElement,"AS") :1,1:1) {
		if ..ColumnName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CallCommand">
<Description>
 call_command ::= 'CALL' stored_proc_call
summary values:CALL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CALL"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CALL")  {
		if ..StoredProcCall(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterFactor">
<Description>
 character_factor ::= character_primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CharacterPrimary(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterPrimary">
<Description>
 character_primary ::= value_expression_primary | string_value_function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ValueExpressionPrimary(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StringValueFunction(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringLiteral">
<Description>
 character_string_literal ::= '"' 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)' '"'
summary values:""</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&P
	; first rule summary P
	if '(..isStringSingle("""",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"""")  {
		if ..addPunctuation(subElement,"regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)")  {
			if ..addPunctuation(subElement,"""")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterSubstringFunction">
<Description>
 character_substring_function ::= 'SUBSTRING' '(' character_value_expression ',' numeric_value_expression ',' numeric_value_expression ')'
summary values:SUBSTRING</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P&?1Rule?&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("SUBSTRING"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SUBSTRING")  {
		if ..addPunctuation(subElement,"(")  {
			if ..CharacterValueExpression(subElement,.addedElement)  {
				if ..addPunctuation(subElement,",")  {
					if ..NumericValueExpression(subElement,.addedElement)  {
						if ..addPunctuation(subElement,",")  {
							if ..NumericValueExpression(subElement,.addedElement)  {
								if ..addPunctuation(subElement,")")  {
									set done=1 ; end compileRules
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterValueExpression">
<Description>
 character_value_expression ::= concatenation | character_factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Concatenation(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CharacterFactor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterValueFunction">
<Description>
 character_value_function ::= character_substring_function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CharacterSubstringFunction(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CheckprivCommand">
<Description>
 CHECKPRIV_command ::= '%CHECKPRIV' checkpriv_objpriv [ '(' column_name ( ',' column_name)* ')' ] 'ON' table_reference
summary values:%CHECKPRIV</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?&K&?1Rule?
	; first rule summary P
	if '(..isStringSingle("%CHECKPRIV",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%CHECKPRIV")  {
		if ..CheckprivObjpriv(subElement,.addedElement)  {
			if ..CheckprivCommand70OptGrp(subElement,.addedElement)  {
				if ..addKeyword(subElement,"ON")  {
					if ..TableReference(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CheckprivCommand70OptGrp">
<Description>

summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..ColumnName(subElement,.addedElement)  {
			if ..CheckprivCommand71RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CheckprivCommand71RepZero">
<Description>
 ( ',' column_name)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..CheckprivCommand72Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CheckprivCommand72Sub">
<Description>
 ',' column_name
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ColumnName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CheckprivObjpriv">
<Description>
 checkpriv_objpriv ::= '%ALTER' | 'DELETE' | 'SELECT' | 'INSERT' | 'UPDATE' | 'EXECUTE' | 'REFERENCES'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|K|K|K|K|K|K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%ALTER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DELETE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SELECT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INSERT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"UPDATE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"EXECUTE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"REFERENCES")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CloseCommand">
<Description>
 close_command ::= 'CLOSE' cursor_name
summary values:CLOSE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("CLOSE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CLOSE")  {
		if ..CursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColList">
<Description>
 col_list ::= column_reference ( ',' column_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ColumnReference(subElement,.addedElement)  {
		if ..ColList163RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColList163RepZero">
<Description>
 ( ',' column_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ColList164Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ColList164Sub">
<Description>
 ',' column_reference
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ColumnReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColonSqlCosVariable">
<Description>
 colon_sql_cos_variable ::= ':' sql_cos_variable
summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..SqlCosVariable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnName">
<Description>
 column_name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnNameList">
<Description>
 column_name_list ::= column_name ( ',' column_name )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ColumnName(subElement,.addedElement)  {
		if ..ColumnNameList45RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnNameList45RepZero">
<Description>
 ( ',' column_name )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ColumnNameList46Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnNameList46Sub">
<Description>
 ',' column_name
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ColumnName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnReference">
<Description>
 column_reference ::= [ alias_name '.' ] column_name [column_reference_implicit]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ColumnReference169OptGrp(subElement,.addedElement)  {
		if ..ColumnName(subElement,.addedElement)  {
			if $S(..ColumnReferenceImplicit(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnReference169OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AliasName(subElement,.addedElement)  {
		if ..addPunctuation(subElement,".")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnReferenceImplicit">
<Description><![CDATA[
 column_reference_implicit ::= ('->' column_name)*]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ColumnReferenceImplicit170RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnReferenceImplicit170RepZero">
<Description><![CDATA[
 ('->' column_name)*]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ColumnReferenceImplicit171Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnReferenceImplicit171Sub">
<Description><![CDATA[
'->' column_name
summary values:->]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("->",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"->")  {
		if ..ColumnName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Concatenation">
<Description>
 concatenation ::= character_value_expression '||' character_factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CharacterValueExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"||")  {
			if ..CharacterFactor(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionDyadicop">
<Description><![CDATA[
 condition_dyadicop ::= "+" | "-" | "\\" | "/" | "<>" | ">" | "'>" | ">=" | "<" | "'<" | "<=" | "=" | "'=" | "**" | "*" | "&&" | "&" | "]]" | "[" | "'[" | "!" | "||" | "_" | "#" | "AND" | "OR" | "%STARTSWITH" | "LIKE" | 'IS']]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|K|K|P|K|K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"\\")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"/")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<>")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'>")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'<")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"**")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"&&")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"&")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"]]")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"[")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'[")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"!")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"||")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"_")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"#")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"AND")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"OR")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%STARTSWITH")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LIKE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"IS")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionExpression">
<Description>
 condition_expression ::= condition_factor ( condition_dyadicop condition_factor )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ConditionFactor(subElement,.addedElement)  {
		if ..ConditionExpression73RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionExpression73RepZero">
<Description>
 ( condition_dyadicop condition_factor )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..ConditionExpression74Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionExpression74Sub">
<Description>
 condition_dyadicop condition_factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ConditionDyadicop(subElement,.addedElement)  {
		if ..ConditionFactor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionFactor">
<Description>
 condition_factor ::= [ condition_monadicop ] condition_term</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..ConditionMonadicop(subElement,.addedElement) :1,1:1) {
		if ..ConditionTerm(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionMonadicop">
<Description>
 condition_monadicop ::= "+" | "-" | 'NOT'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NOT")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionPrimary">
<Description>
 condition_primary ::= sql_number | sql_string | sql_cos_variable | sql_special_variable | column_reference | macrocall | ( '(' subquery_specification ')' ) | ( '(' sql_expression ')' )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlNumber(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlString(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlCosVariable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlSpecialVariable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ColumnReference(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Macrocall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ConditionPrimary75Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ConditionPrimary76Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionPrimary75Sub">
<Description>
 '(' subquery_specification ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..SubquerySpecification(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionPrimary76Sub">
<Description>
 '(' sql_expression ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..SqlExpression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionTerm">
<Description>
 condition_term ::= condition_primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ConditionPrimary(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CorrelationName">
<Description>
 correlation_name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CorrelationSpecification">
<Description>
 correlation_specification ::= [ 'AS' ] correlation_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addKeyword(subElement,"AS") :1,1:1) {
		if ..CorrelationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosVariableIdentifier">
<Description>
 cos_variable_identifier ::= ':' (['{' identifier '}'] | identifier )
summary values::</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(":",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":")  {
		if ..CosVariableIdentifier188Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosVariableIdentifier188Sub">
<Description>
['{' identifier '}'] | identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosVariableIdentifier189OptGrp(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CosVariableIdentifier189OptGrp">
<Description>

summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"}")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CrossJoin">
<Description>
 cross_join ::= table_reference 'CROSS' 'JOIN' table_reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TableReference(subElement,.addedElement)  {
		if ..addKeyword(subElement,"CROSS")  {
			if ..addKeyword(subElement,"JOIN")  {
				if ..TableReference(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CursorName">
<Description>
 cursor_name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeclareCommand">
<Description>
 declare_command ::= 'DECLARE' cursor_name 'CURSOR' 'FOR' query_specification [ 'FOR' ('UPDATE' | ('READ' 'ONLY'))]
summary values:DECLARE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&K&K&?1Rule?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("DECLARE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DECLARE")  {
		if ..CursorName(subElement,.addedElement)  {
			if ..addKeyword(subElement,"CURSOR")  {
				if ..addKeyword(subElement,"FOR")  {
					if ..QuerySpecification(subElement,.addedElement)  {
						if ..DeclareCommand65OptGrp(subElement,.addedElement)  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeclareCommand65OptGrp">
<Description>

summary values:FOR</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("FOR"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FOR")  {
		if ..DeclareCommand66Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeclareCommand66Sub">
<Description>
'UPDATE' | ('READ' 'ONLY')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"UPDATE")  {
		set done=1 ; or
	} elseif ..DeclareCommand67Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeclareCommand67Sub">
<Description>
'READ' 'ONLY'
summary values:READ</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&K
	; first rule summary K
	if '(..isKeywordInList($lb("READ"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"READ")  {
		if ..addKeyword(subElement,"ONLY")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeleteCommand">
<Description>
 delete_command ::= 'DELETE' (update_keyword)* ['FROM'] direct_table [ where_clause ]
summary values:DELETE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&(?4?)*&?4?&?1Rule?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("DELETE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DELETE")  {
		if ..DeleteCommand68RepZero(subElement,.addedElement)  {
			if $S(..addKeyword(subElement,"FROM") :1,1:1) {
				if ..DirectTable(subElement,.addedElement)  {
					if $S(..WhereClause(subElement,.addedElement) :1,1:1) {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeleteCommand68RepZero">
<Description>
 (update_keyword)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..DeleteCommand69Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="DeleteCommand69Sub">
<Description>
update_keyword</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UpdateKeyword(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DerivedColumn">
<Description>
 derived_column ::= sql_expression [ as_clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlExpression(subElement,.addedElement)  {
		if $S(..AsClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DerivedColumnList">
<Description>
 derived_column_list ::= column_name_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ColumnNameList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DerivedTable">
<Description>
 derived_table ::= table_subquery [ table_as_clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TableSubquery(subElement,.addedElement)  {
		if $S(..TableAsClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DerivedTableNoalias">
<Description>
 derived_table_noalias ::= table_subquery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TableSubquery(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DirectTable">
<Description>
 direct_table ::= table_name [ table_as_clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TableName(subElement,.addedElement)  {
		if $S(..TableAsClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DirectTableNoalias">
<Description>
 direct_table_noalias ::= table_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TableName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericLiteral">
<Description>
 exact_numeric_literal ::= (unsigned_integer [ '.' [ unsigned_integer ] ] ) | ('.' unsigned_integer)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExactNumericLiteral183Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ExactNumericLiteral185Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericLiteral183Sub">
<Description>
unsigned_integer [ '.' [ unsigned_integer ] ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UnsignedInteger(subElement,.addedElement)  {
		if ..ExactNumericLiteral184OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericLiteral184OptGrp">
<Description>

summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if $S(..UnsignedInteger(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericLiteral185Sub">
<Description>
'.' unsigned_integer
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Exponent">
<Description>
 exponent ::= signed_integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SignedInteger(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Factor">
<Description>
 factor ::= [ sign ] numeric_primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Sign(subElement,.addedElement) :1,1:1) {
		if ..NumericPrimary(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FetchCommand">
<Description>
 fetch_command ::= 'FETCH' cursor_name [ select_into ]
summary values:FETCH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("FETCH"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FETCH")  {
		if ..CursorName(subElement,.addedElement)  {
			if $S(..SelectInto(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FromClause">
<Description>
 from_clause ::= 'FROM' [from_optimise_list] ( table_reference) [ ( ',' table_reference )* ] ( join )*
summary values:FROM</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?&?4?&(?4?)*
	; first rule summary K
	if '(..isKeywordInList($lb("FROM"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FROM")  {
		if $S(..FromOptimiseList(subElement,.addedElement) :1,1:1) {
			if ..FromClause18Sub(subElement,.addedElement)  {
				if $S(..FromClause19RepZero(subElement,.addedElement) :1,1:1) {
					if ..FromClause21RepZero(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FromClause18Sub">
<Description>
 table_reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TableReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FromClause19RepZero">
<Description>
 ( ',' table_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..FromClause20Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="FromClause20Sub">
<Description>
 ',' table_reference
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..TableReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FromClause21RepZero">
<Description>
 ( join )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..FromClause22Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="FromClause22Sub">
<Description>
 join</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Join(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FromOptimise">
<Description>
 from_optimise ::= ('%firsttable' [alias_name]) | '%ALLINDEX' | '%STARTTABLE' | '%INORDER' | '%FULL' | '%NOFLATTEN' | '%NOMERGE' | '%NOREDUCE' | '%NOSVSO' | '%NOTOPOPT' | '%NOUNIONOROPT' | '%PARALLEL' | ('%IGNOREINDEX' index_reference_list ) | ('%IGNOREINDICES' index_reference_list )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|P|P|P|P|P|P|P|P|P|P|P|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..FromOptimise25Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%ALLINDEX")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%STARTTABLE")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%INORDER")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%FULL")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOFLATTEN")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOMERGE")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOREDUCE")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOSVSO")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOTOPOPT")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOUNIONOROPT")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%PARALLEL")  {
		set done=1 ; or
	} elseif ..FromOptimise26Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..FromOptimise27Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FromOptimise25Sub">
<Description>
'%firsttable' [alias_name]
summary values:%FIRSTTABLE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle("%FIRSTTABLE",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%firsttable")  {
		if $S(..AliasName(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FromOptimise26Sub">
<Description>
'%IGNOREINDEX' index_reference_list
summary values:%IGNOREINDEX</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("%IGNOREINDEX",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%IGNOREINDEX")  {
		if ..IndexReferenceList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FromOptimise27Sub">
<Description>
'%IGNOREINDICES' index_reference_list
summary values:%IGNOREINDICES</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("%IGNOREINDICES",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%IGNOREINDICES")  {
		if ..IndexReferenceList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FromOptimiseList">
<Description>
 from_optimise_list ::= from_optimise ( from_optimise )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..FromOptimise(subElement,.addedElement)  {
		if ..FromOptimiseList23RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FromOptimiseList23RepZero">
<Description>
 ( from_optimise )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..FromOptimiseList24Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="FromOptimiseList24Sub">
<Description>
 from_optimise</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..FromOptimise(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GeneralLiteral">
<Description>
 general_literal ::= character_string_literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CharacterStringLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GeneralValueSpecification">
<Description>
 general_value_specification ::= cos_variable_identifier | '?' | 'USER' | 'CURRENT_USER' | 'SESSION_USER' | 'SYSTEM_USER' | 'VALUE'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|P|K|P|P|P|K
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CosVariableIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"?")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"USER")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"CURRENT_USER")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"SESSION_USER")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"SYSTEM_USER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"VALUE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GroupByClause">
<Description>
 group_by_clause ::= 'GROUP' 'BY' grouping_column_reference_list
summary values:GROUP</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("GROUP"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"GROUP")  {
		if ..addKeyword(subElement,"BY")  {
			if ..GroupingColumnReferenceList(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GroupingColumnReference">
<Description>
 grouping_column_reference ::= sql_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GroupingColumnReferenceList">
<Description>
 grouping_column_reference_list ::= grouping_column_reference ( ',' grouping_column_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..GroupingColumnReference(subElement,.addedElement)  {
		if ..GroupingColumnReferenceList37RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GroupingColumnReferenceList37RepZero">
<Description>
 ( ',' grouping_column_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..GroupingColumnReferenceList38Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="GroupingColumnReferenceList38Sub">
<Description>
 ',' grouping_column_reference
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..GroupingColumnReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HavingClause">
<Description>
 having_clause ::= 'HAVING' sql_expression
summary values:HAVING</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("HAVING"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"HAVING")  {
		if ..SqlExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<Description>
 identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'
summary values:REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("REGEXP:(((\%[A-ZA-Z0-9])|(\$[A-ZA-Z])|[A-ZA-Z])[A-ZA-Z0-9\.]*)",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexReference">
<Description>
 index_reference ::= [ table_reference_noalias '.' ] identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IndexReference30OptGrp(subElement,.addedElement)  {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexReference30OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TableReferenceNoalias(subElement,.addedElement)  {
		if ..addPunctuation(subElement,".")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexReferenceList">
<Description>
 index_reference_list ::= index_reference ( ',' index_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IndexReference(subElement,.addedElement)  {
		if ..IndexReferenceList31RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndexReferenceList31RepZero">
<Description>
 ( ',' index_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..IndexReferenceList32Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="IndexReferenceList32Sub">
<Description>
 ',' index_reference
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..IndexReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InsertCommand">
<Description>
 insert_command ::= 'INSERT' (update_keyword)* ['INTO'] direct_table insert_method
summary values:INSERT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&(?4?)*&?4?&?1Rule?&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("INSERT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INSERT")  {
		if ..InsertCommand48RepZero(subElement,.addedElement)  {
			if $S(..addKeyword(subElement,"INTO") :1,1:1) {
				if ..DirectTable(subElement,.addedElement)  {
					if ..InsertMethod(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InsertCommand48RepZero">
<Description>
 (update_keyword)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..InsertCommand49Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="InsertCommand49Sub">
<Description>
update_keyword</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UpdateKeyword(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InsertMethod">
<Description>
 insert_method ::= insert_set_list | insert_values_list | insert_multirow</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..InsertSetList(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..InsertValuesList(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..InsertMultirow(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InsertMultirow">
<Description>
 insert_multirow ::= [ update_columns ] select_command</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..UpdateColumns(subElement,.addedElement) :1,1:1) {
		if ..SelectCommand(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InsertSet">
<Description>
 insert_set ::= column_reference '=' sql_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ColumnReference(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"=")  {
			if ..SqlExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InsertSetList">
<Description>
 insert_set_list ::= 'SET' insert_set (',' insert_set)*
summary values:SET</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&(?4?)*
	; first rule summary K
	if '(..isKeywordInList($lb("SET"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SET")  {
		if ..InsertSet(subElement,.addedElement)  {
			if ..InsertSetList50RepZero(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InsertSetList50RepZero">
<Description>
 (',' insert_set)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..InsertSetList51Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="InsertSetList51Sub">
<Description>
',' insert_set
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..InsertSet(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InsertValuesList">
<Description>
 insert_values_list ::= update_columns 'VALUES' update_values</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UpdateColumns(subElement,.addedElement)  {
		if ..addKeyword(subElement,"VALUES")  {
			if ..UpdateValues(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Join">
<Description>
 join ::= [('INNER' | 'OUTER' | 'LEFT' | 'RIGHT' | 'CROSS' | 'NATURAL' |'FULL' )*] 'JOIN' table_reference [ join_on ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&K&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Join28RepZero(subElement,.addedElement) :1,1:1) {
		if ..addKeyword(subElement,"JOIN")  {
			if ..TableReference(subElement,.addedElement)  {
				if $S(..JoinOn(subElement,.addedElement) :1,1:1) {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Join28RepZero">
<Description>
('INNER' | 'OUTER' | 'LEFT' | 'RIGHT' | 'CROSS' | 'NATURAL' |'FULL' )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Join29Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Join29Sub">
<Description>
'INNER' | 'OUTER' | 'LEFT' | 'RIGHT' | 'CROSS' | 'NATURAL' |'FULL'
summary values:INNER,OUTER,LEFT,RIGHT,CROSS,NATURAL,FULL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K|K|K
	if '(..isKeywordInList($lb("INNER","OUTER","LEFT","RIGHT","CROSS","NATURAL","FULL"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"INNER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"OUTER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LEFT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"RIGHT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"CROSS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NATURAL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FULL")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="JoinColumnList">
<Description>
 join_column_list ::= column_name_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ColumnNameList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinCondition">
<Description>
 join_condition ::= 'ON' search_condition
summary values:ON</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ON"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ON")  {
		if ..SearchCondition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinOn">
<Description>
 join_on ::= 'ON' sql_expression
summary values:ON</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ON"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ON")  {
		if ..SqlExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinSpecification">
<Description>
 join_specification ::= join_condition | named_columns_join</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..JoinCondition(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NamedColumnsJoin(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinType">
<Description>
 join_type ::= 'INNER' | (outer_join_type [ 'OUTER' ])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INNER")  {
		set done=1 ; or
	} elseif ..JoinType36Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinType36Sub">
<Description>
outer_join_type [ 'OUTER' ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OuterJoinType(subElement,.addedElement)  {
		if $S(..addKeyword(subElement,"OUTER") :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinedTable">
<Description>
 joined_table ::= cross_join | qualified_join | ('(' joined_table ')')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CrossJoin(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..QualifiedJoin(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JoinedTable35Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinedTable35Sub">
<Description>
'(' joined_table ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..JoinedTable(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LengthExpression">
<Description>
 length_expression ::= 'LENGTH' '(' character_Value_expression ')'
summary values:LENGTH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("LENGTH"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"LENGTH")  {
		if ..addPunctuation(subElement,"(")  {
			if ..CharacterValueExpression(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroIdentifier">
<Description>
 macro_identifier ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameter">
<Description>
 macro_parameter ::= sql_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameterList">
<Description>
 macro_parameter_list ::= '(' [ [macro_parameter] ( ',' [macro_parameter] )* ] ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..MacroParameterList85OptGrp(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameterList85OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..MacroParameter(subElement,.addedElement) :1,1:1) {
		if ..MacroParameterList86RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameterList86RepZero">
<Description>
 ( ',' [macro_parameter] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..MacroParameterList87Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameterList87Sub">
<Description>
 ',' [macro_parameter]
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if $S(..MacroParameter(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MacroParameterText">
<Description>
 macro_parameter_text ::= '(' any_text_upto_close_bracket ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..AnyTextUptoCloseBracket(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Macrocall">
<Description>
 macrocall ::= '$$$' macro_identifier [ macro_parameter_list | macro_parameter_text ]
summary values:$$$</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&?4?
	; first rule summary P
	if '(..isStringSingle("$$$",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"$$$")  {
		if ..MacroIdentifier(subElement,.addedElement)  {
			if ..Macrocall84OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Macrocall84OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..MacroParameterList(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MacroParameterText(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Mantissa">
<Description>
 mantissa ::= exact_numeric_literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExactNumericLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NamedColumnsJoin">
<Description>
 named_columns_join ::= 'USING' '(' join_column_list ')'
summary values:USING</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("USING"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"USING")  {
		if ..addPunctuation(subElement,"(")  {
			if ..JoinColumnList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NonJoinQueryExpression">
<Description>
 non_join_query_expression ::= non_join_query_term</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NonJoinQueryTerm(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NonJoinQueryPrimary">
<Description>
 non_join_query_primary ::= simple_table | ( '(' non_join_query_expression ')' )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SimpleTable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NonJoinQueryPrimary44Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NonJoinQueryPrimary44Sub">
<Description>
 '(' non_join_query_expression ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..NonJoinQueryExpression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NonJoinQueryTerm">
<Description>
 non_join_query_term ::= non_join_query_primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NonJoinQueryPrimary(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number">
<Description>
 number ::= ('regexp:[0-9]*' [ '.' 'regexp:[0-9]+'] [ ('e' | 'E') 'regexp:[0-9]+']) | ('.' 'regexp:[0-9]+' [ ('e' | 'E') 'regexp:[0-9]+'])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number176Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Number180Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number176Sub">
<Description>
'regexp:[0-9]*' [ '.' 'regexp:[0-9]+'] [ ('e' | 'E') 'regexp:[0-9]+']
summary values:REGEXP:[0-9]*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&?4?
	; first rule summary P
	if '(..isStringSingle("REGEXP:[0-9]*",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"regexp:[0-9]*")  {
		if ..Number177OptGrp(subElement,.addedElement)  {
			if ..Number178OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number177OptGrp">
<Description>

summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..addPunctuation(subElement,"regexp:[0-9]+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number178OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number179Sub(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"regexp:[0-9]+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number179Sub">
<Description>
'e' | 'E'
summary values:E,E</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("E","E"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"E")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Number180Sub">
<Description>
'.' 'regexp:[0-9]+' [ ('e' | 'E') 'regexp:[0-9]+']
summary values:.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?4?
	; first rule summary P
	if '(..isStringSingle(".",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".")  {
		if ..addPunctuation(subElement,"regexp:[0-9]+")  {
			if ..Number181OptGrp(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number181OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number182Sub(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"regexp:[0-9]+")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Number182Sub">
<Description>
'e' | 'E'
summary values:E,E</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("E","E"),.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"E")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"E")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="NumericPrimary">
<Description>
 numeric_primary ::= value_expression_primary | numeric_value_function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ValueExpressionPrimary(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NumericValueFunction(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericValueExpression">
<Description>
 numeric_value_expression ::= term | ( numeric_value_expression '+' term ) | ( numeric_value_expression '-' term )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Term(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NumericValueExpression165Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NumericValueExpression166Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericValueExpression165Sub">
<Description>
 numeric_value_expression '+' term</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NumericValueExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"+")  {
			if ..Term(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericValueExpression166Sub">
<Description>
 numeric_value_expression '-' term</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NumericValueExpression(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"-")  {
			if ..Term(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericValueFunction">
<Description>
 numeric_value_function ::= length_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LengthExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenCommand">
<Description>
 open_command ::= 'OPEN' cursor_name
summary values:OPEN</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("OPEN"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"OPEN")  {
		if ..CursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OrderByClause">
<Description>
 order_by_clause ::= 'ORDER' 'BY' ordering_column_reference_list
summary values:ORDER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ORDER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ORDER")  {
		if ..addKeyword(subElement,"BY")  {
			if ..OrderingColumnReferenceList(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OrderingColumnReference">
<Description>
 ordering_column_reference ::= sql_expression [ 'ASC' | 'DESC']</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlExpression(subElement,.addedElement)  {
		if ..OrderingColumnReference41OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OrderingColumnReference41OptGrp">
<Description>

summary values:ASC,DESC</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("ASC","DESC"),.value)) { quit 1 /* not found is OK */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"ASC")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DESC")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=1 /* failure rollsback but returns OK */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OrderingColumnReferenceList">
<Description>
 ordering_column_reference_list ::= ordering_column_reference ( ',' ordering_column_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OrderingColumnReference(subElement,.addedElement)  {
		if ..OrderingColumnReferenceList39RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OrderingColumnReferenceList39RepZero">
<Description>
 ( ',' ordering_column_reference )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..OrderingColumnReferenceList40Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="OrderingColumnReferenceList40Sub">
<Description>
 ',' ordering_column_reference
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..OrderingColumnReference(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OuterJoinType">
<Description>
 outer_join_type ::= 'LEFT' | 'RIGHT' | 'FULL'
summary values:LEFT,RIGHT,FULL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K
	if '(..isKeywordInList($lb("LEFT","RIGHT","FULL"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"LEFT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"RIGHT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FULL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QualifiedIdentifier">
<Description>
 qualified_identifier ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QualifiedJoin">
<Description>
 qualified_join ::= table_reference [ 'NATURAL' ] [ join_type ] 'JOIN' table_reference [ join_specification ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?&K&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TableReference(subElement,.addedElement)  {
		if $S(..addKeyword(subElement,"NATURAL") :1,1:1) {
			if $S(..JoinType(subElement,.addedElement) :1,1:1) {
				if ..addKeyword(subElement,"JOIN")  {
					if ..TableReference(subElement,.addedElement)  {
						if $S(..JoinSpecification(subElement,.addedElement) :1,1:1) {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Qualifier">
<Description>
 qualifier ::= table_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TableName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QueryExpression">
<Description>
 query_expression ::= non_join_query_expression | joined_table</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NonJoinQueryExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JoinedTable(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QuerySpecification">
<Description>
 query_specification ::= [with_command ] select_command ( union select_command )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..WithCommand(subElement,.addedElement) :1,1:1) {
		if ..SelectCommand(subElement,.addedElement)  {
			if ..QuerySpecification1RepZero(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QuerySpecification1RepZero">
<Description>
 ( union select_command )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..QuerySpecification2Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="QuerySpecification2Sub">
<Description>
 union select_command</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Union(subElement,.addedElement)  {
		if ..SelectCommand(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ScalarSubquery">
<Description>
 scalar_subquery ::= subquery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Subquery(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaName">
<Description>
 schema_name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SearchCondition">
<Description>
 search_condition ::= condition_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ConditionExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectCommand">
<Description>
 select_command ::= 'SELECT' [ set_quantifier ] select_list [select_into] [ table_expression ]
summary values:SELECT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?&?1Rule?&?4?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("SELECT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SELECT")  {
		if $S(..SetQuantifier(subElement,.addedElement) :1,1:1) {
			if ..SelectList(subElement,.addedElement)  {
				if $S(..SelectInto(subElement,.addedElement) :1,1:1) {
					if $S(..TableExpression(subElement,.addedElement) :1,1:1) {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectInto">
<Description>
 select_into ::= 'INTO' select_into_variable ( ',' select_into_variable)*
summary values:INTO</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&(?4?)*
	; first rule summary K
	if '(..isKeywordInList($lb("INTO"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INTO")  {
		if ..SelectIntoVariable(subElement,.addedElement)  {
			if ..SelectInto33RepZero(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectInto33RepZero">
<Description>
 ( ',' select_into_variable)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SelectInto34Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SelectInto34Sub">
<Description>
 ',' select_into_variable
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SelectIntoVariable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectIntoVariable">
<Description>
 select_into_variable ::= [':'] sql_cos_variable</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addPunctuation(subElement,":") :1,1:1) {
		if ..SqlCosVariable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectList">
<Description>
 select_list ::= select_sublist ( ',' select_sublist )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SelectSublist(subElement,.addedElement)  {
		if ..SelectList15RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectList15RepZero">
<Description>
 ( ',' select_sublist )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SelectList16Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SelectList16Sub">
<Description>
 ',' select_sublist
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SelectSublist(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectSublist">
<Description>
 select_sublist ::= derived_column | (qualifier '.' '*')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DerivedColumn(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SelectSublist17Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectSublist17Sub">
<Description>
qualifier '.' '*'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Qualifier(subElement,.addedElement)  {
		if ..addPunctuation(subElement,".")  {
			if ..addPunctuation(subElement,"*")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetQuantifier">
<Description>
 set_quantifier ::= ( ( 'DISTINCT' ['BY' '(' sql_expression ( ',' sql_expression )* ')' ] ) | 'ALL' | ('TOP' sql_expression) | '%NOFPLAN' | '%NOLOCK' | '%NORUNTIME' | ('%PROFILE' ['ALL']) )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetQuantifier7RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetQuantifier10OptGrp">
<Description>

summary values:BY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&(?4?)*&P
	; first rule summary K
	if '(..isKeywordInList($lb("BY"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BY")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlExpression(subElement,.addedElement)  {
				if ..SetQuantifier11RepZero(subElement,.addedElement)  {
					if ..addPunctuation(subElement,")")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetQuantifier11RepZero">
<Description>
 ( ',' sql_expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SetQuantifier12Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SetQuantifier12Sub">
<Description>
 ',' sql_expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SqlExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetQuantifier13Sub">
<Description>
'TOP' sql_expression
summary values:TOP</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("TOP"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"TOP")  {
		if ..SqlExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetQuantifier14Sub">
<Description>
'%PROFILE' ['ALL']
summary values:%PROFILE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle("%PROFILE",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%PROFILE")  {
		if $S(..addKeyword(subElement,"ALL") :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetQuantifier7RepZero">
<Description>
 ( ( 'DISTINCT' ['BY' '(' sql_expression ( ',' sql_expression )* ')' ] ) | 'ALL' | ('TOP' sql_expression) | '%NOFPLAN' | '%NOLOCK' | '%NORUNTIME' | ('%PROFILE' ['ALL']) )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SetQuantifier8Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SetQuantifier8Sub">
<Description>
 ( 'DISTINCT' ['BY' '(' sql_expression ( ',' sql_expression )* ')' ] ) | 'ALL' | ('TOP' sql_expression) | '%NOFPLAN' | '%NOLOCK' | '%NORUNTIME' | ('%PROFILE' ['ALL'])</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|K|?1Rule?|P|P|P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SetQuantifier9Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ALL")  {
		set done=1 ; or
	} elseif ..SetQuantifier13Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOFPLAN")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOLOCK")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NORUNTIME")  {
		set done=1 ; or
	} elseif ..SetQuantifier14Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetQuantifier9Sub">
<Description>
 'DISTINCT' ['BY' '(' sql_expression ( ',' sql_expression )* ')' ]
summary values:DISTINCT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("DISTINCT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DISTINCT")  {
		if ..SetQuantifier10OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Sign">
<Description>
 sign ::= '+' | '-'
summary values:+,-</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P
	if '(..isStringInList($lb("+","-"),1,.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SignedInteger">
<Description>
 signed_integer ::= [ sign ] unsigned_integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..Sign(subElement,.addedElement) :1,1:1) {
		if ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleTable">
<Description>
 simple_table ::= query_specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..QuerySpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlCaseExpression">
<Description>
 sql_case_expression ::= 'CASE' ( sql_case_expression1 | sql_case_expression2 ) ['ELSE' sql_expression ] 'END'
summary values:CASE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&?4?&K
	; first rule summary K
	if '(..isKeywordInList($lb("CASE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CASE")  {
		if ..SqlCaseExpression157Sub(subElement,.addedElement)  {
			if ..SqlCaseExpression158OptGrp(subElement,.addedElement)  {
				if ..addKeyword(subElement,"END")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlCaseExpression1">
<Description>
 sql_case_expression1 ::= 'WHEN' sql_expression 'THEN' sql_expression ('WHEN' sql_expression 'THEN' sql_expression )*
summary values:WHEN</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&K&?1Rule?&(?4?)*
	; first rule summary K
	if '(..isKeywordInList($lb("WHEN"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WHEN")  {
		if ..SqlExpression(subElement,.addedElement)  {
			if ..addKeyword(subElement,"THEN")  {
				if ..SqlExpression(subElement,.addedElement)  {
					if ..SqlCaseExpression1159RepZero(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlCaseExpression1159RepZero">
<Description>
 ('WHEN' sql_expression 'THEN' sql_expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SqlCaseExpression1160Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SqlCaseExpression1160Sub">
<Description>
'WHEN' sql_expression 'THEN' sql_expression
summary values:WHEN</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("WHEN"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WHEN")  {
		if ..SqlExpression(subElement,.addedElement)  {
			if ..addKeyword(subElement,"THEN")  {
				if ..SqlExpression(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlCaseExpression157Sub">
<Description>
 sql_case_expression1 | sql_case_expression2</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlCaseExpression1(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlCaseExpression2(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlCaseExpression158OptGrp">
<Description>

summary values:ELSE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ELSE"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ELSE")  {
		if ..SqlExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlCaseExpression2">
<Description>
 sql_case_expression2 ::= sql_expression ('WHEN' sql_expression 'THEN' sql_expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlExpression(subElement,.addedElement)  {
		if ..SqlCaseExpression2161RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlCaseExpression2161RepZero">
<Description>
 ('WHEN' sql_expression 'THEN' sql_expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SqlCaseExpression2162Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SqlCaseExpression2162Sub">
<Description>
'WHEN' sql_expression 'THEN' sql_expression
summary values:WHEN</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("WHEN"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WHEN")  {
		if ..SqlExpression(subElement,.addedElement)  {
			if ..addKeyword(subElement,"THEN")  {
				if ..SqlExpression(subElement,.addedElement)  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlCosVariable">
<Description>
 sql_cos_variable ::= 'NEED COS VAR'
summary values:NEED COS VAR</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED COS VAR",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED COS VAR")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlDyadicop">
<Description><![CDATA[
 sql_dyadicop ::= "+" | "-" | "\\" | "/" | "<>" | ">=" | ">" | "!>" | "<=" | "<" | "!<" | "=" | "!=" | "**" | "*" | "&&" | "&" | "]]" | "[" | "'[" | "!" | "||" | "_" | "#" | '\' | "AND" | "OR" | "NOT=" | "SIZE" | "ESCAPE" | sql_predicate | ("NOT" sql_predicate)]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|P|K|K|P|K|K|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"\\")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"/")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<>")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,">")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"!>")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"<")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"!<")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"!=")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"**")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"&&")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"&")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"]]")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"[")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"'[")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"!")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"||")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"_")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"#")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"\")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"AND")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"OR")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"NOT=")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SIZE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ESCAPE")  {
		set done=1 ; or
	} elseif ..SqlPredicate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlDyadicop79Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlDyadicop79Sub">
<Description>
"NOT" sql_predicate
summary values:NOT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("NOT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NOT")  {
		if ..SqlPredicate(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlExpression">
<Description>
 sql_expression ::= sql_factor ( sql_dyadicop sql_factor )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlFactor(subElement,.addedElement)  {
		if ..SqlExpression77RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlExpression77RepZero">
<Description>
 ( sql_dyadicop sql_factor )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SqlExpression78Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SqlExpression78Sub">
<Description>
 sql_dyadicop sql_factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlDyadicop(subElement,.addedElement)  {
		if ..SqlFactor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFactor">
<Description>
 sql_factor ::= [ sql_monadicop ] sql_term</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..SqlMonadicop(subElement,.addedElement) :1,1:1) {
		if ..SqlTerm(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFnFunction">
<Description>
 sql_fn_function ::= '{' 'fn' sql_function '}'
summary values:{</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&K&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("{",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"{")  {
		if ..addKeyword(subElement,"FN")  {
			if ..SqlFunction(subElement,.addedElement)  {
				if ..addPunctuation(subElement,"}")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction">
<Description>
 sql_function ::= ('$' identifier '(' [ sql_expression ( ',' sql_expression)* ] ')') | ('%exact' sql_expression ) | ('count' '(' ['distinct' | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ] ) | ('min' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ] ) | ('max' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ] ) | ('sum' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ] ) | ('avg' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ] ) | ('cast' '(' sql_expression 'as' identifier ['(' sql_expression ( ',' sql_expression)* ')' ] ')' ) | ('exists' '(' subquery_specification ')' ) | ('list' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')') | ('%dlist' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')') | ('FOR' 'SOME' '%ELEMENT' '(' sql_expression ')' sql_expression ) | ('trim' '(' ['leading' | 'trailing' | 'both'] [(sql_expression 'from')] sql_expression ')' ) | ('dateadd' '(' sql_function_datepart_part ',' sql_expression ',' sql_expression ')' ) | ('datediff' '(' sql_function_datepart_part ',' sql_expression ',' sql_expression ')' ) | ('datename' '(' sql_function_datepart_part ',' sql_expression ')' ) | ('datepart' '(' sql_function_datepart_part ',' sql_expression ')' ) | (identifier '(' [ '*' | (sql_expression ( ',' sql_expression)*) ] ')' [ sql_window ] )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlFunction88Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction92Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction93Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction97Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction103Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction109Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction115Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction121Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction125Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction126Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction132Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction138Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction139Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction142Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction143Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction144Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction145Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction146Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction100OptGrp">
<Description>

summary values:BY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("BY"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BY")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction101Sub">
<Description>
'*' | sql_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..SqlExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction102OptGrp">
<Description>

summary values:%FOREACH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("%FOREACH",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%FOREACH")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction103Sub">
<Description>
'max' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ]
summary values:MAX</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?4?&?1Rule?&?4?&P&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("MAX"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"MAX")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunction104OptGrp(subElement,.addedElement)  {
				if ..SqlFunction107Sub(subElement,.addedElement)  {
					if ..SqlFunction108OptGrp(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							if $S(..SqlWindow(subElement,.addedElement) :1,1:1) {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction104OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlFunction105Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ALL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction105Sub">
<Description>
 'distinct' ['by' '(' col_list ')']
summary values:DISTINCT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("DISTINCT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DISTINCT")  {
		if ..SqlFunction106OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction106OptGrp">
<Description>

summary values:BY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("BY"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BY")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction107Sub">
<Description>
'*' | sql_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..SqlExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction108OptGrp">
<Description>

summary values:%FOREACH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("%FOREACH",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%FOREACH")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction109Sub">
<Description>
'sum' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ]
summary values:SUM</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?4?&?1Rule?&?4?&P&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("SUM"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SUM")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunction110OptGrp(subElement,.addedElement)  {
				if ..SqlFunction113Sub(subElement,.addedElement)  {
					if ..SqlFunction114OptGrp(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							if $S(..SqlWindow(subElement,.addedElement) :1,1:1) {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction110OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlFunction111Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ALL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction111Sub">
<Description>
 'distinct' ['by' '(' col_list ')']
summary values:DISTINCT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("DISTINCT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DISTINCT")  {
		if ..SqlFunction112OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction112OptGrp">
<Description>

summary values:BY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("BY"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BY")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction113Sub">
<Description>
'*' | sql_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..SqlExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction114OptGrp">
<Description>

summary values:%FOREACH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("%FOREACH",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%FOREACH")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction115Sub">
<Description>
'avg' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ]
summary values:AVG</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?4?&?1Rule?&?4?&P&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("AVG"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AVG")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunction116OptGrp(subElement,.addedElement)  {
				if ..SqlFunction119Sub(subElement,.addedElement)  {
					if ..SqlFunction120OptGrp(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							if $S(..SqlWindow(subElement,.addedElement) :1,1:1) {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction116OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlFunction117Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ALL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction117Sub">
<Description>
 'distinct' ['by' '(' col_list ')']
summary values:DISTINCT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("DISTINCT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DISTINCT")  {
		if ..SqlFunction118OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction118OptGrp">
<Description>

summary values:BY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("BY"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BY")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction119Sub">
<Description>
'*' | sql_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..SqlExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction120OptGrp">
<Description>

summary values:%FOREACH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("%FOREACH",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%FOREACH")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction121Sub">
<Description>
'cast' '(' sql_expression 'as' identifier ['(' sql_expression ( ',' sql_expression)* ')' ] ')'
summary values:CAST</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&K&?1Rule?&?4?&P
	; first rule summary K
	if '(..isKeywordInList($lb("CAST"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CAST")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlExpression(subElement,.addedElement)  {
				if ..addKeyword(subElement,"AS")  {
					if ..Identifier(subElement,.addedElement)  {
						if ..SqlFunction122OptGrp(subElement,.addedElement)  {
							if ..addPunctuation(subElement,")")  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction122OptGrp">
<Description>

summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..SqlExpression(subElement,.addedElement)  {
			if ..SqlFunction123RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction123RepZero">
<Description>
 ( ',' sql_expression)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SqlFunction124Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction124Sub">
<Description>
 ',' sql_expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SqlExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction125Sub">
<Description>
'exists' '(' subquery_specification ')'
summary values:EXISTS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("EXISTS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"EXISTS")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SubquerySpecification(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction126Sub">
<Description>
'list' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')'
summary values:LIST</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?4?&?1Rule?&?4?&P
	; first rule summary K
	if '(..isKeywordInList($lb("LIST"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"LIST")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunction127OptGrp(subElement,.addedElement)  {
				if ..SqlFunction130Sub(subElement,.addedElement)  {
					if ..SqlFunction131OptGrp(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction127OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlFunction128Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ALL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction128Sub">
<Description>
 'distinct' ['by' '(' col_list ')']
summary values:DISTINCT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("DISTINCT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DISTINCT")  {
		if ..SqlFunction129OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction129OptGrp">
<Description>

summary values:BY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("BY"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BY")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction130Sub">
<Description>
'*' | sql_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..SqlExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction131OptGrp">
<Description>

summary values:%FOREACH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("%FOREACH",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%FOREACH")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction132Sub">
<Description>
'%dlist' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')'
summary values:%DLIST</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?4?&?1Rule?&?4?&P
	; first rule summary P
	if '(..isStringSingle("%DLIST",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%dlist")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunction133OptGrp(subElement,.addedElement)  {
				if ..SqlFunction136Sub(subElement,.addedElement)  {
					if ..SqlFunction137OptGrp(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction133OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlFunction134Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ALL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction134Sub">
<Description>
 'distinct' ['by' '(' col_list ')']
summary values:DISTINCT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("DISTINCT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DISTINCT")  {
		if ..SqlFunction135OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction135OptGrp">
<Description>

summary values:BY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("BY"),.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BY")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction136Sub">
<Description>
'*' | sql_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..SqlExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction137OptGrp">
<Description>

summary values:%FOREACH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("%FOREACH",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%FOREACH")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction138Sub">
<Description>
'FOR' 'SOME' '%ELEMENT' '(' sql_expression ')' sql_expression
summary values:FOR</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&K&P&P&?1Rule?&P&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("FOR"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FOR")  {
		if ..addKeyword(subElement,"SOME")  {
			if ..addPunctuation(subElement,"%ELEMENT")  {
				if ..addPunctuation(subElement,"(")  {
					if ..SqlExpression(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							if ..SqlExpression(subElement,.addedElement)  {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction139Sub">
<Description>
'trim' '(' ['leading' | 'trailing' | 'both'] [(sql_expression 'from')] sql_expression ')'
summary values:TRIM</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?4?&?4?&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("TRIM"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"TRIM")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunction140OptGrp(subElement,.addedElement)  {
				if $S(..SqlFunction141Sub(subElement,.addedElement) :1,1:1) {
					if ..SqlExpression(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction140OptGrp">
<Description>

summary values:LEADING,TRAILING,BOTH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K
	if '(..isKeywordInList($lb("LEADING","TRAILING","BOTH"),.value)) { quit 1 /* not found is OK */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"LEADING")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"TRAILING")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"BOTH")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=1 /* failure rollsback but returns OK */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction141Sub">
<Description>
sql_expression 'from'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlExpression(subElement,.addedElement)  {
		if ..addKeyword(subElement,"FROM")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction142Sub">
<Description>
'dateadd' '(' sql_function_datepart_part ',' sql_expression ',' sql_expression ')'
summary values:DATEADD</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P&?1Rule?&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("DATEADD"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DATEADD")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunctionDatepartPart(subElement,.addedElement)  {
				if ..addPunctuation(subElement,",")  {
					if ..SqlExpression(subElement,.addedElement)  {
						if ..addPunctuation(subElement,",")  {
							if ..SqlExpression(subElement,.addedElement)  {
								if ..addPunctuation(subElement,")")  {
									set done=1 ; end compileRules
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction143Sub">
<Description>
'datediff' '(' sql_function_datepart_part ',' sql_expression ',' sql_expression ')'
summary values:DATEDIFF</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P&?1Rule?&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("DATEDIFF"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DATEDIFF")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunctionDatepartPart(subElement,.addedElement)  {
				if ..addPunctuation(subElement,",")  {
					if ..SqlExpression(subElement,.addedElement)  {
						if ..addPunctuation(subElement,",")  {
							if ..SqlExpression(subElement,.addedElement)  {
								if ..addPunctuation(subElement,")")  {
									set done=1 ; end compileRules
								}
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction144Sub">
<Description>
'datename' '(' sql_function_datepart_part ',' sql_expression ')'
summary values:DATENAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("DATENAME"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DATENAME")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunctionDatepartPart(subElement,.addedElement)  {
				if ..addPunctuation(subElement,",")  {
					if ..SqlExpression(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction145Sub">
<Description>
'datepart' '(' sql_function_datepart_part ',' sql_expression ')'
summary values:DATEPART</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?1Rule?&P&?1Rule?&P
	; first rule summary K
	if '(..isKeywordInList($lb("DATEPART"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DATEPART")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunctionDatepartPart(subElement,.addedElement)  {
				if ..addPunctuation(subElement,",")  {
					if ..SqlExpression(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction146Sub">
<Description>
identifier '(' [ '*' | (sql_expression ( ',' sql_expression)*) ] ')' [ sql_window ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?4?&P&?4?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunction147OptGrp(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					if $S(..SqlWindow(subElement,.addedElement) :1,1:1) {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction147OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..SqlFunction148Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction148Sub">
<Description>
sql_expression ( ',' sql_expression)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlExpression(subElement,.addedElement)  {
		if ..SqlFunction149RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction149RepZero">
<Description>
 ( ',' sql_expression)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SqlFunction150Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction150Sub">
<Description>
 ',' sql_expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SqlExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction88Sub">
<Description>
'$' identifier '(' [ sql_expression ( ',' sql_expression)* ] ')'
summary values:$</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P&?4?&P
	; first rule summary P
	if '(..isStringSingle("$",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"$")  {
		if ..Identifier(subElement,.addedElement)  {
			if ..addPunctuation(subElement,"(")  {
				if ..SqlFunction89OptGrp(subElement,.addedElement)  {
					if ..addPunctuation(subElement,")")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction89OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlExpression(subElement,.addedElement)  {
		if ..SqlFunction90RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction90RepZero">
<Description>
 ( ',' sql_expression)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SqlFunction91Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction91Sub">
<Description>
 ',' sql_expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SqlExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction92Sub">
<Description>
'%exact' sql_expression
summary values:%EXACT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle("%EXACT",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%exact")  {
		if ..SqlExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction93Sub">
<Description>
'count' '(' ['distinct' | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ]
summary values:COUNT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?4?&?1Rule?&?4?&P&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("COUNT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"COUNT")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunction94OptGrp(subElement,.addedElement)  {
				if ..SqlFunction95Sub(subElement,.addedElement)  {
					if ..SqlFunction96OptGrp(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							if $S(..SqlWindow(subElement,.addedElement) :1,1:1) {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction94OptGrp">
<Description>

summary values:DISTINCT,ALL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K
	if '(..isKeywordInList($lb("DISTINCT","ALL"),.value)) { quit 1 /* not found is OK */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addKeyword(subElement,"DISTINCT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ALL")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=1 /* failure rollsback but returns OK */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction95Sub">
<Description>
'*' | sql_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*")  {
		set done=1 ; or
	} elseif ..SqlExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction96OptGrp">
<Description>

summary values:%FOREACH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("%FOREACH",.value)) { quit 1 /* not found is OK */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%FOREACH")  {
		if ..addPunctuation(subElement,"(")  {
			if ..ColList(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction97Sub">
<Description>
'min' '(' [ ( 'distinct' ['by' '(' col_list ')'] ) | 'all' ] ('*' | sql_expression) [ '%FOREACH' '(' col_list ')' ] ')' [ sql_window ]
summary values:MIN</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?4?&?1Rule?&?4?&P&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("MIN"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"MIN")  {
		if ..addPunctuation(subElement,"(")  {
			if ..SqlFunction98OptGrp(subElement,.addedElement)  {
				if ..SqlFunction101Sub(subElement,.addedElement)  {
					if ..SqlFunction102OptGrp(subElement,.addedElement)  {
						if ..addPunctuation(subElement,")")  {
							if $S(..SqlWindow(subElement,.addedElement) :1,1:1) {
								set done=1 ; end compileRules
							}
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction98OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlFunction99Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ALL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunction99Sub">
<Description>
 'distinct' ['by' '(' col_list ')']
summary values:DISTINCT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("DISTINCT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DISTINCT")  {
		if ..SqlFunction100OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunctionDatepartPart">
<Description>
 sql_function_datepart_part ::= sql_function_datepart_part_word | sql_string | colon_sql_cos_variable</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlFunctionDatepartPartWord(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlString(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ColonSqlCosVariable(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlFunctionDatepartPartWord">
<Description>
 sql_function_datepart_part_word ::= 'year' | 'yy' | 'yyyy' | 'quarter' | 'qq' | 'q' | 'month' | 'mm' | 'm' | 'week' | 'wk' | 'ww' | 'weekday' | 'dw' | 'w' | 'dayofyear' | 'dy' | 'y' | 'day' | 'dd' | 'd' | 'hour' | 'hh' | 'h' | 'minute' | 'mi' | 'n' | 'second' | 'ss' | 's' | 'millisecond' | 'ms' | 'sqltimestamp' | 'sts'
summary values:YEAR,YY,YYYY,QUARTER,QQ,Q,MONTH,MM,M,WEEK,WK,WW,WEEKDAY,DW,W,DAYOFYEAR,DY,Y,DAY,DD,D,HOUR,HH,H,MINUTE,MI,N,SECOND,SS,S,MILLISECOND,MS,SQLTIMESTAMP,STS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K|K
	if '(..isKeywordInList($lb("YEAR","YY","YYYY","QUARTER","QQ","Q","MONTH","MM","M","WEEK","WK","WW","WEEKDAY","DW","W","DAYOFYEAR","DY","Y","DAY","DD","D","HOUR","HH","H","MINUTE","MI","N","SECOND","SS","S","MILLISECOND","MS","SQLTIMESTAMP","STS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"YEAR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"YY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"YYYY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"QUARTER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"QQ")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"Q")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MONTH")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MM")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"M")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"WEEK")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"WK")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"WW")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"WEEKDAY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DW")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"W")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DAYOFYEAR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"Y")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DAY")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DD")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"D")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"HOUR")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"HH")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"H")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MINUTE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MI")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"N")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SECOND")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"S")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MILLISECOND")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"MS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SQLTIMESTAMP")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"STS")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlMonadicop">
<Description>
 sql_monadicop ::= "+" | "-" | "NOT" | "%NOINDEX"</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|K|P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"-")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NOT")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOINDEX")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlNumber">
<Description>
 sql_number ::= 'NEED NUMBER'
summary values:NEED NUMBER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED NUMBER",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED NUMBER")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlPredicate">
<Description>
 sql_predicate ::= "%STARTSWITH" | "BETWEEN" | "IS" | "IN" | "%INLIST" | "LIKE" | "%PATTERN" | "%MATCHES"</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|K|K|K|P|K|P|P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%STARTSWITH")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"BETWEEN")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"IS")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"IN")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%INLIST")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LIKE")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%PATTERN")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%MATCHES")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlPrimary">
<Description>
 sql_primary ::= sql_number | sql_string | sql_case_expression | sql_fn_function | sql_function | colon_sql_cos_variable | stored_proc_call | column_reference | sql_special_variable | macrocall | ( '(' subquery_specification ')' ) | ( '(' sql_expression ( ',' sql_expression )* ')' )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlNumber(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlString(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlCaseExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFnFunction(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlFunction(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ColonSqlCosVariable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StoredProcCall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ColumnReference(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlSpecialVariable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Macrocall(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlPrimary80Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlPrimary81Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlPrimary80Sub">
<Description>
 '(' subquery_specification ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..SubquerySpecification(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlPrimary81Sub">
<Description>
 '(' sql_expression ( ',' sql_expression )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..SqlExpression(subElement,.addedElement)  {
			if ..SqlPrimary82RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlPrimary82RepZero">
<Description>
 ( ',' sql_expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SqlPrimary83Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SqlPrimary83Sub">
<Description>
 ',' sql_expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SqlExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlProgram">
<Description>
 sql_program ::= query_specification | call_command | insert_command | update_command | declare_command | open_command | fetch_command | close_command | delete_command | CHECKPRIV_command</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..QuerySpecification(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CallCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..InsertCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..UpdateCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DeclareCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OpenCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..FetchCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CloseCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DeleteCommand(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CheckprivCommand(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlSpecialVariable">
<Description>
 sql_special_variable ::= 'NULL' | '?' | '$H' | '$ZNSPACE'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|P|P|P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"NULL")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"?")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"$H")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"$ZNSPACE")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlString">
<Description>
 sql_string ::= 'NEED STRING'
summary values:NEED STRING</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P
	if '(..isStringSingle("NEED STRING",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"NEED STRING")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlTerm">
<Description>
 sql_term ::= sql_primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlPrimary(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlWindow">
<Description>
 sql_window ::= 'OVER' '(' [ sql_window_partition ] [ order_by_clause ] [ (sql_window_rows_between | sql_window_rows ) ] ')'
summary values:OVER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&P&?4?&?4?&?4?&P
	; first rule summary K
	if '(..isKeywordInList($lb("OVER"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"OVER")  {
		if ..addPunctuation(subElement,"(")  {
			if $S(..SqlWindowPartition(subElement,.addedElement) :1,1:1) {
				if $S(..OrderByClause(subElement,.addedElement) :1,1:1) {
					if $S(..SqlWindow151Sub(subElement,.addedElement) :1,1:1) {
						if ..addPunctuation(subElement,")")  {
							set done=1 ; end compileRules
						}
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlWindow151Sub">
<Description>
sql_window_rows_between | sql_window_rows</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlWindowRowsBetween(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlWindowRows(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlWindowFrame">
<Description>
 sql_window_frame ::= ('UNBOUNDED' 'PRECEDING') | (sql_expression 'PRECEDING') | ('CURRENT' 'ROW') | ('UNBOUNDED' 'FOLLOWING') | (sql_expression 'FOLLOWING')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlWindowFrame152Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlWindowFrame153Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlWindowFrame154Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlWindowFrame155Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlWindowFrame156Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlWindowFrame152Sub">
<Description>
'UNBOUNDED' 'PRECEDING'
summary values:UNBOUNDED</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&K
	; first rule summary K
	if '(..isKeywordInList($lb("UNBOUNDED"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"UNBOUNDED")  {
		if ..addKeyword(subElement,"PRECEDING")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlWindowFrame153Sub">
<Description>
sql_expression 'PRECEDING'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlExpression(subElement,.addedElement)  {
		if ..addKeyword(subElement,"PRECEDING")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlWindowFrame154Sub">
<Description>
'CURRENT' 'ROW'
summary values:CURRENT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&K
	; first rule summary K
	if '(..isKeywordInList($lb("CURRENT"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CURRENT")  {
		if ..addKeyword(subElement,"ROW")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlWindowFrame155Sub">
<Description>
'UNBOUNDED' 'FOLLOWING'
summary values:UNBOUNDED</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&K
	; first rule summary K
	if '(..isKeywordInList($lb("UNBOUNDED"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"UNBOUNDED")  {
		if ..addKeyword(subElement,"FOLLOWING")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlWindowFrame156Sub">
<Description>
sql_expression 'FOLLOWING'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlExpression(subElement,.addedElement)  {
		if ..addKeyword(subElement,"FOLLOWING")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlWindowPartition">
<Description>
 sql_window_partition ::= 'PARTITION' 'BY' col_list
summary values:PARTITION</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("PARTITION"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PARTITION")  {
		if ..addKeyword(subElement,"BY")  {
			if ..ColList(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlWindowRows">
<Description>
 sql_window_rows ::= 'ROWS' sql_window_frame
summary values:ROWS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ROWS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ROWS")  {
		if ..SqlWindowFrame(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlWindowRowsBetween">
<Description>
 sql_window_rows_between ::= 'ROWS' 'BETWEEN' sql_window_frame 'AND' sql_window_frame
summary values:ROWS</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&K&?1Rule?&K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("ROWS"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ROWS")  {
		if ..addKeyword(subElement,"BETWEEN")  {
			if ..SqlWindowFrame(subElement,.addedElement)  {
				if ..addKeyword(subElement,"AND")  {
					if ..SqlWindowFrame(subElement,.addedElement)  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StoredProcCall">
<Description>
 stored_proc_call ::= stored_proc_name stored_proc_parameter_list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StoredProcName(subElement,.addedElement)  {
		if ..StoredProcParameterList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StoredProcName">
<Description>
 stored_proc_name ::= [ schema_name '.' ] qualified_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StoredProcName175OptGrp(subElement,.addedElement)  {
		if ..QualifiedIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StoredProcName175OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SchemaName(subElement,.addedElement)  {
		if ..addPunctuation(subElement,".")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StoredProcParameter">
<Description>
 stored_proc_parameter ::= sql_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SqlExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StoredProcParameterList">
<Description>
 stored_proc_parameter_list ::= '(' [ [stored_proc_parameter] ( ',' [stored_proc_parameter] )* ] ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..StoredProcParameterList172OptGrp(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StoredProcParameterList172OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..StoredProcParameter(subElement,.addedElement) :1,1:1) {
		if ..StoredProcParameterList173RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StoredProcParameterList173RepZero">
<Description>
 ( ',' [stored_proc_parameter] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..StoredProcParameterList174Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StoredProcParameterList174Sub">
<Description>
 ',' [stored_proc_parameter]
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?4?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if $S(..StoredProcParameter(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StoredProcTable">
<Description>
 stored_proc_table ::= stored_proc_name stored_proc_parameter_list [ table_as_clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StoredProcName(subElement,.addedElement)  {
		if ..StoredProcParameterList(subElement,.addedElement)  {
			if $S(..TableAsClause(subElement,.addedElement) :1,1:1) {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StringValueExpression">
<Description>
 string_value_expression ::= character_value_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CharacterValueExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StringValueFunction">
<Description>
 string_value_function ::= character_value_function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CharacterValueFunction(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Subquery">
<Description>
 subquery ::= '(' query_expression ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..QueryExpression(subElement,.addedElement)  {
			if ..addPunctuation(subElement,")")  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SubquerySpecification">
<Description>
 subquery_specification ::= select_command ( union select_command )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&(?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SelectCommand(subElement,.addedElement)  {
		if ..SubquerySpecification3RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SubquerySpecification3RepZero">
<Description>
 ( union select_command )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..SubquerySpecification4Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SubquerySpecification4Sub">
<Description>
 union select_command</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Union(subElement,.addedElement)  {
		if ..SelectCommand(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableAsClause">
<Description>
 table_as_clause ::= [ 'AS' ] alias_name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addKeyword(subElement,"AS") :1,1:1) {
		if ..AliasName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableExpression">
<Description>
 table_expression ::= from_clause [ where_clause ] [ group_by_clause ] [ having_clause ] [ order_by_clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?4?&?4?&?4?&?4?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..FromClause(subElement,.addedElement)  {
		if $S(..WhereClause(subElement,.addedElement) :1,1:1) {
			if $S(..GroupByClause(subElement,.addedElement) :1,1:1) {
				if $S(..HavingClause(subElement,.addedElement) :1,1:1) {
					if $S(..OrderByClause(subElement,.addedElement) :1,1:1) {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableName">
<Description>
 table_name ::= [ schema_name '.' ] qualified_identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TableName47OptGrp(subElement,.addedElement)  {
		if ..QualifiedIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableName47OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SchemaName(subElement,.addedElement)  {
		if ..addPunctuation(subElement,".")  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableReference">
<Description>
 table_reference ::= stored_proc_table | direct_table | derived_table</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..StoredProcTable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DirectTable(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DerivedTable(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableReferenceNoalias">
<Description>
 table_reference_noalias ::= direct_table_noalias | derived_table_noalias</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DirectTableNoalias(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DerivedTableNoalias(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableSubquery">
<Description>
 table_subquery ::= subquery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Subquery(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term">
<Description>
 term ::= factor | ( term '*' factor ) | ( term '/' factor )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Factor(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Term167Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Term168Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term167Sub">
<Description>
 term '*' factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Term(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"*")  {
			if ..Factor(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term168Sub">
<Description>
 term '/' factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Term(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"/")  {
			if ..Factor(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Union">
<Description>
 union ::= 'UNION' ('ALL' | '%PARALLEL')*
summary values:UNION</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&(?4?)*
	; first rule summary K
	if '(..isKeywordInList($lb("UNION"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"UNION")  {
		if ..Union42RepZero(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Union42RepZero">
<Description>
 ('ALL' | '%PARALLEL')*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..Union43Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Union43Sub">
<Description>
'ALL' | '%PARALLEL'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K|P
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ALL")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%PARALLEL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UnsignedInteger">
<Description>
 unsigned_integer_ ::= ( '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '0')*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary (?4?)*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UnsignedInteger186RepZero(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UnsignedInteger186RepZero">
<Description>
 ( '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '0')*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..UnsignedInteger187Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UnsignedInteger187Sub">
<Description>
 '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '0'
summary values:1,2,3,4,5,6,7,8,9,0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P|P|P|P|P|P
	if '(..isStringInList($lb("1","2","3","4","5","6","7","8","9","0"),1,.value)) { quit 0 /* normal */ }
	set subElement=ParentElement
	set done=0 ; method start
	Set subElement=ParentElement
	if ..addPunctuation(subElement,"1")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"2")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"3")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"4")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"5")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"6")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"7")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"8")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"9")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"0")  {
		set done=1 ; end compileRules
	}

	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UnsignedLiteral">
<Description>
 unsigned_literal ::= unsigned_numeric_literal | general_literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UnsignedNumericLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GeneralLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UnsignedNumericLiteral">
<Description>
 unsigned_numeric_literal ::= exact_numeric_literal | approximate_numeric_literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ExactNumericLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ApproximateNumericLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UnsignedValueSpecification">
<Description>
 unsigned_value_specification ::= unsigned_literal | general_value_specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UnsignedLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GeneralValueSpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateColumns">
<Description>
 update_columns ::= '(' column_name ( ',' column_name)* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..ColumnName(subElement,.addedElement)  {
			if ..UpdateColumns61RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateColumns61RepZero">
<Description>
 ( ',' column_name)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..UpdateColumns62Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateColumns62Sub">
<Description>
 ',' column_name
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..ColumnName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateCommand">
<Description>
 update_command ::= 'UPDATE' (update_keyword)* direct_table ( ('SET' update_set (',' update_set)* ) | ( update_columns (('VALUES' update_values) | select_command) ) ) [where_clause]
summary values:UPDATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&(?4?)*&?1Rule?&?1Rule?&?4?
	; first rule summary K
	if '(..isKeywordInList($lb("UPDATE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"UPDATE")  {
		if ..UpdateCommand52RepZero(subElement,.addedElement)  {
			if ..DirectTable(subElement,.addedElement)  {
				if ..UpdateCommand54Sub(subElement,.addedElement)  {
					if $S(..WhereClause(subElement,.addedElement) :1,1:1) {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateCommand52RepZero">
<Description>
 (update_keyword)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..UpdateCommand53Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateCommand53Sub">
<Description>
update_keyword</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UpdateKeyword(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateCommand54Sub">
<Description>
 ('SET' update_set (',' update_set)* ) | ( update_columns (('VALUES' update_values) | select_command) )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UpdateCommand55Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..UpdateCommand58Sub(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateCommand55Sub">
<Description>
'SET' update_set (',' update_set)*
summary values:SET</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&(?4?)*
	; first rule summary K
	if '(..isKeywordInList($lb("SET"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"SET")  {
		if ..UpdateSet(subElement,.addedElement)  {
			if ..UpdateCommand56RepZero(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateCommand56RepZero">
<Description>
 (',' update_set)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..UpdateCommand57Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateCommand57Sub">
<Description>
',' update_set
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..UpdateSet(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateCommand58Sub">
<Description>
 update_columns (('VALUES' update_values) | select_command)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UpdateColumns(subElement,.addedElement)  {
		if ..UpdateCommand59Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateCommand59Sub">
<Description>
('VALUES' update_values) | select_command</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..UpdateCommand60Sub(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SelectCommand(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateCommand60Sub">
<Description>
'VALUES' update_values
summary values:VALUES</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("VALUES"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"VALUES")  {
		if ..UpdateValues(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateKeyword">
<Description>
 update_keyword ::= '%NOCHECK' | '%NOFPLAN' | '%NOINDEX' | '%NOJOURN' | '%NOLOCK' | '%NOTRIGGER' | '%PROFILE_ALL' | '%PROFILE_ALL'
summary values:%NOCHECK,%NOFPLAN,%NOINDEX,%NOJOURN,%NOLOCK,%NOTRIGGER,%PROFILE_ALL,%PROFILE_ALL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P|P|P|P|P|P|P|P
	if '(..isStringInList($lb("%NOCHECK","%NOFPLAN","%NOINDEX","%NOJOURN","%NOLOCK","%NOTRIGGER","%PROFILE_ALL","%PROFILE_ALL"),12,.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%NOCHECK")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOFPLAN")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOINDEX")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOJOURN")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOLOCK")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%NOTRIGGER")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%PROFILE_ALL")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"%PROFILE_ALL")  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateSet">
<Description>
 update_set ::= column_reference '=' sql_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&P&?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..ColumnReference(subElement,.addedElement)  {
		if ..addPunctuation(subElement,"=")  {
			if ..SqlExpression(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateValues">
<Description>
 update_values ::= '(' sql_expression ( ',' sql_expression )* ')'
summary values:(</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?&(?4?)*&P
	; first rule summary P
	if '(..isStringSingle("(",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(")  {
		if ..SqlExpression(subElement,.addedElement)  {
			if ..UpdateValues63RepZero(subElement,.addedElement)  {
				if ..addPunctuation(subElement,")")  {
					set done=1 ; end compileRules
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateValues63RepZero">
<Description>
 ( ',' sql_expression )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..UpdateValues64Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateValues64Sub">
<Description>
 ',' sql_expression
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..SqlExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ValueExpression">
<Description>
 value_expression ::= numeric_value_expression | string_value_expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NumericValueExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StringValueExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ValueExpressionPrimary">
<Description>
 value_expression_primary ::= number | column_reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?|?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Number(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ColumnReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WhereClause">
<Description>
 where_clause ::= 'WHERE' sql_expression
summary values:WHERE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?
	; first rule summary K
	if '(..isKeywordInList($lb("WHERE"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WHERE")  {
		if ..SqlExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithClause">
<Description>
 with_clause ::= alias_name 'AS' '(' select_command ')'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?&K&P&?1Rule?&P
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..AliasName(subElement,.addedElement)  {
		if ..addKeyword(subElement,"AS")  {
			if ..addPunctuation(subElement,"(")  {
				if ..SelectCommand(subElement,.addedElement)  {
					if ..addPunctuation(subElement,")")  {
						set done=1 ; end compileRules
					}
				}
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithCommand">
<Description>
 with_command ::= 'WITH' with_clause (',' with_clause)*
summary values:WITH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary K&?1Rule?&(?4?)*
	; first rule summary K
	if '(..isKeywordInList($lb("WITH"),.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WITH")  {
		if ..WithClause(subElement,.addedElement)  {
			if ..WithCommand5RepZero(subElement,.addedElement)  {
				set done=1 ; end compileRules
			}
		}
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithCommand5RepZero">
<Description>
 (',' with_clause)*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?4?
	set subElement=ParentElement
	set done=0 ; method start
	while ..WithCommand6Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=1 /* nothing found is ok in RZ */
	}
	quit ret
]]></Implementation>
</Method>

<Method name="WithCommand6Sub">
<Description>
',' with_clause
summary values:,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary P&?1Rule?
	; first rule summary P
	if '(..isStringSingle(",",.value)) { quit 0 /* normal */ }
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",")  {
		if ..WithClause(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
	}

	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WithName">
<Description>
 with_name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	; rules summary ?1Rule?
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Identifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}

	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Elements.SQL</ReturnType>
<Implementation><![CDATA[	quit ##class(PXW.DEV.BNF.Elements.SQL).%New(Type)
]]></Implementation>
</Method>

<Parameter name="KeywordPattern">
<Default>1.A</Default>
</Parameter>

<Parameter name="Keywords">
<Default>ALL,AND,AS,ASC,AVG,BETWEEN,BOTH,BY,CALL,CASE,CAST,CLOSE,COUNT,CROSS,CURRENT,CURSOR,D,DATEADD,DATEDIFF,DATENAME,DATEPART,DAY,DAYOFYEAR,DD,DECLARE,DELETE,DESC,DISTINCT,DW,DY,E,ELSE,END,ESCAPE,EXECUTE,EXISTS,FETCH,FN,FOLLOWING,FOR,FROM,FULL,GROUP,H,HAVING,HH,HOUR,IN,INNER,INSERT,INTO,IS,JOIN,LEADING,LEFT,LENGTH,LIKE,LIST,M,MAX,MI,MILLISECOND,MIN,MINUTE,MM,MONTH,MS,N,NATURAL,NOT,NULL,ON,ONLY,OPEN,OR,ORDER,OUTER,OVER,PARTITION,PRECEDING,Q,QQ,QUARTER,READ,REFERENCES,RIGHT,ROW,ROWS,S,SECOND,SELECT,SET,SIZE,SOME,SQLTIMESTAMP,SS,STS,SUBSTRING,SUM,THEN,TOP,TRAILING,TRIM,UNBOUNDED,UNION,UPDATE,USER,USING,VALUE,VALUES,W,WEEK,WEEKDAY,WHEN,WHERE,WITH,WK,WW,Y,YEAR,YY,YYYY</Default>
</Parameter>
</Class>


<Class name="PXW.DEV.BNF.GEN.SQL92">
<Description>
Created: 2024-10-17 16:00:35 PXW.DEV.BNF.Compilers.Compiler3</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>PXW.DEV.BNF.super</Super>
<TimeChanged>67130,57667.514940075</TimeChanged>
<TimeCreated>67125,77563.428428811</TimeCreated>

<Method name="Action">
<Description>
 action ::= SELECT | DELETE | INSERT [ left paren privilege column list right paren ] | UPDATE [ left paren privilege column list right paren ] | REFERENCES [ left paren privilege column list right paren ] | USAGE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SELECT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DELETE")  {
			set done=1 ; or
		} elseif ..Action240Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Action242Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Action244Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"USAGE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Action240Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"INSERT")  && ..Action241OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Action241OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..PrivilegeColumnList(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Action242Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"UPDATE")  && ..Action243OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Action243OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..PrivilegeColumnList(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Action244Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"REFERENCES")  && ..Action245OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Action245OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..PrivilegeColumnList(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ActionList">
<Description>
 action list ::= action [ { comma action }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Action(subElement,.addedElement)  && $S(..ActionList238RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ActionList238RepOne">
<Description>
 { comma action }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ActionList239Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ActionList239Sub">
<Description>
 comma action</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..Action(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ActualIdentifier">
<Description>
 actual identifier ::= regular identifier | delimited identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RegularIdentifier(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DelimitedIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AdaAssignmentOperator">
<Description>
 Ada assignment operator ::= colonequals operator</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Colon(subElement,.addedElement)  && ..EqualsOperator(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AdaHostIdentifier">
<Description>
 Ada host identifier ::= !! See syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AdaInitialValue">
<Description>
 Ada initial value ::= Ada assignment operator character representation</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AdaAssignmentOperator(subElement,.addedElement)  && ..CharacterRepresentation(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AdaQualifiedTypeSpecification">
<Description>
 Ada qualified type specification ::= SQL_STANDARD.CHAR [ CHARACTER SET [ IS ] character set specification ] left paren 1 double period length right paren | SQL_STANDARD.BIT left paren 1 double period length right paren | SQL_STANDARD.SMALLINT | SQL_STANDARD.INT | SQL_STANDARD.REAL | SQL_STANDARD.DOUBLE_PRECISION | SQL_STANDARD.SQLCODE_TYPE | SQL_STANDARD.SQLSTATE_TYPE | SQL_STANDARD.INDICATOR_TYPE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"SQL_STANDARD.CHAR")  && ..AdaQualifiedTypeSpecification313OptGrp(subElement,.addedElement)  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"1")  && ..DoublePeriod(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..AdaQualifiedTypeSpecification314Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SQL_STANDARD.SMALLINT")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SQL_STANDARD.INT")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SQL_STANDARD.REAL")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SQL_STANDARD.DOUBLE_PRECISION")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SQL_STANDARD.SQLCODE_TYPE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SQL_STANDARD.SQLSTATE_TYPE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SQL_STANDARD.INDICATOR_TYPE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AdaQualifiedTypeSpecification313OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CHARACTER")  && ..addKeyword(subElement,"SET")  && $S(..addKeyword(subElement,"IS") :1,1:1) && ..CharacterSetSpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AdaQualifiedTypeSpecification314Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"SQL_STANDARD.BIT")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"1")  && ..DoublePeriod(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="AdaTypeSpecification">
<Description>
 Ada type specification ::= Ada qualified type specification | Ada unqualified type specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AdaQualifiedTypeSpecification(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..AdaUnqualifiedTypeSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AdaUnqualifiedTypeSpecification">
<Description>
 Ada unqualified type specification ::= CHAR left paren 1 double period length right paren | BIT left paren 1 double period length right paren | SMALLINT | INT | REAL | DOUBLE_PRECISION | SQLCODE_TYPE | SQLSTATE_TYPE | INDICATOR_TYPE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CHAR")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"1")  && ..DoublePeriod(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..AdaUnqualifiedTypeSpecification315Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SMALLINT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"REAL")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"DOUBLE_PRECISION")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SQLCODE_TYPE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SQLSTATE_TYPE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"INDICATOR_TYPE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AdaUnqualifiedTypeSpecification315Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"BIT")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"1")  && ..DoublePeriod(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="AdaVariableDefinition">
<Description>
 Ada variable definition ::= Ada host identifier [ { comma Ada host identifier }... ] colon Ada type specification [ Ada initial value ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AdaHostIdentifier(subElement,.addedElement)  && $S(..AdaVariableDefinition311RepOne(subElement,.addedElement) :1,1:1) && ..Colon(subElement,.addedElement)  && ..AdaTypeSpecification(subElement,.addedElement)  && $S(..AdaInitialValue(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AdaVariableDefinition311RepOne">
<Description>
 { comma Ada host identifier }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..AdaVariableDefinition312Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="AdaVariableDefinition312Sub">
<Description>
 comma Ada host identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..AdaHostIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AddColumnDefinition">
<Description>
 add column definition ::= ADD [ COLUMN ] column definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ADD")  && $S(..addKeyword(subElement,"COLUMN") :1,1:1) && ..ColumnDefinition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AddDomainConstraintDefinition">
<Description>
 add domain constraint definition ::= ADD domain constraint</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ADD")  && ..DomainConstraint(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AddTableConstraintDefinition">
<Description>
 add table constraint definition ::= ADD table constraint definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..AddTableConstraintDefinition256Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AddTableConstraintDefinition256Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"ADD")  && ..TableConstraintDefinition(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="All">
<Description>
 all ::= ALL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..All210Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="All210Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"ALL")  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AllocateCursorStatement">
<Description>
 allocate cursor statement ::= ALLOCATE extended cursor name [ INSENSITIVE ] [ SCROLL ] CURSOR FOR extended statement name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ALLOCATE")  && ..ExtendedCursorName(subElement,.addedElement)  && $S(..addKeyword(subElement,"INSENSITIVE") :1,1:1) && $S(..addKeyword(subElement,"SCROLL") :1,1:1) && ..addKeyword(subElement,"CURSOR")  && ..addKeyword(subElement,"FOR")  && ..ExtendedStatementName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AllocateDescriptorStatement">
<Description>
 allocate descriptor statement ::= ALLOCATE DESCRIPTOR descriptor name [ WITH MAX occurrences ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ALLOCATE")  && ..addKeyword(subElement,"DESCRIPTOR")  && ..DescriptorName(subElement,.addedElement)  && ..AllocateDescriptorStatement287OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AllocateDescriptorStatement287OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WITH")  && ..addKeyword(subElement,"MAX")  && ..Occurrences(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AlterColumnAction">
<Description>
 alter column action ::= set column default clause | drop column default clause</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SetColumnDefaultClause(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DropColumnDefaultClause(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AlterColumnDefinition">
<Description>
 alter column definition ::= ALTER [ COLUMN ] column name alter column action</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ALTER")  && $S(..addKeyword(subElement,"COLUMN") :1,1:1) && ..ColumnName(subElement,.addedElement)  && ..AlterColumnAction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AlterDomainAction">
<Description>
 alter domain action ::= set domain default clause | drop domain default clause | add domain constraint definition | drop domain constraint definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SetDomainDefaultClause(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DropDomainDefaultClause(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..AddDomainConstraintDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DropDomainConstraintDefinition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AlterDomainStatement">
<Description>
 alter domain statement ::= ALTER DOMAIN domain name alter domain action</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ALTER")  && ..addKeyword(subElement,"DOMAIN")  && ..DomainName(subElement,.addedElement)  && ..AlterDomainAction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AlterTableAction">
<Description>
 alter table action ::= add column definition | alter column definition | drop column definition | add table constraint definition | drop table constraint definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AddColumnDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..AlterColumnDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DropColumnDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..AddTableConstraintDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DropTableConstraintDefinition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AlterTableStatement">
<Description>
 alter table statement ::= ALTER TABLE table name alter table action</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ALTER")  && ..addKeyword(subElement,"TABLE")  && ..TableName(subElement,.addedElement)  && ..AlterTableAction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Ampersand">
<Description><![CDATA[
 ampersand ::= &]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"&") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ApproximateNumericLiteral">
<Description>
 approximate numeric literal ::= mantissa E exponent</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Mantissa(subElement,.addedElement)  && ..addKeyword(subElement,"E")  && ..Exponent(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ApproximateNumericType">
<Description>
 approximate numeric type ::= FLOAT [ left paren precision right paren ] | REAL | DOUBLE PRECISION</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"FLOAT")  && ..ApproximateNumericType100OptGrp(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"REAL")  {
			set done=1 ; or
		} elseif ..ApproximateNumericType101Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ApproximateNumericType100OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Precision(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ApproximateNumericType101Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"DOUBLE")  && ..addKeyword(subElement,"PRECISION")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Arc1">
<Description>
 arc1 ::= iso | 1 | iso left paren 1 right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ISO")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"1")  {
			set done=1 ; or
		} elseif ..Arc1333Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Arc1333Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"ISO")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"1")  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Arc2">
<Description>
 arc2 ::= standard | 0 | standard left paren 0 right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"STANDARD")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"0")  {
			set done=1 ; or
		} elseif ..Arc2334Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Arc2334Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"STANDARD")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"0")  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Arc3">
<Description>
 arc3 ::= 9075</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"9075")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Argument">
<Description>
 argument ::= target specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TargetSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AsClause">
<Description>
 as clause ::= [ AS ] column name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..addKeyword(subElement,"AS") :1,1:1) && ..ColumnName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AssertionCheck">
<Description>
 assertion check ::= CHECK left paren search condition right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CHECK")  && ..LeftParen(subElement,.addedElement)  && ..SearchCondition(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AssertionDefinition">
<Description>
 assertion definition ::= CREATE ASSERTION constraint name assertion check [ constraint attributes ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CREATE")  && ..addKeyword(subElement,"ASSERTION")  && ..ConstraintName(subElement,.addedElement)  && ..AssertionCheck(subElement,.addedElement)  && $S(..ConstraintAttributes(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Asterisk">
<Description>
 asterisk ::= *</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"*") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="AuthorizationIdentifier">
<Description>
 authorization identifier ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BetweenPredicate">
<Description>
 between predicate ::= row value constructor [ NOT ] BETWEEN row value constructor AND row value constructor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RowValueConstructor(subElement,.addedElement)  && $S(..addKeyword(subElement,"NOT") :1,1:1) && ..addKeyword(subElement,"BETWEEN")  && ..RowValueConstructor(subElement,.addedElement)  && ..addKeyword(subElement,"AND")  && ..RowValueConstructor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Bit">
<Description>
 bit ::= 0 | 1</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"0")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"1")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitConcatenation">
<Description>
 bit concatenation ::= bit value expression concatenation operator bit factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..BitValueExpression(subElement,.addedElement)  && ..ConcatenationOperator(subElement,.addedElement)  && ..BitFactor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitFactor">
<Description>
 bit factor ::= bit primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..BitPrimary(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitLengthExpression">
<Description>
 bit length expression ::= BIT_LENGTH left paren string value expression right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"BIT_LENGTH")  && ..LeftParen(subElement,.addedElement)  && ..StringValueExpression(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitPrimary">
<Description>
 bit primary ::= value expression primary | string value function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpressionPrimary(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StringValueFunction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitStringLiteral">
<Description>
 bit string literal ::= B quote [ bit ... ] quote [ { separator... quote [ bit... ] quote }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"B")  && ..Quote(subElement,.addedElement)  && $S(..BitStringLiteral19RepOne(subElement,.addedElement) :1,1:1) && ..Quote(subElement,.addedElement)  && $S(..BitStringLiteral20RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitStringLiteral19RepOne">
<Description>
 bit ...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Bit(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BitStringLiteral20RepOne">
<Description>
 { separator... quote [ bit... ] quote }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..BitStringLiteral21Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BitStringLiteral21Sub">
<Description>
 separator... quote [ bit... ] quote</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BitStringLiteral22RepOne(subElement,.addedElement)  && ..Quote(subElement,.addedElement)  && $S(..BitStringLiteral23RepOne(subElement,.addedElement) :1,1:1) && ..Quote(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitStringLiteral22RepOne">
<Description>
 separator...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Separator(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BitStringLiteral23RepOne">
<Description>
 bit...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Bit(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="BitStringType">
<Description>
 bit string type ::= BIT [ left paren length right paren ] | BIT VARYING [ left paren length right paren ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"BIT")  && ..BitStringType88OptGrp(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..BitStringType89Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitStringType88OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitStringType89Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"BIT")  && ..addKeyword(subElement,"VARYING")  && ..BitStringType90OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="BitStringType90OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitSubstringFunction">
<Description>
 bit substring function ::= SUBSTRING left paren bit value expression FROM start position [ FOR string length ] right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SUBSTRING")  && ..LeftParen(subElement,.addedElement)  && ..BitValueExpression(subElement,.addedElement)  && ..addKeyword(subElement,"FROM")  && ..StartPosition(subElement,.addedElement)  && ..BitSubstringFunction185OptGrp(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitSubstringFunction185OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FOR")  && ..StringLength(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitValueExpression">
<Description>
 bit value expression ::= bit concatenation | bit factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..BitConcatenation(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..BitFactor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BitValueFunction">
<Description>
 bit value function ::= bit substring function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..BitSubstringFunction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BooleanFactor">
<Description>
 boolean factor ::= [ NOT ] boolean test</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..addKeyword(subElement,"NOT") :1,1:1) && ..BooleanTest(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BooleanPrimary">
<Description>
 boolean primary ::= predicate | left paren search condition right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Predicate(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..BooleanPrimary134Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BooleanPrimary134Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LeftParen(subElement,.addedElement)  && ..SearchCondition(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="BooleanTerm">
<Description>
 boolean term ::= boolean factor | boolean term AND boolean factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..BooleanTerm131Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BooleanTerm131Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..BooleanFactor(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BooleanTerm132Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BooleanTerm132Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..BooleanTerm(subElement,.addedElement)  && ..addKeyword(subElement,"AND")  && ..BooleanFactor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BooleanTest">
<Description>
 boolean test ::= boolean primary [ IS [ NOT ] truth value ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..BooleanPrimary(subElement,.addedElement)  && ..BooleanTest133OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="BooleanTest133OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"IS")  && $S(..addKeyword(subElement,"NOT") :1,1:1) && ..TruthValue(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CArraySpecification">
<Description>
 C array specification ::= left bracket length right bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LeftBracket(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightBracket(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CBitVariable">
<Description>
 C bit variable ::= BIT C host identifier C array specification [ C initial value ] [ { comma C host identifier C array specification [ C initial value ] }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"BIT")  && ..CHostIdentifier(subElement,.addedElement)  && ..CArraySpecification(subElement,.addedElement)  && $S(..CInitialValue(subElement,.addedElement) :1,1:1) && $S(..CBitVariable325RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CBitVariable325RepOne">
<Description>
 { comma C host identifier C array specification [ C initial value ] }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CBitVariable326Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CBitVariable326Sub">
<Description>
 comma C host identifier C array specification [ C initial value ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..CHostIdentifier(subElement,.addedElement)  && ..CArraySpecification(subElement,.addedElement)  && $S(..CInitialValue(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CCharacterVariable">
<Description>
 C character variable ::= char [ CHARACTER SET [ IS ] character set specification ] C host identifier C array specification [ C initial value ] [ { comma C host identifier C array specification [ C initial value ] }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CHAR")  && ..CCharacterVariable319OptGrp(subElement,.addedElement)  && ..CHostIdentifier(subElement,.addedElement)  && ..CArraySpecification(subElement,.addedElement)  && $S(..CInitialValue(subElement,.addedElement) :1,1:1) && $S(..CCharacterVariable320RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CCharacterVariable319OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CHARACTER")  && ..addKeyword(subElement,"SET")  && $S(..addKeyword(subElement,"IS") :1,1:1) && ..CharacterSetSpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CCharacterVariable320RepOne">
<Description>
 { comma C host identifier C array specification [ C initial value ] }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CCharacterVariable321Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CCharacterVariable321Sub">
<Description>
 comma C host identifier C array specification [ C initial value ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..CHostIdentifier(subElement,.addedElement)  && ..CArraySpecification(subElement,.addedElement)  && $S(..CInitialValue(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CClassModifier">
<Description>
 C class modifier ::= const | volatile</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CONST")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"VOLATILE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CDerivedVariable">
<Description>
 C derived variable ::= C VARCHAR variable | C bit variable</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CVarcharVariable(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CBitVariable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CHostIdentifier">
<Description>
 C host identifier ::= !! See syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CInitialValue">
<Description>
 C initial value ::= equals operator character representation</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..EqualsOperator(subElement,.addedElement)  && ..CharacterRepresentation(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CNumericVariable">
<Description>
 C numeric variable ::= { long | short | float | double } C host identifier [ C initial value ] [ { comma C host identifier [ C initial value ] }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CNumericVariable316Sub(subElement,.addedElement)  && ..CHostIdentifier(subElement,.addedElement)  && $S(..CInitialValue(subElement,.addedElement) :1,1:1) && $S(..CNumericVariable317RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CNumericVariable316Sub">
<Description>
 long | short | float | double</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"LONG")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SHORT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FLOAT")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DOUBLE")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CNumericVariable317RepOne">
<Description>
 { comma C host identifier [ C initial value ] }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CNumericVariable318Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CNumericVariable318Sub">
<Description>
 comma C host identifier [ C initial value ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..CHostIdentifier(subElement,.addedElement)  && $S(..CInitialValue(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CStorageClass">
<Description>
 C storage class ::= auto | extern | static</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"AUTO")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"EXTERN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"STATIC")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CVarcharVariable">
<Description>
 C VARCHAR variable ::= VARCHAR [ CHARACTER SET [ IS ] character set specification ] C host identifier C array specification [ C initial value ] [ { comma C host identifier C array specification [ C initial value ] }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"VARCHAR")  && ..CVarcharVariable322OptGrp(subElement,.addedElement)  && ..CHostIdentifier(subElement,.addedElement)  && ..CArraySpecification(subElement,.addedElement)  && $S(..CInitialValue(subElement,.addedElement) :1,1:1) && $S(..CVarcharVariable323RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CVarcharVariable322OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CHARACTER")  && ..addKeyword(subElement,"SET")  && $S(..addKeyword(subElement,"IS") :1,1:1) && ..CharacterSetSpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CVarcharVariable323RepOne">
<Description>
 { comma C host identifier C array specification [ C initial value ] }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CVarcharVariable324Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CVarcharVariable324Sub">
<Description>
 comma C host identifier C array specification [ C initial value ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..CHostIdentifier(subElement,.addedElement)  && ..CArraySpecification(subElement,.addedElement)  && $S(..CInitialValue(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CVariableDefinition">
<Description>
 C variable definition ::= [ C storage class ] [ C class modifier ] C variable specification semicolon</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..CStorageClass(subElement,.addedElement) :1,1:1) && $S(..CClassModifier(subElement,.addedElement) :1,1:1) && ..CVariableSpecification(subElement,.addedElement)  && ..Semicolon(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CVariableSpecification">
<Description>
 C variable specification ::= C numeric variable | C character variable | C derived variable</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CNumericVariable(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CCharacterVariable(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CDerivedVariable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseAbbreviation">
<Description>
 case abbreviation ::= NULLIF left paren value expression comma value expression right paren | COALESCE left paren value expression { comma value expression }... right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"NULLIF")  && ..LeftParen(subElement,.addedElement)  && ..ValueExpression(subElement,.addedElement)  && ..Comma(subElement,.addedElement)  && ..ValueExpression(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CaseAbbreviation174Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseAbbreviation174Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"COALESCE")  && ..LeftParen(subElement,.addedElement)  && ..ValueExpression(subElement,.addedElement)  && ..CaseAbbreviation175RepOne(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="CaseAbbreviation175RepOne">
<Description>
 { comma value expression }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CaseAbbreviation176Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CaseAbbreviation176Sub">
<Description>
 comma value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..ValueExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseExpression">
<Description>
 case expression ::= case abbreviation | case specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CaseAbbreviation(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CaseSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseOperand">
<Description>
 case operand ::= value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CaseSpecification">
<Description>
 case specification ::= simple case | searched case</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleCase(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SearchedCase(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CastOperand">
<Description>
 cast operand ::= value expression | NULL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpression(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NULL")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CastSpecification">
<Description>
 cast specification ::= CAST left paren cast operand AS cast target right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CAST")  && ..LeftParen(subElement,.addedElement)  && ..CastOperand(subElement,.addedElement)  && ..addKeyword(subElement,"AS")  && ..CastTarget(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CastTarget">
<Description>
 cast target ::= domain name | data type</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DomainName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DataType(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CatalogName">
<Description>
 catalog name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharLengthExpression">
<Description>
 char length expression ::= { CHAR_LENGTH | CHARACTER_LENGTH } left paren string value expression right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharLengthExpression202Sub(subElement,.addedElement)  && ..LeftParen(subElement,.addedElement)  && ..StringValueExpression(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharLengthExpression202Sub">
<Description>
 CHAR_LENGTH | CHARACTER_LENGTH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"CHAR_LENGTH")  {
		set done=1 ; or
	} elseif ..addPunctuation(subElement,"CHARACTER_LENGTH")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterFactor">
<Description>
 character factor ::= character primary [ collate clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterPrimary(subElement,.addedElement)  && $S(..CollateClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterPrimary">
<Description>
 character primary ::= value expression primary | string value function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpressionPrimary(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StringValueFunction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterRepresentation">
<Description>
 character representation ::= nonquote character | quote symbol</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..NonquoteCharacter(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..QuoteSymbol(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterSetDefinition">
<Description>
 character set definition ::= CREATE CHARACTER SET character set name [ AS ] character set source [ collate clause | limited collation definition ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CREATE")  && ..addKeyword(subElement,"CHARACTER")  && ..addKeyword(subElement,"SET")  && ..CharacterSetName(subElement,.addedElement)  && $S(..addKeyword(subElement,"AS") :1,1:1) && ..CharacterSetSource(subElement,.addedElement)  && ..CharacterSetDefinition250OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterSetDefinition250OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CollateClause(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..LimitedCollationDefinition(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterSetName">
<Description>
 character set name ::= [ schema name period ] SQL language identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterSetName35OptGrp(subElement,.addedElement)  && ..SqlLanguageIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterSetName35OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SchemaName(subElement,.addedElement)  && ..Period(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterSetSource">
<Description>
 character set source ::= GET existing character set name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"GET")  && ..ExistingCharacterSetName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterSetSpecification">
<Description>
 character set specification ::= standard character repertoire name | implementation-defined character repertoire name | user-defined character repertoire name | standard universal character form-of-use name | implementation-defined universal character form-of-use name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StandardCharacterRepertoireName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ImplementationDefinedCharacterRepertoireName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..UserDefinedCharacterRepertoireName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StandardUniversalCharacterFormOfUseName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ImplementationDefinedUniversalCharacterFormOfUseName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringLiteral">
<Description>
 character string literal ::= [ introducercharacter set specification ] quote [ character representation... ] quote [ { separator... quote [ character representation... ] quote }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterStringLiteral29OptGrp(subElement,.addedElement)  && ..Quote(subElement,.addedElement)  && $S(..CharacterStringLiteral30RepOne(subElement,.addedElement) :1,1:1) && ..Quote(subElement,.addedElement)  && $S(..CharacterStringLiteral31RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringLiteral29OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Introducer(subElement,.addedElement)  && ..CharacterSetSpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringLiteral30RepOne">
<Description>
 character representation...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CharacterRepresentation(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringLiteral31RepOne">
<Description>
 { separator... quote [ character representation... ] quote }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CharacterStringLiteral32Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringLiteral32Sub">
<Description>
 separator... quote [ character representation... ] quote</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CharacterStringLiteral33RepOne(subElement,.addedElement)  && ..Quote(subElement,.addedElement)  && $S(..CharacterStringLiteral34RepOne(subElement,.addedElement) :1,1:1) && ..Quote(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringLiteral33RepOne">
<Description>
 separator...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Separator(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringLiteral34RepOne">
<Description>
 character representation...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CharacterRepresentation(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringType">
<Description>
 character string type ::= CHARACTER [ left paren length right paren ] | CHAR [ left paren length right paren ] | CHARACTER VARYING [ left paren length right paren ] | CHAR VARYING [ left paren length right paren ] | VARCHAR [ left paren length right paren ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CHARACTER")  && ..CharacterStringType68OptGrp(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CharacterStringType69Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CharacterStringType71Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CharacterStringType73Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CharacterStringType75Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringType68OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringType69Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"CHAR")  && ..CharacterStringType70OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringType70OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringType71Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"CHARACTER")  && ..addKeyword(subElement,"VARYING")  && ..CharacterStringType72OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringType72OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringType73Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"CHAR")  && ..addKeyword(subElement,"VARYING")  && ..CharacterStringType74OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringType74OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringType75Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"VARCHAR")  && ..CharacterStringType76OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="CharacterStringType76OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterSubstringFunction">
<Description>
 character substring function ::= SUBSTRING left paren character value expression FROM start position [ FOR string length ] right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SUBSTRING")  && ..LeftParen(subElement,.addedElement)  && ..CharacterValueExpression(subElement,.addedElement)  && ..addKeyword(subElement,"FROM")  && ..StartPosition(subElement,.addedElement)  && ..CharacterSubstringFunction181OptGrp(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterSubstringFunction181OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FOR")  && ..StringLength(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterTranslation">
<Description>
 character translation ::= TRANSLATE left paren character value expression USING translation name right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"TRANSLATE")  && ..LeftParen(subElement,.addedElement)  && ..CharacterValueExpression(subElement,.addedElement)  && ..addKeyword(subElement,"USING")  && ..TranslationName(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterValueExpression">
<Description>
 character value expression ::= concatenation | character factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Concatenation(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CharacterFactor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CharacterValueFunction">
<Description>
 character value function ::= character substring function | fold | form-of-use conversion | character translation | trim function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterSubstringFunction(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Fold(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..FormOfUseConversion(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CharacterTranslation(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TrimFunction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CheckConstraintDefinition">
<Description>
 check constraint definition ::= CHECK left paren search condition right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CHECK")  && ..LeftParen(subElement,.addedElement)  && ..SearchCondition(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CloseStatement">
<Description>
 close statement ::= CLOSE cursor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CLOSE")  && ..CursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CobolHostIdentifier">
<Description>
 Cobol host identifier ::= !! See syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CobolVariableDefinition">
<Description>
 Cobol variable definition ::= ...omitted...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	quit 0 ; omitted rule never true
]]></Implementation>
</Method>

<Method name="CollateClause">
<Description>
 collate clause ::= COLLATE collation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"COLLATE")  && ..CollationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CollatingSequenceDefinition">
<Description>
 collating sequence definition ::= external collation | schema collation name | DESC left paren collation name right paren | DEFAULT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ExternalCollation(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SchemaCollationName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CollatingSequenceDefinition251Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DEFAULT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CollatingSequenceDefinition251Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"DESC")  && ..LeftParen(subElement,.addedElement)  && ..CollationName(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="CollationDefinition">
<Description>
 collation definition ::= CREATE COLLATION collation name FOR character set specification FROM collation source [ pad attribute ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CREATE")  && ..addKeyword(subElement,"COLLATION")  && ..CollationName(subElement,.addedElement)  && ..addKeyword(subElement,"FOR")  && ..CharacterSetSpecification(subElement,.addedElement)  && ..addKeyword(subElement,"FROM")  && ..CollationSource(subElement,.addedElement)  && $S(..PadAttribute(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CollationName">
<Description>
 collation name ::= qualified name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..QualifiedName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CollationSource">
<Description>
 collation source ::= collating sequence definition | translation collation</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CollatingSequenceDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TranslationCollation(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Colon">
<Description>
 colon ::= :</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,":") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnConstraint">
<Description>
 column constraint ::= NOT NULL | unique specification | references specification | check constraint definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"NOT")  && ..addKeyword(subElement,"NULL")  {
			set done=1 ; or
		} elseif ..UniqueSpecification(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ReferencesSpecification(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CheckConstraintDefinition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnConstraintDefinition">
<Description>
 column constraint definition ::= [ constraint name definition ] column constraint [ constraint attributes ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..ConstraintNameDefinition(subElement,.addedElement) :1,1:1) && ..ColumnConstraint(subElement,.addedElement)  && $S(..ConstraintAttributes(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnDefinition">
<Description>
 column definition ::= column name { data type | domain name } [ default clause ] [ column constraint definition... ] [ collate clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnName(subElement,.addedElement)  && ..ColumnDefinition65Sub(subElement,.addedElement)  && $S(..DefaultClause(subElement,.addedElement) :1,1:1) && $S(..ColumnDefinition66RepOne(subElement,.addedElement) :1,1:1) && $S(..CollateClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnDefinition65Sub">
<Description>
 data type | domain name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DataType(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DomainName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnDefinition66RepOne">
<Description>
 column constraint definition...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ColumnConstraintDefinition(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnName">
<Description>
 column name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnNameList">
<Description>
 column name list ::= column name [ { comma column name }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnName(subElement,.addedElement)  && $S(..ColumnNameList123RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnNameList123RepOne">
<Description>
 { comma column name }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ColumnNameList124Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnNameList124Sub">
<Description>
 comma column name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..ColumnName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnReference">
<Description>
 column reference ::= [ qualifier period ] column name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnReference147OptGrp(subElement,.addedElement)  && ..ColumnName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ColumnReference147OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Qualifier(subElement,.addedElement)  && ..Period(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Comma">
<Description>
 comma ::= ,</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,",") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Comment">
<Description>
 comment ::= comment introducer [ comment character... ] newline</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Comment16Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Comment16Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..CommentIntroducer(subElement,.addedElement)  && $S(..Comment17RepOne(subElement,.addedElement) :1,1:1) && ..Newline(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Comment17RepOne">
<Description>
 comment character...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CommentCharacter(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CommentCharacter">
<Description>
 comment character ::= nonquote character | quote</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..NonquoteCharacter(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Quote(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CommentIntroducer">
<Description>
 comment introducer ::= minus signminus sign [minus sign...]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..MinusSign(subElement,.addedElement)  && ..MinusSign(subElement,.addedElement)  && $S(..CommentIntroducer18RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CommentIntroducer18RepOne">
<Description>
minus sign...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..MinusSign(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="CommitStatement">
<Description>
 commit statement ::= COMMIT [ WORK ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"COMMIT")  && $S(..addKeyword(subElement,"WORK") :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CompOp">
<Description>
 comp op ::= equals operator | not equals operator | less than operator | greater than operator | less than or equals operator | greater than or equals operator</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..EqualsOperator(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NotEqualsOperator(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LessThanOperator(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GreaterThanOperator(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LessThanOrEqualsOperator(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GreaterThanOrEqualsOperator(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ComparisonPredicate">
<Description>
 comparison predicate ::= row value constructor comp op row value constructor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RowValueConstructor(subElement,.addedElement)  && ..CompOp(subElement,.addedElement)  && ..RowValueConstructor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Concatenation">
<Description>
 concatenation ::= character value expression concatenation operator character factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Concatenation180Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Concatenation180Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..CharacterValueExpression(subElement,.addedElement)  && ..ConcatenationOperator(subElement,.addedElement)  && ..CharacterFactor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConcatenationOperator">
<Description>
 concatenation operator ::= ||</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"||") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Condition">
<Description>
 condition ::= SQLERROR | NOT FOUND</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SQLERROR")  {
			set done=1 ; or
		} elseif ..Condition328Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Condition328Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"NOT")  && ..addKeyword(subElement,"FOUND")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ConditionAction">
<Description>
 condition action ::= CONTINUE | go to</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CONTINUE")  {
			set done=1 ; or
		} elseif ..GoTo(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionInformation">
<Description>
 condition information ::= EXCEPTION condition number condition information item [ { comma condition information item }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..ConditionInformation305Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionInformation305Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"EXCEPTION")  && ..ConditionNumber(subElement,.addedElement)  && ..ConditionInformationItem(subElement,.addedElement)  && $S(..ConditionInformation306RepOne(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionInformation306RepOne">
<Description>
 { comma condition information item }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ConditionInformation307Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionInformation307Sub">
<Description>
 comma condition information item</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..ConditionInformationItem(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionInformationItem">
<Description>
 condition information item ::= simple target specification equals operator condition information item name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..ConditionInformationItem308Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionInformationItem308Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..SimpleTargetSpecification(subElement,.addedElement)  && ..EqualsOperator(subElement,.addedElement)  && ..ConditionInformationItemName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionInformationItemName">
<Description>
 condition information item name ::= CONDITION_NUMBER | RETURNED_SQLSTATE | CLASS_ORIGIN | SUBCLASS_ORIGIN | SERVER_NAME | CONNECTION_NAME | CONSTRAINT_CATALOG | CONSTRAINT_SCHEMA | CONSTRAINT_NAME | CATALOG_NAME | SCHEMA_NAME | TABLE_NAME | COLUMN_NAME | CURSOR_NAME | MESSAGE_TEXT | MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"CONDITION_NUMBER")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"RETURNED_SQLSTATE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CLASS_ORIGIN")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SUBCLASS_ORIGIN")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SERVER_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CONNECTION_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CONSTRAINT_CATALOG")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CONSTRAINT_SCHEMA")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CONSTRAINT_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CATALOG_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SCHEMA_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"TABLE_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"COLUMN_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CURSOR_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"MESSAGE_TEXT")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"MESSAGE_LENGTH")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"MESSAGE_OCTET_LENGTH")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConditionNumber">
<Description>
 condition number ::= simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConnectStatement">
<Description>
 connect statement ::= CONNECT TO connection target</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CONNECT")  && ..addKeyword(subElement,"TO")  && ..ConnectionTarget(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConnectionName">
<Description>
 connection name ::= simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConnectionObject">
<Description>
 connection object ::= DEFAULT | connection name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DEFAULT")  {
			set done=1 ; or
		} elseif ..ConnectionName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConnectionTarget">
<Description>
 connection target ::= SQL-server name [ AS connection name ] [ USER user name ] | DEFAULT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlServerName(subElement,.addedElement)  && ..ConnectionTarget284OptGrp(subElement,.addedElement)  && ..ConnectionTarget285OptGrp(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DEFAULT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConnectionTarget284OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"AS")  && ..ConnectionName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConnectionTarget285OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"USER")  && ..UserName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConstraintAttributes">
<Description>
 constraint attributes ::= constraint check time [ [ NOT ] DEFERRABLE ] | [ NOT ] DEFERRABLE [ constraint check time ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ConstraintCheckTime(subElement,.addedElement)  && ..ConstraintAttributes213OptGrp(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ConstraintAttributes214Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConstraintAttributes213OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..addKeyword(subElement,"NOT") :1,1:1) && ..addKeyword(subElement,"DEFERRABLE")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConstraintAttributes214Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if $S(..addKeyword(subElement,"NOT") :1,1:1) && ..addKeyword(subElement,"DEFERRABLE")  && $S(..ConstraintCheckTime(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ConstraintCheckTime">
<Description>
 constraint check time ::= INITIALLY DEFERRED | INITIALLY IMMEDIATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"INITIALLY")  && ..addKeyword(subElement,"DEFERRED")  {
			set done=1 ; or
		} elseif ..ConstraintCheckTime215Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConstraintCheckTime215Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"INITIALLY")  && ..addKeyword(subElement,"IMMEDIATE")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ConstraintName">
<Description>
 constraint name ::= qualified name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..QualifiedName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConstraintNameDefinition">
<Description>
 constraint name definition ::= CONSTRAINT constraint name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CONSTRAINT")  && ..ConstraintName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConstraintNameList">
<Description>
 constraint name list ::= ALL | constraint name [ { comma constraint name }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ALL")  {
			set done=1 ; or
		} elseif ..ConstraintNameList281Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ConstraintNameList281Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..ConstraintName(subElement,.addedElement)  && $S(..ConstraintNameList282RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ConstraintNameList282RepOne">
<Description>
 { comma constraint name }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ConstraintNameList283Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ConstraintNameList283Sub">
<Description>
 comma constraint name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..ConstraintName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CorrelationName">
<Description>
 correlation name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CorrelationSpecification">
<Description>
 correlation specification ::= [ AS ] correlation name [ left paren derived column list right paren ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..addKeyword(subElement,"AS") :1,1:1) && ..CorrelationName(subElement,.addedElement)  && ..CorrelationSpecification160OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CorrelationSpecification160OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..DerivedColumnList(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CorrespondingColumnList">
<Description>
 corresponding column list ::= column name list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnNameList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CorrespondingSpec">
<Description>
 corresponding spec ::= CORRESPONDING [ BY left paren corresponding column list right paren ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CORRESPONDING")  && ..CorrespondingSpec172OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CorrespondingSpec172OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"BY")  && ..LeftParen(subElement,.addedElement)  && ..CorrespondingColumnList(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CrossJoin">
<Description>
 cross join ::= table reference CROSS JOIN table reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..CrossJoin163Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CrossJoin163Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..TableReference(subElement,.addedElement)  && ..addKeyword(subElement,"CROSS")  && ..addKeyword(subElement,"JOIN")  && ..TableReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CurrentDateValueFunction">
<Description>
 current date value function ::= CURRENT_DATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"CURRENT_DATE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CurrentTimeValueFunction">
<Description>
 current time value function ::= CURRENT_TIME [ left paren time precision right paren ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"CURRENT_TIME")  && ..CurrentTimeValueFunction117OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CurrentTimeValueFunction117OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..TimePrecision(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CurrentTimestampValueFunction">
<Description>
 current timestamp value function ::= CURRENT_TIMESTAMP [ left paren timestamp precision right paren ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"CURRENT_TIMESTAMP")  && ..CurrentTimestampValueFunction118OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CurrentTimestampValueFunction118OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..TimestampPrecision(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CursorName">
<Description>
 cursor name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="CursorSpecification">
<Description>
 cursor specification ::= query expression [ order by clause ] [ updatability clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..QueryExpression(subElement,.addedElement)  && $S(..OrderByClause(subElement,.addedElement) :1,1:1) && $S(..UpdatabilityClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DataType">
<Description>
 data type ::= character string type [ CHARACTER SET character set specification ] | national character string type | bit string type | numeric type | datetime type | interval type</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterStringType(subElement,.addedElement)  && ..DataType67OptGrp(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NationalCharacterStringType(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..BitStringType(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NumericType(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DatetimeType(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..IntervalType(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DataType67OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"CHARACTER")  && ..addKeyword(subElement,"SET")  && ..CharacterSetSpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DateLiteral">
<Description>
 date literal ::= DATE date string</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DATE")  && ..DateString(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DateString">
<Description>
 date string ::= quote date value quote</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Quote(subElement,.addedElement)  && ..DateValue(subElement,.addedElement)  && ..Quote(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DateValue">
<Description>
 date value ::= years value minus sign months value minus sign days value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..YearsValue(subElement,.addedElement)  && ..MinusSign(subElement,.addedElement)  && ..MonthsValue(subElement,.addedElement)  && ..MinusSign(subElement,.addedElement)  && ..DaysValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeFactor">
<Description>
 datetime factor ::= datetime primary [ time zone ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DatetimePrimary(subElement,.addedElement)  && $S(..TimeZone(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeField">
<Description>
 datetime field ::= non-second datetime field | SECOND</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..DatetimeField186Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeField186Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..NonSecondDatetimeField(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"SECOND")  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeLiteral">
<Description>
 datetime literal ::= date literal | time literal | timestamp literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DateLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TimeLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TimestampLiteral(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimePrimary">
<Description>
 datetime primary ::= value expression primary | datetime value function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpressionPrimary(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DatetimeValueFunction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeTerm">
<Description>
 datetime term ::= datetime factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DatetimeFactor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeType">
<Description>
 datetime type ::= DATE | TIME [ left paren time precision right paren ] [ WITH TIME ZONE ] | TIMESTAMP [ left paren timestamp precision right paren ] [ WITH TIME ZONE ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DATE")  {
			set done=1 ; or
		} elseif ..DatetimeType102Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DatetimeType105Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeType102Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"TIME")  && ..DatetimeType103OptGrp(subElement,.addedElement)  && ..DatetimeType104OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="DatetimeType103OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..TimePrecision(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeType104OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WITH")  && ..addKeyword(subElement,"TIME")  && ..addKeyword(subElement,"ZONE")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeType105Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"TIMESTAMP")  && ..DatetimeType106OptGrp(subElement,.addedElement)  && ..DatetimeType107OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="DatetimeType106OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..TimestampPrecision(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeType107OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WITH")  && ..addKeyword(subElement,"TIME")  && ..addKeyword(subElement,"ZONE")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeValue">
<Description>
 datetime value ::= unsigned integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeValueExpression">
<Description>
 datetime value expression ::= datetime term | interval value expression plus sign datetime term | datetime value expression plus sign interval term | datetime value expression minus sign interval term</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..DatetimeValueExpression187Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeValueExpression187Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..DatetimeTerm(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DatetimeValueExpression188Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DatetimeValueExpression189Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DatetimeValueExpression190Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeValueExpression188Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IntervalValueExpression(subElement,.addedElement)  && ..PlusSign(subElement,.addedElement)  && ..DatetimeTerm(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeValueExpression189Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DatetimeValueExpression(subElement,.addedElement)  && ..PlusSign(subElement,.addedElement)  && ..IntervalTerm(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeValueExpression190Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..DatetimeValueExpression(subElement,.addedElement)  && ..MinusSign(subElement,.addedElement)  && ..IntervalTerm(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DatetimeValueFunction">
<Description>
 datetime value function ::= current date value function | current time value function | current timestamp value function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CurrentDateValueFunction(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CurrentTimeValueFunction(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CurrentTimestampValueFunction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DayTimeInterval">
<Description>
 day-time interval ::= days value [ space hours value [ colon minutes value [ colon seconds value ] ] ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DaysValue(subElement,.addedElement)  && ..DayTimeInterval49OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DayTimeInterval49OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Space(subElement,.addedElement)  && ..HoursValue(subElement,.addedElement)  && ..DayTimeInterval50OptGrp(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DayTimeInterval50OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Colon(subElement,.addedElement)  && ..MinutesValue(subElement,.addedElement)  && ..DayTimeInterval51OptGrp(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DayTimeInterval51OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Colon(subElement,.addedElement)  && ..SecondsValue(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DayTimeLiteral">
<Description>
 day-time literal ::= day-time interval | time interval</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DayTimeInterval(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TimeInterval(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DaysValue">
<Description>
 days value ::= datetime value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DatetimeValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeallocateDescriptorStatement">
<Description>
 deallocate descriptor statement ::= DEALLOCATE DESCRIPTOR descriptor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DEALLOCATE")  && ..addKeyword(subElement,"DESCRIPTOR")  && ..DescriptorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeallocatePreparedStatement">
<Description>
 deallocate prepared statement ::= DEALLOCATE PREPARE SQL statement name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DEALLOCATE")  && ..addKeyword(subElement,"PREPARE")  && ..SqlStatementName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeclareCursor">
<Description>
 declare cursor ::= DECLARE cursor name [ INSENSITIVE ] [ SCROLL ] CURSOR FOR cursor specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..DeclareCursor216Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeclareCursor216Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"DECLARE")  && ..CursorName(subElement,.addedElement)  && $S(..addKeyword(subElement,"INSENSITIVE") :1,1:1) && $S(..addKeyword(subElement,"SCROLL") :1,1:1) && ..addKeyword(subElement,"CURSOR")  && ..addKeyword(subElement,"FOR")  && ..CursorSpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DefaultClause">
<Description>
 default clause ::= DEFAULT default option</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DEFAULT")  && ..DefaultOption(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DefaultOption">
<Description>
 default option ::= literal | datetime value function | USER | CURRENT_USER | SESSION_USER | SYSTEM_USER | NULL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Literal(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DatetimeValueFunction(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"USER")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CURRENT_USER")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SESSION_USER")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SYSTEM_USER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NULL")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DefaultSpecification">
<Description>
 default specification ::= DEFAULT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DEFAULT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeleteRule">
<Description>
 delete rule ::= ON DELETE referential action</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ON")  && ..addKeyword(subElement,"DELETE")  && ..ReferentialAction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeleteStatementPositioned">
<Description>
 delete statement: positioned ::= DELETE FROM table name WHERE CURRENT OF cursor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DELETE")  && ..addKeyword(subElement,"FROM")  && ..TableName(subElement,.addedElement)  && ..addKeyword(subElement,"WHERE")  && ..addKeyword(subElement,"CURRENT")  && ..addKeyword(subElement,"OF")  && ..CursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeleteStatementSearched">
<Description>
 delete statement: searched ::= DELETE FROM table name [ WHERE search condition ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DELETE")  && ..addKeyword(subElement,"FROM")  && ..TableName(subElement,.addedElement)  && ..DeleteStatementSearched267OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DeleteStatementSearched267OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WHERE")  && ..SearchCondition(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelimitedIdentifier">
<Description>
 delimited identifier ::= double quote delimited identifier body double quote</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..DelimitedIdentifier40Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelimitedIdentifier40Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..DoubleQuote(subElement,.addedElement)  && ..DelimitedIdentifierBody(subElement,.addedElement)  && ..DoubleQuote(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelimitedIdentifierBody">
<Description>
 delimited identifier body ::= delimited identifier part...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DelimitedIdentifierBody41RepOne(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelimitedIdentifierBody41RepOne">
<Description>
 delimited identifier part...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..DelimitedIdentifierPart(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="DelimitedIdentifierPart">
<Description>
 delimited identifier part ::= nondoublequote character | doublequote symbol</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..NondoublequoteCharacter(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DoublequoteSymbol(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DelimiterToken">
<Description>
 delimiter token ::= character string literal | date string | time string | timestamp string | delimited identifier | SQL special character | not equals operator | greater than or equals operator | less than or equals operator | concatenation operator | double period | left bracket | right bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterStringLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DateString(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TimeString(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TimestampString(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DelimitedIdentifier(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlSpecialCharacter(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NotEqualsOperator(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GreaterThanOrEqualsOperator(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LessThanOrEqualsOperator(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ConcatenationOperator(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DoublePeriod(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LeftBracket(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..RightBracket(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DerivedColumn">
<Description>
 derived column ::= value expression [ as clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpression(subElement,.addedElement)  && $S(..AsClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DerivedColumnList">
<Description>
 derived column list ::= column name list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnNameList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DerivedTable">
<Description>
 derived table ::= table subquery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TableSubquery(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DescribeInputStatement">
<Description>
 describe input statement ::= DESCRIBE INPUT SQL statement name using descriptor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DESCRIBE")  && ..addKeyword(subElement,"INPUT")  && ..SqlStatementName(subElement,.addedElement)  && ..UsingDescriptor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DescribeOutputStatement">
<Description>
 describe output statement ::= DESCRIBE [ OUTPUT ] SQL statement name using descriptor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DESCRIBE")  && $S(..addKeyword(subElement,"OUTPUT") :1,1:1) && ..SqlStatementName(subElement,.addedElement)  && ..UsingDescriptor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DescribeStatement">
<Description>
 describe statement ::= describe input statement | describe output statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DescribeInputStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DescribeOutputStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DescriptorItemName">
<Description>
 descriptor item name ::= TYPE | LENGTH | OCTET_LENGTH | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | PRECISION | SCALE | DATETIME_INTERVAL_CODE | DATETIME_INTERVAL_PRECISION | NULLABLE | INDICATOR | DATA | NAME | UNNAMED | COLLATION_CATALOG | COLLATION_SCHEMA | COLLATION_NAME | CHARACTER_SET_CATALOG | CHARACTER_SET_SCHEMA | CHARACTER_SET_NAME</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"TYPE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LENGTH")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"OCTET_LENGTH")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"RETURNED_LENGTH")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"RETURNED_OCTET_LENGTH")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PRECISION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SCALE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"DATETIME_INTERVAL_CODE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"DATETIME_INTERVAL_PRECISION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NULLABLE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INDICATOR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DATA")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NAME")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"UNNAMED")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"COLLATION_CATALOG")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"COLLATION_SCHEMA")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"COLLATION_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CHARACTER_SET_CATALOG")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CHARACTER_SET_SCHEMA")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CHARACTER_SET_NAME")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DescriptorName">
<Description>
 descriptor name ::= [ scope option ] simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..ScopeOption(subElement,.addedElement) :1,1:1) && ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DiagnosticsSize">
<Description>
 diagnostics size ::= DIAGNOSTICS SIZE number of conditions</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..DiagnosticsSize279Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DiagnosticsSize279Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"DIAGNOSTICS")  && ..addKeyword(subElement,"SIZE")  && ..NumberOfConditions(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Digit">
<Description>
 digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"0")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"1")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"2")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"3")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"4")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"5")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"6")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"7")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"8")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"9")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DirectImplementationDefinedStatement">
<Description>
 direct implementation-defined statement ::= !! See the syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DirectSelectStatementMultipleRows">
<Description>
 direct select statement: multiple rows ::= query expression [ order by clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..QueryExpression(subElement,.addedElement)  && $S(..OrderByClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DirectSqlDataStatement">
<Description>
 direct SQL data statement ::= delete statement: searched | direct select statement: multiple rows | insert statement | update statement: searched | temporary table declaration</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DeleteStatementSearched(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DirectSelectStatementMultipleRows(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..InsertStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..UpdateStatementSearched(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TemporaryTableDeclaration(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DirectSqlStatement">
<Description>
 direct SQL statement ::= direct SQL data statement | SQL schema statement | SQL transaction statement | SQL connection statement | SQL session statement | direct implementation-defined statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DirectSqlDataStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlSchemaStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlTransactionStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlConnectionStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlSessionStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DirectImplementationDefinedStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DisconnectObject">
<Description>
 disconnect object ::= connection object | ALL | CURRENT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ConnectionObject(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ALL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CURRENT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DisconnectStatement">
<Description>
 disconnect statement ::= DISCONNECT disconnect object</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DISCONNECT")  && ..DisconnectObject(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DomainConstraint">
<Description>
 domain constraint ::= [ constraint name definition ] check constraint definition [ constraint attributes ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..ConstraintNameDefinition(subElement,.addedElement) :1,1:1) && ..CheckConstraintDefinition(subElement,.addedElement)  && $S(..ConstraintAttributes(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DomainDefinition">
<Description>
 domain definition ::= CREATE DOMAIN domain name [ AS ] data type [ default clause ] [ domain constraint ] [ collate clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CREATE")  && ..addKeyword(subElement,"DOMAIN")  && ..DomainName(subElement,.addedElement)  && $S(..addKeyword(subElement,"AS") :1,1:1) && ..DataType(subElement,.addedElement)  && $S(..DefaultClause(subElement,.addedElement) :1,1:1) && $S(..DomainConstraint(subElement,.addedElement) :1,1:1) && $S(..CollateClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DomainName">
<Description>
 domain name ::= qualified name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..QualifiedName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoublePeriod">
<Description>
 double period ::= ..</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"..") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoubleQuote">
<Description>
 double quote ::= "</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"""") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DoublequoteSymbol">
<Description>
 doublequote symbol ::= double quotedouble quote</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DoubleQuote(subElement,.addedElement)  && ..DoubleQuote(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropAssertionStatement">
<Description>
 drop assertion statement ::= DROP ASSERTION constraint name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && ..addKeyword(subElement,"ASSERTION")  && ..ConstraintName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropBehaviour">
<Description>
 drop behaviour ::= CASCADE | RESTRICT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CASCADE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"RESTRICT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropCharacterSetStatement">
<Description>
 drop character set statement ::= DROP CHARACTER SET character set name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && ..addKeyword(subElement,"CHARACTER")  && ..addKeyword(subElement,"SET")  && ..CharacterSetName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropCollationStatement">
<Description>
 drop collation statement ::= DROP COLLATION collation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && ..addKeyword(subElement,"COLLATION")  && ..CollationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropColumnDefaultClause">
<Description>
 drop column default clause ::= DROP DEFAULT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && ..addKeyword(subElement,"DEFAULT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropColumnDefinition">
<Description>
 drop column definition ::= DROP [ COLUMN ] column name drop behaviour</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && $S(..addKeyword(subElement,"COLUMN") :1,1:1) && ..ColumnName(subElement,.addedElement)  && ..DropBehaviour(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropDomainConstraintDefinition">
<Description>
 drop domain constraint definition ::= DROP CONSTRAINT constraint name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && ..addKeyword(subElement,"CONSTRAINT")  && ..ConstraintName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropDomainDefaultClause">
<Description>
 drop domain default clause ::= DROP DEFAULT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && ..addKeyword(subElement,"DEFAULT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropDomainStatement">
<Description>
 drop domain statement ::= DROP DOMAIN domain name drop behaviour</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && ..addKeyword(subElement,"DOMAIN")  && ..DomainName(subElement,.addedElement)  && ..DropBehaviour(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropSchemaStatement">
<Description>
 drop schema statement ::= DROP SCHEMA schema name drop behaviour</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && ..addKeyword(subElement,"SCHEMA")  && ..SchemaName(subElement,.addedElement)  && ..DropBehaviour(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropTableConstraintDefinition">
<Description>
 drop table constraint definition ::= DROP CONSTRAINT constraint name drop behaviour</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && ..addKeyword(subElement,"CONSTRAINT")  && ..ConstraintName(subElement,.addedElement)  && ..DropBehaviour(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropTableStatement">
<Description>
 drop table statement ::= DROP TABLE table name drop behaviour</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && ..addKeyword(subElement,"TABLE")  && ..TableName(subElement,.addedElement)  && ..DropBehaviour(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropTranslationStatement">
<Description>
 drop translation statement ::= DROP TRANSLATION translation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && ..addKeyword(subElement,"TRANSLATION")  && ..TranslationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DropViewStatement">
<Description>
 drop view statement ::= DROP VIEW table name drop behaviour</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DROP")  && ..addKeyword(subElement,"VIEW")  && ..TableName(subElement,.addedElement)  && ..DropBehaviour(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicCloseStatement">
<Description>
 dynamic close statement ::= CLOSE dynamic cursor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CLOSE")  && ..DynamicCursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicCursorName">
<Description>
 dynamic cursor name ::= cursor name | extended cursor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CursorName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ExtendedCursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicDeclareCursor">
<Description>
 dynamic declare cursor ::= DECLARE cursor name [ INSENSITIVE ] [ SCROLL ] CURSOR FOR statement name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DECLARE")  && ..CursorName(subElement,.addedElement)  && $S(..addKeyword(subElement,"INSENSITIVE") :1,1:1) && $S(..addKeyword(subElement,"SCROLL") :1,1:1) && ..addKeyword(subElement,"CURSOR")  && ..addKeyword(subElement,"FOR")  && ..StatementName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicDeleteStatementPositioned">
<Description>
 dynamic delete statement: positioned ::= DELETE FROM table name WHERE CURRENT OF dynamic cursor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DELETE")  && ..addKeyword(subElement,"FROM")  && ..TableName(subElement,.addedElement)  && ..addKeyword(subElement,"WHERE")  && ..addKeyword(subElement,"CURRENT")  && ..addKeyword(subElement,"OF")  && ..DynamicCursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicFetchStatement">
<Description>
 dynamic fetch statement ::= FETCH [ [ fetch orientation ] FROM ] dynamic cursor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"FETCH")  && ..DynamicFetchStatement298OptGrp(subElement,.addedElement)  && ..DynamicCursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicFetchStatement298OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..FetchOrientation(subElement,.addedElement) :1,1:1) && ..addKeyword(subElement,"FROM")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicOpenStatement">
<Description>
 dynamic open statement ::= OPEN dynamic cursor name [ using clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"OPEN")  && ..DynamicCursorName(subElement,.addedElement)  && $S(..UsingClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicParameterSpecification">
<Description>
 dynamic parameter specification ::= question mark</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..QuestionMark(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicSelectStatement">
<Description>
 dynamic select statement ::= cursor specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CursorSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicSingleRowSelectStatement">
<Description>
 dynamic single row select statement ::= query specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..QuerySpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicUpdateStatementPositioned">
<Description>
 dynamic update statement: positioned ::= UPDATE table name SET set clause [ { comma set clause }... ] WHERE CURRENT OF dynamic cursor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"UPDATE")  && ..TableName(subElement,.addedElement)  && ..addKeyword(subElement,"SET")  && ..SetClause(subElement,.addedElement)  && $S(..DynamicUpdateStatementPositioned299RepOne(subElement,.addedElement) :1,1:1) && ..addKeyword(subElement,"WHERE")  && ..addKeyword(subElement,"CURRENT")  && ..addKeyword(subElement,"OF")  && ..DynamicCursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicUpdateStatementPositioned299RepOne">
<Description>
 { comma set clause }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..DynamicUpdateStatementPositioned300Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="DynamicUpdateStatementPositioned300Sub">
<Description>
 comma set clause</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..SetClause(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ElseClause">
<Description>
 else clause ::= ELSE result</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ELSE")  && ..Result(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedCharacterSetDeclaration">
<Description>
 embedded character set declaration ::= SQL NAMES ARE character set specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SQL")  && ..addKeyword(subElement,"NAMES")  && ..addKeyword(subElement,"ARE")  && ..CharacterSetSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedExceptionDeclaration">
<Description>
 embedded exception declaration ::= WHENEVER condition condition action</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"WHENEVER")  && ..Condition(subElement,.addedElement)  && ..ConditionAction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlAdaProgram">
<Description>
 embedded SQL Ada program ::= !! See the syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlBeginDeclare">
<Description>
 embedded SQL begin declare ::= SQL prefix BEGIN DECLARE SECTION [ SQL terminator ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlPrefix(subElement,.addedElement)  && ..addKeyword(subElement,"BEGIN")  && ..addKeyword(subElement,"DECLARE")  && ..addKeyword(subElement,"SECTION")  && $S(..SqlTerminator(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlCProgram">
<Description>
 embedded SQL C program ::= !! See the syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlCobolProgram">
<Description>
 embedded SQL Cobol program ::= !! See the syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlDeclareSection">
<Description>
 embedded SQL declare section ::= embedded SQL begin declare [ embedded character set declaration ] [ host variable definition ... ] embedded SQL end declare | embedded SQL MUMPS declare</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..EmbeddedSqlBeginDeclare(subElement,.addedElement)  && $S(..EmbeddedCharacterSetDeclaration(subElement,.addedElement) :1,1:1) && $S(..EmbeddedSqlDeclareSection309RepOne(subElement,.addedElement) :1,1:1) && ..EmbeddedSqlEndDeclare(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..EmbeddedSqlMumpsDeclare(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlDeclareSection309RepOne">
<Description>
 host variable definition ...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..HostVariableDefinition(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlEndDeclare">
<Description>
 embedded SQL end declare ::= SQL prefix END DECLARE SECTION [ SQL terminator ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlPrefix(subElement,.addedElement)  && ..addKeyword(subElement,"END")  && ..addKeyword(subElement,"DECLARE")  && ..addKeyword(subElement,"SECTION")  && $S(..SqlTerminator(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlFortranProgram">
<Description>
 embedded SQL Fortran program ::= !! See the syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlHostProgram">
<Description>
 embedded SQL host program ::= embedded SQL Ada program | embedded SQL C program | embedded SQL Cobol program | embedded SQL Fortran program | embedded SQL MUMPS program | embedded SQL Pascal program | embedded SQL PL/I program</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..EmbeddedSqlAdaProgram(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..EmbeddedSqlCProgram(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..EmbeddedSqlCobolProgram(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..EmbeddedSqlFortranProgram(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..EmbeddedSqlMumpsProgram(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..EmbeddedSqlPascalProgram(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..EmbeddedSqlPlIProgram(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlMumpsDeclare">
<Description>
 embedded SQL MUMPS declare ::= SQL prefix BEGIN DECLARE SECTION [ embedded character set declaration ] [ host variable definition... ] END DECLARE SECTION SQL terminator</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlPrefix(subElement,.addedElement)  && ..addKeyword(subElement,"BEGIN")  && ..addKeyword(subElement,"DECLARE")  && ..addKeyword(subElement,"SECTION")  && $S(..EmbeddedCharacterSetDeclaration(subElement,.addedElement) :1,1:1) && $S(..EmbeddedSqlMumpsDeclare327RepOne(subElement,.addedElement) :1,1:1) && ..addKeyword(subElement,"END")  && ..addKeyword(subElement,"DECLARE")  && ..addKeyword(subElement,"SECTION")  && ..SqlTerminator(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlMumpsDeclare327RepOne">
<Description>
 host variable definition...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..HostVariableDefinition(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlMumpsProgram">
<Description>
 embedded SQL MUMPS program ::= !! See the syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlPascalProgram">
<Description>
 embedded SQL Pascal program ::= !! See the syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlPlIProgram">
<Description>
 embedded SQL PL/I program ::= !! See the syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedSqlStatement">
<Description>
 embedded SQL statement ::= SQL prefix statement or declaration [ SQL terminator ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlPrefix(subElement,.addedElement)  && ..StatementOrDeclaration(subElement,.addedElement)  && $S(..SqlTerminator(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EmbeddedVariableName">
<Description>
 embedded variable name ::= colonhost identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Colon(subElement,.addedElement)  && ..HostIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EndField">
<Description>
 end field ::= non-second datetime field | SECOND [ left paren interval fractional seconds precision right paren ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..NonSecondDatetimeField(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..EndField109Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EndField109Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"SECOND")  && ..EndField110OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="EndField110OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..IntervalFractionalSecondsPrecision(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EqualsOperator">
<Description>
 equals operator ::= =</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"=") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="EscapeCharacter">
<Description>
 escape character ::= character value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericLiteral">
<Description>
 exact numeric literal ::= unsigned integer [ period [ unsigned integer ] ] | period unsigned integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedInteger(subElement,.addedElement)  && ..ExactNumericLiteral5OptGrp(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ExactNumericLiteral6Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericLiteral5OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Period(subElement,.addedElement)  && $S(..UnsignedInteger(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericLiteral6Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Period(subElement,.addedElement)  && ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericType">
<Description>
 exact numeric type ::= NUMERIC [ left paren precision [ comma scale ] right paren ] | DECIMAL [ left paren precision [ comma scale ] right paren ] | DEC [ left paren precision [ comma scale ] right paren ] | INTEGER | INT | SMALLINT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"NUMERIC")  && ..ExactNumericType92OptGrp(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ExactNumericType94Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ExactNumericType97Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INTEGER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SMALLINT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericType92OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Precision(subElement,.addedElement)  && ..ExactNumericType93OptGrp(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericType93OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..Scale(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericType94Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"DECIMAL")  && ..ExactNumericType95OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericType95OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Precision(subElement,.addedElement)  && ..ExactNumericType96OptGrp(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericType96OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..Scale(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericType97Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"DEC")  && ..ExactNumericType98OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericType98OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Precision(subElement,.addedElement)  && ..ExactNumericType99OptGrp(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExactNumericType99OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..Scale(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExecuteImmediateStatement">
<Description>
 execute immediate statement ::= EXECUTE IMMEDIATE SQL statement variable</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"EXECUTE")  && ..addKeyword(subElement,"IMMEDIATE")  && ..SqlStatementVariable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExecuteStatement">
<Description>
 execute statement ::= EXECUTE SQL statement name [ result using clause ] [ parameter using clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"EXECUTE")  && ..SqlStatementName(subElement,.addedElement)  && $S(..ResultUsingClause(subElement,.addedElement) :1,1:1) && $S(..ParameterUsingClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExistingCharacterSetName">
<Description>
 existing character set name ::= standard character repertoire name | implementation-defined character repertoire name | schema character set name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StandardCharacterRepertoireName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ImplementationDefinedCharacterRepertoireName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SchemaCharacterSetName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExistsPredicate">
<Description>
 exists predicate ::= EXISTS table subquery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"EXISTS")  && ..TableSubquery(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExplicitTable">
<Description>
 explicit table ::= TABLE table name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"TABLE")  && ..TableName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Exponent">
<Description>
 exponent ::= signed integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtendedCursorName">
<Description>
 extended cursor name ::= [ scope option ] simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..ScopeOption(subElement,.addedElement) :1,1:1) && ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtendedStatementName">
<Description>
 extended statement name ::= [ scope option ] simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..ScopeOption(subElement,.addedElement) :1,1:1) && ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExternalCollation">
<Description>
 external collation ::= EXTERNAL left paren quote external collation name quote right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..ExternalCollation252Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExternalCollation252Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"EXTERNAL")  && ..LeftParen(subElement,.addedElement)  && ..Quote(subElement,.addedElement)  && ..ExternalCollationName(subElement,.addedElement)  && ..Quote(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExternalCollationName">
<Description>
 external collation name ::= standard collation name | implementation-defined collation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StandardCollationName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ImplementationDefinedCollationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExternalTranslation">
<Description>
 external translation ::= EXTERNAL left paren quote external translation name quote right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..ExternalTranslation255Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExternalTranslation255Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"EXTERNAL")  && ..LeftParen(subElement,.addedElement)  && ..Quote(subElement,.addedElement)  && ..ExternalTranslationName(subElement,.addedElement)  && ..Quote(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExternalTranslationName">
<Description>
 external translation name ::= standard translation name | implementation-defined translation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StandardTranslationName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ImplementationDefinedTranslationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtractExpression">
<Description>
 extract expression ::= EXTRACT left paren extract field FROM extract source right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"EXTRACT")  && ..LeftParen(subElement,.addedElement)  && ..ExtractField(subElement,.addedElement)  && ..addKeyword(subElement,"FROM")  && ..ExtractSource(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtractField">
<Description>
 extract field ::= datetime field | time zone field</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DatetimeField(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TimeZoneField(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ExtractSource">
<Description>
 extract source ::= datetime value expression | interval value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DatetimeValueExpression(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..IntervalValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Factor">
<Description>
 factor ::= [ sign ] numeric primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..Sign(subElement,.addedElement) :1,1:1) && ..NumericPrimary(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FetchOrientation">
<Description>
 fetch orientation ::= NEXT | PRIOR | FIRST | LAST | { ABSOLUTE | RELATIVE } simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"NEXT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PRIOR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FIRST")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LAST")  {
			set done=1 ; or
		} elseif ..FetchOrientation261Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FetchOrientation261Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..FetchOrientation262Sub(subElement,.addedElement)  && ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="FetchOrientation262Sub">
<Description>
 ABSOLUTE | RELATIVE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ABSOLUTE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"RELATIVE")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FetchStatement">
<Description>
 fetch statement ::= FETCH [ [ fetch orientation ] FROM ] cursor name INTO fetch target list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"FETCH")  && ..FetchStatement260OptGrp(subElement,.addedElement)  && ..CursorName(subElement,.addedElement)  && ..addKeyword(subElement,"INTO")  && ..FetchTargetList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FetchStatement260OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..FetchOrientation(subElement,.addedElement) :1,1:1) && ..addKeyword(subElement,"FROM")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FetchTargetList">
<Description>
 fetch target list ::= target specification [ { comma target specification }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TargetSpecification(subElement,.addedElement)  && $S(..FetchTargetList263RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FetchTargetList263RepOne">
<Description>
 { comma target specification }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..FetchTargetList264Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="FetchTargetList264Sub">
<Description>
 comma target specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..TargetSpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Fold">
<Description>
 fold ::= { UPPER | LOWER } left paren character value expression right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Fold182Sub(subElement,.addedElement)  && ..LeftParen(subElement,.addedElement)  && ..CharacterValueExpression(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Fold182Sub">
<Description>
 UPPER | LOWER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"UPPER")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LOWER")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormOfUseConversion">
<Description>
 form-of-use conversion ::= CONVERT left paren character value expression USING form-of-use conversion name right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..FormOfUseConversion183Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormOfUseConversion183Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"CONVERT")  && ..LeftParen(subElement,.addedElement)  && ..CharacterValueExpression(subElement,.addedElement)  && ..addKeyword(subElement,"USING")  && ..FormOfUseConversionName(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FormOfUseConversionName">
<Description>
 form-of-use conversion name ::= qualified name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..QualifiedName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FortranHostIdentifier">
<Description>
 Fortran host identifier ::= !! See syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FortranVariableDefinition">
<Description>
 Fortran variable definition ::= ...omitted...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	quit 0 ; omitted rule never true
]]></Implementation>
</Method>

<Method name="FromClause">
<Description>
 from clause ::= FROM table reference [ { comma table reference }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"FROM")  && ..TableReference(subElement,.addedElement)  && $S(..FromClause157RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="FromClause157RepOne">
<Description>
 { comma table reference }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..FromClause158Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="FromClause158Sub">
<Description>
 comma table reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..TableReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GeneralLiteral">
<Description>
 general literal ::= character string literal | national character string literal | bit string literal | hex string literal | datetime literal | interval literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterStringLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NationalCharacterStringLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..BitStringLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..HexStringLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DatetimeLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..IntervalLiteral(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GeneralSetFunction">
<Description>
 general set function ::= set function type left paren [ set quantifier ] value expression right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SetFunctionType(subElement,.addedElement)  && ..LeftParen(subElement,.addedElement)  && $S(..SetQuantifier(subElement,.addedElement) :1,1:1) && ..ValueExpression(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GeneralValueSpecification">
<Description>
 general value specification ::= parameter specification | dynamic parameter specification | variable specification | USER | CURRENT_USER | SESSION_USER | SYSTEM_USER | VALUE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ParameterSpecification(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DynamicParameterSpecification(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..VariableSpecification(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"USER")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CURRENT_USER")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SESSION_USER")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SYSTEM_USER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"VALUE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GetCount">
<Description>
 get count ::= simple target specification 1 equals operator COUNT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleTargetSpecification1(subElement,.addedElement)  && ..EqualsOperator(subElement,.addedElement)  && ..addKeyword(subElement,"COUNT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GetDescriptorInformation">
<Description>
 get descriptor information ::= get count | VALUE item number get item information [ { comma get item information }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..GetCount(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GetDescriptorInformation291Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GetDescriptorInformation291Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"VALUE")  && ..ItemNumber(subElement,.addedElement)  && ..GetItemInformation(subElement,.addedElement)  && $S(..GetDescriptorInformation292RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="GetDescriptorInformation292RepOne">
<Description>
 { comma get item information }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..GetDescriptorInformation293Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="GetDescriptorInformation293Sub">
<Description>
 comma get item information</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..GetItemInformation(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GetDescriptorStatement">
<Description>
 get descriptor statement ::= GET DESCRIPTOR descriptor name get descriptor information</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"GET")  && ..addKeyword(subElement,"DESCRIPTOR")  && ..DescriptorName(subElement,.addedElement)  && ..GetDescriptorInformation(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GetDiagnosticsStatement">
<Description>
 get diagnostics statement ::= GET DIAGNOSTICS sql diagnostics information</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"GET")  && ..addKeyword(subElement,"DIAGNOSTICS")  && ..SqlDiagnosticsInformation(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GetItemInformation">
<Description>
 get item information ::= simple target specification 2 equals operator descriptor item name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleTargetSpecification2(subElement,.addedElement)  && ..EqualsOperator(subElement,.addedElement)  && ..DescriptorItemName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GoTo">
<Description>
 go to ::= { GOTO | GO TO } goto target</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..GoTo329Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GoTo329Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..GoTo330Sub(subElement,.addedElement)  && ..GotoTarget(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GoTo330Sub">
<Description>
 GOTO | GO TO</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"GOTO")  {
		set done=1 ; or
	} elseif ..GoTo331Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GoTo331Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"GO")  && ..addKeyword(subElement,"TO")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GotoTarget">
<Description>
 goto target ::= host label identifier | unsigned integer | host PL/I label variable</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..HostLabelIdentifier(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..HostPlILabelVariable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GrantStatement">
<Description>
 grant statement ::= GRANT privileges ON object name TO grantee [ { comma grantee }... ] [ WITH GRANT OPTION ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"GRANT")  && ..Privileges(subElement,.addedElement)  && ..addKeyword(subElement,"ON")  && ..ObjectName(subElement,.addedElement)  && ..addKeyword(subElement,"TO")  && ..Grantee(subElement,.addedElement)  && $S(..GrantStatement234RepOne(subElement,.addedElement) :1,1:1) && ..GrantStatement236OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GrantStatement234RepOne">
<Description>
 { comma grantee }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..GrantStatement235Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="GrantStatement235Sub">
<Description>
 comma grantee</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..Grantee(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GrantStatement236OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WITH")  && ..addKeyword(subElement,"GRANT")  && ..addKeyword(subElement,"OPTION")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Grantee">
<Description>
 grantee ::= PUBLIC | authorization identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"PUBLIC")  {
			set done=1 ; or
		} elseif ..AuthorizationIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GreaterThanOperator">
<Description><![CDATA[
 greater than operator ::= >]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,">") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GreaterThanOrEqualsOperator">
<Description><![CDATA[
 greater than or equals operator ::= >=]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,">=") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GroupByClause">
<Description>
 group by clause ::= GROUP BY grouping column reference list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"GROUP")  && ..addKeyword(subElement,"BY")  && ..GroupingColumnReferenceList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GroupingColumnReference">
<Description>
 grouping column reference ::= column reference [ collate clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnReference(subElement,.addedElement)  && $S(..CollateClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GroupingColumnReferenceList">
<Description>
 grouping column reference list ::= grouping column reference [ { comma grouping column reference }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..GroupingColumnReference(subElement,.addedElement)  && $S(..GroupingColumnReferenceList166RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="GroupingColumnReferenceList166RepOne">
<Description>
 { comma grouping column reference }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..GroupingColumnReferenceList167Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="GroupingColumnReferenceList167Sub">
<Description>
 comma grouping column reference</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..GroupingColumnReference(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HavingClause">
<Description>
 having clause ::= HAVING search condition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"HAVING")  && ..SearchCondition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HexStringLiteral">
<Description>
 hex string literal ::= X quote [ hexit ... ] quote [ { separator... quote [ hexit... ] quote }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"X")  && ..Quote(subElement,.addedElement)  && $S(..HexStringLiteral24RepOne(subElement,.addedElement) :1,1:1) && ..Quote(subElement,.addedElement)  && $S(..HexStringLiteral25RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HexStringLiteral24RepOne">
<Description>
 hexit ...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Hexit(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="HexStringLiteral25RepOne">
<Description>
 { separator... quote [ hexit... ] quote }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..HexStringLiteral26Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="HexStringLiteral26Sub">
<Description>
 separator... quote [ hexit... ] quote</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..HexStringLiteral27RepOne(subElement,.addedElement)  && ..Quote(subElement,.addedElement)  && $S(..HexStringLiteral28RepOne(subElement,.addedElement) :1,1:1) && ..Quote(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HexStringLiteral27RepOne">
<Description>
 separator...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Separator(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="HexStringLiteral28RepOne">
<Description>
 hexit...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Hexit(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Hexit">
<Description>
 hexit ::= digit | A | B | C | D | E | F | a | b | c | d | e | f</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Digit(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"A")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"B")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"C")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"D")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"E")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"F")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"A")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"B")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"C")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"D")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"E")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"F")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="High">
<Description>
 high ::= 2 | High left paren 2 right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..High345Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="High345Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addPunctuation(subElement,"2")  {
		set done=1 ; or
	} elseif ..High346Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="High346Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"HIGH")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"2")  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HostIdentifier">
<Description>
 host identifier ::= Ada host identifier | C host identifier | Cobol host identifier | Fortran host identifier | MUMPS host identifier | Pascal host identifier | PL/I host identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..HostIdentifier146Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HostIdentifier146Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..AdaHostIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CHostIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..CobolHostIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..FortranHostIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MumpsHostIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PascalHostIdentifier(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..PlIHostIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HostLabelIdentifier">
<Description>
 host label identifier ::= !! See the syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HostPlILabelVariable">
<Description>
 host PL/I label variable ::= !! See the syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HostVariableDefinition">
<Description>
 host variable definition ::= Ada variable definition | C variable definition | Cobol variable definition | Fortran variable definition | MUMPS variable definition | Pascal variable definition | PL/I variable definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AdaVariableDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CVariableDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CobolVariableDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..FortranVariableDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..MumpsVariableDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..PascalVariableDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..PlIVariableDefinition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="HoursValue">
<Description>
 hours value ::= datetime value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DatetimeValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<Description>
 identifier ::= [ introducercharacter set specification ] actual identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Identifier38Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Identifier38Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..Identifier39OptGrp(subElement,.addedElement)  && ..ActualIdentifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Identifier39OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Introducer(subElement,.addedElement)  && ..CharacterSetSpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IdentifierBody">
<Description>
 identifier body ::= identifier start [ { underscore | identifier part } ... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..IdentifierStart(subElement,.addedElement)  && $S(..IdentifierBody3RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IdentifierBody3RepOne">
<Description>
 { underscore | identifier part } ...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..IdentifierBody4Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="IdentifierBody4Sub">
<Description>
 underscore | identifier part</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Underscore(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IdentifierPart(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IdentifierPart">
<Description>
 identifier part ::= identifier start | digit</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..IdentifierStart(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Digit(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IdentifierStart">
<Description>
 identifier start ::= !! See the Syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImplementationDefinedCharacterRepertoireName">
<Description>
 implementation-defined character repertoire name ::= character set name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterSetName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImplementationDefinedCollationName">
<Description>
 implementation-defined collation name ::= collation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CollationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImplementationDefinedTranslationName">
<Description>
 implementation-defined translation name ::= translation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TranslationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ImplementationDefinedUniversalCharacterFormOfUseName">
<Description>
 implementation-defined universal character form-of-use name ::= character set name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterSetName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InPredicate">
<Description>
 in predicate ::= row value constructor [ NOT ] IN in predicate value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..InPredicate205Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InPredicate205Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..RowValueConstructor(subElement,.addedElement)  && $S(..addKeyword(subElement,"NOT") :1,1:1) && ..addKeyword(subElement,"IN")  && ..InPredicateValue(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InPredicateValue">
<Description>
 in predicate value ::= table subquery | left paren in value list right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TableSubquery(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..InPredicateValue206Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InPredicateValue206Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LeftParen(subElement,.addedElement)  && ..InValueList(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="InValueList">
<Description>
 in value list ::= value expression { comma value expression } ...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpression(subElement,.addedElement)  && ..InValueList207RepOne(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InValueList207RepOne">
<Description>
 { comma value expression } ...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..InValueList208Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="InValueList208Sub">
<Description>
 comma value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..ValueExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndicatorParameter">
<Description>
 indicator parameter ::= [ INDICATOR ] parameter name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..addKeyword(subElement,"INDICATOR") :1,1:1) && ..ParameterName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IndicatorVariable">
<Description>
 indicator variable ::= [ INDICATOR ] embedded variable name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..addKeyword(subElement,"INDICATOR") :1,1:1) && ..EmbeddedVariableName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InsertColumnList">
<Description>
 insert column list ::= column name list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnNameList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InsertColumnsAndSource">
<Description>
 insert columns and source ::= [ left paren insert column list right paren ] query expression | DEFAULT VALUES</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..InsertColumnsAndSource268OptGrp(subElement,.addedElement)  && ..QueryExpression(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..InsertColumnsAndSource269Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InsertColumnsAndSource268OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..InsertColumnList(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="InsertColumnsAndSource269Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"DEFAULT")  && ..addKeyword(subElement,"VALUES")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="InsertStatement">
<Description>
 insert statement ::= INSERT INTO table name insert columns and source</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"INSERT")  && ..addKeyword(subElement,"INTO")  && ..TableName(subElement,.addedElement)  && ..InsertColumnsAndSource(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntegrityNo">
<Description>
 integrity no ::= 0 | IntegrityNo left paren 0 right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"0")  {
			set done=1 ; or
		} elseif ..IntegrityNo338Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntegrityNo338Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"INTEGRITYNO")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"0")  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="IntegrityYes">
<Description>
 integrity yes ::= 1 | IntegrityYes left paren 1 right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"1")  {
			set done=1 ; or
		} elseif ..IntegrityYes339Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntegrityYes339Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"INTEGRITYYES")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"1")  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Intermediate">
<Description>
 intermediate ::= 1 | Intermediate left paren 1 right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Intermediate343Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Intermediate343Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addPunctuation(subElement,"1")  {
		set done=1 ; or
	} elseif ..Intermediate344Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Intermediate344Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"INTERMEDIATE")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"1")  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalFactor">
<Description>
 interval factor ::= [ sign ] interval primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..Sign(subElement,.addedElement) :1,1:1) && ..IntervalPrimary(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalFractionalSecondsPrecision">
<Description>
 interval fractional seconds precision ::= unsigned integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalLeadingFieldPrecision">
<Description>
 interval leading field precision ::= unsigned integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalLiteral">
<Description>
 interval literal ::= INTERVAL [ sign ] interval string interval qualifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"INTERVAL")  && $S(..Sign(subElement,.addedElement) :1,1:1) && ..IntervalString(subElement,.addedElement)  && ..IntervalQualifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalPrimary">
<Description>
 interval primary ::= value expression primary [ interval qualifier ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpressionPrimary(subElement,.addedElement)  && $S(..IntervalQualifier(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalQualifier">
<Description>
 interval qualifier ::= start field TO end field | single datetime field</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StartField(subElement,.addedElement)  && ..addKeyword(subElement,"TO")  && ..EndField(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SingleDatetimeField(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalString">
<Description>
 interval string ::= quote { year-month literal | day-time literal } quote</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Quote(subElement,.addedElement)  && ..IntervalString46Sub(subElement,.addedElement)  && ..Quote(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalString46Sub">
<Description>
 year-month literal | day-time literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..YearMonthLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DayTimeLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalTerm">
<Description>
 interval term ::= interval factor | interval term 2 asterisk factor | interval term 2 solidus factor | term asterisk interval factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..IntervalTerm191Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalTerm1">
<Description>
 interval term 1 ::= interval term</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..IntervalTerm(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalTerm191Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..IntervalFactor(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IntervalTerm192Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IntervalTerm193Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IntervalTerm194Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalTerm192Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IntervalTerm2(subElement,.addedElement)  && ..Asterisk(subElement,.addedElement)  && ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalTerm193Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IntervalTerm2(subElement,.addedElement)  && ..Solidus(subElement,.addedElement)  && ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalTerm194Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Term(subElement,.addedElement)  && ..Asterisk(subElement,.addedElement)  && ..IntervalFactor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalTerm2">
<Description>
 interval term 2 ::= interval term</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..IntervalTerm(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalType">
<Description>
 interval type ::= INTERVAL interval qualifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"INTERVAL")  && ..IntervalQualifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalValueExpression">
<Description>
 interval value expression ::= interval term | interval value expression 1 plus sign interval term 1 | interval value expression 1 minus sign interval term 1 | left paren datetime value expression minus sign datetime term right paren interval qualifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..IntervalValueExpression195Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalValueExpression1">
<Description>
 interval value expression 1 ::= interval value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..IntervalValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalValueExpression195Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..IntervalTerm(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IntervalValueExpression196Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IntervalValueExpression197Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IntervalValueExpression198Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalValueExpression196Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IntervalValueExpression1(subElement,.addedElement)  && ..PlusSign(subElement,.addedElement)  && ..IntervalTerm1(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalValueExpression197Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..IntervalValueExpression1(subElement,.addedElement)  && ..MinusSign(subElement,.addedElement)  && ..IntervalTerm1(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IntervalValueExpression198Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..DatetimeValueExpression(subElement,.addedElement)  && ..MinusSign(subElement,.addedElement)  && ..DatetimeTerm(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  && ..IntervalQualifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Introducer">
<Description>
 introducer ::= underscore</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Underscore(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IsolationLevel">
<Description>
 isolation level ::= ISOLATION LEVEL level of isolation</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..IsolationLevel275Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="IsolationLevel275Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"ISOLATION")  && ..addKeyword(subElement,"LEVEL")  && ..LevelOfIsolation(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ItemNumber">
<Description>
 item number ::= simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinColumnList">
<Description>
 join column list ::= column name list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnNameList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinCondition">
<Description>
 join condition ::= ON search condition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ON")  && ..SearchCondition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinSpecification">
<Description>
 join specification ::= join condition | named columns join</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..JoinCondition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NamedColumnsJoin(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinType">
<Description>
 join type ::= INNER | outer join type [ OUTER ] | UNION</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..JoinType164Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinType164Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"INNER")  {
		set done=1 ; or
	} elseif ..JoinType165Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"UNION")  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinType165Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..OuterJoinType(subElement,.addedElement)  && $S(..addKeyword(subElement,"OUTER") :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinedTable">
<Description>
 joined table ::= cross join | qualified join | left paren joined table right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..JoinedTable161Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinedTable161Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..CrossJoin(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..QualifiedJoin(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JoinedTable162Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="JoinedTable162Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..JoinedTable(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="KeyWord">
<Description>
 key word ::= reserved word | non-reserved word</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ReservedWord(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NonReservedWord(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LanguageClause">
<Description>
 language clause ::= LANGUAGE language name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"LANGUAGE")  && ..LanguageName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LanguageName">
<Description>
 language name ::= ADA | C | COBOL | FORTRAN | MUMPS | PASCAL | PLI</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ADA")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"C")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"COBOL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FORTRAN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MUMPS")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PASCAL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PLI")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LeftBracket">
<Description>
 left bracket ::= [</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"[") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LeftParen">
<Description>
 left paren ::= (</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"(") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Length">
<Description>
 length ::= unsigned integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LengthExpression">
<Description>
 length expression ::= char length expression | octet length expression | bit length expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..LengthExpression201Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LengthExpression201Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..CharLengthExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OctetLengthExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BitLengthExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LessThanOperator">
<Description><![CDATA[
 less than operator ::= <]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LessThanOrEqualsOperator">
<Description><![CDATA[
 less than or equals operator ::= <=]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<=") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LevelOfIsolation">
<Description>
 level of isolation ::= READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"READ")  && ..addKeyword(subElement,"UNCOMMITTED")  {
			set done=1 ; or
		} elseif ..LevelOfIsolation276Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LevelOfIsolation277Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SERIALIZABLE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LevelOfIsolation276Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"READ")  && ..addKeyword(subElement,"COMMITTED")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LevelOfIsolation277Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"REPEATABLE")  && ..addKeyword(subElement,"READ")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="LevelsClause">
<Description>
 levels clause ::= CASCADED | LOCAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CASCADED")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LOCAL")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LikePredicate">
<Description>
 like predicate ::= match value [ NOT ] LIKE pattern [ ESCAPE escape character ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..MatchValue(subElement,.addedElement)  && $S(..addKeyword(subElement,"NOT") :1,1:1) && ..addKeyword(subElement,"LIKE")  && ..Pattern(subElement,.addedElement)  && ..LikePredicate209OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LikePredicate209OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ESCAPE")  && ..EscapeCharacter(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LimitedCollationDefinition">
<Description>
 limited collation definition ::= COLLATION FROM collation source</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"COLLATION")  && ..addKeyword(subElement,"FROM")  && ..CollationSource(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Literal">
<Description>
 literal ::= signed numeric literal | general literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Literal116Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Literal116Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..SignedNumericLiteral(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GeneralLiteral(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="LocalTableName">
<Description>
 local table name ::= qualified identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..QualifiedIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Low">
<Description>
 low ::= 0 | Low left paren 0 right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Low341Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Low341Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addPunctuation(subElement,"0")  {
		set done=1 ; or
	} elseif ..Low342Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Low342Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"LOW")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"0")  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Mantissa">
<Description>
 mantissa ::= exact numeric literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ExactNumericLiteral(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MatchPredicate">
<Description>
 match predicate ::= row value constructor MATCH [ UNIQUE ] [ PARTIAL | FULL ] table subquery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RowValueConstructor(subElement,.addedElement)  && ..addKeyword(subElement,"MATCH")  && $S(..addKeyword(subElement,"UNIQUE") :1,1:1) && ..MatchPredicate212OptGrp(subElement,.addedElement)  && ..TableSubquery(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MatchPredicate212OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PARTIAL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"FULL")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MatchType">
<Description>
 match type ::= FULL | PARTIAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"FULL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PARTIAL")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MatchValue">
<Description>
 match value ::= character value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MinusSign">
<Description>
 minus sign ::= -</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"-") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MinutesValue">
<Description>
 minutes value ::= datetime value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DatetimeValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Module">
<Description>
 module ::= module name clause language clause module authorization clause [ temporary table declaration... ] module contents...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Module56Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Module56Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..ModuleNameClause(subElement,.addedElement)  && ..LanguageClause(subElement,.addedElement)  && ..ModuleAuthorizationClause(subElement,.addedElement)  && $S(..Module57RepOne(subElement,.addedElement) :1,1:1) && ..Module58RepOne(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Module57RepOne">
<Description>
 temporary table declaration...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..TemporaryTableDeclaration(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Module58RepOne">
<Description>
 module contents...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ModuleContents(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ModuleAuthorizationClause">
<Description>
 module authorization clause ::= SCHEMA schema name | AUTHORIZATION module authorization identifier | SCHEMA schema name AUTHORIZATION module authorization identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SCHEMA")  && ..SchemaName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ModuleAuthorizationClause59Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ModuleAuthorizationClause60Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ModuleAuthorizationClause59Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"AUTHORIZATION")  && ..ModuleAuthorizationIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ModuleAuthorizationClause60Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"SCHEMA")  && ..SchemaName(subElement,.addedElement)  && ..addKeyword(subElement,"AUTHORIZATION")  && ..ModuleAuthorizationIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ModuleAuthorizationIdentifier">
<Description>
 module authorization identifier ::= authorization identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AuthorizationIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ModuleCharacterSetSpecification">
<Description>
 module character set specification ::= NAMES ARE character set specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"NAMES")  && ..addKeyword(subElement,"ARE")  && ..CharacterSetSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ModuleContents">
<Description>
 module contents ::= declare cursor | dynamic declare cursor | procedure</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DeclareCursor(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DynamicDeclareCursor(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Procedure(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ModuleName">
<Description>
 module name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ModuleNameClause">
<Description>
 module name clause ::= MODULE [ module name ] [ module character set specification ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"MODULE")  && $S(..ModuleName(subElement,.addedElement) :1,1:1) && $S(..ModuleCharacterSetSpecification(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MonthsValue">
<Description>
 months value ::= datetime value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DatetimeValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MumpsHostIdentifier">
<Description>
 MUMPS host identifier ::= !! See syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="MumpsVariableDefinition">
<Description>
 MUMPS variable definition ::= ...omitted...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	quit 0 ; omitted rule never true
]]></Implementation>
</Method>

<Method name="NamedColumnsJoin">
<Description>
 named columns join ::= USING left paren join column list right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"USING")  && ..LeftParen(subElement,.addedElement)  && ..JoinColumnList(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringLiteral">
<Description>
 national character string literal ::= N quote [ character representation ... ] quote [ { separator... quote [ character representation... ] quote }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"N")  && ..Quote(subElement,.addedElement)  && $S(..NationalCharacterStringLiteral9RepOne(subElement,.addedElement) :1,1:1) && ..Quote(subElement,.addedElement)  && $S(..NationalCharacterStringLiteral10RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringLiteral10RepOne">
<Description>
 { separator... quote [ character representation... ] quote }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..NationalCharacterStringLiteral11Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringLiteral11Sub">
<Description>
 separator... quote [ character representation... ] quote</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NationalCharacterStringLiteral12RepOne(subElement,.addedElement)  && ..Quote(subElement,.addedElement)  && $S(..NationalCharacterStringLiteral13RepOne(subElement,.addedElement) :1,1:1) && ..Quote(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringLiteral12RepOne">
<Description>
 separator...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Separator(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringLiteral13RepOne">
<Description>
 character representation...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CharacterRepresentation(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringLiteral9RepOne">
<Description>
 character representation ...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..CharacterRepresentation(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringType">
<Description>
 national character string type ::= NATIONAL CHARACTER [ left paren length right paren ] | NATIONAL CHAR [ left paren length right paren ] | NCHAR [ left paren length right paren ] | NATIONAL CHARACTER VARYING [ left paren length right paren ] | NATIONAL CHAR VARYING [ left paren length right paren ] | NCHAR VARYING [ left paren length right paren ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"NATIONAL")  && ..addKeyword(subElement,"CHARACTER")  && ..NationalCharacterStringType77OptGrp(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NationalCharacterStringType78Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NationalCharacterStringType80Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NationalCharacterStringType82Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NationalCharacterStringType84Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NationalCharacterStringType86Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringType77OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringType78Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"NATIONAL")  && ..addKeyword(subElement,"CHAR")  && ..NationalCharacterStringType79OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringType79OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringType80Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"NCHAR")  && ..NationalCharacterStringType81OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringType81OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringType82Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"NATIONAL")  && ..addKeyword(subElement,"CHARACTER")  && ..addKeyword(subElement,"VARYING")  && ..NationalCharacterStringType83OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringType83OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringType84Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"NATIONAL")  && ..addKeyword(subElement,"CHAR")  && ..addKeyword(subElement,"VARYING")  && ..NationalCharacterStringType85OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringType85OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringType86Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"NCHAR")  && ..addKeyword(subElement,"VARYING")  && ..NationalCharacterStringType87OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="NationalCharacterStringType87OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..Length(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Newline">
<Description>
 newline ::= !! implementation defined end of line indicator</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NonJoinQueryExpression">
<Description>
 non-join query expression ::= non-join query term | query expression UNION [ ALL ] [ corresponding spec ] query term | query expression EXCEPT [ ALL ] [ corresponding spec ] query term</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..NonJoinQueryTerm(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NonJoinQueryExpression149Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NonJoinQueryExpression150Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NonJoinQueryExpression149Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..QueryExpression(subElement,.addedElement)  && ..addKeyword(subElement,"UNION")  && $S(..addKeyword(subElement,"ALL") :1,1:1) && $S(..CorrespondingSpec(subElement,.addedElement) :1,1:1) && ..QueryTerm(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="NonJoinQueryExpression150Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..QueryExpression(subElement,.addedElement)  && ..addKeyword(subElement,"EXCEPT")  && $S(..addKeyword(subElement,"ALL") :1,1:1) && $S(..CorrespondingSpec(subElement,.addedElement) :1,1:1) && ..QueryTerm(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="NonJoinQueryPrimary">
<Description>
 non-join query primary ::= simple table | left paren non-join query expression right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleTable(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NonJoinQueryPrimary152Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NonJoinQueryPrimary152Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LeftParen(subElement,.addedElement)  && ..NonJoinQueryExpression(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="NonJoinQueryTerm">
<Description>
 non-join query term ::= non-join query primary | query term INTERSECT [ ALL ] [ corresponding spec ] query primary</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..NonJoinQueryPrimary(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NonJoinQueryTerm151Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NonJoinQueryTerm151Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..QueryTerm(subElement,.addedElement)  && ..addKeyword(subElement,"INTERSECT")  && $S(..addKeyword(subElement,"ALL") :1,1:1) && $S(..CorrespondingSpec(subElement,.addedElement) :1,1:1) && ..QueryPrimary(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="NonReservedWord">
<Description>
 non-reserved word ::= ADA | C | CATALOG_NAME | CHARACTER_SET_CATALOG | CHARACTER_SET_NAME | CHARACTER_SET_SCHEMA | CLASS_ORIGIN | COBOL | COLLATION_CATALOG | COLLATION_NAME | COLLATION_SCHEMA | COLUMN_NAME | COMMAND_FUNCTION | COMMITTED | CONDITION_NUMBER | CONNECTION_NAME | CONSTRAINT_CATALOG | CONSTRAINT_NAME | CONSTRAINT_SCHEMA | CURSOR_NAME | DATA | DATETIME_INTERVAL_CODE | DATETIME_INTERVAL_PRECISION | DYNAMIC_FUNCTION | FORTRAN | LENGTH | MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH | MESSAGE_TEXT | MORE | MUMPS | NAME | NULLABLE | NUMBER | PASCAL | PLI | REPEATABLE | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_SQLSTATE | ROW_COUNT | SCALE | SCHEMA_NAME | SERIALIZABLE | SERVER_NAME | SUBCLASS_ORIGIN | TABLE_NAME | TYPE | UNCOMMITTED | UNNAMED</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ADA")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"C")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CATALOG_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CHARACTER_SET_CATALOG")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CHARACTER_SET_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CHARACTER_SET_SCHEMA")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CLASS_ORIGIN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"COBOL")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"COLLATION_CATALOG")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"COLLATION_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"COLLATION_SCHEMA")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"COLUMN_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"COMMAND_FUNCTION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"COMMITTED")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CONDITION_NUMBER")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CONNECTION_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CONSTRAINT_CATALOG")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CONSTRAINT_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CONSTRAINT_SCHEMA")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CURSOR_NAME")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DATA")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"DATETIME_INTERVAL_CODE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"DATETIME_INTERVAL_PRECISION")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"DYNAMIC_FUNCTION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FORTRAN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LENGTH")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"MESSAGE_LENGTH")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"MESSAGE_OCTET_LENGTH")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"MESSAGE_TEXT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MORE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MUMPS")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NAME")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NULLABLE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NUMBER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PASCAL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PLI")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"REPEATABLE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"RETURNED_LENGTH")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"RETURNED_OCTET_LENGTH")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"RETURNED_SQLSTATE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"ROW_COUNT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SCALE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SCHEMA_NAME")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SERIALIZABLE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SERVER_NAME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SUBCLASS_ORIGIN")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"TABLE_NAME")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TYPE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"UNCOMMITTED")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"UNNAMED")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NonSecondDatetimeField">
<Description>
 non-second datetime field ::= YEAR | MONTH | DAY | HOUR | MINUTE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"YEAR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MONTH")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DAY")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"HOUR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MINUTE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NondelimiterToken">
<Description>
 nondelimiter token ::= regular identifier | key word | unsigned numeric literal | national character string literal | bit string literal | hex string literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RegularIdentifier(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..KeyWord(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..UnsignedNumericLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NationalCharacterStringLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..BitStringLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..HexStringLiteral(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NondoublequoteCharacter">
<Description>
 nondoublequote character ::= !! See the syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NonquoteCharacter">
<Description>
 nonquote character ::= !! See the Syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NotEqualsOperator">
<Description><![CDATA[
 not equals operator ::= <>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"<>") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NullPredicate">
<Description>
 null predicate ::= row value constructor IS [ NOT ] NULL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RowValueConstructor(subElement,.addedElement)  && ..addKeyword(subElement,"IS")  && $S(..addKeyword(subElement,"NOT") :1,1:1) && ..addKeyword(subElement,"NULL")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NullSpecification">
<Description>
 null specification ::= NULL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"NULL")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumberOfConditions">
<Description>
 number of conditions ::= simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericPrimary">
<Description>
 numeric primary ::= value expression primary | numeric value function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpressionPrimary(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NumericValueFunction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericType">
<Description>
 numeric type ::= exact numeric type | approximate numeric type</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..NumericType91Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericType91Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..ExactNumericType(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ApproximateNumericType(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericValueExpression">
<Description>
 numeric value expression ::= term | numeric value expression plus sign term | numeric value expression minus sign term</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..NumericValueExpression139Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericValueExpression139Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..Term(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NumericValueExpression140Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NumericValueExpression141Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericValueExpression140Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NumericValueExpression(subElement,.addedElement)  && ..PlusSign(subElement,.addedElement)  && ..Term(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericValueExpression141Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..NumericValueExpression(subElement,.addedElement)  && ..MinusSign(subElement,.addedElement)  && ..Term(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="NumericValueFunction">
<Description>
 numeric value function ::= position expression | extract expression | length expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..PositionExpression(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ExtractExpression(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LengthExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectColumn">
<Description>
 object column ::= column name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectName">
<Description>
 object name ::= [ TABLE ] table name | DOMAIN domain name | COLLATION collation name | CHARACTER SET character set name | TRANSLATION translation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..addKeyword(subElement,"TABLE") :1,1:1) && ..TableName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ObjectName246Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ObjectName247Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ObjectName248Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ObjectName249Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ObjectName246Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"DOMAIN")  && ..DomainName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ObjectName247Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"COLLATION")  && ..CollationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ObjectName248Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"CHARACTER")  && ..addKeyword(subElement,"SET")  && ..CharacterSetName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ObjectName249Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"TRANSLATION")  && ..TranslationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="Occurrences">
<Description>
 occurrences ::= simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OctetLengthExpression">
<Description>
 octet length expression ::= OCTET_LENGTH left paren string value expression right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"OCTET_LENGTH")  && ..LeftParen(subElement,.addedElement)  && ..StringValueExpression(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OpenStatement">
<Description>
 open statement ::= OPEN cursor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"OPEN")  && ..CursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OrderByClause">
<Description>
 order by clause ::= ORDER BY sort specification list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ORDER")  && ..addKeyword(subElement,"BY")  && ..SortSpecificationList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OrderingSpecification">
<Description>
 ordering specification ::= ASC | DESC</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ASC")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DESC")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OuterJoinType">
<Description>
 outer join type ::= LEFT | RIGHT | FULL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"LEFT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"RIGHT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FULL")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="OverlapsPredicate">
<Description>
 overlaps predicate ::= row value constructor 1 OVERLAPS row value constructor 2</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RowValueConstructor1(subElement,.addedElement)  && ..addKeyword(subElement,"OVERLAPS")  && ..RowValueConstructor2(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PadAttribute">
<Description>
 pad attribute ::= NO PAD | PAD SPACE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"NO")  && ..addKeyword(subElement,"PAD")  {
			set done=1 ; or
		} elseif ..PadAttribute254Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PadAttribute254Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"PAD")  && ..addKeyword(subElement,"SPACE")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ParameterDeclaration">
<Description>
 parameter declaration ::= parameter name data type | status parameter</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ParameterName(subElement,.addedElement)  && ..DataType(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..StatusParameter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterDeclarationList">
<Description>
 parameter declaration list ::= left paren parameter declaration [ { comma parameter declaration }... ] right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LeftParen(subElement,.addedElement)  && ..ParameterDeclaration(subElement,.addedElement)  && $S(..ParameterDeclarationList223RepOne(subElement,.addedElement) :1,1:1) && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterDeclarationList223RepOne">
<Description>
 { comma parameter declaration }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..ParameterDeclarationList224Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterDeclarationList224Sub">
<Description>
 comma parameter declaration</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..ParameterDeclaration(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterName">
<Description>
 parameter name ::= colon identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Colon(subElement,.addedElement)  && ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterSpecification">
<Description>
 parameter specification ::= parameter name [ indicator parameter ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ParameterName(subElement,.addedElement)  && $S(..IndicatorParameter(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ParameterUsingClause">
<Description>
 parameter using clause ::= using clause</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UsingClause(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PascalHostIdentifier">
<Description>
 Pascal host identifier ::= !! See syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PascalVariableDefinition">
<Description>
 Pascal variable definition ::= ...omitted...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	quit 0 ; omitted rule never true
]]></Implementation>
</Method>

<Method name="Pattern">
<Description>
 pattern ::= character value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Percent">
<Description>
 percent ::= %</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"%") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Period">
<Description>
 period ::= .</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,".") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PlIHostIdentifier">
<Description>
 PL/I host identifier ::= !! See syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PlIVariableDefinition">
<Description>
 PL/I variable definition ::= ...omitted...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	quit 0 ; omitted rule never true
]]></Implementation>
</Method>

<Method name="PlusSign">
<Description>
 plus sign ::= +</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"+") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PositionExpression">
<Description>
 position expression ::= POSITION left paren character value expression IN character value expression right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"POSITION")  && ..LeftParen(subElement,.addedElement)  && ..CharacterValueExpression(subElement,.addedElement)  && ..addKeyword(subElement,"IN")  && ..CharacterValueExpression(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Precision">
<Description>
 precision ::= unsigned integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Predicate">
<Description>
 predicate ::= comparison predicate | between predicate | in predicate | like predicate | null predicate | quantified comparison predicate | exists predicate | match predicate | overlaps predicate</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Predicate135Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Predicate135Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..ComparisonPredicate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..BetweenPredicate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..InPredicate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..LikePredicate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..NullPredicate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..QuantifiedComparisonPredicate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..ExistsPredicate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MatchPredicate(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..OverlapsPredicate(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PreparableDynamicDeleteStatementPositioned">
<Description>
 preparable dynamic delete statement: positioned ::= DELETE [ FROM table name ] WHERE CURRENT OF cursor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DELETE")  && ..PreparableDynamicDeleteStatementPositioned332OptGrp(subElement,.addedElement)  && ..addKeyword(subElement,"WHERE")  && ..addKeyword(subElement,"CURRENT")  && ..addKeyword(subElement,"OF")  && ..CursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PreparableDynamicDeleteStatementPositioned332OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"FROM")  && ..TableName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PreparableDynamicUpdateStatementPositioned">
<Description>
 preparable dynamic update statement: positioned ::= UPDATE [ table name ] SET set clause WHERE CURRENT OF cursor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"UPDATE")  && $S(..TableName(subElement,.addedElement) :1,1:1) && ..addKeyword(subElement,"SET")  && ..SetClause(subElement,.addedElement)  && ..addKeyword(subElement,"WHERE")  && ..addKeyword(subElement,"CURRENT")  && ..addKeyword(subElement,"OF")  && ..CursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PreparableSqlDataStatement">
<Description>
 preparable SQL data statement ::= delete statement: searched | dynamic single row select statement | insert statement | dynamic select statement | update statement: searched | preparable dynamic delete statement: positioned | preparable dynamic update statement: positioned</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DeleteStatementSearched(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DynamicSingleRowSelectStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..InsertStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DynamicSelectStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..UpdateStatementSearched(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..PreparableDynamicDeleteStatementPositioned(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..PreparableDynamicUpdateStatementPositioned(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PreparableSqlImplementationDefinedStatement">
<Description>
 preparable SQL implementation-defined statement ::= !! See the syntax rules</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"!!")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PreparableSqlSchemaStatement">
<Description>
 preparable SQL schema statement ::= SQL schema statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlSchemaStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PreparableSqlSessionStatement">
<Description>
 preparable SQL session statement ::= SQL session statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlSessionStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PreparableSqlTransactionStatement">
<Description>
 preparable SQL transaction statement ::= SQL transaction statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlTransactionStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PreparableStatement">
<Description>
 preparable statement ::= preparable SQL data statement | preparable SQL schema statement | preparable SQL transaction statement | preparable SQL session statement | preparable SQL implementation-defined statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..PreparableSqlDataStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..PreparableSqlSchemaStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..PreparableSqlTransactionStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..PreparableSqlSessionStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..PreparableSqlImplementationDefinedStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PrepareStatement">
<Description>
 prepare statement ::= PREPARE SQL statement name FROM SQL statement variable</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"PREPARE")  && ..SqlStatementName(subElement,.addedElement)  && ..addKeyword(subElement,"FROM")  && ..SqlStatementVariable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="PrivilegeColumnList">
<Description>
 privilege column list ::= column name list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnNameList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Privileges">
<Description>
 privileges ::= ALL PRIVILEGES | action list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Privileges237Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Privileges237Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"ALL")  && ..addKeyword(subElement,"PRIVILEGES")  {
		set done=1 ; or
	} elseif ..ActionList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Procedure">
<Description>
 procedure ::= PROCEDURE procedure name parameter declaration list semicolon SQL procedure statement semicolon</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Procedure222Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Procedure222Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"PROCEDURE")  && ..ProcedureName(subElement,.addedElement)  && ..ParameterDeclarationList(subElement,.addedElement)  && ..Semicolon(subElement,.addedElement)  && ..SqlProcedureStatement(subElement,.addedElement)  && ..Semicolon(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ProcedureName">
<Description>
 procedure name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QualifiedIdentifier">
<Description>
 qualified identifier ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QualifiedJoin">
<Description>
 qualified join ::= table reference [ NATURAL ] [ join type ] JOIN table reference [ join specification ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TableReference(subElement,.addedElement)  && $S(..addKeyword(subElement,"NATURAL") :1,1:1) && $S(..JoinType(subElement,.addedElement) :1,1:1) && ..addKeyword(subElement,"JOIN")  && ..TableReference(subElement,.addedElement)  && $S(..JoinSpecification(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QualifiedLocalTableName">
<Description>
 qualified local table name ::= MODULE period local table name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"MODULE")  && ..Period(subElement,.addedElement)  && ..LocalTableName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QualifiedName">
<Description>
 qualified name ::= [ schema name period ] qualified identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..QualifiedName115OptGrp(subElement,.addedElement)  && ..QualifiedIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QualifiedName115OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SchemaName(subElement,.addedElement)  && ..Period(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Qualifier">
<Description>
 qualifier ::= table name | correlation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TableName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CorrelationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QuantifiedComparisonPredicate">
<Description>
 quantified comparison predicate ::= row value constructor comp op quantifier table subquery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RowValueConstructor(subElement,.addedElement)  && ..CompOp(subElement,.addedElement)  && ..Quantifier(subElement,.addedElement)  && ..TableSubquery(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Quantifier">
<Description>
 quantifier ::= all | some</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..All(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Some(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QueryExpression">
<Description>
 query expression ::= non-join query expression | joined table</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..QueryExpression148Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QueryExpression148Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..NonJoinQueryExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JoinedTable(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QueryPrimary">
<Description>
 query primary ::= non-join query primary | joined table</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..QueryPrimary173Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QueryPrimary173Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..NonJoinQueryPrimary(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JoinedTable(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QuerySpecification">
<Description>
 query specification ::= SELECT [ set quantifier ] select list table expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SELECT")  && $S(..SetQuantifier(subElement,.addedElement) :1,1:1) && ..SelectList(subElement,.addedElement)  && ..TableExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QueryTerm">
<Description>
 query term ::= non-join query term | joined table</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..QueryTerm171Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QueryTerm171Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..NonJoinQueryTerm(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..JoinedTable(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QuestionMark">
<Description>
 question mark ::= ?</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"?") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Quote">
<Description>
 quote ::= '</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"'") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="QuoteSymbol">
<Description>
 quote symbol ::= quote quote</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Quote(subElement,.addedElement)  && ..Quote(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReferenceColumnList">
<Description>
 reference column list ::= column name list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnNameList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReferencedTableAndColumns">
<Description>
 referenced table and columns ::= table name [ left paren reference column list right paren ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TableName(subElement,.addedElement)  && ..ReferencedTableAndColumns121OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReferencedTableAndColumns121OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..ReferenceColumnList(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReferencesSpecification">
<Description>
 references specification ::= REFERENCES referenced table and columns [ MATCH match type ] [ referential triggered action ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"REFERENCES")  && ..ReferencedTableAndColumns(subElement,.addedElement)  && ..ReferencesSpecification120OptGrp(subElement,.addedElement)  && $S(..ReferentialTriggeredAction(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReferencesSpecification120OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"MATCH")  && ..MatchType(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReferencingColumns">
<Description>
 referencing columns ::= reference column list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ReferenceColumnList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReferentialAction">
<Description>
 referential action ::= CASCADE | SET NULL | SET DEFAULT | NO ACTION</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CASCADE")  {
			set done=1 ; or
		} elseif ..ReferentialAction126Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ReferentialAction127Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ReferentialAction128Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReferentialAction126Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"SET")  && ..addKeyword(subElement,"NULL")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ReferentialAction127Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"SET")  && ..addKeyword(subElement,"DEFAULT")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ReferentialAction128Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"NO")  && ..addKeyword(subElement,"ACTION")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ReferentialConstraintDefinition">
<Description>
 referential constraint definition ::= FOREIGN KEY left paren referencing columns right paren references specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"FOREIGN")  && ..addKeyword(subElement,"KEY")  && ..LeftParen(subElement,.addedElement)  && ..ReferencingColumns(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  && ..ReferencesSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReferentialTriggeredAction">
<Description>
 referential triggered action ::= update rule [ delete rule ] | delete rule [ update rule ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UpdateRule(subElement,.addedElement)  && $S(..DeleteRule(subElement,.addedElement) :1,1:1) {
			set done=1 ; or
		} elseif ..ReferentialTriggeredAction125Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReferentialTriggeredAction125Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..DeleteRule(subElement,.addedElement)  && $S(..UpdateRule(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="RegularIdentifier">
<Description>
 regular identifier ::= identifier body</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..IdentifierBody(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ReservedWord">
<Description>
 reserved word ::= ABSOLUTE | ACTION | ADD | ALL | ALLOCATE | ALTER | AND | ANY | ARE | AS | ASC | ASSERTION | AT | AUTHORIZATION | AVG | BEGIN | BETWEEN | BIT | BIT_LENGTH | BOTH | BY | CASCADE | CASCADED | CASE | CAST | CATALOG | CHAR | CHARACTER | CHARACTER_LENGTH | CHAR_LENGTH | CHECK | CLOSE | COALESCE | COLLATE | COLLATION | COLUMN | COMMIT | CONNECT | CONNECTION | CONSTRAINT | CONSTRAINTS | CONTINUE | CONVERT | CORRESPONDING | CREATE | CROSS | CURRENT | CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR | DATE | DAY | DEALLOCATE | DEC | DECIMAL | DECLARE | DEFAULT | DEFERRABLE | DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR | DIAGNOSTICS | DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP | ELSE | END | END-EXEC | ESCAPE | EXCEPT | EXCEPTION | EXEC | EXECUTE | EXISTS | EXTERNAL | EXTRACT | FALSE | FETCH | FIRST | FLOAT | FOR | FOREIGN | FOUND | FROM | FULL | GET | GLOBAL | GO | GOTO | GRANT | GROUP | HAVING | HOUR | IDENTITY | IMMEDIATE | IN | INDICATOR | INITIALLY | INNER | INPUT | INSENSITIVE | INSERT | INT | INTEGER | INTERSECT | INTERVAL | INTO | IS | ISOLATION | JOIN | KEY | LANGUAGE | LAST | LEADING | LEFT | LEVEL | LIKE | LOCAL | LOWER | MATCH | MAX | MIN | MINUTE | MODULE | MONTH | NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO | NOT | NULL | NULLIF | NUMERIC | OCTET_LENGTH | OF | ON | ONLY | OPEN | OPTION | OR | ORDER | OUTER | OUTPUT | OVERLAPS | PAD | PARTIAL | POSITION | PRECISION | PREPARE | PRESERVE | PRIMARY | PRIOR | PRIVILEGES | PROCEDURE | PUBLIC | READ | REAL | REFERENCES | RELATIVE | RESTRICT | REVOKE | RIGHT | ROLLBACK | ROWS | SCHEMA | SCROLL | SECOND | SECTION | SELECT | SESSION | SESSION_USER | SET | SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE | SQLERROR | SQLSTATE | SUBSTRING | SUM | SYSTEM_USER | TABLE | TEMPORARY | THEN | TIME | TIMESTAMP | TIMEZONE_HOUR | TIMEZONE_MINUTE | TO | TRAILING | TRANSACTION | TRANSLATE | TRANSLATION | TRIM | TRUE | UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE | USER | USING | VALUE | VALUES | VARCHAR | VARYING | VIEW | WHEN | WHENEVER | WHERE | WITH | WORK | WRITE | YEAR | ZONE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ABSOLUTE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ACTION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ADD")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ALL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ALLOCATE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ALTER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"AND")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ANY")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ARE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"AS")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ASC")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ASSERTION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"AT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"AUTHORIZATION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"AVG")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"BEGIN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"BETWEEN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"BIT")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"BIT_LENGTH")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"BOTH")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"BY")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CASCADE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CASCADED")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CASE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CAST")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CATALOG")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CHAR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CHARACTER")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CHARACTER_LENGTH")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CHAR_LENGTH")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CHECK")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CLOSE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"COALESCE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"COLLATE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"COLLATION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"COLUMN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"COMMIT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CONNECT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CONNECTION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CONSTRAINT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CONSTRAINTS")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CONTINUE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CONVERT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CORRESPONDING")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CREATE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CROSS")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CURRENT")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CURRENT_DATE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CURRENT_TIME")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CURRENT_TIMESTAMP")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"CURRENT_USER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"CURSOR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DATE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DAY")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DEALLOCATE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DEC")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DECIMAL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DECLARE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DEFAULT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DEFERRABLE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DEFERRED")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DELETE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DESC")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DESCRIBE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DESCRIPTOR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DIAGNOSTICS")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DISCONNECT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DISTINCT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DOMAIN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DOUBLE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DROP")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ELSE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"END")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"END-EXEC")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ESCAPE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"EXCEPT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"EXCEPTION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"EXEC")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"EXECUTE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"EXISTS")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"EXTERNAL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"EXTRACT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FALSE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FETCH")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FIRST")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FLOAT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FOR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FOREIGN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FOUND")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FROM")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FULL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"GET")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"GLOBAL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"GO")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"GOTO")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"GRANT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"GROUP")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"HAVING")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"HOUR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"IDENTITY")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"IMMEDIATE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"IN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INDICATOR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INITIALLY")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INNER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INPUT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INSENSITIVE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INSERT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INTEGER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INTERSECT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INTERVAL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"INTO")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"IS")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ISOLATION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"JOIN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"KEY")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LANGUAGE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LAST")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LEADING")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LEFT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LEVEL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LIKE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LOCAL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LOWER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MATCH")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MAX")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MIN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MINUTE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MODULE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MONTH")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NAMES")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NATIONAL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NATURAL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NCHAR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NEXT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NO")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NOT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NULL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NULLIF")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"NUMERIC")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"OCTET_LENGTH")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"OF")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ON")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ONLY")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"OPEN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"OPTION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"OR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ORDER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"OUTER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"OUTPUT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"OVERLAPS")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PAD")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PARTIAL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"POSITION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PRECISION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PREPARE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PRESERVE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PRIMARY")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PRIOR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PRIVILEGES")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PROCEDURE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"PUBLIC")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"READ")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"REAL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"REFERENCES")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"RELATIVE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"RESTRICT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"REVOKE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"RIGHT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ROLLBACK")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ROWS")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SCHEMA")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SCROLL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SECOND")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SECTION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SELECT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SESSION")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SESSION_USER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SET")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SIZE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SMALLINT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SOME")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SPACE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SQL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SQLCODE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SQLERROR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SQLSTATE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SUBSTRING")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SUM")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"SYSTEM_USER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TABLE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TEMPORARY")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"THEN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TIME")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TIMESTAMP")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"TIMEZONE_HOUR")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"TIMEZONE_MINUTE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TO")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TRAILING")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TRANSACTION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TRANSLATE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TRANSLATION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TRIM")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TRUE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"UNION")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"UNIQUE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"UNKNOWN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"UPDATE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"UPPER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"USAGE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"USER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"USING")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"VALUE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"VALUES")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"VARCHAR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"VARYING")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"VIEW")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"WHEN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"WHENEVER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"WHERE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"WITH")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"WORK")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"WRITE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"YEAR")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ZONE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Result">
<Description>
 result ::= result expression | NULL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Result178Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Result178Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..ResultExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"NULL")  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ResultExpression">
<Description>
 result expression ::= value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ResultUsingClause">
<Description>
 result using clause ::= using clause</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UsingClause(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RevokeStatement">
<Description>
 revoke statement ::= REVOKE [ GRANT OPTION FOR ] privileges ON object name FROM grantee [ { comma grantee }... ] drop behaviour</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"REVOKE")  && ..RevokeStatement257OptGrp(subElement,.addedElement)  && ..Privileges(subElement,.addedElement)  && ..addKeyword(subElement,"ON")  && ..ObjectName(subElement,.addedElement)  && ..addKeyword(subElement,"FROM")  && ..Grantee(subElement,.addedElement)  && $S(..RevokeStatement258RepOne(subElement,.addedElement) :1,1:1) && ..DropBehaviour(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RevokeStatement257OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"GRANT")  && ..addKeyword(subElement,"OPTION")  && ..addKeyword(subElement,"FOR")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RevokeStatement258RepOne">
<Description>
 { comma grantee }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..RevokeStatement259Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="RevokeStatement259Sub">
<Description>
 comma grantee</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..Grantee(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RightBracket">
<Description>
 right bracket ::= ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"]") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RightParen">
<Description>
 right paren ::= )</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,")") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RollbackStatement">
<Description>
 rollback statement ::= ROLLBACK [ WORK ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ROLLBACK")  && $S(..addKeyword(subElement,"WORK") :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RowSubquery">
<Description>
 row subquery ::= subquery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Subquery(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RowValueConstructor">
<Description>
 row value constructor ::= row value constructor element | left paren row value constructor list right paren | row subquery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..RowValueConstructor136Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RowValueConstructor1">
<Description>
 row value constructor 1 ::= row value constructor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RowValueConstructor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RowValueConstructor136Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..RowValueConstructorElement(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RowValueConstructor137Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..RowSubquery(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RowValueConstructor137Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..RowValueConstructorList(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RowValueConstructor2">
<Description>
 row value constructor 2 ::= row value constructor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RowValueConstructor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RowValueConstructorElement">
<Description>
 row value constructor element ::= value expression | null specification | default specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpression(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NullSpecification(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DefaultSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RowValueConstructorList">
<Description>
 row value constructor list ::= row value constructor element [ { comma row value constructor element } ... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RowValueConstructorElement(subElement,.addedElement)  && $S(..RowValueConstructorList203RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="RowValueConstructorList203RepOne">
<Description>
 { comma row value constructor element } ...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..RowValueConstructorList204Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="RowValueConstructorList204Sub">
<Description>
 comma row value constructor element</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..RowValueConstructorElement(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ScalarSubquery">
<Description>
 scalar subquery ::= subquery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Subquery(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Scale">
<Description>
 scale ::= unsigned integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaAuthorizationIdentifier">
<Description>
 schema authorization identifier ::= authorization identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AuthorizationIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaCharacterSetName">
<Description>
 schema character set name ::= character set name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterSetName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaCharacterSetSpecification">
<Description>
 schema character set specification ::= DEFAULT CHARACTER SET character set specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DEFAULT")  && ..addKeyword(subElement,"CHARACTER")  && ..addKeyword(subElement,"SET")  && ..CharacterSetSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaCollationName">
<Description>
 schema collation name ::= collation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CollationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaDefinition">
<Description>
 schema definition ::= CREATE SCHEMA schema name clause [ schema character set specification ] [ schema element... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CREATE")  && ..addKeyword(subElement,"SCHEMA")  && ..SchemaNameClause(subElement,.addedElement)  && $S(..SchemaCharacterSetSpecification(subElement,.addedElement) :1,1:1) && $S(..SchemaDefinition225RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaDefinition225RepOne">
<Description>
 schema element...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..SchemaElement(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaElement">
<Description>
 schema element ::= domain definition | table definition | view definition | grant statement | assertion definition | character set definition | collation definition | translation definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DomainDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TableDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ViewDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GrantStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..AssertionDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CharacterSetDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CollationDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TranslationDefinition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaName">
<Description>
 schema name ::= [ catalog name period ] unqualified schema name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..SchemaName36Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaName36Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..SchemaName37OptGrp(subElement,.addedElement)  && ..UnqualifiedSchemaName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaName37OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..CatalogName(subElement,.addedElement)  && ..Period(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaNameClause">
<Description>
 schema name clause ::= schema name | AUTHORIZATION schema authorization identifier | schema name AUTHORIZATION schema authorization identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SchemaName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SchemaNameClause226Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SchemaNameClause227Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SchemaNameClause226Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"AUTHORIZATION")  && ..SchemaAuthorizationIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SchemaNameClause227Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SchemaName(subElement,.addedElement)  && ..addKeyword(subElement,"AUTHORIZATION")  && ..SchemaAuthorizationIdentifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SchemaTranslationName">
<Description>
 schema translation name ::= translation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TranslationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ScopeOption">
<Description>
 scope option ::= GLOBAL | LOCAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"GLOBAL")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LOCAL")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SearchCondition">
<Description>
 search condition ::= boolean term | search condition OR boolean term</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..SearchCondition129Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SearchCondition129Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..BooleanTerm(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SearchCondition130Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SearchCondition130Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..SearchCondition(subElement,.addedElement)  && ..addKeyword(subElement,"OR")  && ..BooleanTerm(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SearchedCase">
<Description>
 searched case ::= CASE searched when clause... [ else clause ] END</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CASE")  && ..SearchedCase179RepOne(subElement,.addedElement)  && $S(..ElseClause(subElement,.addedElement) :1,1:1) && ..addKeyword(subElement,"END")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SearchedCase179RepOne">
<Description>
 searched when clause...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..SearchedWhenClause(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SearchedWhenClause">
<Description>
 searched when clause ::= WHEN search condition THEN result</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"WHEN")  && ..SearchCondition(subElement,.addedElement)  && ..addKeyword(subElement,"THEN")  && ..Result(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SecondsFraction">
<Description>
 seconds fraction ::= unsigned integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SecondsIntegerValue">
<Description>
 seconds integer value ::= unsigned integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SecondsValue">
<Description>
 seconds value ::= seconds integer value [ period [ seconds fraction ] ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SecondsIntegerValue(subElement,.addedElement)  && ..SecondsValue45OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SecondsValue45OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Period(subElement,.addedElement)  && $S(..SecondsFraction(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectList">
<Description>
 select list ::= asterisk | select sublist [ { comma select sublist }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Asterisk(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SelectList153Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectList153Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..SelectSublist(subElement,.addedElement)  && $S(..SelectList154RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SelectList154RepOne">
<Description>
 { comma select sublist }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..SelectList155Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SelectList155Sub">
<Description>
 comma select sublist</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..SelectSublist(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectStatementSingleRow">
<Description>
 select statement: single row ::= SELECT [ set quantifier ] select list INTO select target list table expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SELECT")  && $S(..SetQuantifier(subElement,.addedElement) :1,1:1) && ..SelectList(subElement,.addedElement)  && ..addKeyword(subElement,"INTO")  && ..SelectTargetList(subElement,.addedElement)  && ..TableExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectSublist">
<Description>
 select sublist ::= derived column | qualifier period asterisk</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DerivedColumn(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SelectSublist156Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectSublist156Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Qualifier(subElement,.addedElement)  && ..Period(subElement,.addedElement)  && ..Asterisk(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SelectTargetList">
<Description>
 select target list ::= target specification [ { comma target specification }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TargetSpecification(subElement,.addedElement)  && $S(..SelectTargetList265RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SelectTargetList265RepOne">
<Description>
 { comma target specification }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..SelectTargetList266Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SelectTargetList266Sub">
<Description>
 comma target specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..TargetSpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Semicolon">
<Description>
 semicolon ::= ;</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,";") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Separator">
<Description>
 separator ::= { comment | space | newline }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Separator14RepOne(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Separator14RepOne">
<Description>
 { comment | space | newline }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Separator15Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="Separator15Sub">
<Description>
 comment | space | newline</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comment(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Space(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Newline(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetCatalogStatement">
<Description>
 set catalog statement ::= SET CATALOG value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SET")  && ..addKeyword(subElement,"CATALOG")  && ..ValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetClause">
<Description>
 set clause ::= object column equals operator update source</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ObjectColumn(subElement,.addedElement)  && ..EqualsOperator(subElement,.addedElement)  && ..UpdateSource(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetClauseList">
<Description>
 set clause list ::= set clause [ { comma set clause } ... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SetClause(subElement,.addedElement)  && $S(..SetClauseList270RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetClauseList270RepOne">
<Description>
 { comma set clause } ...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..SetClauseList271Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SetClauseList271Sub">
<Description>
 comma set clause</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..SetClause(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetColumnDefaultClause">
<Description>
 set column default clause ::= SET default clause</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SET")  && ..DefaultClause(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetConnectionStatement">
<Description>
 set connection statement ::= SET CONNECTION connection object</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SET")  && ..addKeyword(subElement,"CONNECTION")  && ..ConnectionObject(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetConstraintsModeStatement">
<Description>
 set constraints mode statement ::= SET CONSTRAINTS constraint name list { DEFERRED | IMMEDIATE }</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SET")  && ..addKeyword(subElement,"CONSTRAINTS")  && ..ConstraintNameList(subElement,.addedElement)  && ..SetConstraintsModeStatement280Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetConstraintsModeStatement280Sub">
<Description>
 DEFERRED | IMMEDIATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DEFERRED")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"IMMEDIATE")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetCount">
<Description>
 set count ::= COUNT equals operator simple value specification 1</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"COUNT")  && ..EqualsOperator(subElement,.addedElement)  && ..SimpleValueSpecification1(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetDescriptorInformation">
<Description>
 set descriptor information ::= set count | VALUE item number set item information [ { comma set item information }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SetCount(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SetDescriptorInformation288Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetDescriptorInformation288Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"VALUE")  && ..ItemNumber(subElement,.addedElement)  && ..SetItemInformation(subElement,.addedElement)  && $S(..SetDescriptorInformation289RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SetDescriptorInformation289RepOne">
<Description>
 { comma set item information }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..SetDescriptorInformation290Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SetDescriptorInformation290Sub">
<Description>
 comma set item information</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..SetItemInformation(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetDescriptorStatement">
<Description>
 set descriptor statement ::= SET DESCRIPTOR descriptor name set descriptor information</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SET")  && ..addKeyword(subElement,"DESCRIPTOR")  && ..DescriptorName(subElement,.addedElement)  && ..SetDescriptorInformation(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetDomainDefaultClause">
<Description>
 set domain default clause ::= SET default clause</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SET")  && ..DefaultClause(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetFunctionSpecification">
<Description>
 set function specification ::= COUNT left paren asterisk right paren | general set function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"COUNT")  && ..LeftParen(subElement,.addedElement)  && ..Asterisk(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GeneralSetFunction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetFunctionType">
<Description>
 set function type ::= AVG | MAX | MIN | SUM | COUNT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"AVG")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MAX")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MIN")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SUM")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"COUNT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetItemInformation">
<Description>
 set item information ::= descriptor item name equals operator simple value specification 2</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DescriptorItemName(subElement,.addedElement)  && ..EqualsOperator(subElement,.addedElement)  && ..SimpleValueSpecification2(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetLocalTimeZoneStatement">
<Description>
 set local time zone statement ::= SET TIME ZONE set time zone value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SET")  && ..addKeyword(subElement,"TIME")  && ..addKeyword(subElement,"ZONE")  && ..SetTimeZoneValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetNamesStatement">
<Description>
 set names statement ::= SET NAMES value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SET")  && ..addKeyword(subElement,"NAMES")  && ..ValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetQuantifier">
<Description>
 set quantifier ::= DISTINCT | ALL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DISTINCT")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"ALL")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetSchemaStatement">
<Description>
 set schema statement ::= SET SCHEMA value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SET")  && ..addKeyword(subElement,"SCHEMA")  && ..ValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetSessionAuthorizationIdentifierStatement">
<Description>
 set session authorization identifier statement ::= SET SESSION AUTHORIZATION value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SET")  && ..addKeyword(subElement,"SESSION")  && ..addKeyword(subElement,"AUTHORIZATION")  && ..ValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetTimeZoneValue">
<Description>
 set time zone value ::= interval value expression | LOCAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..IntervalValueExpression(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"LOCAL")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetTransactionStatement">
<Description>
 set transaction statement ::= SET TRANSACTION transaction mode [ { comma transaction mode }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SET")  && ..addKeyword(subElement,"TRANSACTION")  && ..TransactionMode(subElement,.addedElement)  && $S(..SetTransactionStatement273RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SetTransactionStatement273RepOne">
<Description>
 { comma transaction mode }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..SetTransactionStatement274Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SetTransactionStatement274Sub">
<Description>
 comma transaction mode</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..TransactionMode(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Sign">
<Description>
 sign ::= plus sign | minus sign</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Sign8Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Sign8Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..PlusSign(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..MinusSign(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SignedInteger">
<Description>
 signed integer ::= [ sign ] unsigned integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..Sign(subElement,.addedElement) :1,1:1) && ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SignedNumericLiteral">
<Description>
 signed numeric literal ::= [ sign ] unsigned numeric literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..Sign(subElement,.addedElement) :1,1:1) && ..UnsignedNumericLiteral(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleCase">
<Description>
 simple case ::= CASE case operand simple when clause... [ else clause ] END</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CASE")  && ..CaseOperand(subElement,.addedElement)  && ..SimpleCase177RepOne(subElement,.addedElement)  && $S(..ElseClause(subElement,.addedElement) :1,1:1) && ..addKeyword(subElement,"END")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleCase177RepOne">
<Description>
 simple when clause...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..SimpleWhenClause(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleLatinLetter">
<Description>
 simple Latin letter ::= simple Latin upper case letter | simple Latin lower case letter</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleLatinUpperCaseLetter(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SimpleLatinLowerCaseLetter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleLatinLowerCaseLetter">
<Description>
 simple Latin lower case letter ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"A")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"B")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"C")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"D")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"E")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"F")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"G")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"H")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"I")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"J")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"K")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"L")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"M")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"N")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"O")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"P")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"Q")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"R")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"S")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"T")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"U")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"V")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"W")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"X")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"Y")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"Z")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleLatinUpperCaseLetter">
<Description>
 simple Latin upper case letter ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"A")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"B")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"C")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"D")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"E")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"F")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"G")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"H")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"I")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"J")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"K")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"L")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"M")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"N")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"O")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"P")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"Q")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"R")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"S")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"T")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"U")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"V")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"W")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"X")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"Y")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"Z")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleTable">
<Description>
 simple table ::= query specification | table value constructor | explicit table</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..QuerySpecification(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TableValueConstructor(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ExplicitTable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleTargetSpecification">
<Description>
 simple target specification ::= parameter name | embedded variable name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ParameterName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..EmbeddedVariableName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleTargetSpecification1">
<Description>
 simple target specification 1 ::= simple target specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleTargetSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleTargetSpecification2">
<Description>
 simple target specification 2 ::= simple target specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleTargetSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleValueSpecification">
<Description>
 simple value specification ::= parameter name | embedded variable name | literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ParameterName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..EmbeddedVariableName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Literal(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleValueSpecification1">
<Description>
 simple value specification 1 ::= simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleValueSpecification2">
<Description>
 simple value specification 2 ::= simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SimpleWhenClause">
<Description>
 simple when clause ::= WHEN when operand THEN result</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"WHEN")  && ..WhenOperand(subElement,.addedElement)  && ..addKeyword(subElement,"THEN")  && ..Result(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SingleDatetimeField">
<Description>
 single datetime field ::= non-second datetime field [ left paren interval leading field precision right paren ] | SECOND [ left paren interval leading field precision [ comma interval fractional seconds precision ] right paren ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..NonSecondDatetimeField(subElement,.addedElement)  && ..SingleDatetimeField111OptGrp(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SingleDatetimeField112Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SingleDatetimeField111OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..IntervalLeadingFieldPrecision(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SingleDatetimeField112Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"SECOND")  && ..SingleDatetimeField113OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SingleDatetimeField113OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..IntervalLeadingFieldPrecision(subElement,.addedElement)  && ..SingleDatetimeField114OptGrp(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SingleDatetimeField114OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..IntervalFractionalSecondsPrecision(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Solidus">
<Description>
 solidus ::= /</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"/") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Some">
<Description>
 some ::= SOME | ANY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Some211Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Some211Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"SOME")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"ANY")  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SortKey">
<Description>
 sort key ::= column name | unsigned integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SortSpecification">
<Description>
 sort specification ::= sort key [ collate clause ] [ ordering specification ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SortKey(subElement,.addedElement)  && $S(..CollateClause(subElement,.addedElement) :1,1:1) && $S(..OrderingSpecification(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SortSpecificationList">
<Description>
 sort specification list ::= sort specification [ { comma sort specification }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SortSpecification(subElement,.addedElement)  && $S(..SortSpecificationList217RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SortSpecificationList217RepOne">
<Description>
 { comma sort specification }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..SortSpecificationList218Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SortSpecificationList218Sub">
<Description>
 comma sort specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..SortSpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SourceCharacterSetSpecification">
<Description>
 source character set specification ::= character set specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterSetSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Space">
<Description>
 space ::= !! space character in character set in use</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Space1Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Space1Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addPunctuation(subElement,"!!")  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlConformance">
<Description>
 SQL conformance ::= low | intermediate | high</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Low(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Intermediate(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..High(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlConnectionStatement">
<Description>
 SQL connection statement ::= connect statement | set connection statement | disconnect statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ConnectStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SetConnectionStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DisconnectStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlDataChangeStatement">
<Description>
 SQL data change statement ::= delete statement: positioned | delete statement: searched | insert statement | update statement: positioned | update statement: searched</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DeleteStatementPositioned(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DeleteStatementSearched(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..InsertStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..UpdateStatementPositioned(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..UpdateStatementSearched(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlDataStatement">
<Description>
 SQL data statement ::= open statement | fetch statement | close statement | select statement: single row | SQL data change statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..OpenStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..FetchStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CloseStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SelectStatementSingleRow(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlDataChangeStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlDiagnosticsInformation">
<Description>
 sql diagnostics information ::= statement information | condition information</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StatementInformation(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ConditionInformation(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlDiagnosticsStatement">
<Description>
 SQL diagnostics statement ::= get diagnostics statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..GetDiagnosticsStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlDynamicDataStatement">
<Description>
 SQL dynamic data statement ::= allocate cursor statement | dynamic open statement | dynamic close statement | dynamic fetch statement | dynamic delete statement: positioned | dynamic update statement: positioned</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AllocateCursorStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DynamicOpenStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DynamicCloseStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DynamicFetchStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DynamicDeleteStatementPositioned(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DynamicUpdateStatementPositioned(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlDynamicStatement">
<Description>
 SQL dynamic statement ::= system descriptor statement | prepare statement | deallocate prepared statement | describe statement | execute statement | execute immediate statement | SQL dynamic data statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SystemDescriptorStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..PrepareStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DeallocatePreparedStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DescribeStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ExecuteStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ExecuteImmediateStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlDynamicDataStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlEdition">
<Description>
 SQL edition ::= 1987 | 1989 | 1992</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..mn1987(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..mn1989(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..mn1992(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlEmbeddedLanguageCharacter">
<Description>
 SQL embedded language character ::= left bracket | right bracket</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LeftBracket(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..RightBracket(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlLanguageCharacter">
<Description>
 SQL language character ::= simple Latin letter | digit | SQL special character</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleLatinLetter(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Digit(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlSpecialCharacter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlLanguageIdentifier">
<Description>
 SQL language identifier ::= SQL language identifier start [ { underscore | SQL language identifier part }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..SqlLanguageIdentifier42Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlLanguageIdentifier42Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..SqlLanguageIdentifierStart(subElement,.addedElement)  && $S(..SqlLanguageIdentifier43RepOne(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlLanguageIdentifier43RepOne">
<Description>
 { underscore | SQL language identifier part }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..SqlLanguageIdentifier44Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="SqlLanguageIdentifier44Sub">
<Description>
 underscore | SQL language identifier part</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Underscore(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..SqlLanguageIdentifierPart(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlLanguageIdentifierPart">
<Description>
 SQL language identifier part ::= simple Latin letter | digit</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleLatinLetter(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Digit(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlLanguageIdentifierStart">
<Description>
 SQL language identifier start ::= simple Latin letter</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleLatinLetter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlObjectIdentifier">
<Description>
 SQL object identifier ::= SQL provenance SQL variant</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlProvenance(subElement,.addedElement)  && ..SqlVariant(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlPrefix">
<Description><![CDATA[
 SQL prefix ::= EXEC SQL | ampersandSQL<left paren>]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"EXEC")  && ..addKeyword(subElement,"SQL")  {
			set done=1 ; or
		} elseif ..SqlPrefix310Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlPrefix310Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..Ampersand(subElement,.addedElement)  && ..addPunctuation(subElement,"SQL<left")  && ..addPunctuation(subElement,"paren>")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="SqlProcedureStatement">
<Description>
 SQL procedure statement ::= SQL schema statement | SQL data statement | SQL transaction statement | SQL connection statement | SQL session statement | SQL dynamic statement | SQL diagnostics statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlSchemaStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlDataStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlTransactionStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlConnectionStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlSessionStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlDynamicStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlDiagnosticsStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlProvenance">
<Description>
 SQL provenance ::= arc1 arc2 arc3</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Arc1(subElement,.addedElement)  && ..Arc2(subElement,.addedElement)  && ..Arc3(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlSchemaDefinitionStatement">
<Description>
 SQL schema definition statement ::= schema definition | table definition | view definition | grant statement | domain definition | character set definition | collation definition | translation definition | assertion definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SchemaDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TableDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ViewDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GrantStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DomainDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CharacterSetDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CollationDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TranslationDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..AssertionDefinition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlSchemaManipulationStatement">
<Description>
 SQL schema manipulation statement ::= drop schema statement | alter table statement | drop table statement | drop view statement | revoke statement | alter domain statement | drop domain statement | drop character set statement | drop collation statement | drop translation statement | drop assertion statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DropSchemaStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..AlterTableStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DropTableStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DropViewStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..RevokeStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..AlterDomainStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DropDomainStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DropCharacterSetStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DropCollationStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DropTranslationStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DropAssertionStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlSchemaStatement">
<Description>
 SQL schema statement ::= SQL schema definition statement | SQL schema manipulation statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlSchemaDefinitionStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlSchemaManipulationStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlServerName">
<Description>
 SQL-server name ::= simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlSessionStatement">
<Description>
 SQL session statement ::= set catalog statement | set schema statement | set names statement | set session authorization identifier statement | set local time zone statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SetCatalogStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SetSchemaStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SetNamesStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SetSessionAuthorizationIdentifierStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SetLocalTimeZoneStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlSpecialCharacter">
<Description>
 SQL special character ::= space | double quote | percent | ampersand | quote | left paren | right paren | asterisk | plus sign | comma | minus sign | period | solidus | colon | semicolon | less than operator | greater than operator | equals operator | question mark | underscore | vertical bar</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Space(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DoubleQuote(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Percent(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Ampersand(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Quote(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LeftParen(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..RightParen(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Asterisk(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..PlusSign(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Comma(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..MinusSign(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Period(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Solidus(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Colon(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Semicolon(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..LessThanOperator(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GreaterThanOperator(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..EqualsOperator(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..QuestionMark(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..Underscore(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..VerticalBar(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlStatementName">
<Description>
 SQL statement name ::= statement name | extended statement name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..StatementName(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ExtendedStatementName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlStatementVariable">
<Description>
 SQL statement variable ::= simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlTerminalCharacter">
<Description>
 SQL terminal character ::= SQL language character | SQL embedded language character</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlLanguageCharacter(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlEmbeddedLanguageCharacter(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlTerminator">
<Description>
 SQL terminator ::= END-EXEC | semicolon | right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"END-EXEC")  {
			set done=1 ; or
		} elseif ..Semicolon(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlTransactionStatement">
<Description>
 SQL transaction statement ::= set transaction statement | set constraints mode statement | commit statement | rollback statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SetTransactionStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SetConstraintsModeStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CommitStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..RollbackStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SqlVariant">
<Description>
 SQL variant ::= SQL edition SQL conformance</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SqlEdition(subElement,.addedElement)  && ..SqlConformance(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StandardCharacterRepertoireName">
<Description>
 standard character repertoire name ::= character set name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterSetName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StandardCollationName">
<Description>
 standard collation name ::= collation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CollationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StandardTranslationName">
<Description>
 standard translation name ::= translation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TranslationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StandardUniversalCharacterFormOfUseName">
<Description>
 standard universal character form-of-use name ::= character set name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterSetName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StartField">
<Description>
 start field ::= non-second datetime field [ left paren interval leading field precision right paren ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..NonSecondDatetimeField(subElement,.addedElement)  && ..StartField108OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StartField108OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..IntervalLeadingFieldPrecision(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StartPosition">
<Description>
 start position ::= numeric value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..NumericValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatementInformation">
<Description>
 statement information ::= statement information item [ { comma statement information item }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..StatementInformation301Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatementInformation301Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..StatementInformationItem(subElement,.addedElement)  && $S(..StatementInformation302RepOne(subElement,.addedElement) :1,1:1) {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatementInformation302RepOne">
<Description>
 { comma statement information item }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..StatementInformation303Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="StatementInformation303Sub">
<Description>
 comma statement information item</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..StatementInformationItem(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatementInformationItem">
<Description>
 statement information item ::= simple target specification equals operator statement information item name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..StatementInformationItem304Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatementInformationItem304Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..SimpleTargetSpecification(subElement,.addedElement)  && ..EqualsOperator(subElement,.addedElement)  && ..StatementInformationItemName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatementInformationItemName">
<Description>
 statement information item name ::= NUMBER | MORE | COMMAND_FUNCTION | DYNAMIC_FUNCTION | ROW_COUNT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"NUMBER")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"MORE")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"COMMAND_FUNCTION")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"DYNAMIC_FUNCTION")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"ROW_COUNT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatementName">
<Description>
 statement name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatementOrDeclaration">
<Description>
 statement or declaration ::= declare cursor | dynamic declare cursor | temporary table declaration | embedded exception declaration | SQL procedure statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DeclareCursor(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DynamicDeclareCursor(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TemporaryTableDeclaration(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..EmbeddedExceptionDeclaration(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SqlProcedureStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StatusParameter">
<Description>
 status parameter ::= SQLCODE | SQLSTATE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"SQLCODE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"SQLSTATE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StringLength">
<Description>
 string length ::= numeric value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..NumericValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StringValueExpression">
<Description>
 string value expression ::= character value expression | bit value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterValueExpression(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..BitValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="StringValueFunction">
<Description>
 string value function ::= character value function | bit value function</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterValueFunction(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..BitValueFunction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Subquery">
<Description>
 subquery ::= left paren query expression right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LeftParen(subElement,.addedElement)  && ..QueryExpression(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="SystemDescriptorStatement">
<Description>
 system descriptor statement ::= allocate descriptor statement | deallocate descriptor statement | get descriptor statement | set descriptor statement</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..AllocateDescriptorStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DeallocateDescriptorStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GetDescriptorStatement(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SetDescriptorStatement(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableConstraint">
<Description>
 table constraint ::= unique constraint definition | referential constraint definition | check constraint definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UniqueConstraintDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ReferentialConstraintDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CheckConstraintDefinition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableConstraintDefinition">
<Description>
 table constraint definition ::= [ constraint name definition ] table constraint [ constraint check time ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if $S(..ConstraintNameDefinition(subElement,.addedElement) :1,1:1) && ..TableConstraint(subElement,.addedElement)  && $S(..ConstraintCheckTime(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableDefinition">
<Description>
 table definition ::= CREATE [ { GLOBAL | LOCAL } TEMPORARY ] TABLE table name table element list [ ON COMMIT { DELETE | PRESERVE } ROWS ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CREATE")  && ..TableDefinition228OptGrp(subElement,.addedElement)  && ..addKeyword(subElement,"TABLE")  && ..TableName(subElement,.addedElement)  && ..TableElementList(subElement,.addedElement)  && ..TableDefinition230OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableDefinition228OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..TableDefinition229Sub(subElement,.addedElement)  && ..addKeyword(subElement,"TEMPORARY")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableDefinition229Sub">
<Description>
 GLOBAL | LOCAL</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"GLOBAL")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"LOCAL")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableDefinition230OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ON")  && ..addKeyword(subElement,"COMMIT")  && ..TableDefinition231Sub(subElement,.addedElement)  && ..addKeyword(subElement,"ROWS")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableDefinition231Sub">
<Description>
 DELETE | PRESERVE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"DELETE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"PRESERVE")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableElement">
<Description>
 table element ::= column definition | table constraint definition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnDefinition(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TableConstraintDefinition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableElementList">
<Description>
 table element list ::= left paren table element [ { comma table element }... ] right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..LeftParen(subElement,.addedElement)  && ..TableElement(subElement,.addedElement)  && $S(..TableElementList63RepOne(subElement,.addedElement) :1,1:1) && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableElementList63RepOne">
<Description>
 { comma table element }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..TableElementList64Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="TableElementList64Sub">
<Description>
 comma table element</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..TableElement(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableExpression">
<Description>
 table expression ::= from clause [ where clause ] [ group by clause ] [ having clause ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..FromClause(subElement,.addedElement)  && $S(..WhereClause(subElement,.addedElement) :1,1:1) && $S(..GroupByClause(subElement,.addedElement) :1,1:1) && $S(..HavingClause(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableName">
<Description>
 table name ::= qualified name | qualified local table name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..TableName122Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableName122Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..QualifiedName(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..QualifiedLocalTableName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableReference">
<Description>
 table reference ::= table name [ correlation specification ] | derived table correlation specification | joined table</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TableName(subElement,.addedElement)  && $S(..CorrelationSpecification(subElement,.addedElement) :1,1:1) {
			set done=1 ; or
		} elseif ..TableReference159Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..JoinedTable(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableReference159Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..DerivedTable(subElement,.addedElement)  && ..CorrelationSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TableSubquery">
<Description>
 table subquery ::= subquery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Subquery(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableValueConstructor">
<Description>
 table value constructor ::= VALUES table value constructor list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..TableValueConstructor168Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableValueConstructor168Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"VALUES")  && ..TableValueConstructorList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableValueConstructorList">
<Description>
 table value constructor list ::= row value constructor [ { comma row value constructor }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..RowValueConstructor(subElement,.addedElement)  && $S(..TableValueConstructorList169RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TableValueConstructorList169RepOne">
<Description>
 { comma row value constructor }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..TableValueConstructorList170Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="TableValueConstructorList170Sub">
<Description>
 comma row value constructor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..RowValueConstructor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TargetCharacterSetSpecification">
<Description>
 target character set specification ::= character set specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterSetSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TargetSpecification">
<Description>
 target specification ::= parameter specification | variable specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ParameterSpecification(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..VariableSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TemporaryTableDeclaration">
<Description>
 temporary table declaration ::= DECLARE LOCAL TEMPORARY TABLE qualified local table name table element list [ ON COMMIT { PRESERVE | DELETE } ROWS ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"DECLARE")  && ..addKeyword(subElement,"LOCAL")  && ..addKeyword(subElement,"TEMPORARY")  && ..addKeyword(subElement,"TABLE")  && ..QualifiedLocalTableName(subElement,.addedElement)  && ..TableElementList(subElement,.addedElement)  && ..TemporaryTableDeclaration61OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TemporaryTableDeclaration61OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"ON")  && ..addKeyword(subElement,"COMMIT")  && ..TemporaryTableDeclaration62Sub(subElement,.addedElement)  && ..addKeyword(subElement,"ROWS")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TemporaryTableDeclaration62Sub">
<Description>
 PRESERVE | DELETE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"PRESERVE")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"DELETE")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term">
<Description>
 term ::= factor | term asterisk factor | term solidus factor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Term142Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term142Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..Factor(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Term143Or(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..Term144Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term143Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Term(subElement,.addedElement)  && ..Asterisk(subElement,.addedElement)  && ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Term144Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Term(subElement,.addedElement)  && ..Solidus(subElement,.addedElement)  && ..Factor(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeFractionalSecondsPrecision">
<Description>
 time fractional seconds precision ::= unsigned integer</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedInteger(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeInterval">
<Description>
 time-interval ::= hours value [ colon minutes value [ colon seconds value ] ] | minutes value [ colon seconds value ] | seconds value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..HoursValue(subElement,.addedElement)  && ..TimeInterval52OptGrp(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TimeInterval54Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SecondsValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeInterval52OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Colon(subElement,.addedElement)  && ..MinutesValue(subElement,.addedElement)  && ..TimeInterval53OptGrp(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeInterval53OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Colon(subElement,.addedElement)  && ..SecondsValue(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeInterval54Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..MinutesValue(subElement,.addedElement)  && ..TimeInterval55OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TimeInterval55OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Colon(subElement,.addedElement)  && ..SecondsValue(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeLiteral">
<Description>
 time literal ::= TIME time string</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"TIME")  && ..TimeString(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimePrecision">
<Description>
 time precision ::= time fractional seconds precision</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TimeFractionalSecondsPrecision(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeString">
<Description>
 time string ::= quote time value [ time zone interval ] quote</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Quote(subElement,.addedElement)  && ..TimeValue(subElement,.addedElement)  && $S(..TimeZoneInterval(subElement,.addedElement) :1,1:1) && ..Quote(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeValue">
<Description>
 time value ::= hours value colon minutes value colon seconds value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..HoursValue(subElement,.addedElement)  && ..Colon(subElement,.addedElement)  && ..MinutesValue(subElement,.addedElement)  && ..Colon(subElement,.addedElement)  && ..SecondsValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeZone">
<Description>
 time zone ::= AT time zone specifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..TimeZone199Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeZone199Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..addKeyword(subElement,"AT")  && ..TimeZoneSpecifier(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeZoneField">
<Description>
 time zone field ::= TIMEZONE_HOUR | TIMEZONE_MINUTE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"TIMEZONE_HOUR")  {
			set done=1 ; or
		} elseif ..addPunctuation(subElement,"TIMEZONE_MINUTE")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeZoneInterval">
<Description>
 time zone interval ::= sign hours value colon minutes value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Sign(subElement,.addedElement)  && ..HoursValue(subElement,.addedElement)  && ..Colon(subElement,.addedElement)  && ..MinutesValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeZoneSpecifier">
<Description>
 time zone specifier ::= LOCAL | TIME ZONE interval value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"LOCAL")  {
			set done=1 ; or
		} elseif ..TimeZoneSpecifier200Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimeZoneSpecifier200Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"TIME")  && ..addKeyword(subElement,"ZONE")  && ..IntervalValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TimestampLiteral">
<Description>
 timestamp literal ::= TIMESTAMP timestamp string</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"TIMESTAMP")  && ..TimestampString(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimestampPrecision">
<Description>
 timestamp precision ::= time fractional seconds precision</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TimeFractionalSecondsPrecision(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TimestampString">
<Description>
 timestamp string ::= quote date value space time value [ time zone interval ] quote</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Quote(subElement,.addedElement)  && ..DateValue(subElement,.addedElement)  && ..Space(subElement,.addedElement)  && ..TimeValue(subElement,.addedElement)  && $S(..TimeZoneInterval(subElement,.addedElement) :1,1:1) && ..Quote(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Token">
<Description>
 token ::= nondelimiter token | delimiter token</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..Token2Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Token2Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..NondelimiterToken(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DelimiterToken(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TransactionAccessMode">
<Description>
 transaction access mode ::= READ ONLY | READ WRITE</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"READ")  && ..addKeyword(subElement,"ONLY")  {
			set done=1 ; or
		} elseif ..TransactionAccessMode278Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TransactionAccessMode278Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"READ")  && ..addKeyword(subElement,"WRITE")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="TransactionMode">
<Description>
 transaction mode ::= isolation level | transaction access mode | diagnostics size</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..IsolationLevel(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..TransactionAccessMode(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..DiagnosticsSize(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TranslationCollation">
<Description>
 translation collation ::= TRANSLATION translation name [ THEN COLLATION collation name ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"TRANSLATION")  && ..TranslationName(subElement,.addedElement)  && ..TranslationCollation253OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TranslationCollation253OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"THEN")  && ..addKeyword(subElement,"COLLATION")  && ..CollationName(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TranslationDefinition">
<Description>
 translation definition ::= CREATE TRANSLATION translation name FOR source character set specification TO target character set specification FROM translation source</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CREATE")  && ..addKeyword(subElement,"TRANSLATION")  && ..TranslationName(subElement,.addedElement)  && ..addKeyword(subElement,"FOR")  && ..SourceCharacterSetSpecification(subElement,.addedElement)  && ..addKeyword(subElement,"TO")  && ..TargetCharacterSetSpecification(subElement,.addedElement)  && ..addKeyword(subElement,"FROM")  && ..TranslationSource(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TranslationName">
<Description>
 translation name ::= qualified name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..QualifiedName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TranslationSource">
<Description>
 translation source ::= translation specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TranslationSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TranslationSpecification">
<Description>
 translation specification ::= external translation | IDENTITY | schema translation name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ExternalTranslation(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"IDENTITY")  {
			set done=1 ; or
		} elseif ..SchemaTranslationName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TrimCharacter">
<Description>
 trim character ::= character value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TrimFunction">
<Description>
 trim function ::= TRIM left paren trim operands right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"TRIM")  && ..LeftParen(subElement,.addedElement)  && ..TrimOperands(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TrimOperands">
<Description>
 trim operands ::= [ [ trim specification ] [ trim character ] FROM ] trim source</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..TrimOperands184OptGrp(subElement,.addedElement)  && ..TrimSource(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TrimOperands184OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if $S(..TrimSpecification(subElement,.addedElement) :1,1:1) && $S(..TrimCharacter(subElement,.addedElement) :1,1:1) && ..addKeyword(subElement,"FROM")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TrimSource">
<Description>
 trim source ::= character value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TrimSpecification">
<Description>
 trim specification ::= LEADING | TRAILING | BOTH</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"LEADING")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"TRAILING")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"BOTH")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="TruthValue">
<Description>
 truth value ::= TRUE | FALSE | UNKNOWN</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"TRUE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"FALSE")  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"UNKNOWN")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="Underscore">
<Description>
 underscore ::= _</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"_") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UniqueColumnList">
<Description>
 unique column list ::= column name list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnNameList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UniqueConstraintDefinition">
<Description>
 unique constraint definition ::= unique specification left paren unique column list right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UniqueSpecification(subElement,.addedElement)  && ..LeftParen(subElement,.addedElement)  && ..UniqueColumnList(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UniquePredicate">
<Description>
 unique predicate ::= UNIQUE table subquery</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"UNIQUE")  && ..TableSubquery(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UniqueSpecification">
<Description>
 unique specification ::= UNIQUE | PRIMARY KEY</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"UNIQUE")  {
			set done=1 ; or
		} elseif ..UniqueSpecification119Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UniqueSpecification119Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addKeyword(subElement,"PRIMARY")  && ..addKeyword(subElement,"KEY")  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="UnqualifiedSchemaName">
<Description>
 unqualified schema name ::= identifier</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..Identifier(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UnsignedInteger">
<Description>
 unsigned integer ::= digit ...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedInteger7RepOne(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UnsignedInteger7RepOne">
<Description>
 digit ...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..Digit(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UnsignedLiteral">
<Description>
 unsigned literal ::= unsigned numeric literal | general literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedNumericLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GeneralLiteral(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UnsignedNumericLiteral">
<Description>
 unsigned numeric literal ::= exact numeric literal | approximate numeric literal</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ExactNumericLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ApproximateNumericLiteral(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UnsignedValueSpecification">
<Description>
 unsigned value specification ::= unsigned literal | general value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedLiteral(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..GeneralValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdatabilityClause">
<Description>
 updatability clause ::= FOR { READ ONLY | UPDATE [ OF column name list ] }</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"FOR")  && ..UpdatabilityClause219Sub(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdatabilityClause219Sub">
<Description>
 READ ONLY | UPDATE [ OF column name list ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"READ")  && ..addKeyword(subElement,"ONLY")  {
		set done=1 ; or
	} elseif ..UpdatabilityClause220Or(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdatabilityClause220Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"UPDATE")  && ..UpdatabilityClause221OptGrp(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdatabilityClause221OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"OF")  && ..ColumnNameList(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateRule">
<Description>
 update rule ::= ON UPDATE referential action</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"ON")  && ..addKeyword(subElement,"UPDATE")  && ..ReferentialAction(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateSource">
<Description>
 update source ::= value expression | null specification | DEFAULT</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpression(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..NullSpecification(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..addKeyword(subElement,"DEFAULT")  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateStatementPositioned">
<Description>
 update statement: positioned ::= UPDATE table name SET set clause list WHERE CURRENT OF cursor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"UPDATE")  && ..TableName(subElement,.addedElement)  && ..addKeyword(subElement,"SET")  && ..SetClauseList(subElement,.addedElement)  && ..addKeyword(subElement,"WHERE")  && ..addKeyword(subElement,"CURRENT")  && ..addKeyword(subElement,"OF")  && ..CursorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateStatementSearched">
<Description>
 update statement: searched ::= UPDATE table name SET set clause list [ WHERE search condition ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"UPDATE")  && ..TableName(subElement,.addedElement)  && ..addKeyword(subElement,"SET")  && ..SetClauseList(subElement,.addedElement)  && ..UpdateStatementSearched272OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UpdateStatementSearched272OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WHERE")  && ..SearchCondition(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UserDefinedCharacterRepertoireName">
<Description>
 user-defined character repertoire name ::= character set name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..CharacterSetName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UserName">
<Description>
 user name ::= simple value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..SimpleValueSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UsingArguments">
<Description>
 using arguments ::= { USING | INTO } argument [ { comma argument }... ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UsingArguments295Sub(subElement,.addedElement)  && ..Argument(subElement,.addedElement)  && $S(..UsingArguments296RepOne(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UsingArguments295Sub">
<Description>
 USING | INTO</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"USING")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INTO")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UsingArguments296RepOne">
<Description>
 { comma argument }...</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set subElement=ParentElement
	set done=0 ; method start
	set done=0 ; must be at least 1
	while ..UsingArguments297Sub(subElement,.addedElement)  {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	quit ret
]]></Implementation>
</Method>

<Method name="UsingArguments297Sub">
<Description>
 comma argument</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..Comma(subElement,.addedElement)  && ..Argument(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UsingClause">
<Description>
 using clause ::= using arguments | using descriptor</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UsingArguments(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..UsingDescriptor(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UsingDescriptor">
<Description>
 using descriptor ::= { USING | INTO } SQL DESCRIPTOR descriptor name</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UsingDescriptor294Sub(subElement,.addedElement)  && ..addKeyword(subElement,"SQL")  && ..addKeyword(subElement,"DESCRIPTOR")  && ..DescriptorName(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="UsingDescriptor294Sub">
<Description>
 USING | INTO</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"USING")  {
		set done=1 ; or
	} elseif ..addKeyword(subElement,"INTO")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ValueExpression">
<Description>
 value expression ::= numeric value expression | string value expression | datetime value expression | interval value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..ValueExpression138Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ValueExpression138Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..NumericValueExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..StringValueExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..DatetimeValueExpression(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..IntervalValueExpression(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ValueExpressionPrimary">
<Description>
 value expression primary ::= unsigned value specification | column reference | set function specification | scalar subquery | case expression | left paren value expression right paren | cast specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..UnsignedValueSpecification(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ColumnReference(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..SetFunctionSpecification(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ScalarSubquery(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CaseExpression(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..ValueExpressionPrimary145Or(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..CastSpecification(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ValueExpressionPrimary145Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..LeftParen(subElement,.addedElement)  && ..ValueExpression(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="ValueSpecification">
<Description>
 value specification ::= literal | general value specification</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..ValueSpecification286Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ValueSpecification286Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..Literal(subElement,.addedElement)  {
		set done=1 ; or
	} elseif ..GeneralValueSpecification(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="VariableSpecification">
<Description>
 variable specification ::= embedded variable name [ indicator variable ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..EmbeddedVariableName(subElement,.addedElement)  && $S(..IndicatorVariable(subElement,.addedElement) :1,1:1) {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="VerticalBar">
<Description>
 vertical bar ::= |</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addPunctuation(subElement,"|") {
		set done=1
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ViewColumnList">
<Description>
 view column list ::= column name list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ColumnNameList(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ViewDefinition">
<Description>
 view definition ::= CREATE VIEW table name [ left paren view column list right paren ] AS query expression [ WITH [ levels clause ] CHECK OPTION ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"CREATE")  && ..addKeyword(subElement,"VIEW")  && ..TableName(subElement,.addedElement)  && ..ViewDefinition232OptGrp(subElement,.addedElement)  && ..addKeyword(subElement,"AS")  && ..QueryExpression(subElement,.addedElement)  && ..ViewDefinition233OptGrp(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ViewDefinition232OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..LeftParen(subElement,.addedElement)  && ..ViewColumnList(subElement,.addedElement)  && ..RightParen(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="ViewDefinition233OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..addKeyword(subElement,"WITH")  && $S(..LevelsClause(subElement,.addedElement) :1,1:1) && ..addKeyword(subElement,"CHECK")  && ..addKeyword(subElement,"OPTION")  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WhenOperand">
<Description>
 when operand ::= value expression</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..ValueExpression(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="WhereClause">
<Description>
 where clause ::= WHERE search condition</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addKeyword(subElement,"WHERE")  && ..SearchCondition(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="YearMonthLiteral">
<Description>
 year-month literal ::= years value | [ years value minus sign ] months value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..YearsValue(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..YearMonthLiteral47Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="YearMonthLiteral47Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..YearMonthLiteral48OptGrp(subElement,.addedElement)  && ..MonthsValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="YearMonthLiteral48OptGrp">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFSTART(subElement)
	set done=0 ; method start
	if ..YearsValue(subElement,.addedElement)  && ..MinusSign(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		$$$BNFCOMMITCOPY(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=1 /* failure rollsback but returns OK */
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="YearsValue">
<Description>
 years value ::= datetime value</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..DatetimeValue(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="mn1987">
<Description>
 1987 ::= 0 | edition1987 left paren 0 right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"0")  {
			set done=1 ; or
		} elseif ..mn1987335Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="mn1987335Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"edition1987")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"0")  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="mn1989">
<Description>
 1989 ::= 1989 base 1989 package</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	set done=0,ok=1,pos=..stream.pos,lastpos=pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set ret=($isobject(subElement))
		if ret $$$BNFCOMMITCOPY(subElement,ParentElement)
		quit ret
	}
	$$$BNFMEMOSET(pos,"")
	do ..getBookmark(.bm)
	while ok {
	$$$BNFSTART(subElement)
		do ..gotoBookmark(.bm)
		set rec=..mn1989336Recurse(subElement,.addedElement)
		if rec,..stream.pos>lastpos {
			$$$BNFMEMOSET(pos,addedElement)
			set done=1,lastpos=..stream.pos
		} else {
			set ok=0 $$$BNFMEMOGET(pos,subElement) ; restore to best 
		}
	}
	if done {
		$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		if $isobject(subElement) $$$BNFROLLBACK(subElement)
		set ret=0
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="mn1989336Recurse">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	set subElement=ParentElement
	set done=0 ; method start
	if ..mn1989Base(subElement,.addedElement)  && ..mn1989Package(subElement,.addedElement)  {
		set done=1 ; end compileRules
	}
	if done {
		set ret=1
	} else {
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="mn1989Base">
<Description>
 1989 base ::= 1 | edition1989 left paren 1 right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"1")  {
			set done=1 ; or
		} elseif ..mn1989Base337Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="mn1989Base337Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"edition1989")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"1")  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="mn1989Package">
<Description>
 1989 package ::= integrity no | integrity yes</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..IntegrityNo(subElement,.addedElement)  {
			set done=1 ; or
		} elseif ..IntegrityYes(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="mn1992">
<Description>
 1992 ::= 2 | edition1992 left paren 2 right paren</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	set done=0 ; method start
	set pos=..stream.pos
	if $$$BNFMEMOExists(pos) {
		$$$BNFMEMOGET(pos,subElement)
		set done=$isobject(subElement)
	} else {
		if ..addPunctuation(subElement,"2")  {
			set done=1 ; or
		} elseif ..mn1992340Or(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}

	}
	if done {
		$$$BNFMEMOSET(pos,subElement)
	} else {
	}
	if done {
			$$$BNFCOMMIT(subElement,ParentElement)
		set ret=1
	} else {
		$$$BNFROLLBACK(subElement)
		set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	quit ret
]]></Implementation>
</Method>

<Method name="mn1992340Or">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
		$$$DEBUGMethodBegin
		$$$BNFSTART(subElement)
		set done=0 ; method start
		if ..addPunctuation(subElement,"edition1992")  && ..LeftParen(subElement,.addedElement)  && ..addPunctuation(subElement,"2")  && ..RightParen(subElement,.addedElement)  {
			set done=1 ; end compileRules
		}
		if done {
			$$$BNFCOMMITCOPY(subElement,ParentElement)
			set ret=1
		} else {
			$$$BNFROLLBACK(subElement)
			set ret=0
		}
		$$$DEBUGMethodEnd
		quit ret
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>Type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Elements.SQL</ReturnType>
<Implementation><![CDATA[	quit ##class(PXW.DEV.BNF.Elements.SQL).%New(Type)
]]></Implementation>
</Method>

<Parameter name="KeywordPattern">
<Default>1.A</Default>
</Parameter>

<Parameter name="Keywords"/>
</Class>


<Class name="PXW.DEV.BNF.Run.COS">
<Super>PXW.DEV.BNF.GEN.COS</Super>
<TimeChanged>67125,77563.309473161</TimeChanged>
<TimeCreated>67125,77563.309473161</TimeCreated>

<Property name="codemode">
<Type>%String</Type>
</Property>

<Property name="bracketStack">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="bracketDepth">
<Type>%Integer</Type>
</Property>

<Method name="Dyadicop">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
	$$$BNFSTART(subElement)
	Set done=0
	If ..addPunctuationInList(subElement,$LISTBUILD("'<=","']]","'>="),3)
        || ..addPunctuationInList(subElement,$LISTBUILD("\\",">=","'>","<=","'<","'=","**","&&","]]","']","'[","||"),2)
        || ..addPunctuationInList(subElement,$LISTBUILD("+","-","/","\",">","<","=","*","]","[","!","_"),1)
    	 || ..HashOp(subElement,.addedElement)
		 || ..AmpOp(subElement,.addedElement)	 {
		Set done=1
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Number">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
	$$$BNFSTART(subElement)
	Set done=0

    Set n=""
    ; -
    While (..peek(1)="-") || (..peek(1)="+") {
        Set n=n_..nextNotEOL(1)
    }

    ; -123
    While (..peek(1)?1N) {
        Set n=n_..nextNotEOL(1)
    }

    ; start with a .
    If ..peek(2)?1"."1N {
        Set n=n_..next(2)
    }
    
    If n'="" {

        ; -123.456
        While (..peek(1)?1N) {
            Set n=n_..nextNotEOL(1)
        }

        ; -123.456E
        If (..peek(1)="E") || (..peek(1)="e") {
            Set n=n_..nextNotEOL(1)
            ; 123.456E-
            If ..peek(1)="-"{
                Set n=n_..nextNotEOL(1)
            }

            ; -123.456E-789
            While (..peek(1)?1N) {
                Set n=n_..nextNotEOL(1)
            }
        }

        If n'="" {
            Set atom=..newAtom("Number",n)
            Do subElement.AddPart(atom)
            Set done=1
        }

        If done {
            $$$BNFCOMMIT(subElement,ParentElement)
            Set ret=1
        } Else {
            $$$BNFROLLBACK(subElement)
            Set ret=0
        }
    } Else {
        Set ret=0
    }
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<Description>
identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'

This needs a lot of work, we really want to return a VARIABLE and then add on all the properties later I think
hacked to get going</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    Set ok=0
    If ..peek(2)="i%" {
        Set value=value_..next(2)
        If ..peek(1)="""" {
            Set value=value_..nextNotEOL(1)
            While ..peek(1)'="""" {
                Set value=value_..nextNotEOL(1)
            }
            Set value=value_..nextNotEOL(1)
            Set atom=..newAtom(ParentElement.type,value)
            Do ParentElement.AddPart(atom)
            Set ok=1
        }
    } Else {
        If ..peek(1)="%" Set value=..nextNotEOL(1)
        If ..peek(1)="%" Set value=..nextNotEOL(1)
        ; not a letter (or number)
        Set ch=..peek(1)
        ; no % so must start with a letter
        If value="",ch?1A Set value=..nextNotEOL(1)

        Set ok=1    
        If value="" {
            $$$DEBUG("checking identifier, ok=0")
            Set ok=0
        }
    }
    If ok {

        Set ch=..peek(1)
        While (ch?1A) || (ch?1N) || (ch=".")  {
            Set value=value_..nextNotEOL(1)
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom("identifier",value)
        Do ParentElement.AddPart(atom)
    }
    ;$$$DEBUG("checking identifier, ok=1")
    ;zw atom
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="ClassIdentifier">
<Description>
identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    ;d ..skipWhiteSpaceAndComments()
    
    ; IN COSSQL mode (on property definitions and maybe triiger, not tested triggers) 
    ; you can put {%%CLASSNAME}, you may be able to put other properties by I cannot make 
    ; any others work, so hard coding CLASSNAME only
    ;property RawContent As %String(MAXLEN = 10000) [ Calculated, ReadOnly, SqlComputeCode = { Set {RawContent}=##class({%%CLASSNAME}).getContentAsString({ID}) }, SqlComputed, Transient ];    
    
    If ..peek(13)="{%%CLASSNAME}" {
        Set atom=..newAtom(ParentElement.type,..next(13))
        Do ParentElement.AddPart(atom)
        Set ret=1
    } ElseIf ..peek(1)="""" {
        Set quote1=..nextNotEOL(1)
        Set value=""
        While ..peek(1)'="""" {
            Set value=value_..nextNotEOL(1)
        }
        Set quote2=..nextNotEOL(1)
        Set atom=..newAtom(ParentElement.type,value)
        Set atom.start=quote1
        Set atom.end=quote2
        Do ParentElement.AddPart(atom)
        Set ret=1
    } Else {
        Set ret=1
        Set value=""
        If ..peek(1)="%" Set value=..nextNotEOL(1)
        ; not a letter (or number)
        Set ch=..peek(1)
        ; no % so must start with a letter
        If value="",ch?1A Set value=..nextNotEOL(1)
        
        If value="" {
            ;$$$DEBUG("checking identifier, ok=0")
            Set ret=0
        }
        
        If ret {

            Set ch=..peek(1)
            While (ch?1A) || (ch?1N) || (ch=".")  {
                Set value=value_..nextNotEOL(1)
                Set ch=..peek(1)
            }
        
            Set atom=..newAtom(ParentElement.type,value)
            Do ParentElement.AddPart(atom)
        }
    }
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="LabelDefinition">
<Description>
label_definition ::= label [ label_formal_specification ] [ label_scope ]</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	;set currentpath=$g(%path) new %path set %path=currentpath_$c(47)_"LabelDefinition"
    ;;$$$DEBUG("%path="_%path)
    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
    ; labels only defined in first column (0)
    $$$DEBUG("LabelDefinition col="_..stream.col)

	If ..stream.col'=0 Quit 0

    ; there may be a macro on the first column
    If ..peek(3)="$$$" Quit ..Macrocall(ParentElement,.subElement)

    ; if the first thing is a # then do not consume it but leave it to be consumed by #dim etc
    If ..peek(1)="#" Quit 0

    Set res=##super(ParentElement,.subElement)
    $$$DEBUGMethodEnd
    Quit res
]]></Implementation>
</Method>

<Method name="HashOp">
<Description>
hash_op ::= '#'
special case where it mus NOT be the first thing on the line
eg this is valid
    s x=var # 2 
but this is not valid
    s x=var 
         # 2
this does not apply to other operators, # is special becasue it also starts special commands</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[

    $$$BNFPATH
    ;$$$DEBUG("%path="_%path)
    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
    Set hash=..peek(1)
    If hash'="#" Quit 0

    ; if it is at the start of line then its NOT an operation but IS start of #dim #define etc
    If ..whitespace,..whitespace.value[$CHAR(13) Quit 0

    Set hash=..nextNotEOL(1)
    Set atom=..newAtom("punctuation",hash)
    Do ParentElement.AddPart(atom)
    Quit 1
]]></Implementation>
</Method>

<Method name="AmpOp">
<Description><![CDATA[
amp_op ::= '&'
special case where it can signal &html, &sql, &js]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$BNFPATH
    ;$$$DEBUG("%path="_%path)
    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
    Set peek=$$$UPPER(..peek(20))
    If $EXTRACT(peek,1)'="&" Quit 0

    If $EXTRACT(peek,1,6)="&HTML<" Quit 0
    If $EXTRACT(peek,1,5)="&SQL(" Quit 0
    If $EXTRACT(peek,1,4)="&JS<" Quit 0
    If $EXTRACT(peek,1,12)="&JAVASCRIPT<" Quit 0

    Set amp=..nextNotEOL(1)
    Set atom=..newAtom("punctuation",amp)
    Do ParentElement.AddPart(atom)
    Quit 1
]]></Implementation>
</Method>

<Method name="PatternMatch">
<Description><![CDATA[
pattern_match ::= ( "?" | "'?" ) (pattern_match_combo )*
 summary=(S|S)&(F)
 type=group
 not=0]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	#dim atom as PXW.DEV.Atom
    #dim c as %CSP.Documatic

    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    Set peek=..peek(2)
    If $EXTRACT(peek,1)'="?",peek'="'?" Quit 0

	$$$DEBUGMethodBegin

    Set pat=""
    If peek="'?" {
        Set pat=pat_..nextNotEOL(2)
    } Else {
        Set pat=pat_..nextNotEOL(1)
    }
    	
	Set ok=1,bracket=0,patternN=0,instring=0,indirection=0,ret=1

    ; ?@indirect is special case
    If ..peek(1)="@" Set ok=0,indirection=1
    $$$DEBUG("pattern indirection="_indirection)

	While '..eof() && ok {
		Set ok=0,patternN=patternN+1
		Set peek=..peek(1)

        If peek="""" {
            If instring {
                Set peek2=..peek(2)
                If peek2="""""" {
                    Set pat=pat_..nextNotEOL(2)
                } Else {
                    Set pat=pat_..nextNotEOL(1)
                    Set instring=0
                }
            } Else {
                Set instring=1
                Set pat=pat_..nextNotEOL(1)
            }
            Set ok=1
            Continue
        }
        If instring {
            Set pat=pat_..nextNotEOL(1)
            Set ok=1
            Continue
        }

		If peek="(" {
			Set bracket=bracket+1
			Set pat=pat_..nextNotEOL(1)
			Set ok=1
			Continue
		}
		If bracket>0,peek=")" {
			Set bracket=bracket-1
			Set pat=pat_..nextNotEOL(1)
			Set ok=1
			Continue
		}

		If bracket=0,peek=")" {
			Set ok=0
			Continue
		}

		If bracket>0,peek="," {
			Set pat=pat_..nextNotEOL(1)
			Set ok=1
			Continue
		}

		If bracket=0,peek="," {
			Set ok=0
			Continue
		}

        If $LISTFIND($LISTBUILD(":","|","&","{"),peek) {
            Set ok=0
            Continue
        } 


    	; patterns are all joined together, no whitespace
        If $CHAR(9,32,160,13,10)[peek {
        	; except the first one which is allowed a leading space
            If patternN=1 {
                Set ok=1
                Set pat=pat_..nextNotEOL(1)
                Continue
            } Else {
                Set ok=0
                Continue
            }
        } 
        
        Set pat=pat_..nextNotEOL(1)
        Set ok=1
        Continue
    
    }
    Set atom=..newAtom("PatternMatch",pat)
    Do ParentElement.AddPart(atom)
  
    If indirection {
        Set ret=..SimpleIndirection(ParentElement,.indirectSubElement)
        $$$DEBUG("pattern indirection result="_ret)
    }

	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Whitespace">
<Description>
whitespace ::= ( [ comment ] [ ( ' ' | '\t' | '\r') ] )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[

	;set currentpath=$g(%path) new %path set %path=currentpath_$c(47)_"whitespace"
	;;$$$DEBUG("%path="_%path)
	
    ; whitespace is handled by the super, and there is something wrong with the logic below
    ;
    Quit 0 
 /*    
    if ($$REP263()) { quit 1 } else { quit 0 }
REP263()
	while ($$OPT260() && 
		$$OPT262()) {} quit 1 
OPT260()
	if (..Comment()) {} quit 1
OPT262()
	if ($$GRP261()) {} quit 1
GRP261()
	if (..isString(" ") || 
		..isString("\t") || 
		..isString("\r")) { quit 1 } else { quit 0 }
        */
]]></Implementation>
</Method>

<Method name="OneCosStatement">
<Description>
one_cos_statement ::= [ label_definition ] cos_command</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	;$$$BNFPATH
	$$$BNFSTART(subElement)

    Set label=..LabelDefinition(subElement)
    ; check to see if the label is on a line on its own
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set dots=0
   	While (..isString(subElement,".")) { Set dots=1 }

    Set directive=0,command=0
    If ..stream.col=0 {
        Set directive=..CosDirective(subElement)
    } Else {
        If ..stream.col>0 Set command=..CosCommand(subElement)
    }
    If label || dots || directive || command {
        $$$BNFCOMMIT(subElement,ParentElement)
        Set ret=1
    } Else {
        $$$BNFROLLBACK(subElement)
        Set ret=0
    }

    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="ObjectChainOLD">
<Description>
object_chain ::= '.' object_chain_item ( '.' object_chain_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    ; an object.method should not have white spaces
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
	If ..whitespace Quit 0
    ;break
    $$$DEBUGMethodBegin
	;$$$BNFPATH
	$$$BNFSTART(subElement)
	;;$$$DEBUG("%path="_%path)
	If (..isString(subElement,".") && 
		..ObjectChainItem(subElement) && 
		$$REP298(subElement)) {
		$$$BNFCOMMIT(subElement,ParentElement)
 		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0
	}
    $$$DEBUGMethodEnd
    Quit ret
REP298(ParentElement) New %done 
	$$$BNFSTART(subElement)
	While (..isString(subElement,".") && 
		..ObjectChainItem(%subElement)) { Set %done=1 }
	If $GET(%done) {
		$$$BNFCOMMIT(subElement,ParentElement)
		Quit 1
	} Else {
		$$$BNFROLLBACK(subElement)
		Quit 1
	}
]]></Implementation>
</Method>

<Method name="ObjectChain">
<Description>
object_chain ::= '.' object_chain_item ( '.' object_chain_item )*</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    ; an object.method should not have white spaces
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
	If ..whitespace Quit 0
    Quit ##super(ParentElement)
]]></Implementation>
</Method>

<Method name="Naked">
<Description>
naked ::= ' ' /* this is going to need some special code to recognise naked commands */</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    ; in single line mode and no white space found then we must be at the end of line
    ; eg: f x=1:1:10 d
    ; and therefore IS naked
    If ..stopAtEOL,'$ISOBJECT(..whitespace) {
        Set ret=1 
    } ElseIf ..peek(1)="{" {
        ; code block does not count as naked
        Set ret=0
    } ElseIf ..peek(1)="}" {
        ; immediate end to code block does count as naked
        Set ret=1
    } Else {
       ;d ..skipWhiteSpaceAndComments()
        Set ch=$EXTRACT(..whitespace.value,1,2)
        Set chspc=$TRANSLATE(ch,$CHAR(9)," ") ; turn tabs into spaces for checking
        Set ret=0
        If chspc="  " {
            Set ret=1 ; is naked
        } ElseIf chspc=(" "_$CHAR(13)) {
            Set ret=1 ; is naked
        } Else {
            If $EXTRACT(ch,1)=$CHAR(13) Set ret=1 ; naked
        }
    }
    $$$DEBUG("Naked="_ret)
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="String">
<Description>
string ::= '""' | ('"' 'regexp:[^\"\r\n]*' '"')</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	#dim o as PXW.DEV.Atom

    $$$DEBUGMethodBegin
	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set ok=1
    If ..peek(1)'="""" {
        Set ok=0
    }

    If ok {
        $$$BNFSTART(subElement)

        Set q1=..nextNotEOL(1)
        Set n=""
        Set instring=1
        While '..eof() && instring {
            Set chs=..peek(2)
            Set ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,2)
            ; embedded quotes or end of string?
            If ch="""" {
                If ch2="""" {
                    Set n=n_..nextNotEOL(2)
                } Else {
                    Set instring=0
                    Set q2=..nextNotEOL(1)
                }
            } Else {
                Set n=n_..nextNotEOL(1)
            }
        }
        Set o=..newAtom("String",n)
        Set o.start=q1
        Set o.end=q2
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="JsonString">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
     Do:..needsWScheck ..skipWhiteSpaceAndComments()
   
	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Set ok=1
    Set open=..peek(1)
    If open'="""" {
        Set ok=0
    }

    If ok {
        $$$BNFSTART(subElement)

        Set n=..nextNotEOL(1)
        Set instring=1
        While '..eof() && instring {
            Set chs=..peek(2)
            Set ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,1,2)
            ; embedded quotes or end of string?
            ; I am not sure how these get encoded so sticking with COS "" for quotes in quotes
            If ch2="\""" {
                Set n=n_..nextNotEOL(2)
                Continue
            }
            If ch="""" {
                Set instring=0
                Set n=n_..nextNotEOL(1)
            } Else {
                Set n=n_..nextNotEOL(1)
            }
        }
        Set o=..newAtom("String",n)
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="VariableIdentifier">
<Description>
identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If ..codemode["SQL" Quit ..VariableIdentifierSQL(ParentElement)

    $$$DEBUGMethodBegin
    ;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
    Set value=""
    If ..peek(1)="%" Set value=value_..nextNotEOL(1)
    ; not a letter (or number)
    Set ch=..peek(1)
    ; no % so must start with a letter
    If value="",ch?1A Set value=..nextNotEOL(1)
    
    Set ok=1
    If value="" {
        ;$$$DEBUG("checking identifier, ok=0")
        Set ok=0
    }
    If ok {
        Set ch=..peek(1)
        While (ch?1A) || (ch?1N)   {
            Set value=value_..nextNotEOL(1)
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom(ParentElement.type,value)
        Do ParentElement.AddPart(atom)
    }

    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="zzzIntrinsicfncall">
<Description><![CDATA[
intrinsicfncall ::= case_function_call
| select_function_call
| extract_function_call
| piece_function_call
| listitem_function_call
| listupdate_function_call
| increment_function_call
| method_function_call
| classmethod_function_call
| zobjmethod_function_call
| zobjclassmethod_function_call
| text_function_call
| bitlogic_function_call
| expression_function_call
| ('$' identifier function_parameter_list /* intrinsicfncall_parameter_list */ [ object_chain ])
 summary=F|F|F|F|F|F|F|F|F|F|F|F|F|F|(S&F&F&[F])
 type=group
 not=0]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Set ret=0
	If ..peek(1)="$" {
     ;   s ret=##super(ParentElement,.subElement)
    }
    Quit ret
]]></Implementation>
</Method>

<Method name="GlobalIdentifier">
<Description>
identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
    Set value=""
    If ..peek(1)="%" Set value=value_..nextNotEOL(1)
    If ..peek(1)="$" Set value=value_..nextNotEOL(1) ; ^$LOCK
    
    ; not a letter (or number)
    Set ch=..peek(1)
    ; no % so must start with a letter
    If value="",ch?1A Set value=..nextNotEOL(1)
    
    Set ok=1
    If value="" {
        ;$$$DEBUG("checking identifier, ok=0")
        Set ok=0
    }
    If ok {
        Set ch=..peek(1)
        While (ch?1A) || (ch?1N) || (ch=".")  {
            Set value=value_..nextNotEOL(1)
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom(ParentElement.type,value)
        Do ParentElement.AddPart(atom)
    }

    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="ArrayParameterList">
<Description><![CDATA[
array_parameter_list ::= '('  expression ( ',' expression )*  ')'
 summary=S&F&(S&F)&S
 type=group
 not=0]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	; make sure there is NO leading space
    Set ..needsWScheck=0
    Set ret=##super(ParentElement,.subElement)
    Set ..needsWScheck=1
    Quit ret
]]></Implementation>
</Method>

<Method name="VariableIdentifierSQL">
<Description>
This is more complicated that the normal variable SQL, putting in a separate routine so that we can optimize them separately 
(don't mind losing a bit of speed here as it will be called less often)</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    ;d ..skipWhiteSpaceAndComments()
    $$$BNFSTART(subElement)

    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""

    ; we need to allow:
    ; s x={*}
    ; s x={field}
    ; s x={field*C} (or *N or *O)
    ; 
    ; we need to block
    ; s x={"json":444}
    ; the json will be picked up by the json handler
    Set done=0,curly=0

    If ..isString(subElement,"{") {
        Set curly=1
        ; {*}
        If ..isString(subElement,"*") {
            If ..isString(subElement,"}") {
                Set done=1
            }
        } Else {
           Do:..needsWScheck ..skipWhiteSpaceAndComments() 
            Set ch=..peek(1),value=""
            While (ch?1A) || (ch?1N) || (ch="%") || (ch="*")  || (ch="_") || (ch="."){
                Set value=value_..nextNotEOL(1)
                Set ch=..peek(1)
            }
            If value'="" {
                Set atom=..newAtom(ParentElement.type,value)
                Do subElement.AddPart(atom)
                If ..isString(subElement,"}") {
                    Set done=1
                }
            }
        }
    } Else {
        ; now we do the same as for a normal variable 
        If ..peek(1)="%" Set value=..nextNotEOL(1)
        ; not a letter (or number)
        Set ch=..peek(1)
        ; no % so must start with a letter
        If value="",ch?1A Set value=..nextNotEOL(1)
        
        If value'="" {
            Set ch=..peek(1)
            While (ch?1A) || (ch?1N)   {
                Set value=value_..nextNotEOL(1)
                Set ch=..peek(1)
            }
        
            Set atom=..newAtom(ParentElement.type,value)
            Do ParentElement.AddPart(atom)
            Set done=1
        } 
    }
    If curly {
        If done {
            $$$BNFCOMMIT(subElement,ParentElement)
        } Else {
            $$$BNFROLLBACK(subElement)
        }
    }
    $$$DEBUGMethodEnd
    Quit done
]]></Implementation>
</Method>

<Method name="MacroIdentifier">
<Description>
identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;$$$BNFPATH
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set ok=1
    Set value=""
    If ..peek(1)="%" Set value=..nextNotEOL(1)
    ; not a letter (or number)
    Set ch=..peek(1) 
    ; no % so must start with a letter (or number)
    If value="",ch?1AN Set value=..nextNotEOL(1)
    
    If value="" {
        ;$$$DEBUG("checking identifier, ok=0")
        Set ok=0
    }
    If ok  {
        Set ch=..peek(1)
        While (ch?1A) || (ch?1N)   {
            Set value=value_..nextNotEOL(1)
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom(ParentElement.type,value)
        Do ParentElement.AddPart(atom)
    }
    $$$DEBUGMethodEnd
    Quit 1
]]></Implementation>
</Method>

<Method name="RoutineIdentifier">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;$$$BNFPATH

    Do:..needsWScheck ..skipWhiteSpaceAndComments()
 
    Set ok=1
    Set value=""
    If ..peek(1)="%" Set value=..nextNotEOL(1)
    ; not a letter (or number)
    Set ch=..peek(1)
    ; no % so must start with a letter
    If value="",ch?1A Set value=..nextNotEOL(1)
    
    If value="" {
        ;$$$DEBUG("checking identifier, ok=0")
        Set ok=0
    }
    If ok {
        Set ch=..peek(1)
        While (ch?1A) || (ch?1N) || (ch=".")   {
            Set value=value_..nextNotEOL(1)
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom(ParentElement.type,value)
        Do ParentElement.AddPart(atom)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="LabelIdentifier">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;$$$BNFPATH

    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set ok=1
    Set value=""
    If ..peek(1)="%" Set value=..nextNotEOL(1)
    Set ch=..peek(1)
    ; no % so must start with a letter or number
    If value="",ch?1AN Set value=..nextNotEOL(1)
    
    If value="" {
        Set ok=0
    }
    If ok {
        Set ch=..peek(1)
        While (ch?1A) || (ch?1N)   {
            Set value=value_..nextNotEOL(1)
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom(ParentElement.type,value)
        Do ParentElement.AddPart(atom)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="ObjectMemberIdentifier">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;$$$BNFPATH

    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set ok=1
    If ..peek(1)="""" {
        Set value=..nextNotEOL(1)
        Set instring=1
        While '..eof() && instring {
            Set chs=..peek(2)
            Set ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,2)
            ; embedded quotes or end of string?
            If ch="""" {
                If ch2="""" {
                    Set value=value_..nextNotEOL(2)
                } Else {
                    Set instring=0
                    Set value=value_..nextNotEOL(1)
                }
            } Else {
                Set value=value_..nextNotEOL(1)
            }
        }
    } Else {
        Set value=""
        If ..peek(1)="#" Set value=value_..nextNotEOL(1)
        If ..peek(1)="%" Set value=value_..nextNotEOL(1)
        ; not a letter (or number)
        Set ch=..peek(1)
        ; no % so must start with a letter
        If value="",ch?1A Set value=..nextNotEOL(1)
        
        If value="" {
            ;$$$DEBUG("checking identifier, ok=0")
            Set ok=0
            
        }
        If ok {
            Set ch=..peek(1)
            While (ch?1A) || (ch?1N)   {
                Set value=value_..nextNotEOL(1)
                Set ch=..peek(1)
            }
        }
    }
 
    If ok {
        Set atom=..newAtom(ParentElement.type,value)
        Do ParentElement.AddPart(atom)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// any_text_upto_close_bracket ::= 'code this'

]]></Content>
</UDLText>

<Method name="AnyTextUptoCloseBracket">
<Description>
 summary=S
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[

    $$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set ok=1
        $$$BNFSTART(subElement)

        Set n=""
        Set bracket=1
        While '..eof() && (bracket>0) {
            Set ch=..peek(1)
            If ch="(" {
                Set n=n_..nextNotEOL(1)
                Set bracket=bracket+1
            } ElseIf ch=")" {
                If bracket>1 {
                    Set n=n_..nextNotEOL(1)
                }
                Set bracket=bracket-1
            } Else {
                Set n=n_..nextNotEOL(1)
            }
        }
        Set o=..newAtom(subElement.type,n)
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
 
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="CosDirective">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    ; looing for #
    If ..peek(1)'="#" Quit 0
    ; but NOT ##
    If ..peek(2)="##" Quit 0
    
    Set oldmode=..stopAtEOL
    Set ..stopAtEOL=1
    Set ret=##super(ParentElement,.subElement)
    If ret=0 {
        Set ret=..recover(ParentElement,.recsub,"{}",$LISTBUILD($CHAR(13)))
    }
    Set ..stopAtEOL=oldmode
    Set ..needsWScheck=1
    Quit ret
]]></Implementation>
</Method>

<Method name="CommandListEol">
<Description><![CDATA[
command_list_eol ::= cos_command ( cos_command )* /* needs to stop at end of line */
 summary=F&(F)
 type=group
 not=0]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Set oldmode=..stopAtEOL
    Set ..stopAtEOL=1
    Set ret=##super(ParentElement,.subElement)
    Set ..stopAtEOL=oldmode
    Set ..needsWScheck=1
    Quit ret
]]></Implementation>
</Method>

<Method name="SubExpression">
<Description><![CDATA[
sub_expression ::= '(' expression ')'
 summary=S&F&S
 type=group
 not=0]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Set oldmode=..stopAtWhitespace
    Set ..stopAtWhitespace=0
    Set ret=##super(ParentElement,.subElement)
    Set ..stopAtWhitespace=oldmode
    Set ..needsWScheck=1
    Quit ret
]]></Implementation>
</Method>

<Method name="CloseBracket">
<Description>
close_bracket ::= ')'
 summary=S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    If ..isStringSingle(")",.value)=0 Quit 0
    $$$DEBUGMethodBegin
    Set atom=..newAtom("punctuation",..nextNotEOL(1))
    Do ParentElement.AddPart(atom)
    Set data=..bracketStack(..bracketDepth)
    Kill ..bracketStack(..bracketDepth)
    Set ..bracketDepth=..bracketDepth-1
    Set ..stopAtEOL=$LISTGET(data,1)
    Set ..stopAtWhitespace=$LISTGET(data,2)
    $$$DEBUGMethodEnd
    Quit 1
]]></Implementation>
</Method>

<Method name="OpenBracket">
<Description>
open_bracket ::= '('
 summary=S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    ; THIS MUST NOT REMOVE WHITESPACE, it is used for things like ARRAY() and $PIECE() where the ( ) must come DIRECTLY after the function name
	If ..peek(1)'="(" Quit 0
    $$$DEBUGMethodBegin
    Set atom=..newAtom("punctuation",..nextNotEOL(1))
    Do ParentElement.AddPart(atom)
    Set ..bracketDepth=..bracketDepth+1
    Set ..bracketStack(..bracketDepth)=$LISTBUILD(..stopAtEOL,..stopAtWhitespace)
    Set ..stopAtEOL=0
    Set ..stopAtWhitespace=0
    $$$DEBUGMethodEnd
    Quit 1
]]></Implementation>
</Method>

<Method name="PostConditional">
<Description><![CDATA[
post_conditional ::= ':' expression
 summary=S&F
 type=group
 not=0]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Set oldmode=..stopAtWhitespace
    Set ..stopAtWhitespace=1
    Set ret=##super(ParentElement,.subElement)
    Set ..stopAtWhitespace=oldmode
    Set ..needsWScheck=1
    Quit ret
]]></Implementation>
</Method>

<Method name="WriteFormatExpression">
<Description>
write_format_expression ::= write_bang_expression
| write_hash_expression
| write_pos_expression
| write_mnemonic_expression
 summary=F|F|F|F
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Set oldmode=..stopAtWhitespace
    Set ..stopAtWhitespace=1
    Set ..needsWScheck=0
    Set ret=##super(ParentElement,.subElement)
    Set ..stopAtWhitespace=oldmode
    Set ..needsWScheck=1
    Quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockSql">
<Description>
This is used by SQL compute, it does NOT allow line labels, it does allow {*} variables</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Set oldmode=..codemode
    Set ..codemode="COSSQL"
    Set ret=##super(ParentElement,.subElement)
    Set ..codemode=oldmode
    Quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockSqlStorage">
<Description>
This is used by SQL compute, it does NOT allow line labels, it does allow {*} variables</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Set oldmode=..codemode
    Set ..codemode="COSSQLSTORAGE"
    Set ret=##super(ParentElement,.subElement)
    Set ..codemode=oldmode
    Quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlockTrigger">
<Description>
This is used by SQL compute, it does allow line labels, it does allow {*} variables</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Set oldmode=..codemode
    Set ..codemode="COSSQL"
    Set ret=##super(ParentElement,.subElement)
    Set ..codemode=oldmode
    Quit ret
]]></Implementation>
</Method>

<Method name="HtmlBody">
<Description>
html_body ::= 'NEED HTML BODY'
 summary=S
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)

   	#dim atom as PXW.DEV.Atom
	;$$$BNFPATH
	$$$BNFSTART(subElement)
    Set atom=..newAtom("CSPCodeBlock Begin","")
    Do ParentElement.AddPart(atom)

	Set parser=##class(PXW.DEV.BNF.Run.CSP).%New()
	Set parser.stream=..stream
    Do parser.skipWhiteSpaceAndComments()
    ;$$$DEBUG("COS CODE BLOCK peeked "_parser.peek(1))
	If parser.CspPage(subElement) {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
    	Set atom=..newAtom("CSPCodeBlock End","")
		Do ParentElement.AddPart(atom)
		Set ret=1
	} Else {
        $$$BNFROLLBACK(subElement)
        Set ret=0
    }
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="JsBody">
<Description>
js_body ::= 'NEED JS BODY'
 summary=S
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
 	#dim atom as PXW.DEV.Atom
    $$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
    Set atom=..newAtom("JavascriptCodeBlock Begin","")
    Do ParentElement.AddPart(atom)

	Set parser=##class(PXW.DEV.BNF.Run.JS).%New()
	Set parser.stream=..stream
    Do parser.skipWhiteSpaceAndComments()

    $$$DEBUG("Javascript language normal")
    If parser.StatementList(subElement) {
        $$$BNFCOMMIT(subElement,ParentElement)
        Set ..whitespace=parser.whitespace
        Set ..comment=parser.comment
        Set atom=..newAtom("JavascriptCodeBlock End","")
        Do ParentElement.AddPart(atom)
        Set ret=1
    } Else {
        $$$BNFROLLBACK(subElement)
        Set ret=0
    }
    $$$DEBUGMethodBegin
    Quit ret
]]></Implementation>
</Method>

<Method name="SqlBody">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)

   	#dim atom as PXW.DEV.Atom
	;$$$BNFPATH
	$$$BNFSTART(subElement)
    Set atom=..newAtom("SQLCodeBlock Begin","")
    Do ParentElement.AddPart(atom)
	Set parser=##class(PXW.DEV.BNF.Run.SQL).%New()
	Set parser.stream=..stream
    Do parser.skipWhiteSpaceAndComments()
    ;$$$DEBUG("COS CODE BLOCK peeked "_parser.peek(1))
	If parser.SqlProgram(subElement) {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
    	Set atom=..newAtom("SQLCodeBlock End","")
		Do ParentElement.AddPart(atom)
		Set ret=1
	} Else {
        Set recret=..recover(ParentElement,.recsub,"()","")
        If recret=0 {
            $$$BNFROLLBACK(subElement)
            Set ret=0
        } Else {
            Set ret=1
        }
    }
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="CosDirectiveDefineSubst">
<Description><![CDATA[
cos_directive_define_subst ::= [cos_command | expression ] text_to_eol_continue
 summary=[F|F]&F
 type=group
 not=0]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	Set oldmode=..codemode
    Set ..codemode="DEFINE" 
    Set ret=##super(ParentElement,.subElement)
    Set ..codemode=oldmode
    Quit ret
]]></Implementation>
</Method>

<Method name="CosCommand">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	Set ret=##super(ParentElement,.subElement)
    
    If ret=0 {
        If ..codemode="DEFINE" {
            ; in DEFINE mode, just let it fail, do not attempt recovery
        } ElseIf ..codemode["STORAGE" {
            ; in storge we want to stop at the end tag (<) or if in a cdata:]]]]><![CDATA[> 
            ; we can only allow 1 letter in each item in the list
            Set ret=..recover(ParentElement,.recSub,"{}",$LISTBUILD($CHAR(13),"<","]"))
        } Else {
            Set ret=..recover(ParentElement,.recSub,"{}",$LISTBUILD($CHAR(9)," ",$CHAR(13)))
        }
    }
    ;i ret=0 break
    Quit ret
]]></Implementation>
</Method>

<Method name="TextToEolContinue">
<Description>
text_to_eol_continue ::= 'regexp:[^\r\n]*'
 summary=R
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ; this is used in situations like below, where set x=2 and set y=2 are in the macro
    ;#define x set x=2 ##continue
    ;            set y=3
    
    ; note that the continue is valid only until the next line, so don't skip all white space
    Set n=""
    While '..eof(),..peek(1)'=$CHAR(13) {
        ; at continue directive read the word and then the eol char
        If $$$UPPER(..peek(10))="##CONTINUE" {
            ; add what we have so far
            Set atom=..newAtom("text",n)
            Do ParentElement.AddPart(atom)
            
            Set n=..next(10) ; the ##continue directive
            Set atom=..newAtom("keyword",n)
            Do ParentElement.AddPart(atom)

            Set n=""
            While ..peek(1)'=$CHAR(13) { Set n=n_..nextNotEOL(1) } ; add trailing whitespace (after the ##continue)
            Set n=n_..nextNotEOL(1)   ; the next line
            Set ..whitespace=..newAtom("whitespace",n)
            Set n=""

            Continue
        }
        Set n=n_..nextNotEOL(1)
    } 
    If n'="" {
        Set atom=..newAtom(ParentElement.type,n)
        Do ParentElement.AddPart(atom)
    }
    $$$DEBUGMethodEnd
    Quit 1
]]></Implementation>
</Method>

<Method name="AnyKeyword">
<Description>
any_keyword ::= 'need any keyword'
 summary=S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Set keyword=..peekKeyword()
    If keyword'="" {
        Set next=..nextNotEOL($LENGTH(keyword))
        Do ParentElement.AddPart(..newAtom("keyword",next))
        Set ret=1
    } Else {
        Set ret=0
    }
    Quit ret
]]></Implementation>
</Method>

<Method name="skipComments">
<Description>
Skip over the next set of comments, return 1 if something was done or 0</Description>
<FormalSpec>ch10:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Set ch=$EXTRACT(ch10,1)
    If ch=";" Set ..comment=..readLineComment(";") Quit 1
    Set ch2=$EXTRACT(ch10,1,2)
    If ch2="/*" Set ..comment=..readBlockComment() Quit 1
    If ch2="//" Set ..comment=..readLineComment("//") Quit 1
    If ch2="#;" Set ..comment=..readLineComment("#;") Quit 1
    Set ch3=$EXTRACT(ch10,1,3)
    If ch3="##;" Set ..comment=..readLineComment("##;") Quit 1
    Quit 0
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Run.CSP">
<Super>PXW.DEV.BNF.GEN.CSP</Super>
<TimeChanged>67125,77563.28656646</TimeChanged>
<TimeCreated>67125,77563.28656646</TimeCreated>

<Property name="commentMode">
<Description>
Set to CDEF, COS</Description>
<Type>%String</Type>
<InitialExpression>"XML"</InitialExpression>
</Property>

<Method name="Text">
<Description>
xml_content ::= text
 summary=F
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    $$$BNFSTART(subElement)
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
    ; reached a mismatched > so at the end?
    If ..peek(1)=">" Quit 0

	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Set ok=0,n=""
    While ('..eof()) && (..peek(1)'="<") && (..peek(1)'=">") {
        Set cos=0
        While ('..eof()) && (..peek(1)'="<") && (..peek(1)'=">") && ('cos) {
            Set ch2=..peek(2)
            If ch2="#(" {
                Set cos=1
            } Else {
                Set n=n_..next()
            }
            Set ok=1
        }
        Set o=..newAtom(subElement.type,n)
        Do subElement.AddPart(o)
        If cos {
            Do ..CosExpression(subElement,.cosSubElement)
        }
    }
    $$$BNFCOMMIT(subElement,ParentElement)
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="TextNoSpace">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    $$$BNFSTART(subElement)
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
    ; reached a mismatched > so at the end?
    If ..peek(1)=">" Quit 0

	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Set ok=0,n=""
    While ('..eof()) && (..peek(1)'="<") && (..peek(1)'=">")  && (..peek(1)'=" ") {
        Set cos=0
        While ('..eof()) && (..peek(1)'="<") && (..peek(1)'=">") && (..peek(1)'=" ") && ('cos) {
            Set ch2=..peek(2)
            If ch2="#(" {
                Set cos=1
            } Else {
                Set n=n_..next()
            }
            Set ok=1
        }
        Set o=..newAtom(subElement.type,n)
        Do subElement.AddPart(o)
        If cos {
            Do ..CosExpression(subElement,.cosSubElement)
        }
    }
    $$$BNFCOMMIT(subElement,ParentElement)
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="CspElement">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	Set oldmode=..commentMode
    Set ..commentMode="XML"
    Set ret=##super(ParentElement,.subElement)
    Set ..commentMode=oldmode
    Quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    $$$BNFSTART(subElement)
    $$$BNFPATH
	;$$$DEBUG("%path="_%path)

    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    Set ok=0
    ;i ..peek(1)="%" s value=..next()
    ;i ..peek(1)="%" s value=..next()
    ; not a letter (or number)
    Set ch=..peek(1)
    ; no % so must start with a letter
    If value="",ch?1A Set value=..next()

    Set ok=1    
    If value="" {
        $$$DEBUG("checking identifier, ok=0")
        Set ok=0
    }
    If ok {

        Set ch=..peek(1)
        While (ch?1A) || (ch?1N) || (ch=".") || (ch="-")  {
            Set value=value_..next()
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom(subElement.type,value)
        Do subElement.AddPart(atom)
        Do ParentElement.AddPart(subElement)
    }
    ;$$$DEBUG("checking identifier, ok=1")
    ;zw atom
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="String">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    $$$BNFSTART(subElement)
    $$$BNFPATH
	;$$$DEBUG("%path="_%path)

    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    Set ok=0
    Set char=..peek(1)
    If char="""" Set ok=1
    If char="'" Set ok=1

    Set instring=1 ; 1 means started, 2=continuation (after code expression)
    If ok {
        While '..eof() && instring {
            Set o=..newAtom("String")
            If instring=1 {
                Set o.start=..next()
                Set n=""
                Set marker=o.start
                Set instring=2
            }
            Set cos=0
            While '..eof() && instring && 'cos {
                Set ch=..peek(1),ch2=$EXTRACT(..peek(2),2)
                
                If ch="\" {
                    ; escaped marker (' or ")
                    If ch2=marker {
                        Set n=n_..next(2) ; \"
                    } ElseIf ch2="\" {
                        Set n=n_..next(2) ; \\
                    } Else {
                        Set n=n_..next()
                    }
                } ElseIf ch="#",ch2="(" { 
                    Set cos=1                
                } ElseIf ch=marker {
                    Set instring=0
                    Set o.end=..next()
                } Else {
                    Set n=n_..next()
                }
            }
            Set o.value=n
            Do subElement.AddPart(o)
            If cos {
                Set cosdone=..CosExpression(subElement,.cosSubElement) 
            }
        }
    }
    If ok {
 
        Do ParentElement.AddPart(subElement)
    }
    
    ;$$$DEBUG("checking identifier, ok=1")
    ;zw atom
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="Number">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    $$$BNFSTART(subElement)
    $$$BNFPATH
	;$$$DEBUG("%path="_%path)

    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    Set ok=0

    Set ch=..peek(1)
    While (ch?1N) || (ch=".")  {
        Set value=value_..next()
        Set ch=..peek(1)
        Set ok=1
    }
    If ok {
        Set atom=..newAtom(subElement.type,value)
        Do subElement.AddPart(atom)
        Do ParentElement.AddPart(subElement)
    }

    ;$$$DEBUG("checking identifier, ok=1")
    ;zw atom
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="CosExpressionBody">
<Description>
cos_expression_body ::= 'NEEDS COS EXPRESSION BODY'
 summary=S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
		#dim atom as PXW.DEV.Atom
	$$$DEBUGMethodBegin
    $$$BNFPATH
	$$$BNFSTART(subElement)
    Set atom=..newAtom("CosCodeExpression Begin","")
    Do ParentElement.AddPart(atom)

	Set parser=##class(PXW.DEV.BNF.Run.COS).%New()
	Set parser.stream=..stream
    Do parser.skipWhiteSpaceAndComments()
    ;$$$DEBUG("COS CODE BLOCK peeked "_parser.peek(1))
	Set done=0
    If parser.peek(2)=")#" {
		; its empty 
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
		Set atom=..newAtom("CosCodeExpression Empty","")
		Do ParentElement.AddPart(atom)
        Set done=1
	} ElseIf parser.Expression(subElement) {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
		Set atom=..newAtom("CosCodeBlock End","")
		Do ParentElement.AddPart(atom)
		Set done=1
	} Else {
        $$$BNFROLLBACK(subElement)
        Set done=0
    }
    $$$DEBUGMethodEnd
    Quit done
]]></Implementation>
</Method>

<Method name="JavascriptBody">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    #dim atom as PXW.DEV.Atom
    $$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
    Set atom=..newAtom("JavascriptCodeBlock Begin","")
    Do ParentElement.AddPart(atom)

	Set parser=##class(PXW.DEV.BNF.Run.JS).%New()
	Set parser.stream=..stream
    Do parser.skipWhiteSpaceAndComments()

    $$$DEBUG("Javascript language normal")
    If parser.StatementList(subElement) {
        $$$BNFCOMMIT(subElement,ParentElement)
        Set ..whitespace=parser.whitespace
        Set ..comment=parser.comment
        Set atom=..newAtom("JavascriptCodeBlock End","")
        Do ParentElement.AddPart(atom)
        Set ret=1
    } Else {
        $$$BNFROLLBACK(subElement)
        Set ret=0
    }
    $$$DEBUGMethodBegin
    Quit ret
   	/*#dim tokenstream as PXW.DEV.TokenStream

	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)

	s parser=##class(PXW.DEV.JS.Parser).%New()
	d parser.inputNewObject()
	s parser.input.input=..stream
    s parser.EndEmbeddedChar="</SCRIPT>"

	s imp=##class(PXW.DEV.Element).%New()
    ;s imp.This=..This 
    ;s imp.ThisMethod=..ThisMethod
    ;s imp.Parser=parser.%ClassName(1)
    set next=parser.Next(.scratch)
    while next {
        d imp.AddPart(next)
        s next=parser.Next(.scratch)
    }
    d ParentElement.AddPart(imp)

    ; the tokeniser will have the last thing in it which should be a ">" so go back
    s ..stream.pos=..stream.pos-1

    ;w "<pre>" w "peek2="_..peek((10)) d ..getBookmark(.bookMark) zw bookMark w "</pre>"
    $$$DEBUGMethodEnd
    q 1
    */


    /*
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)

   	#dim atom as PXW.DEV.Atom
	;$$$BNFPATH
	$$$BNFSTART(subElement)
    s atom=..newAtom("JSCodeBlock Begin","")
    d ParentElement.AddPart(atom)

	s parser=##class(PXW.DEV.BNF.Run.JS).%New()
	s parser.stream=..stream
    d parser.skipWhiteSpaceAndComments()
    ;$$$DEBUG("COS CODE BLOCK peeked "_parser.peek(1))
	i parser.CspPage(subElement) {
		$$$BNFCOMMIT(subElement,ParentElement)
		s ..whitespace=parser.whitespace
		s ..comment=parser.comment
    	s atom=..newAtom("CSPCodeBlock End","")
		d ParentElement.AddPart(atom)
		quit 1
	} else {
        $$$BNFROLLBACK(subElement)
        quit 0
    }*/
]]></Implementation>
</Method>

<Method name="skipComments">
<Description>
Skip over the next set of comments, return 1 if something was done or 0</Description>
<FormalSpec>ch10:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Set ch4=$EXTRACT(ch10,1,4)
    If ch4="<!--" Set ..comment=..readXMLBlockComment() Quit 1
    Quit 0
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Run.ClassDefinition">
<Super>PXW.DEV.BNF.GEN.ClassDefinition</Super>
<TimeChanged>67125,77563.216526585</TimeChanged>
<TimeCreated>67125,77563.216526585</TimeCreated>

<Property name="commentMode">
<Description>
Set to CDEF, COS</Description>
<Type>%String</Type>
<InitialExpression>"CDEF"</InitialExpression>
</Property>

<UDLText name="T">
<Content><![CDATA[/* properties that are reset on every member */
]]></Content>
</UDLText>

<Property name="language">
<Type>%String</Type>
</Property>

<Property name="codemode">
<Type>%String</Type>
</Property>

<Property name="mimetype">
<Type>%String</Type>
</Property>

<Property name="lowmem">
<Description>
When this runs in lowmem mode you are expected to handle some of the stuff in the caller</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="nextStage">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Parameter name="keywordAtomType">
<Default>CDEFKeyword</Default>
</Parameter>

<Method name="test2">
<Description>
d ##class(PXW.DEV.BNF.Run.ClassDefinition).test2("%Library.RegisteredObject",.x)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassName,x</FormalSpec>
<Implementation><![CDATA[
 
    ;$$$DEBUGNew("")
    ;$$$DEBUGNew(##class(PXW.Debuggers.Timing).%ClassName(1))

    $$$DEBUG("Testing Class="_ClassName)
    ;$$$DEBUG("method="_method)
    Set zh=$ZHOROLOG
    Set %NS="LOCAL_USER"
    Set ClassServer=##class(PXW.DEV.Dictionary.ClassDefinitionObject).%OpenId(%NS)
    Set sc=ClassServer.GetClassStudioText(ClassName,.text,.linesOfCode)
    Write !,"load "_($ZHOROLOG-zh) Set zh=$ZHOROLOG
    ; make crlf just cr so that its 1 char, I am sure it will make things simpler
	;s flat=Code 
	Set flat=$REPLACE(text,$CHAR(13,10),$CHAR(13))

    ;$$$DEBUG("main element:"_element)
    Set x=..%New() 
    Set x.stream=##class(PXW.DEV.InputStream).NewString(flat)
    Set element=##class(PXW.DEV.Element).%New()
    While x.cheese(element) {
        Set element=##class(PXW.DEV.Element).%New()
        Set ok=1
    }

    Write !,"cheesed "_($ZHOROLOG-zh) Set zh=$ZHOROLOG

    If $$$debugIsON Do element.write() ; this is silly if debugging is not going to screen!
    $$$DEBUG("Testing complete")
    $$$DEBUG("")
    $$$DEBUG("ok="_ok)
    If ok {
        $$$DEBUG("x.element.ToString()="_$REPLACE(element.ToString(),$CHAR(13),$CHAR(13,10)))
    } Else {
        $$$DEBUG("decoded up to:"_$REPLACE($EXTRACT(x.stream.input,1,x.stream.lastStartOfLinePos),$CHAR(13),$CHAR(13,10)))
        $$$DEBUG("**************")
        $$$DEBUG("stuck at     :"_$REPLACE($EXTRACT(x.stream.input,x.stream.lastStartOfLinePos,x.stream.lastPos),$CHAR(13),$CHAR(13,10)))
        $$$DEBUG("**************")
        $$$DEBUG("rest of line: "_$REPLACE($EXTRACT(x.stream.input,x.stream.lastStartOfLinePos,*),$CHAR(13),$CHAR(13,10)) )
    }
]]></Implementation>
</Method>

<Method name="test3">
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassName,x</FormalSpec>
<Implementation><![CDATA[
    ;$$$DEBUGNew("")
    ;$$$DEBUGNew(##class(PXW.Debuggers.Timing).%ClassName(1))

    $$$DEBUG("Testing Class="_ClassName)
    ;$$$DEBUG("method="_method)

    Set %NS="LOCAL_USER"
    Set ClassServer=##class(PXW.DEV.Dictionary.ClassDefinitionObject).%OpenId(%NS)
    Set sc=ClassServer.GetClassStudioText(ClassName,.text,.linesOfCode)
	
    ; make crlf just cr so that its 1 char, I am sure it will make things simpler
	;s flat=Code 
	Set flat=$REPLACE(text,$CHAR(13,10),$CHAR(13))

    Set element=##class(PXW.DEV.Element).%New()
    Set %section=element
    $$$DEBUG("main element:"_element)
    Set x=..%New()
    Set x.stream=##class(PXW.DEV.InputStream).NewString(flat)
    Set ok=$METHOD(x,"ClassDefinition",element)
    Set x.element=element
    If $$$debugIsON Do element.write() ; this is silly if debugging is not going to screen!
    $$$DEBUG("Testing complete")
    $$$DEBUG("")
    $$$DEBUG("ok="_ok)
    If ok {
        $$$DEBUG("x.element.ToString()="_$REPLACE(element.ToString(),$CHAR(13),$CHAR(13,10)))
    } Else {
        $$$DEBUG("decoded up to:"_$REPLACE($EXTRACT(x.stream.input,1,x.stream.lastStartOfLinePos),$CHAR(13),$CHAR(13,10)))
        $$$DEBUG("**************")
        $$$DEBUG("stuck at     :"_$REPLACE($EXTRACT(x.stream.input,x.stream.lastStartOfLinePos,x.stream.lastPos),$CHAR(13),$CHAR(13,10)))
        $$$DEBUG("**************")
        $$$DEBUG("rest of line: "_$REPLACE($EXTRACT(x.stream.input,x.stream.lastStartOfLinePos,*),$CHAR(13),$CHAR(13,10)) )
    }
]]></Implementation>
</Method>

<Method name="cheese">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[

    If ..nextStage=0 {
         Set ok=..UdlStatement(element)
         Set ..nextStage=1
    } ElseIf ..nextStage=1 {
        Set ok=..OneClassmember(element)
        ; when we get past the memebers ok=0 so THEN move on
        If ok=0 {
            Set ok=..addPunctuation(element,"}")
            If ok {
                Set ..nextStage=2
            }
        }  
    } Else {
        Set ok=0
    }

    Quit ok
]]></Implementation>
</Method>

<Method name="ClassMemberSection">
<Description><![CDATA[
class_member_section ::= '{' class_member_list? '}'
 summary=S&?&S
 type=group
 not=0]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	If ..isStringSingle("{",.value)=0 Quit 0
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
	$$$BNFSTART(subElement)
	Set done=0
	; type=group, check=if, skip=1, skipall=0
	Set gotVal=..next($LENGTH(value)),atom=..newAtom("punctuation",gotVal)
	Do subElement.AddPart(atom)
   
    If ..lowmem { 
        Set done=1
    } Else {
        If $SELECT(..ClassMemberList(subElement,.addedElement):1,1:1) {
            If ..addPunctuation(subElement,"}")	 {
                Set done=1
            }
        }
    }
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="OneClassmember">
<Description>
one_classMember ::= class_class_method
| class_ForeignKey
| class_index
| class_method
| class_property
| class_parameter
| class_projection
| class_query
| class_relationship
| class_storage
| class_trigger
| class_view
| class_xdata
| class_client_method
 summary=F|F|F|F|F|F|F|F|F|F|F|F|F|F
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Set ..language="objectscript"
    Set ..codemode=""

	Set ret=##super(ParentElement,.subElement)

    If ret=0 {
        Set peek=..peek(1)
        ; not eol or end of block
        If peek'=$CHAR(13),peek'="}" {
            Set ret=..recover(ParentElement,.recSub,"{}",$LISTBUILD($CHAR(13)))
        }
    }

    Quit ret
]]></Implementation>
</Method>

<Method name="XdataJson">
<Description>
xdata_json ::= xdata_json_object | xdata_json_array | xdata_json_prim
 summary=F|F|F
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Set ret=##super(ParentElement,.subElement)
   
    If ret=0 {
        Set ret=..recover(ParentElement,.recSub,"{}","")
    }

    Quit ret
]]></Implementation>
</Method>

<Method name="XdataJsonArrayItems">
<Description><![CDATA[
xdata_json_array_items ::= xdata_json (',' xdata_json)*
 summary=F&(S&F)
 type=group
 not=0]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    ; if empty array just quit (OK)
    If ..isStringSingle("]") Quit 1

	Set ret=##super(ParentElement,.subElement)
    Quit ret
]]></Implementation>
</Method>

<Method name="ClassLanguageName">
<Description>
class_language_name ::= 'cache' | 'basic' |  'javascript' | 'java' | 'mvbasic' | 'tsql' | 'cpp'
 summary=S|S|S|S|S|S|S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	Set ret=##super(ParentElement,.subElement)
    If ret=1 {
        Set ..language=subElement.ToString(0)
    }
    Quit ret
]]></Implementation>
</Method>

<Method name="AttributeCodemodetype">
<Description>
attribute_CodeModeType ::= 'call' | 'code' | 'expression' | 'objectgenerator' | 'generator'
 summary=S|S|S|S|S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	Set ret=##super(ParentElement,.subElement)
    If ret=1 {
        Set ..codemode=subElement.ToString(0)
    }
    Quit ret
]]></Implementation>
</Method>

<Method name="AttributeMimetype">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	Set ret=##super(ParentElement,.subElement)
    If ret=1 {
        Set ..mimetype=$PIECE(subElement.ToString(0),"=",2,*)
    }
    Quit ret
]]></Implementation>
</Method>

<Method name="CosCodeBlock">
<Description>
cos_code_block ::= 'NEEDS COS CODE BLOCK'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	#dim atom as PXW.DEV.Atom
	;$$$BNFPATH
	$$$BNFSTART(subElement)
    Set atom=..newAtom("CosCodeBlock Begin","")
    Do ParentElement.AddPart(atom)

    If $$$UPPER(..language)="PYTHON" {
        ;$$$DEBUGNew("")
        Set subElement.type="PythonBody"
        Set parser=##class(PXW.DEV.BNF.Run.Python).%New()
        Set parser.stream=..stream
        Do parser.skipWhiteSpaceAndComments()
        If parser.peek(1)="}" {
            ; its empty 
            Set ..whitespace=parser.whitespace
            Set ..comment=parser.comment
            Set atom=..newAtom("CosCodeBlock Empty","")
            Do ParentElement.AddPart(atom)
            Quit 1
        }
        If parser.File(subElement) {
             $$$BNFCOMMIT(subElement,ParentElement)
            Set ..whitespace=parser.whitespace
            Set ..comment=parser.comment
            Set atom=..newAtom("CosCodeBlock End","")
            Do ParentElement.AddPart(atom)
		    Quit 1
        } Else {
            Set ret=..recover(ParentElement,.subElement,"{}","") ; NOT WORKING AS EXPECTED!
            ;;$$$BNFROLLBACK(subElement)
            ;Quit 1
        }
    }

	Set parser=##class(PXW.DEV.BNF.Run.COS).%New()
	Set parser.stream=..stream
    Do parser.skipWhiteSpaceAndComments()
    ;$$$DEBUG("COS CODE BLOCK peeked "_parser.peek(1))
	If parser.peek(1)="}" {
		; its empty 
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
		Set atom=..newAtom("CosCodeBlock Empty","")
		Do ParentElement.AddPart(atom)
		Quit 1
	}

    ; the only example of a call I have seen looked like an expression and not what was documented
    ; 
	If (..codemode="expression") || (..codemode="call") {
        $$$DEBUG("COS language EXPRESSION")
        If parser.Expression(subElement) {
            ; maybe its codemode=expression (need to check specifically)
            $$$BNFCOMMIT(subElement,ParentElement)
            Set ..whitespace=parser.whitespace
            Set ..comment=parser.comment
            Set atom=..newAtom("CosCodeBlock End","")
            Do ParentElement.AddPart(atom)
		    Quit 1
        } Else {
            $$$BNFROLLBACK(subElement)
            Quit 0
        }
    } Else {
        $$$DEBUG("COS language normal")
        If parser.CosCodeBlock(subElement) {
            $$$BNFCOMMIT(subElement,ParentElement)
            Set ..whitespace=parser.whitespace
            Set ..comment=parser.comment
            Set atom=..newAtom("CosCodeBlock End","")
            Do ParentElement.AddPart(atom)
            Quit 1
        } Else {
            $$$BNFROLLBACK(subElement)
            Quit 0
        }
	}
]]></Implementation>
</Method>

<Method name="CosCodeBlockSql">
<Description>
cos_code_block ::= 'NEEDS COS SQL CODE BLOCK'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	#dim atom as PXW.DEV.Atom
	;$$$BNFPATH
	$$$BNFSTART(subElement)
    Set atom=..newAtom("CosCodeBlock Begin","")
    Do ParentElement.AddPart(atom)

	Set parser=##class(PXW.DEV.BNF.Run.COS).%New()
 	Set parser.stream=..stream
    Do parser.skipWhiteSpaceAndComments()
    ;$$$DEBUG("COS CODE BLOCK peeked "_parser.peek(1))
	If parser.peek(1)="}" {
		; its empty 
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
		Set atom=..newAtom("CosCodeBlock Empty","")
		Do ParentElement.AddPart(atom)
		Quit 1
	}
    
	If ..codemode="expression" {
        $$$DEBUG("COS language EXPRESSION")
        If parser.Expression(subElement) {
            ; maybe its codemode=expression (need to check specifically)
            $$$BNFCOMMIT(subElement,ParentElement)
            Set ..whitespace=parser.whitespace
            Set ..comment=parser.comment
            Set atom=..newAtom("CosCodeBlock End","")
            Do ParentElement.AddPart(atom)
		    Quit 1
        } Else {
            $$$BNFROLLBACK(subElement)
            Quit 0
        }
    } Else {
        $$$DEBUG("COS language normal")
        If parser.CosCodeBlockSql(subElement) {
            $$$BNFCOMMIT(subElement,ParentElement)
            Set ..whitespace=parser.whitespace
            Set ..comment=parser.comment
            Set atom=..newAtom("CosCodeBlock End","")
            Do ParentElement.AddPart(atom)
            Quit 1
        } Else {
            $$$BNFROLLBACK(subElement)
            Quit 0
        }
	}
]]></Implementation>
</Method>

<Method name="CosCodeBlockSqlStorage">
<Description>
cos_code_block ::= 'NEEDS COS SQL CODE BLOCK'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	#dim atom as PXW.DEV.Atom
	;$$$BNFPATH
	$$$BNFSTART(subElement)
    Set atom=..newAtom("CosCodeBlock Begin","")
    Do ParentElement.AddPart(atom)

	Set parser=##class(PXW.DEV.BNF.Run.COS).%New()
 	Set parser.stream=..stream
    Do parser.skipWhiteSpaceAndComments()
    ;$$$DEBUG("COS CODE BLOCK peeked "_parser.peek(1))
	If parser.peek(1)="}" {
		; its empty 
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
		Set atom=..newAtom("CosCodeBlock Empty","")
		Do ParentElement.AddPart(atom)
		Quit 1
	}
    
	If ..codemode="expression" {
        $$$DEBUG("COS language EXPRESSION")
        If parser.Expression(subElement) {
            ; maybe its codemode=expression (need to check specifically)
            $$$BNFCOMMIT(subElement,ParentElement)
            Set ..whitespace=parser.whitespace
            Set ..comment=parser.comment
            Set atom=..newAtom("CosCodeBlock End","")
            Do ParentElement.AddPart(atom)
		    Quit 1
        } Else {
            $$$BNFROLLBACK(subElement)
            Quit 0
        }
    } Else {
        $$$DEBUG("COS language normal")
        If parser.CosCodeBlockSqlStorage(subElement) {
            $$$BNFCOMMIT(subElement,ParentElement)
            Set ..whitespace=parser.whitespace
            Set ..comment=parser.comment
            Set atom=..newAtom("CosCodeBlock End","")
            Do ParentElement.AddPart(atom)
            Quit 1
        } Else {
            $$$BNFROLLBACK(subElement)
            Quit 0
        }
	}
]]></Implementation>
</Method>

<Method name="CosCodeBlockTrigger">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	#dim atom as PXW.DEV.Atom
	;$$$BNFPATH
	$$$BNFSTART(subElement)
    Set atom=..newAtom("CosCodeBlockTrigger Begin","")
    Do ParentElement.AddPart(atom)
 	Set parser=##class(PXW.DEV.BNF.Run.COS).%New()
	Set parser.stream=..stream
    Do parser.skipWhiteSpaceAndComments()
    ;$$$DEBUG("COS CODE BLOCK peeked "_parser.peek(1))
	If parser.peek(1)="}" {
		; its empty 
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
		Set atom=..newAtom("CosCodeBlockTrigger Empty","")
		Do ParentElement.AddPart(atom)
		Quit 1
	}
    
	If ..codemode="expression" {
        $$$DEBUG("COS language EXPRESSION")
        If parser.Expression(subElement) {
            ; maybe its codemode=expression (need to check specifically)
            $$$BNFCOMMIT(subElement,ParentElement)
            Set ..whitespace=parser.whitespace
            Set ..comment=parser.comment
            Set atom=..newAtom("CosCodeBlockTigger End","")
            Do ParentElement.AddPart(atom)
		    Quit 1
        } Else {
            $$$BNFROLLBACK(subElement)
            Quit 0
        }
    } Else {
        $$$DEBUG("COS language normal")
        If parser.CosCodeBlockTrigger(subElement) {
            $$$BNFCOMMIT(subElement,ParentElement)
            Set ..whitespace=parser.whitespace
            Set ..comment=parser.comment
            Set atom=..newAtom("CosCodeBlockTrigger End","")
            Do ParentElement.AddPart(atom)
            Quit 1
        } Else {
            $$$BNFROLLBACK(subElement)
            Quit 0
        }
	}
]]></Implementation>
</Method>

<Method name="JavascriptCodeBlock">
<Description>
cos_code_block ::= 'NEEDS COS CODE BLOCK'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
 	#dim atom as PXW.DEV.Atom
	;$$$BNFPATH
	$$$BNFSTART(subElement)
    Set atom=..newAtom("JavascriptCodeBlock Begin","")
    Do ParentElement.AddPart(atom)

	Set parser=##class(PXW.DEV.BNF.Run.JS).%New()
	Set parser.stream=..stream
    Do parser.skipWhiteSpaceAndComments()
    ;$$$DEBUG("COS CODE BLOCK peeked "_parser.peek(1))
	If parser.peek(1)="}" {
		; its empty 
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
		Set atom=..newAtom("JavascriptCodeBlock Empty","")
		Do ParentElement.AddPart(atom)
		Quit 1
	}
    ; the only example of a call I have seen looked like an expression and not what was documented
    ; 

    $$$DEBUG("Javascript language normal")
    If parser.StatementList(subElement) {
        $$$BNFCOMMIT(subElement,ParentElement)
        Set ..whitespace=parser.whitespace
        Set ..comment=parser.comment
        Set atom=..newAtom("JavascriptCodeBlock End","")
        Do ParentElement.AddPart(atom)
        Quit 1
    } Else {
        $$$BNFROLLBACK(subElement)
        Quit 0
    }
]]></Implementation>
</Method>

<Method name="Expression">
<Description>
expression ::= 'NEEDS EXPRESSION'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	#dim atom as PXW.DEV.Atom
	;$$$BNFPATH
 	$$$BNFSTART(subElement)
    Set ret=0
    
    ;s atom=..newAtom("Expression Begin","")
    ; d subElement.AddPart(atom)

    Set parser=##class(PXW.DEV.BNF.Run.COS).%New()
    Set parser.stream=..stream
    ;d parser.skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    If parser.peek(1)="}" {
        ; its empty 
        ;s ..whitespace=parser.whitespace
        ;s ..comment=parser.comment
        ;s atom=..newAtom("CosCodeBlock Empty","")
        ;d ParentElement.AddPart(atom)

        Set ret=1
    } ElseIf parser.Expression(subElement) {
        Set ret=1
    } 
    If ret=1 {
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
		Set atom=..newAtom("CosCodeBlock End","")
		Do subElement.AddPart(atom)
		$$$BNFCOMMIT(subElement,ParentElement)
	} Else {
		$$$BNFROLLBACK(subElement)
	}
    Quit ret
]]></Implementation>
</Method>

<Method name="CosExpressionSql">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	#dim atom as PXW.DEV.Atom
	;$$$BNFPATH
 	$$$BNFSTART(subElement)
    Set ret=0
    
    ;s atom=..newAtom("Expression Begin","")
    ; d subElement.AddPart(atom)

    Set parser=##class(PXW.DEV.BNF.Run.COS).%New()
    Set parser.stream=..stream
    Set parser.codemode="COSSQL"
    ;d parser.skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    If parser.peek(1)="}" {
        ; its empty 
        ;s ..whitespace=parser.whitespace
        ;s ..comment=parser.comment
        ;s atom=..newAtom("CosCodeBlock Empty","")
        ;d ParentElement.AddPart(atom)

        Set ret=1
    } ElseIf parser.Expression(subElement) {
        Set ret=1
    } 
    If ret=1 {
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
		Set atom=..newAtom("CosCodeBlock End","")
		Do subElement.AddPart(atom)
		$$$BNFCOMMIT(subElement,ParentElement)
	} Else {
		$$$BNFROLLBACK(subElement)
	}
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="Filename">
<Description>
filename ::= 'NEEDS FILE NAME'
 summary=S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    Set ch=..peek(1)
    While (ch?1A) || (ch?1N) || (ch=".") || (ch="/") {
        Set value=value_..next()
        Set ch=..peek(1)
    }
 
    Set atom=..newAtom("FileName",value)
    Do ParentElement.AddPart(atom)
    ;$$$DEBUG("checking identifier, ok=1")
    ;zw atom
    Quit 1
]]></Implementation>
</Method>

<Method name="Identifier">
<Description>
identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    If ..peek(1)="%" Set value=..next()
    If ..peek(1)="%" Set value=..next() ; EG %%OID
    ; not a letter (or number)
    Set ch=..peek(1)
    ; no % so must start with a letter
    If value="",ch?1A Set value=..next()
    
    If value="" {
        $$$DEBUG("checking identifier, ok=0")
        Quit 0
    }
    Set ch=..peek(1)
    While (ch?1A) || (ch?1N) || (ch=".")  {
        Set value=value_..next()
        Set ch=..peek(1)
    }
 
    Set atom=..newAtom(ParentElement.type,value)
    Do ParentElement.AddPart(atom)
    $$$DEBUG("checking identifier, ok=1")
    Quit 1
]]></Implementation>
</Method>

<Method name="ClassItemIdentifier">
<Description>
class_item_identifier ::= string | identifier
 summary=F|F
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	Set ret=##super(ParentElement,.subElement)
    If ret {
        Set atom=subElement.FirstAtom()
        If $PIECE(atom.type,":",1)="String" Set atom.type="ClassItemIdentifier"
    }
    Quit ret
]]></Implementation>
</Method>

<Method name="ClientIdentifier">
<Description>
identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    If ..peek(1)="%" Set value=..next()
    If ..peek(1)="%" Set value=..next() ; EG %%OID
    If ..peek(1)="_" Set value=..next()
    ; not a letter (or number)
    Set ch=..peek(1)
    ; no % so must start with a letter
    If value="",ch?1A Set value=..next()
    
    If value="" {
        $$$DEBUG("checking identifier, ok=0")
        Quit 0
    }
    Set ch=..peek(1)
    While (ch?1A) || (ch?1N) || (ch=".") || (ch="_") {
        Set value=value_..next()
        Set ch=..peek(1)
    }
 
    Set atom=..newAtom("ClientIdentifier",value)
    Do ParentElement.AddPart(atom)
    $$$DEBUG("checking identifier, ok=1")
    Quit 1
]]></Implementation>
</Method>

<Method name="XmlIdentifier">
<Description>
identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'</Description>
<FormalSpec>ParentElement:PXW.DEV.BNF.Element,*subElement:PXW.DEV.BNF.Element</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    If ..peek(1)="_" Set value=..next()
    ; not a letter (or number)
    Set ch=..peek(1)
    ; no % so must start with a letter
    If value="",ch?1A Set value=..next()
    
    If value="" {
        $$$DEBUG("checking identifier, ok=0")
        Quit 0
    }
    Set ch=..peek(1)
    While (ch?1A) || (ch?1N) || (ch="-") || (ch="_") || (ch=".")  {
        Set value=value_..next()
        Set ch=..peek(1)
    }
 
    Set atom=..newAtom("XmlIdentifier",value)
    Do ParentElement.AddPart(atom)
    ;$$$DEBUG("checking identifier, ok=1")
    ;zw atom
    Quit 1
]]></Implementation>
</Method>

<Method name="SqlFieldName">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    If ..peek(1)="""" {
        Set value=""      
        Set value=value_..next()
        While ..peek(1)'="""" {
            Set value=value_..next()
        }
        Set value=value_..next()
        Set atom=..newAtom("SqlFieldName",value)
        Do ParentElement.AddPart(atom)
    } Else {

        Set value=""
        If ..peek(1)="%" Set value=..next()
        If ..peek(1)="%" Set value=..next() ; EG %%OID
        If ..peek(1)="_" Set value=..next()
        ; not a letter (or number)
        Set ch=..peek(1)
        ; no % so must start with a letter
        If value="",ch?1A Set value=..next()
        
        If value="" {
            $$$DEBUG("checking identifier, ok=0")
            Quit 0
        }
        Set ch=..peek(1)
        While (ch?1A) || (ch?1N) || (ch="_")  {
            Set value=value_..next()
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom("SqlFieldName",value)
        Do ParentElement.AddPart(atom)
        $$$DEBUG("checking identifier, ok=1")
    }
    Quit 1
]]></Implementation>
</Method>

<Method name="SqlTableName">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    ;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    If ..peek(1)="""" {
        Set value=""
        Set value=value_..next()
        While ..peek(1)'="""" {
            Set value=value_..next()
        }
        Set value=value_..next()
        Set atom=..newAtom("SqlTableName",value)
        Do ParentElement.AddPart(atom)
    } Else {
        Set value=""
        If ..peek(1)="%" Set value=..next()
        If ..peek(1)="%" Set value=..next() ; EG %%OID
        If ..peek(1)="_" Set value=..next()
        ; not a letter (or number)
        Set ch=..peek(1)
        ; no % so must start with a letter
        If value="",ch?1A Set value=..next()
        
        If value="" {
            $$$DEBUG("checking identifier, ok=0")
            Quit 0
        }
        Set ch=..peek(1)
        While (ch?1A) || (ch?1N) || (ch="_")  {
            Set value=value_..next()
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom("SqlTableName",value)
        Do ParentElement.AddPart(atom)
    }
    Quit 1
]]></Implementation>
</Method>

<Method name="AliasIdentifier">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    Set done=1
    If ..peek(1)="""" {
        Set value=value_..next(1)
        While ..peek(1)'="""" {
            Set value=value_..next(1)
        }
        Set value=value_..next(1)
        Set done=1
    } Else {

        If ..peek(1)="%" Set value=..next()
        ; not a letter (or number)
        Set ch=..peek(1)
        ; no % so must start with a letter
        If value="",ch?1A Set value=..next()
        
        If value'="" {
            Set ch=..peek(1)
            While (ch?1A) || (ch?1N) || (ch=".") ||(ch="_")  {
                Set value=value_..next()
                ;zw value,..stream.pos
                Set ch=..peek(1)
            }
            Set done=1
        }
    }
    If done {
        Set atom=..newAtom(ParentElement.type,value)
        Do ParentElement.AddPart(atom)
    }
    Quit done
]]></Implementation>
</Method>

<Method name="ClassIdentifier">
<Description>
identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    ;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    If ..peek(1)="%" Set value=..next()
    ; not a letter (or number)
    Set ch=..peek(1)
    ; no % so must start with a letter
    If value="",ch?1A Set value=..next()
    
    If value="" {
        $$$DEBUG("checking identifier, ok=0")
        Quit 0
    }
    Set ch=..peek(1)
    While (ch?1A) || (ch?1N) || (ch=".")  {
        Set value=value_..next()
		;zw value,..stream.pos
        Set ch=..peek(1)
    }
 
    Set atom=..newAtom(ParentElement.type,value)
    Do ParentElement.AddPart(atom)

    Quit 1
]]></Implementation>
</Method>

<Method name="VariableIdentifier">
<Description>
identifier ::= 'regexp:(((\%[a-zA-Z0-9])|(\$[a-zA-Z])|[a-zA-Z])[a-zA-Z0-9\.]*)'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    If ..peek(1)="%" Set value=..next()
    ; not a letter (or number)
    Set ch=..peek(1)
    ; no % so must start with a letter
    If value="",ch?1A Set value=..next()
    
    Set ok=1
    If value="" {
        ;$$$DEBUG("checking identifier, ok=0")
        Set ok=0
    }
    If ok {
        Set ch=..peek(1)
        While (ch?1A) || (ch?1N)   {
            Set value=value_..next()
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom(ParentElement.type,value)
        Do ParentElement.AddPart(atom)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="Number">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
	$$$BNFSTART(subElement)
	Set done=0

    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set n=""
    ; -
    While (..peek(1)="-") || (..peek(1)="+") {
        Set n=n_..next()
    }

    ; -123
    While (..peek(1)?1N) {
        Set n=n_..next()
    }

    ; start with a .
    If ..peek(2)?1"."1N {
        Set n=n_..next(2)
    }
    
    If n'="" {

        ; -123.456
        While (..peek(1)?1N) {
            Set n=n_..next()
        }

        ; -123.456E
        If (..peek(1)="E") || (..peek(1)="e") {
            Set n=n_..next()
            ; 123.456E-
            If ..peek(1)="-"{
                Set n=n_..next()
            }

            ; -123.456E-789
            While (..peek(1)?1N) {
                Set n=n_..next()
            }
        }

        If n'="" {
            Set atom=..newAtom("Number",n)
            Do subElement.AddPart(atom)
            Set done=1
        }

        If done {
            $$$BNFCOMMIT(subElement,ParentElement)
            Set ret=1
        } Else {
            $$$BNFROLLBACK(subElement)
            Set ret=0
        }
    } Else {
        Set ret=0
    }
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="String">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
     Do:..needsWScheck ..skipWhiteSpaceAndComments()
   
	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Set ok=1
    Set open=..peek(1)
    If open'="""",open'="'" {
        Set ok=0
    }

    If ok {
        $$$BNFSTART(subElement)

        Set n=..next()
        Set instring=1
        While '..eof() && instring {
            Set chs=..peek(2)
            Set ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,2)
            ; embedded quotes or end of string?
            ; I am not sure how these get encoded so sticking with COS "" for quotes in quotes
            If ch=open {
                If ch2=open {
                    Set n=n_..next()_..next()
                } Else {
                    Set instring=0
                    Set n=n_..next()
                }
            } Else {
                Set n=n_..next()
            }
        }
        Set o=..newAtom("String",n)
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="JsonString">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
     Do:..needsWScheck ..skipWhiteSpaceAndComments()
   
	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Set ok=1
    Set open=..peek(1)
    If open'="""" {
        Set ok=0
    }

    If ok {
        $$$BNFSTART(subElement)

        Set n=..next()
        Set instring=1
        While '..eof() && instring {
            Set chs=..peek(2)
            Set ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,1,2)
            ; embedded quotes or end of string?
            ; I am not sure how these get encoded so sticking with COS "" for quotes in quotes
            If ch2="\""" {
                Set n=n_..next()_..next()
                Continue
            }
            If ch="""" {
                Set instring=0
                Set n=n_..next()
            } Else {
                Set n=n_..next()
            }
        }
        Set o=..newAtom("String",n)
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="ClassQueryBody">
<Description>
class_query_body ::= text_brace_block
 summary=F
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
   	#dim atom as PXW.DEV.Atom
	$$$BNFPATH
	$$$BNFSTART(subElement)
    Set atom=..newAtom("SQLCodeBlock Begin","")
    Do ParentElement.AddPart(atom)

	Set parser=##class(PXW.DEV.BNF.Run.SQL).%New()
	Set parser.stream=..stream
    Do parser.skipWhiteSpaceAndComments()
    ;$$$DEBUG("COS CODE BLOCK peeked "_parser.peek(1))
	If parser.peek(1)="}" {
		; its empty 
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
		Set atom=..newAtom("SQLCodeBlock Empty","")
		Do ParentElement.AddPart(atom)
		Quit 1
	}
	If parser.QuerySpecification(subElement) {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ..whitespace=parser.whitespace
		Set ..comment=parser.comment
		Set atom=..newAtom("SQLCodeBlock End","")
		Do ParentElement.AddPart(atom)
        If ..peek(1)'="}" {
            Set recret=..recover(ParentElement,.recsub,"{}","")
        }
 
		Quit 1
	} Else {
        ;s recret=..recover(ParentElement,.recsub,"{}","")
        $$$BNFROLLBACK(subElement)
        Quit 0
    }
]]></Implementation>
</Method>

<Method name="XmlContent">
<Description>
xml_content ::= text
 summary=F
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    $$$BNFSTART(subElement)
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Set ok=0,n=""
    While ('..eof()) && (..peek(1)'="<") {
        Set n=n_..next()
        Set ok=1
    }
    Set o=..newAtom(subElement.type,n)
    Do subElement.AddPart(o)
    $$$BNFCOMMIT(subElement,ParentElement)
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// xml_content ::= text

]]></Content>
</UDLText>

<Method name="XdataText">
<Description>
 summary=F
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[

    ; is this really XML or JSON?
    ; the recovery in json means that we need to do the check twice and since this is overridden anyway its simple to plug in here
    If ..isPunctuationInList($LISTBUILD("<","{","["),1)'=0 Quit 0
    If ..peek(1)="}" Quit 1 ; lets count empty block as text

    $$$DEBUGMethodBegin
    $$$BNFSTART(subElement)
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Set ok=0,n="",curly=0
    While ('..eof()) && ((curly>0)||(..peek(1)'="}")) {
        If ..peek(1)="{" Set curly=curly+1
        If ..peek(1)="}" Set curly=curly-1
        Set n=n_..next()
        Set ok=1
    }
    Set o=..newAtom(subElement.type,n)
    Do subElement.AddPart(o)
    $$$BNFCOMMIT(subElement,ParentElement)
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="ClassXdata">
<Description><![CDATA[
class_xdata ::= 'xdata' xdata_name [ '[' (xdata_attributes)* ']' ] '{' (xdata_text | xdata_xml | xdata_json )   /* ([xml_xml] [xml_data] [xdata_json] */ '}'
 summary=S&F&[S&(F)*&S]&S&(F|F|F)&S
 type=group
 not=0]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	Set ..mimetype=""
    Quit ##super(ParentElement,.subElement)
]]></Implementation>
</Method>

<Method name="XmlCdataText">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    $$$BNFSTART(subElement)
    
	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Set ok=1,n=""
    While ('..eof()) && (..peek(3)'="]]]]><![CDATA[>") {
        Set n=n_..next()
        Set ok=1
    }
 
    Set o=..newAtom(subElement.type,n)
    Do subElement.AddPart(o)
   
    $$$BNFCOMMIT(subElement,ParentElement)
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="XmlData">
<Description><![CDATA[
xml_data ::= xml_tag_s_a xml_tag_ns_name (xml_attribute)* xml_tag_s_b ( (xml_data)* | xml_content ) xml_tag_e_a xml_tag_ns_name xml_tag_e_b
 summary=F&F&(F)&F&((F)|F)&F&F&F
 type=group]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	Set oldmode=..commentMode
    Set ..commentMode="XML"
    Set ret=##super(ParentElement,.subElement)
    Set ..commentMode=oldmode
    Quit ret
]]></Implementation>
</Method>

<Method name="TextInCurly">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    $$$BNFSTART(subElement)
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Set ok=1,n=""
    While ('..eof()) && (..peek(1)'="}") {
        Set n=n_..next()
    }
    Set o=..newAtom(subElement.type,n)
    Do subElement.AddPart(o)
    $$$BNFCOMMIT(subElement,ParentElement)
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="skipComments">
<FormalSpec>ch10:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If ..commentMode="XML" {
        If $EXTRACT(ch10,1,4)="<!--" Set ..comment=..readXMLBlockComment() Quit 1
    } Else {
        If $EXTRACT(ch10,1,3)="///" Set ..comment=..readLineComment("///") Quit 1
        If $EXTRACT(ch10,1,2)="//" Set ..comment=..readLineComment("//") Quit 1
        If $EXTRACT(ch10,1,2)="/*" Set ..comment=..readBlockComment() Quit 1

    }
    Quit 0
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Run.JS">
<Super>PXW.DEV.BNF.GEN.JS</Super>
<TimeChanged>67125,77563.313623153</TimeChanged>
<TimeCreated>67125,77563.313623153</TimeCreated>

<Property name="commentMode">
<Description>
Set to CDEF, COS</Description>
<Type>%String</Type>
<InitialExpression>"JS"</InitialExpression>
</Property>

<Method name="Eos">
<Description>
eos ::= SemiColon
| end_of_file
/*| {this.lineTerminatorAhead()}?
| {this.closeBrace()}?
*/
 summary=F|F 
 type=group
 not=0 </Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    If ..needsWScheck Do ..skipWhiteSpaceAndComments()

    If $ISOBJECT(..whitespace),..whitespace[$CHAR(13) Quit 1
    If ..peek(1)="}" Quit 1 ; do not consume

	$$$DEBUGMethodBegin
	$$$BNFPATH
	$$$BNFSTART(subElement)
	Set done=0
	If ..Semicolon(subElement,.addedElement) {
	 Set done=1 
	} ElseIf ..eof()	 {
		Set done=1 
	}  
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0
	} 
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
IDENTIFIER_NAME ::= 'NEED IDENTIFIER NAME'
STRING_LITERAL ::= 'NEED STRING LITERAL'
DECIMAL_LITERAL ::= 'NEED DECIMAL LITERAL'
HEX_INTEGER_LITERAL ::= 'NEED HEX INTEGER LITERAL'
*/
]]></Content>
</UDLText>

<Method name="Identifier">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[    Quit ..IdentifierName(ParentElement,.subElement)
]]></Implementation>
</Method>

<Method name="IdentifierName">
<Description>
IDENTIFIER_NAME ::= 'NEED IDENTIFIER NAME'
 summary=S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	    $$$DEBUGMethodBegin
    ;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    Set ok=0
  
    ;i ..peek(1)="%" s value=..nextNotEOL(1)
    If ..peek(1)="_" Set value=..nextNotEOL(1)
    ; not a letter (or number)
    Set ch=..peek(1)
    ; no % so must start with a letter
    If value="",ch?1A Set value=..nextNotEOL(1)

    Set ok=1    
    If value="" {
        $$$DEBUG("checking identifier, ok=0")
        Set ok=0
    }
    If ok {

        Set ch=..peek(1)
        While (ch?1A) || (ch?1N)  {
            Set value=value_..nextNotEOL(1)
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom("identifier",value)
        Do ParentElement.AddPart(atom)
    }
    ;$$$DEBUG("checking identifier, ok=1")
    ;zw atom
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="DecimalLiteral">
<Description>
DECIMAL_LITERAL ::= 'NEED DECIMAL LITERAL'
 summary=S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
	$$$BNFSTART(subElement)
	Set done=0

    Set n=""
    ; -
    While (..peek(1)="-") || (..peek(1)="+") {
        Set n=n_..nextNotEOL(1)
    }

    ; -123
    While (..peek(1)?1N) {
        Set n=n_..nextNotEOL(1)
    }

    ; start with a .
    If ..peek(2)?1"."1N {
        Set n=n_..next(2)
    }
    
    If n'="" {

        ; -123.456
        While (..peek(1)?1N) || (..peek(1)=".") {
            Set n=n_..nextNotEOL(1)
        }

        ; -123.456E
        If (..peek(1)="E") || (..peek(1)="e") {
            Set n=n_..nextNotEOL(1)
            ; 123.456E-
            If ..peek(1)="-"{
                Set n=n_..nextNotEOL(1)
            }

            ; -123.456E-789
            While (..peek(1)?1N) {
                Set n=n_..nextNotEOL(1)
            }
        }

        If n'="" {
            Set atom=..newAtom("Number",n)
            Do subElement.AddPart(atom)
            Set done=1
        }
        If done {
            $$$BNFCOMMIT(subElement,ParentElement)
            Set ret=1
        } Else {
            $$$BNFROLLBACK(subElement)
            Set ret=0
        }
    } Else {
        Set ret=0
    }
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="HexIntegerLiteral">
<Description>
HEX_INTEGER_LITERAL ::= 'NEED HEX INTEGER LITERAL'
 summary=S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
	$$$BNFSTART(subElement)
	Set done=0

    If ..peek(2)="0x" {
        Set n=..nextNotEOL(2) 
        ; -123
        While (..peek(1)'=""), ("0123456789ABCDEF"[..peek(1)) {
            Set n=n_..nextNotEOL(1)
        }

        If n'="" {
            Set atom=..newAtom("Number",n)
            Do subElement.AddPart(atom)
            Set done=1
        }

        If done {
            $$$BNFCOMMIT(subElement,ParentElement)
            Set ret=1
        } Else {
            $$$BNFROLLBACK(subElement)
            Set ret=0
        }
    } Else {
        Set ret=0
    }
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="StringLiteral">
<Description>
STRING_LITERAL ::= 'NEED STRING LITERAL'
 summary=S
 type=group
 not=0</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
		#dim o as PXW.DEV.Atom

    $$$DEBUGMethodBegin
	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set ok=0
    If ..peek(1)'="","""'"[..peek(1) {
        Set ok=1
    }

    If ok {
        $$$BNFSTART(subElement)

        Set q1=..nextNotEOL(1)
        Set n=""
        Set instring=1
        While '..eof() && instring {
            Set chs=..peek(2)
            Set ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,2)
            ; embedded quotes
            If ch="\" {
                If ch2=q1 {
                    Set n=n_..nextNotEOL(2)
                } Else {
                    Set n=n_..nextNotEOL(1)
                }
            } ElseIf ch=q1 {
                    Set instring=0
                    Set q2=..nextNotEOL(1)
            } Else {
                Set n=n_..nextNotEOL(1)
            }
        }
        Set o=..newAtom("String",n)
        Set o.start=q1
        Set o.end=q2
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="skipComments">
<FormalSpec>ch10:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If $EXTRACT(ch10,1,2)="//" Set ..comment=..readLineComment("//") Quit 1
    If $EXTRACT(ch10,1,2)="/*" Set ..comment=..readBlockComment() Quit 1
    Quit 0
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Run.Python">
<Super>PXW.DEV.BNF.GEN.Python</Super>
<TimeChanged>67125,77563.369834153</TimeChanged>
<TimeCreated>67125,77563.369834153</TimeCreated>

<Property name="fStringEndChar">
<Type>%String</Type>
</Property>

<Property name="bracketDepth">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="sqDepth">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="curlyDepth">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="currentIndent">
<Type>%String</Type>
</Property>

<Method name="addPunctuation">
<FormalSpec>ParentElement:PXW.DEV.Element,Punctuation:%String,*foundString:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set ret=##super(ParentElement,Punctuation,.foundString)
    ; stuff in ( ) can span more than 1 line
    If ret {
        If foundString="(" {
            Set ..bracketDepth=..bracketDepth+1,..stopAtEOL=0
        } ElseIf foundString=")" {
            Set ..bracketDepth=..bracketDepth-1
        } ElseIf foundString="[" {
            Set ..sqDepth=..sqDepth+1,..stopAtEOL=0 
        } ElseIf foundString="]" {
            Set ..sqDepth=..sqDepth-1
        } ElseIf foundString="{" {
            Set ..curlyDepth=..curlyDepth+1,..stopAtEOL=0
        } ElseIf foundString="}" {
            Set ..curlyDepth=..curlyDepth-1
        }
        If ..bracketDepth=0,..curlyDepth=0,..sqDepth=0 {
            Set ..stopAtEOL=1
        }
    }
    Quit ret
]]></Implementation>
</Method>

<Method name="getBookmark">
<FormalSpec><![CDATA[&bookmark:%String]]></FormalSpec>
<Implementation><![CDATA[
    ;$$$DEBUGMethodBegin
    
    Set bookmark=$LISTBUILD(..stream.pos,..stream.col,..stream.line,..stream.startOfLinePos,..needsWScheck,..stopAtEOL,..stopAtWhitespace,
                    ..bracketDepth,..sqDepth,..curlyDepth,..currentIndent) 
    Set bookmark("ws")=..whitespace
    Set bookmark("c")=..comment

    ;$$$DEBUGMethodEnd
]]></Implementation>
</Method>

<Method name="gotoBookmark">
<FormalSpec><![CDATA[&bookmark:%String]]></FormalSpec>
<Implementation><![CDATA[
    ;quit
    ;$$$DEBUGMethodBegin
    Set forward=(..stream.pos<$LISTGET(bookmark,1))
    $$$DEBUG("Going "_$SELECT(forward:"forward",1:"back")_" from:"_$zconvert(..peek(20),"O","JSON"))
    
    Set $LISTBUILD(pos,col,line,startOfLinePos,needsWScheck,stopeol,stopws,
            bracketDepth,sqDepth,curlyDepth,indent)=bookmark
    Set ..stream.pos=pos,..stream.col=col,..stream.line=line,..stream.startOfLinePos=startOfLinePos
    Set ..bracketDepth=bracketDepth
    Set ..sqDepth=sqDepth
    Set ..curlyDepth=curlyDepth
    Set ..currentIndent=indent
    ;s $lb(sm,needsWScheck,stopeol,stopws)=bookmark
    ;d ..stream.GotoBookmark(sm)
    Set ..whitespace=bookmark("ws")
    Set ..comment=bookmark("c") 
    Set ..needsWScheck=needsWScheck
    ;s ..comment=""
    ;s ..whitespace=""
    ;s ..needsWScheck=1

    Set ..keyword="",..peekedlen=0
    Set ..stopAtEOL=stopeol
    Set ..stopAtWhitespace=stopws
    $$$DEBUG("Going "_$SELECT(forward:"forward",1:"back")_"   to:"_$zconvert(..peek(20),"O","JSON"))
    ;$$$DEBUGMethodEnd
]]></Implementation>
</Method>

<Method name="File">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set ret=##super(ParentElement,.subElement)
    If ret=0 {
        Set ret=..recover(ParentElement,.recsub,"",$LISTBUILD())
    }
    Quit ret
]]></Implementation>
</Method>

<Method name="FuncTypeComment">
<Description><![CDATA[
 func_type_comment: | NEWLINE TYPE_COMMENT &(NEWLINE INDENT) | TYPE_COMMENT]]></Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[    Quit 0 ; never happenes, handled by regular comments for now
]]></Implementation>
</Method>

<Method name="Name">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set value=""
    Set ok=0
    Do ..getBookmark(.bm)
    Set ch=..peek(1)
    ; starts with letter
    If ch?1a Set ok=1
    ; starts with underscore
    If ch="_" Set ok=1

    ; f strings (f' or f") are treated as Fstrings later
    If $$$UPPER(..peek(2))="F'" Set ok=0
    If $$$UPPER(..peek(2))="F""" Set ok=0
    ; r strings (r' or r") are treated as strings later
    If $$$UPPER(..peek(2))="R'" Set ok=0
    If $$$UPPER(..peek(2))="R""" Set ok=0
    If $$$UPPER(..peek(2))="B'" Set ok=0
    If $$$UPPER(..peek(2))="B""" Set ok=0

    If ok {

        Set ch=..peek(1)
        While (ch?1A) || (ch?1N) || (ch="_")  {
            Set value=value_..nextNotEOL(1)
            Set ch=..peek(1)
        }
    
        ; is not a keyword
        If '$LISTFIND($LISTFROMSTRING(..#Keywords),$$$UPPER(value)) {
            Set atom=..newAtom("Identifier",value)
            Do ParentElement.AddPart(atom)
        } Else {
            Set ok=0
            Do ..gotoBookmark(.bm)
        }
    }
    ;$$$DEBUG("checking identifier, ok=1")
    ;zw atom
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="String">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
		#dim o as PXW.DEV.Atom

    $$$DEBUGMethodBegin
	;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set ok=0

    If (..peek(3)="'''") || (..peek(3)="""""""")  
    || ($$$LOWER(..peek(4))="r'''") || ($$$LOWER(..peek(4))="r""""""") {
        $$$BNFSTART(subElement)
        Set r1=""
        If $$$LOWER(..peek(1))="r" Set r1=..nextNotEOL(1)
        Set q1=..nextNotEOL(3),n="",instring=1
        While '..eof() && instring {
            Set chs=..peek(3),ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,2),ch3=$EXTRACT(chs,3)
            ; what do embedded quotes look like here?
           If chs=q1 {
                    Set instring=0
                    Set q2=..next(3)
            } Else {
                Set n=n_..next(1)
            }
        }
        Set o=..newAtom("String",n)
        Set o.start=r1_q1,o.end=q2
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
        Set ok=1
    } ElseIf ..peek(1)'="","""'"[..peek(1) {
        ; single or double quote start
        Set ok=1
        $$$BNFSTART(subElement)

        Set q1=..nextNotEOL(1),n="",instring=1
        While '..eof() && instring {
            Set chs=..peek(2),ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,2)
            ; embedded quotes (\') or escaped \ (\\)
            If ch="\" {
                If ch2=q1 {
                    Set n=n_..nextNotEOL(2)
                } ElseIf ch2="\" {
                    Set n=n_..nextNotEOL(2)
                } Else {
                    Set n=n_..nextNotEOL(1)
                }
            } ElseIf ch=q1 {
                    Set instring=0
                    Set q2=..nextNotEOL(1)
            } Else {
                Set n=n_..nextNotEOL(1)
            }
        }
        Set o=..newAtom("String",n)
        Set o.start=q1,o.end=q2
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    } ElseIf ..peek(1)'="",$LISTFIND($LISTBUILD("R""","R'","B'","B"""),$$$UPPER(..peek(2))) {
        ; r' r" start (raw string)
        ; b strings ??
        Set ok=1
        $$$BNFSTART(subElement)

        Set rq1=..nextNotEOL(2),q1=$EXTRACT(rq1,2),n="",instring=1
        While '..eof() && instring {
            Set chs=..peek(2),ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,2)
            ; embedded quotes - in raw string -NOT SURE
            If ch="\" {
                If ch2=q1 {
                    Set n=n_..nextNotEOL(2)
                } Else {
                    Set n=n_..nextNotEOL(1)
                }
            } ElseIf ch=q1 {
                    Set instring=0
                    Set q2=..nextNotEOL(1)
            } Else {
                Set n=n_..nextNotEOL(1)
            }
        }
        Set o=..newAtom("String",n)
        Set o.start=rq1,o.end=q2
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    }
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="Number">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
	$$$BNFSTART(subElement)
	Set done=0

    ; hex number
    If $$$LOWER(..peek(2))="0x" {
        Set n=..nextNotEOL(2)
        While (..peek(1)'="") && ("01234567890ABCDEFabcdef_"[..peek(1)) {
            Set n=n_..nextNotEOL(1)
        }
        If n'="" {
            Set atom=..newAtom("Number",n)
            Do subElement.AddPart(atom)
            Set ret=1
        }
    ; binary number
    } ElseIf $$$LOWER(..peek(2))="0b" {
        Set n=..nextNotEOL(2)
        While (..peek(1)'="") && ("01_"[..peek(1)) {
            Set n=n_..nextNotEOL(1)
        }
        If n'="" {
            Set atom=..newAtom("Number",n)
            Do subElement.AddPart(atom)
            Set ret=1
        }
    } Else {

        Set n=""
        ; -
        While (..peek(1)="-") || (..peek(1)="+") {
            Set n=n_..nextNotEOL(1)
        }

        ; -123
        While (..peek(1)?1N) {
            Set n=n_..nextNotEOL(1)
        }

        ; start with a .
        If ..peek(2)?1"."1N {
            Set n=n_..next(2)
        }
        If n'="" {

            ; -123.456
            While (..peek(1)?1N) || (..peek(1)="_"){
                Set n=n_..nextNotEOL(1)
            }

            ; -123.456E
            If (..peek(1)="E") || (..peek(1)="e") {
                Set n=n_..nextNotEOL(1)
                ; 123.456E-
                If ..peek(1)="-"{
                    Set n=n_..nextNotEOL(1)
                }

                ; -123.456E-789
                While (..peek(1)?1N) || (..peek(1)="_") {
                    Set n=n_..nextNotEOL(1)
                }
            }

            If n'="" {
                Set atom=..newAtom("Number",n)
                Do subElement.AddPart(atom)
                Set done=1
            }

            If done {
                $$$BNFCOMMITCOPY(subElement,ParentElement)
                Set ret=1
            } Else {
                $$$BNFROLLBACK(subElement)
                Set ret=0
            }
        } Else {
            Set ret=0
        }
    }
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Endmarker">
<Description>
 ENDMARKER : 'code endmarker'
summary values:CODE ENDMARKER</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If ..eof() Quit 1
    ; IN THE CONTEXT OF AN EMBEDDED PYTHON METHOD LOOK FOR "}"
    If ..peek(1)="}" Quit 1
    Quit 0
]]></Implementation>
</Method>

<Method name="Newline">
<Description>
Does the whitespace contain new line char?</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Set ret=0
    ; this must not stop at new line, thats exactly what its looking for
    Set old=..stopAtEOL
    Set ..stopAtEOL=0,..needsWScheck=1
	Do:..needsWScheck ..skipWhiteSpaceAndComments()
    If $ISOBJECT(..whitespace),..whitespace.value[..stream.eolChar Set ret=1
    If ..eof() Set ret=1
    Set ..stopAtEOL=old
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="Indent">
<Description>
Does the white space have indentation? Not keeping track of the depth yet.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Set ret=0
	Do:..needsWScheck ..skipWhiteSpaceAndComments()
    If $ISOBJECT(..whitespace),..whitespace.value[" " Set ret=1
    If $ISOBJECT(..whitespace),..whitespace.value[$CHAR(9) Set ret=1
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="Dedent">
<Description>
Not keeping track of the depth yet, always pass</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Set ret=1
	;d:..needsWScheck ..skipWhiteSpaceAndComments()
    ;i $isobject(..whitespace),..whitespace.value[" " s ret=1
    ;i $isobject(..whitespace),..whitespace.value[$c(9) s ret=1
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="TypeComment">
<Description>
 TYPE_COMMENT : 'code type_comment'
This is a special type of comment used for documentation I think (''').
For now we will just treat as a comment and it will be dealt with in
the skip comments.</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    Set ret=1
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="FstringStart">
<Description>
 FSTRING_START : 'code fstring_start'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    Set ok=0
    If $$$UPPER(..peek(2))="F'" Set ok=1,..fStringEndChar="'"
    If $$$UPPER(..peek(2))="F""" Set ok=1,..fStringEndChar=""""
    If ok=1 {
        Set ret=1
        Set atom=..newAtom("FstringStart")
        Set atom.value=..next(2)
        Do ParentElement.AddPart(atom)
    } Else {
        Set ret=0
    }
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="FstringEnd">
<Description>
 FSTRING_END : 'code fstring_end'</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If ..fStringEndChar="" Quit 0
    $$$DEBUGMethodBegin
    
    Set ch=..peek($LENGTH(..fStringEndChar))
    If ch=..fStringEndChar {
        Set atom=..newAtom("FstringEnd")
        Set atom.value=..next($LENGTH(..fStringEndChar))
        Do ParentElement.AddPart(atom)
        Set ret=1
        Set ..fStringEndChar=""
    } Else {
        Set ret=0
    }
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="FstringMiddle">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	Set subElement=ParentElement
	Set done=0 ; method start
	If ..FstringReplacementField(subElement,.addedElement)  {
		Set done=1 ; or
	} ElseIf ..FstringMiddleText(subElement,.addedElement)  {
		Set done=1 ; end compileRules
	}
	If done {
		Set ret=1
	} Else {
		Set ret=0 ; normal rollback
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="FstringMiddleText">
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    #dim o as PXW.DEV.Atom
    $$$DEBUGMethodBegin
    ;$$$BNFPATH
    ;;$$$DEBUG("%path="_%path)
    Set n=""
    While ..peek(1)'="{",..peek($LENGTH(..fStringEndChar))'=..fStringEndChar {
        Set n=n_..next(1)
    }
    If n'="" {
        Set o=..newAtom("String",n)
        Do ParentElement.AddPart(o)
        Set ret=1
    } Else {
        Set ret=0
    }
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="Statement">
<Description>
 statement: compound_stmt | simple_stmts</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set old=..stopAtEOL
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    Set ..stopAtEOL=1

    ; Until I sort out the whole skipWhiteSpaceAndComment issue:
    ; The superclass happily skips whitespaces but in Python they are important!
    ; I will have to track indents here
    Set ret=1
    If $ISOBJECT(..whitespace) {
        Set indent=$PIECE(..whitespace.value,..stream.eolChar,*)
        ; have we moved back a level, if so then treat this as a FAILURE
        ; which should fall back into the block and allow it to continue again later
        If $LENGTH(indent)<$LENGTH(..currentIndent) {
            Set ret=0
        }
        Set ..currentIndent=indent
    }

    If ret {
        Set ret=##super(ParentElement,.subElement)
    }
    Set ..stopAtEOL=old
    Quit ret
]]></Implementation>
</Method>

<Method name="skipComments">
<Description>
Skip over the next set of comments, return 1 if something was done or 0.
ch10 is the next 10 chars in the stream</Description>
<FormalSpec>ch10:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If $EXTRACT(ch10,1,1)="#" Set ..comment=..readLineComment("#") Quit 1

    ; there seems to be some argument about the below 
    ; with some saying the only # is a comment
    ;i $e(ch10,1,3)="'''" s ..comment=..readBlockComment("'''","'''") q 1
    ;i $e(ch10,1,3)="""""""" s ..comment=..readBlockComment("""""""","""""""") q 1

    ; treat \ at end of line like a comment and skip to next line 
    If $EXTRACT(ch10,1,2)=("\"_..stream.eolChar) Set ..comment=..newAtom("linecomment",..next(2)) Quit 1
    Quit 0
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
Method readWhitespace() As PXW.DEV.Atom
{
    $$$DEBUGMethodBegin
    i ..stopAtEOL { 
        s ws=$c(32,9,160)
    } else {
        s ws=$c(32,9,13,10,160)
    }
    s spaces=""
    do {
        s spaces=spaces_..stream.NextChars(ws)
        ; \ at end of line means we can continue to the next
        i ..peek(2)=("\"_..stream.eolChar) s spaces=spaces_..next(2)
    } while '..eof() && (ws[..peek(1))
    
    s o=..newAtom("whitespace",spaces)
    $$$DEBUGMethodEnd
	q o
}
/// methods in here need to do a DIRECT lookup on ..text
Method skipWhiteSpaceAndComments()
{
    #define isWS(%x) $c(32,9,13,10,160)[%x
    $$$DEBUGMethodBegin

    i ..stopAtEOL { 
        s ws=$c(32,9,160)
    } else {
        s ws=$c(32,9,13,10,160)
    }
    $$$DEBUG("StopAtWhiteSpace="_..stopAtWhitespace_",StopAtEOL="_..stopAtEOL)
    i ..stopAtWhitespace g readExit

readNextLoop		
	s ch10=..peek(10),ch=$e(ch10,1)
	
	; leading whitespace and comments end up embedded in the next real object
	; so you could end up with a returned object like this
	; object={ 
	;          type:"variable",
	;         value:111,
	;       comment:{
	;                type:"comment",
	;               value:"a comment",
	;          whitespace:{
	;                      type:"whitespace",
	;                     value:"  "
	;                     }
	;          }                
	;
    ;
	;i '..eof(),$$$isWS(ch) s ..whitespace=..readWhitespace() g readNextLoop
    i '..eof(),ws[ch s ..whitespace=..readWhitespace() g readNextLoop
    i '..eof(),($e(ch10,1,2)="\"_..stream.eolChar) s ..whitespace=..readWhitespace() g readNextLoop
    i '..eof(),..skipComments(ch10) g readNextLoop
    s ..needsWScheck=0
readExit
    $$$DEBUGMethodEnd 
    q
}
*/
]]></Content>
</UDLText>
</Class>


<Class name="PXW.DEV.BNF.Run.SQL">
<Super>PXW.DEV.BNF.GEN.SQL</Super>
<TimeChanged>67125,77563.380519686</TimeChanged>
<TimeCreated>67125,77563.380519686</TimeCreated>

<Property name="commentMode">
<Description>
Set to CDEF, COS</Description>
<Type>%String</Type>
<InitialExpression>"SQL"</InitialExpression>
</Property>

<Method name="AliasName">
<Description>
alias_name ::= identifier
 summary=F
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
	$$$BNFSTART(subElement)
	Set done=0
	If ..Identifier(subElement,.addedAtom) {
        Set string=$$$UPPER(subElement.ToString(0))
        ; an alias must not be any of the following
        $$$DEBUG("Alias name found:"_string)
        If $LISTFIND($LISTBUILD("LEFT","RIGHT","INNER","OUTER","CROSS","JOIN","FROM","WHERE","UNION","ON","INTO","SET","HAVING"),string)>0 {
            Set done=0
        } Else {
            ; it may be ORDER unless its followed by BY
            If $LISTFIND($LISTBUILD("ORDER","GROUP"),string) {
                Do ..skipWhiteSpaceAndComments()
                Set peek=$$$UPPER(..peek(2))
                If peek="BY" {
                    Set done=0
                } Else {
                    Set done=1
                }
            } Else {
		        Set done=1
            }
        }
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="ColumnName">
<Description>
column_name ::= identifier
 summary=F
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Elements.SQL]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
	$$$BNFSTART(subElement)
	Set done=0
    If ..addPunctuation(subElement,"*") {
        Set done=1
    } ElseIf ..Identifier(subElement,.addedElement)	 {
        Set string=$$$UPPER(subElement.ToString(0))
        ; an alias must not be any of the following
        If $LISTFIND($LISTBUILD("LEFT","RIGHT","INNER","OUTER","CROSS","JOIN","FROM","WHERE","UNION","ON","INTO"),string)>0 {
            Set done=0
        } Else {
            ; it may be ORDER unless its followed by BY
            If string="ORDER" {
                Do ..skipWhiteSpaceAndComments()
                Set peek=$$$UPPER(..peek(2))
                If peek="BY" {
                    Set done=0
                } Else {
                    Set done=1
                }
            } Else {
		        Set done=1
            }
        }
    }
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<FormalSpec>ParentElement:PXW.DEV.BNF.Element</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    $$$BNFPATH
	;$$$DEBUG("%path="_%path)

    ;d ..skipWhiteSpaceAndComments()
    Do:('..whitespace&&'..comment) ..skipWhiteSpaceAndComments()

    Set value=""
    Set ok=0

    ; identifiers in SQL can be in ""
    If ..peek(1)="""" {
        
        Set q1=..next()
        Set ok=1
        While ok {
            Set ch2=..peek(2)
            If ch2="""""" {
                Set value=value_..next(2)
            } ElseIf ..peek(1)'="""" {
                Set value=value_..next()
            } Else {
                Set ok=0
            }
        }
        Set q2=..next()
        Set atom=..newAtom(ParentElement.type,value)
        Set atom.start=q1
        Set atom.end=q2
        Do ParentElement.AddPart(atom)
        Set ok=1
    } Else {

        If ..peek(1)="%" Set value=..next()
        If ..peek(1)="%" Set value=..next()
        If ..peek(1)="_" Set value=..next()
        ; not a letter (or number)
        Set ch=..peek(1)
        ; no % so must start with a letter
        If value="",ch?1A Set value=..next()

        Set ok=1    
        If value="" {
            $$$DEBUG("checking identifier, ok=0")
            Set ok=0
        }
    
        If ok {

            Set ch=..peek(1)
            While (ch?1A) || (ch?1N) || (ch="_")  {
                Set value=value_..next()
                Set ch=..peek(1)
            }
        
            Set atom=..newAtom(ParentElement.type,value)
            Do ParentElement.AddPart(atom)
        }
    }
    ;$$$DEBUG("checking identifier, ok=1")
    ;zw atom
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="zzzQualifiedIdentifier">
<FormalSpec>ParentElement:PXW.DEV.Element</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    ;d ..skipWhiteSpaceAndComments()
    Do:('..whitespace&&'..comment) ..skipWhiteSpaceAndComments()

    Set value=""
    Set ok=0
 
        If ..peek(1)="%" Set value=..next()
        If ..peek(1)="%" Set value=..next()
        ; not a letter (or number)
        Set ch=..peek(1)
        ; no % so must start with a letter
        If value="",ch?1A Set value=..next()

        Set ok=1    
        If value="" {
            $$$DEBUG("checking qualified identifier, ok=0")
            Set ok=0
        }
 
    If ok {

        Set ch=..peek(1)
        While (ch?1A) || (ch?1N) || (ch=".") || (ch="_")  {
            Set value=value_..next()
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom(ParentElement.type,value)
        Do ParentElement.AddPart(atom)
    }
    ;$$$DEBUG("checking identifier, ok=1")
    ;zw atom
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="SqlNumber">
<Description>
sql_number ::= 'NEED NUMBER'
 summary=S
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Elements.SQL]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
    Set digits="01234567890."
	Set n="",done=0
	While ('..eof()) && (digits[..peek(1)) {
		Set n=n_..next()
        Set done=1
	}
    ; -123.456E
    If done,((..peek(1)="E") || (..peek(1)="e")) {
        Set n=n_..nextNotEOL(1)
        ; 123.456E-
        If ..peek(1)="-"{
            Set n=n_..nextNotEOL(1)
        }

        ; -123.456E-789
        While (..peek(1)?1N) {
            Set n=n_..nextNotEOL(1)
        }
    }
    
	If done {
        Set atom=..newAtom("Number",n)
        Do ParentElement.AddPart(atom)
		Set ret=1
	} Else {
		Set ret=0
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="SqlString">
<Description>
sql_string ::= 'NEED STRING'
 summary=S
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Elements.SQL]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
    Do:('..whitespace&&'..comment) ..skipWhiteSpaceAndComments()

    Set ok=1
    Set quote=..peek(1)
    If quote'="'" {
        Set ok=0
    }

    If ok {
        $$$BNFSTART(subElement)

        Set n=..next()
        Set instring=1
        While '..eof() && instring {
            Set chs=..peek(2)
            Set ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,2)
            ; embedded quotes or end of string?
            If ch=quote {
                If ch2=quote {
                    Set n=n_..next()_..next()
                } Else {
                    Set instring=0
                    Set n=n_..next()
                }
            } Else {
                Set n=n_..next()
            }
        }
        Set o=..newAtom("String",n)
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    }
    $$$DEBUGMethodEnd
    Quit ok
	/*if '(..isStringInList($lb("NEED STRING"),11,.value)) quit 0
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
	s done=0
	; type=group, check=if, skip=0, skipall=1
	s dum=..next($l(value)),atom=..newAtom("keyword",value)
	d ParentElement.AddPart(atom)
	if 1	 {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0
	}
	$$$DEBUGMethodEnd
	q ret*/
]]></Implementation>
</Method>

<Method name="SqlCosVariable">
<FormalSpec>ParentElement:PXW.DEV.BNF.Element</FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	#dim atom as PXW.DEV.Atom
    $$$DEBUGMethodBegin
	$$$BNFPATH
 	$$$BNFSTART(subElement)
    Set ret=0
 
    ;d:..needsWScheck ..skipWhiteSpaceAndComments()
    ;i ..isString(subElement,":") {
 
        
        Set parser=##class(PXW.DEV.BNF.Run.COS).%New()
        Set parser.stream=..stream
        Set parser.codemode="COSSQL" ; not really true, should only be set for TRIGGERS but at this point we don't know where we are! and we should treat these as field names
        Set parser.whitespace=..whitespace
        Set parser.comment=..comment
        ;d parser.skipWhiteSpaceAndComments()
        If parser.Variable(subElement) {
            Set ret=1
        } 
        If ret=1 {
            Set ..whitespace=parser.whitespace
            Set ..comment=parser.comment
            $$$BNFCOMMIT(subElement,ParentElement)
        } Else {
            $$$BNFROLLBACK(subElement)
        }
    ;}
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="skipComments">
<FormalSpec>ch10:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If $EXTRACT(ch10,1,2)="--" Set ..comment=..readLineComment("--") Quit 1
    If $EXTRACT(ch10,1,2)="/*" Set ..comment=..readBlockComment() Quit 1
    Quit 0
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.Run.SQL92">
<Super>PXW.DEV.BNF.GEN.SQL92</Super>
<TimeChanged>67125,77563.36019354</TimeChanged>
<TimeCreated>67125,77563.36019354</TimeCreated>

<Property name="commentMode">
<Description>
Set to CDEF, COS</Description>
<Type>%String</Type>
<InitialExpression>"SQL"</InitialExpression>
</Property>

<Method name="AliasName">
<Description>
alias_name ::= identifier
 summary=F
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Element]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
	$$$BNFSTART(subElement)
	Set done=0
	If ..Identifier(subElement,.addedAtom) {
        Set string=$$$UPPER(subElement.ToString(0))
        ; an alias must not be any of the following
        $$$DEBUG("Alias name found:"_string)
        If $LISTFIND($LISTBUILD("LEFT","RIGHT","INNER","OUTER","CROSS","JOIN","FROM","WHERE","UNION","ON","INTO","SET","HAVING"),string)>0 {
            Set done=0
        } Else {
            ; it may be ORDER unless its followed by BY
            If $LISTFIND($LISTBUILD("ORDER","GROUP"),string) {
                Do ..skipWhiteSpaceAndComments()
                Set peek=$$$UPPER(..peek(2))
                If peek="BY" {
                    Set done=0
                } Else {
                    Set done=1
                }
            } Else {
		        Set done=1
            }
        }
	}
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="ColumnName">
<Description>
column_name ::= identifier
 summary=F
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Elements.SQL]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
	$$$BNFSTART(subElement)
	Set done=0
    If ..addPunctuation(subElement,"*") {
        Set done=1
    } ElseIf ..Identifier(subElement,.addedElement)	 {
        Set string=$$$UPPER(subElement.ToString(0))
        ; an alias must not be any of the following
        If $LISTFIND($LISTBUILD("LEFT","RIGHT","INNER","OUTER","CROSS","JOIN","FROM","WHERE","UNION","ON","INTO"),string)>0 {
            Set done=0
        } Else {
            ; it may be ORDER unless its followed by BY
            If string="ORDER" {
                Do ..skipWhiteSpaceAndComments()
                Set peek=$$$UPPER(..peek(2))
                If peek="BY" {
                    Set done=0
                } Else {
                    Set done=1
                }
            } Else {
		        Set done=1
            }
        }
    }
	If done {
		$$$BNFCOMMIT(subElement,ParentElement)
		Set ret=1
	} Else {
		$$$BNFROLLBACK(subElement)
		Set ret=0
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="Identifier">
<FormalSpec>ParentElement:PXW.DEV.BNF.Element</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    $$$BNFPATH
	;$$$DEBUG("%path="_%path)

    ;d ..skipWhiteSpaceAndComments()
    Do:('..whitespace&&'..comment) ..skipWhiteSpaceAndComments()

    Set value=""
    Set ok=0

    ; identifiers in SQL can be in ""
    If ..peek(1)="""" {
        
        Set q1=..next()
        Set ok=1
        While ok {
            Set ch2=..peek(2)
            If ch2="""""" {
                Set value=value_..next(2)
            } ElseIf ..peek(1)'="""" {
                Set value=value_..next()
            } Else {
                Set ok=0
            }
        }
        Set q2=..next()
        Set atom=..newAtom(ParentElement.type,value)
        Set atom.start=q1
        Set atom.end=q2
        Do ParentElement.AddPart(atom)
        Set ok=1
    } Else {

        If ..peek(1)="%" Set value=..next()
        If ..peek(1)="%" Set value=..next()
        If ..peek(1)="_" Set value=..next()
        ; not a letter (or number)
        Set ch=..peek(1)
        ; no % so must start with a letter
        If value="",ch?1A Set value=..next()

        Set ok=1    
        If value="" {
            $$$DEBUG("checking identifier, ok=0")
            Set ok=0
        }
    
        If ok {

            Set ch=..peek(1)
            While (ch?1A) || (ch?1N) || (ch="_")  {
                Set value=value_..next()
                Set ch=..peek(1)
            }
        
            Set atom=..newAtom(ParentElement.type,value)
            Do ParentElement.AddPart(atom)
        }
    }
    ;$$$DEBUG("checking identifier, ok=1")
    ;zw atom
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="zzzQualifiedIdentifier">
<FormalSpec>ParentElement:PXW.DEV.Element</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;$$$BNFPATH
	;;$$$DEBUG("%path="_%path)

    ;d ..skipWhiteSpaceAndComments()
    Do:('..whitespace&&'..comment) ..skipWhiteSpaceAndComments()

    Set value=""
    Set ok=0
 
        If ..peek(1)="%" Set value=..next()
        If ..peek(1)="%" Set value=..next()
        ; not a letter (or number)
        Set ch=..peek(1)
        ; no % so must start with a letter
        If value="",ch?1A Set value=..next()

        Set ok=1    
        If value="" {
            $$$DEBUG("checking qualified identifier, ok=0")
            Set ok=0
        }
 
    If ok {

        Set ch=..peek(1)
        While (ch?1A) || (ch?1N) || (ch=".") || (ch="_")  {
            Set value=value_..next()
            Set ch=..peek(1)
        }
    
        Set atom=..newAtom(ParentElement.type,value)
        Do ParentElement.AddPart(atom)
    }
    ;$$$DEBUG("checking identifier, ok=1")
    ;zw atom
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="SqlNumber">
<Description>
sql_number ::= 'NEED NUMBER'
 summary=S
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Elements.SQL]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
    Set digits="01234567890."
	Set n="",done=0
	While ('..eof()) && (digits[..peek(1)) {
		Set n=n_..next()
        Set done=1
	}
    ; -123.456E
    If done,((..peek(1)="E") || (..peek(1)="e")) {
        Set n=n_..nextNotEOL(1)
        ; 123.456E-
        If ..peek(1)="-"{
            Set n=n_..nextNotEOL(1)
        }

        ; -123.456E-789
        While (..peek(1)?1N) {
            Set n=n_..nextNotEOL(1)
        }
    }
    
	If done {
        Set atom=..newAtom("Number",n)
        Do ParentElement.AddPart(atom)
		Set ret=1
	} Else {
		Set ret=0
	}
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>

<Method name="SqlString">
<Description>
sql_string ::= 'NEED STRING'
 summary=S
 type=group</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.BNF.Element,&subElement:PXW.DEV.BNF.Elements.SQL]]></FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
    Do:('..whitespace&&'..comment) ..skipWhiteSpaceAndComments()

    Set ok=1
    Set quote=..peek(1)
    If quote'="'" {
        Set ok=0
    }

    If ok {
        $$$BNFSTART(subElement)

        Set n=..next()
        Set instring=1
        While '..eof() && instring {
            Set chs=..peek(2)
            Set ch=$EXTRACT(chs,1),ch2=$EXTRACT(chs,2)
            ; embedded quotes or end of string?
            If ch=quote {
                If ch2=quote {
                    Set n=n_..next()_..next()
                } Else {
                    Set instring=0
                    Set n=n_..next()
                }
            } Else {
                Set n=n_..next()
            }
        }
        Set o=..newAtom("String",n)
        Do subElement.AddPart(o)
        $$$BNFCOMMIT(subElement,ParentElement)
    }
    $$$DEBUGMethodEnd
    Quit ok
	/*if '(..isStringInList($lb("NEED STRING"),11,.value)) quit 0
	$$$DEBUGMethodBegin
	$$$BNFPATH
	;$$$DEBUG("%path="_%path)
	s done=0
	; type=group, check=if, skip=0, skipall=1
	s dum=..next($l(value)),atom=..newAtom("keyword",value)
	d ParentElement.AddPart(atom)
	if 1	 {
		set done=1
	}
	if done {
		set ret=1
	} else {
		set ret=0
	}
	$$$DEBUGMethodEnd
	q ret*/
]]></Implementation>
</Method>

<Method name="SqlCosVariable">
<FormalSpec>ParentElement:PXW.DEV.BNF.Element</FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
	#dim atom as PXW.DEV.Atom
    $$$DEBUGMethodBegin
	$$$BNFPATH
 	$$$BNFSTART(subElement)
    Set ret=0
 
    ;d:..needsWScheck ..skipWhiteSpaceAndComments()
    ;i ..isString(subElement,":") {
 
        
        Set parser=##class(PXW.DEV.BNF.Run.COS).%New()
        Set parser.stream=..stream
        Set parser.codemode="COSSQL" ; not really true, should only be set for TRIGGERS but at this point we don't know where we are! and we should treat these as field names
        Set parser.whitespace=..whitespace
        Set parser.comment=..comment
        ;d parser.skipWhiteSpaceAndComments()
        If parser.Variable(subElement) {
            Set ret=1
        } 
        If ret=1 {
            Set ..whitespace=parser.whitespace
            Set ..comment=parser.comment
            $$$BNFCOMMIT(subElement,ParentElement)
        } Else {
            $$$BNFROLLBACK(subElement)
        }
    ;}
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="skipComments">
<FormalSpec>ch10:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If $EXTRACT(ch10,1,2)="--" Set ..comment=..readLineComment("--") Quit 1
    If $EXTRACT(ch10,1,2)="/*" Set ..comment=..readBlockComment() Quit 1
    Quit 0
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.BNF.super">
<IncludeCode>PXW.Debuggers.Macros,PXW.DEV.BNF.macros</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77562.347011804</TimeChanged>
<TimeCreated>67125,77562.347011804</TimeCreated>

<Property name="stream">
<Type>PXW.DEV.InputStream</Type>
</Property>

<Property name="whitespace">
<Description>
object containing any whitespace leading up to whatever object we are going to return</Description>
<Type>PXW.DEV.Atom</Type>
</Property>

<Property name="comment">
<Description>
object containing any comment leading up to whatever object we are going to return</Description>
<Type>PXW.DEV.Atom</Type>
</Property>

<Property name="element">
<Type>PXW.DEV.Element</Type>
</Property>

<Property name="needsWScheck">
<Description>
This gets set when the comment or whitespace check needs to be done</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="commentMode">
<Description>
Set to CDEF, COS</Description>
<Type>%String</Type>
<InitialExpression>"COS"</InitialExpression>
</Property>

<Property name="lastElement">
<Description>
last element added to</Description>
<Type>PXW.DEV.Element</Type>
</Property>

<Property name="streamlen">
<Type>%Integer</Type>
</Property>

<Property name="stopAtEOL">
<Description>
Set to 1 if you want to stop skipping whitespace at the end of line (eg #dim command)</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<UDLText name="T">
<Content><![CDATA[
/*
method stopAtEOLSet(val) as %Status
{
    $$$DEBUG("Setting stopAtEOL="_val_", "_$g(%path))
    s i%stopAtEOL=val
    q $$$OK 
}
*/
]]></Content>
</UDLText>

<Property name="stopAtWhitespace">
<Description>
Set to 1 if you never want to skip whitespace (eg on postconditional)</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="keyword">
<Description>
temporary storge of the last keyword read</Description>
<Type>%String</Type>
</Property>

<Parameter name="keywordAtomType">
<Default>Keyword</Default>
</Parameter>

<Property name="peeked">
<Description>
temporary storage of last peek</Description>
<Type>%String</Type>
</Property>

<Property name="peekedlen">
<Type>%Integer</Type>
</Property>

<Property name="streaminput">
<Description>
copy of the stream</Description>
<Type>%Integer</Type>
</Property>

<Property name="memo">
<Description>
a place to store things during the parsing, eg as a store of last result from recursion</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Parameter name="KeywordPattern">
<Default>1.A</Default>
</Parameter>

<Method name="streamSet">
<FormalSpec>val:PXW.DEV.InputStream</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    If $ISOBJECT(val) {
        Set i%stream=val
        Set ..streamlen=$LENGTH(val.input)
        Set ..streaminput=val.input
    }
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="test1">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[text:%String,method:%String,&element:PXW.DEV.Element,debugToFile:%Boolean=0]]></FormalSpec>
<Implementation><![CDATA[
    New %path Set %path=""
    Set debugger="PXW.Debuggers.Basic"
    If debugToFile {
        Set debugger="PXW.Debuggers.BasicToFile"
    }
    $$$DEBUGNew(debugger)

    $$$DEBUG("Testing="_text)
    $$$DEBUG("method="_method)
    Set element=##class(PXW.DEV.Element).%New()
    Set %section=element
    Set x=..%New()
    ;s x.element=element
    Set x.stream=##class(PXW.DEV.InputStream).NewString(text)
    Set ok=$METHOD(x,method,element)
    $$$DEBUG("ok="_ok)
    $$$DEBUG("x.element.ToString()="_element.ToString())
    $$$DEBUG("Testing complete")
    $$$DEBUG("")
    If debugToFile {
        set debug=$$$debugObject
        Write !,"Debug file "_debug.file
    }
]]></Implementation>
</Method>

<Method name="getBookmark">
<FormalSpec><![CDATA[&bookmark:%String]]></FormalSpec>
<Implementation><![CDATA[
    ;$$$DEBUGMethodBegin
    
    Set bookmark=$LISTBUILD(..stream.pos,..stream.col,..stream.line,..stream.startOfLinePos,..needsWScheck,..stopAtEOL,..stopAtWhitespace) 
    Set bookmark("ws")=..whitespace
    Set bookmark("c")=..comment

    ;$$$DEBUGMethodEnd
]]></Implementation>
</Method>

<Method name="gotoBookmark">
<FormalSpec><![CDATA[&bookmark:%String]]></FormalSpec>
<Implementation><![CDATA[
    ;quit
    ;$$$DEBUGMethodBegin
    Set forward=(..stream.pos<$LISTGET(bookmark,1))
    $$$DEBUG("Going "_$SELECT(forward:"forward",1:"back")_" from:"_$zconvert(..peek(20),"O","JSON"))
    
    Set $LISTBUILD(pos,col,line,startOfLinePos,needsWScheck,stopeol,stopws)=bookmark
    Set ..stream.pos=pos,..stream.col=col,..stream.line=line,..stream.startOfLinePos=startOfLinePos
    ;s $lb(sm,needsWScheck,stopeol,stopws)=bookmark
    ;d ..stream.GotoBookmark(sm)
    Set ..whitespace=bookmark("ws")
    Set ..comment=bookmark("c") 
    Set ..needsWScheck=needsWScheck
    ;s ..comment=""
    ;s ..whitespace=""
    ;s ..needsWScheck=1

    Set ..keyword="",..peekedlen=0
    Set ..stopAtEOL=stopeol
    Set ..stopAtWhitespace=stopws
    $$$DEBUG("Going "_$SELECT(forward:"forward",1:"back")_"   to:"_$zconvert(..peek(20),"O","JSON"))
    ;$$$DEBUGMethodEnd
]]></Implementation>
</Method>

<Method name="peek">
<FormalSpec>number:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set p=..stream.pos
    Quit $EXTRACT(..streaminput,p,p+number-1)
    Quit ..peeked
]]></Implementation>
</Method>

<Method name="peekKeyword">
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    #define CODE(%l) do %code.WriteLine(%l)
    $$$CODE($CHAR(9)_"i ..keyword'="""" q ..keyword")
    $$$CODE($CHAR(9)_"$$$DEBUGMethodBegin")
    $$$CODE($CHAR(9)_"s i=0,testword=""""")
    $$$CODE($CHAR(9)_"do {")
    $$$CODE($CHAR(9)_$CHAR(9)_"s word=testword")
    $$$CODE($CHAR(9)_$CHAR(9)_"s ch=..stream.Peek(i)")
    $$$CODE($CHAR(9)_$CHAR(9)_"s testword=word_ch")
    $$$CODE($CHAR(9)_$CHAR(9)_"s i=i+1 ;$$$DEBUG(""word=""_testword)" )
    $$$CODE($CHAR(9)_"} while ch'="""",testword?"_%parameter("KeywordPattern"))
    $$$CODE($CHAR(9)_"s ..keyword=word")
    $$$CODE($CHAR(9)_"$$$DEBUGMethodEnd")
    $$$CODE($CHAR(9)_"q word")
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="next">
<FormalSpec>number:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    ;$$$DEBUGMethodBegin
    Set value=..stream.NextMany(number)
    Set ..keyword="",..peekedlen=0
    ;$$$DEBUGMethodEnd
    Quit value
]]></Implementation>
</Method>

<Method name="nextNotEOL">
<FormalSpec>number:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    ;$$$DEBUGMethodBegin
    Set value=..stream.NextNOTEol(number)
    Set ..keyword="",..peekedlen=0
    ;$$$DEBUGMethodEnd
    Quit value
]]></Implementation>
</Method>

<Method name="eof">
<Description>
lengthAdjust takes into account that you might be peeking past the end but the position has not been updated</Description>
<FormalSpec>lengthAdjust:%Integer=0</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    ;q ((..stream.pos+lengthAdjust)>$l(..stream.input))
    Quit ((..stream.pos+lengthAdjust)>..streamlen)
]]></Implementation>
</Method>

<Method name="isPunctuationInList">
<FormalSpec>ListOfStrings:%List,longestLen:%Integer=50,*foundString:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set next50=..peek(longestLen)
    Set UPP50=$$$UPPER(next50)
    Set found=$LISTFIND(ListOfStrings,UPP50)
    If found Set foundString=$LIST(ListOfStrings,found)
    ;$$$DEBUG($s(found:"("_foundString_") ",1:"NOT ")_"found:"_UPP50_" in list "_$LISTTOSTRING(ListOfStrings))
    $$$DEBUGMethodEnd
    Quit found
]]></Implementation>
</Method>

<Method name="isKeywordInList">
<FormalSpec>ListOfStrings:%List,*foundString:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  
    $$$DEBUGMethodBegin
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set keyword=..peekKeyword()
    Set UPP=$$$UPPER(keyword)
    Set found=$LISTFIND(ListOfStrings,UPP)
    If found Set foundString=keyword
    $$$DEBUG($SELECT(found:"("_foundString_") ",1:"NOT ")_"found:"_UPP_" in list "_$LISTTOSTRING(ListOfStrings))
    $$$DEBUGMethodEnd
    Quit found
]]></Implementation>
</Method>

<Method name="isKeyword">
<FormalSpec>KeywordToCheck:%String,*foundString:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set keyword=..peekKeyword()
    Set UPP=$$$UPPER(keyword)
    Set found=(UPP=KeywordToCheck)
    If found Set foundString=keyword
    ;$$$DEBUG($s(found:"("_foundString_") ",1:"NOT ")_"found:"_UPP)
    $$$DEBUGMethodEnd
    Quit found
]]></Implementation>
</Method>

<Method name="isStringInList">
<FormalSpec>ListOfStrings:%List,longestLen:%Integer=50,*foundString:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Do:..needsWScheck ..skipWhiteSpaceAndComments()

    Set next50=..peek(longestLen)
    Set UPP50=$$$UPPER(next50)
    Set ptr=0,notfound=1
    While notfound, $LISTNEXT(ListOfStrings,ptr,value) {
       Set len=$LENGTH(value)
       If value?1.A {
            Set peeked=$$$UPPER(..peekKeyword())
       } Else {
            Set peeked=$EXTRACT(UPP50,1,len)
       }
        If peeked=value {
            Set notfound=0,foundString=$EXTRACT(next50,1,len)
        }
    }
    ;$$$DEBUG($s(notfound=0:"("_peeked_","_value_","_..keyword_")",1:"NOT ")_"found:"_UPP50_" in list "_$LISTTOSTRING(ListOfStrings))
    $$$DEBUGMethodEnd
    Quit 'notfound
]]></Implementation>
</Method>

<Method name="isStringSingle">
<FormalSpec>String:%String,*foundString:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin  
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    
    Set len=$LENGTH(String)
    Set foundString=..peek(len)
    If $$$UPPER(foundString)=String {
        Set found=1
    } Else {
        Set found=0
    }
    ;$$$DEBUG("lookingFor="_String_" found="_found_" foundString="_foundString)
    ;s x=$i(%pxw1(String,found))
    $$$DEBUGMethodEnd
    Quit found
]]></Implementation>
</Method>

<Method name="isString">
<FormalSpec>ParentElement:PXW.DEV.Element="",StringToCheck:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    //#define UPPER(%x) $zconvert(%x,"U")
    $$$DEBUGMethodBegin
    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
 
    ;$$$DEBUG("checking string '"_StringToCheck_"' found '"_$zconvert(..peek(10),"O","JS")_"'")
    Set ok=0
    Set len=$LENGTH(StringToCheck)
    Set peeked=..peek(len)
    If $$$UPPER(peeked)=$$$UPPER(StringToCheck) {
        If $ISOBJECT(ParentElement) {
            Set value=..next(len)
            If value?1.P {
                Set atom=..newAtom("punctuation",value)
            } Else {
                Set atom=..newAtom(..#keywordAtomType,value)
            }
            Do ParentElement.AddPart(atom)
            Set ..lastElement=ParentElement
        }
        Set ok=1
    }
    ;$$$DEBUG("checking string '"_StringToCheck_"' ok="_ok)
    ;s %pxwstrings(StringToCheck_"="_ok)=$g(%pxwstrings(StringToCheck_"="_ok))+1
    $$$DEBUGMethodEnd
     Quit ok
]]></Implementation>
</Method>

<Method name="isPunctuation">
<FormalSpec>StringToCheck:%String,*foundString:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    //#define UPPER(%x) $zconvert(%x,"U")
    $$$DEBUGMethodBegin
    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
 
    ;$$$DEBUG("checking punctuation '"_StringToCheck_"' found '"_$zconvert(..peek(10),"O","JS")_"'")
    Set ok=0
    Set len=$LENGTH(StringToCheck) 
    Set peeked=..peek(len)
    If $$$UPPER(peeked)=$$$UPPER(StringToCheck) {
        Set ok=1
        Set foundString=peeked
    }
    ;$$$DEBUG("checking punctuation'"_StringToCheck_"' ok="_ok)
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="addString">
<FormalSpec>ParentElement:PXW.DEV.Element="",StringToCheck:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    //#define UPPER(%x) $zconvert(%x,"U")
    $$$DEBUGMethodBegin
    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
 
    $$$DEBUG("checking string '"_StringToCheck_"' found '"_$ZCONVERT(..peek(10),"O","JS")_"'")
    Set ok=0
    Set len=$LENGTH(StringToCheck)
    Set peeked=..peek(len)
    If $$$UPPER(peeked)=$$$UPPER(StringToCheck) {
        Set value=..next(len)
        If value?1.P {
            Set atom=..newAtom("punctuation",value)
        } Else {
            Set atom=..newAtom(..#keywordAtomType,value)
        }
        Do ParentElement.AddPart(atom)
        Set ..lastElement=ParentElement
        Set ok=1
    }
    $$$DEBUG("checking string '"_StringToCheck_"' ok="_ok)
    ;s %pxwstrings(StringToCheck_"="_ok)=$g(%pxwstrings(StringToCheck_"="_ok))+1
    $$$DEBUGMethodEnd
     Quit ok
]]></Implementation>
</Method>

<Method name="addStringInList">
<FormalSpec>ParentElement:PXW.DEV.Element,ListOfStrings:%List,longestLen:%Integer=50,*foundString:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Set ret=0
    If ..isStringInList(ListOfStrings,longestLen,.value) {
        If value?1.P {
            Set atom=..newAtom("punctuation",value)
        } Else {
            Set atom=..newAtom(..#keywordAtomType,value)
        }
        Do ParentElement.AddPart(atom)
        Set ..lastElement=ParentElement
        Set ret=1
        Set foundString=value
    }
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="addKeywordInList">
<FormalSpec>ParentElement:PXW.DEV.Element,ListOfStrings:%List,*foundString:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Set ret=0  
    If ..isKeywordInList(ListOfStrings,.value) {
        Set foundString=..next($LENGTH(value))
        Set atom=..newAtom(..#keywordAtomType,foundString)
        Do ParentElement.AddPart(atom)
        Set ..lastElement=ParentElement
        Set ret=1
    }
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="addKeyword">
<FormalSpec>ParentElement:PXW.DEV.Element,Keyword:%String,*foundString:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Set ret=0
    If ..isKeyword(Keyword,.value) {
        Set foundString=..next($LENGTH(value))
        Set atom=..newAtom(..#keywordAtomType,foundString)
        Do ParentElement.AddPart(atom)
        Set ..lastElement=ParentElement
        Set ret=1
    }
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="addPunctuation">
<FormalSpec>ParentElement:PXW.DEV.Element,Punctuation:%String,*foundString:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Set ret=0
    If ..isPunctuation(Punctuation,.value) {
        Set foundString=..next($LENGTH(value))
        Set atom=..newAtom("punctuation",foundString)
        Do ParentElement.AddPart(atom)
        Set ..lastElement=ParentElement
        Set ret=1
    }
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="addPunctuationInList">
<FormalSpec>ParentElement:PXW.DEV.Element,ListOfStrings:%List,longestLen:%Integer=50,*foundString:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Set ret=0
    If ..isPunctuationInList(ListOfStrings,longestLen,.value) {
        Set foundString=..next(longestLen)
        Set atom=..newAtom("punctuation",foundString)
        Do ParentElement.AddPart(atom)
        Set ..lastElement=ParentElement
        Set ret=1
    }
    $$$DEBUGMethodEnd
    Quit ret
]]></Implementation>
</Method>

<Method name="concatChar">
<FormalSpec><![CDATA[&string:%String,char:%String]]></FormalSpec>
<Implementation><![CDATA[    If ..peek(1)=char Set string=string_char
]]></Implementation>
</Method>

<Method name="isRegex">
<FormalSpec>ParentElement:PXW.DEV.Element,Match:%String</FormalSpec>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    ;d ..skipWhiteSpaceAndComments()
    Do:..needsWScheck ..skipWhiteSpaceAndComments()
    $$$DEBUG("checking match '"_Match_"' found '"_$ZCONVERT(..peek(10),"O","JS")_"'")
    Set value="",count=1,ok=0
    While '..eof(count-1),$MATCH(..peek(count),Match) {
        Set count=count+1
    }
    ;$$$DEBUG("count="_count)
    If count>1 {
        If $ISOBJECT(ParentElement) {
            Set value=..next(count-1) 
            Set atom=..newAtom(ParentElement.type,value)
            Do ParentElement.AddPart(atom)
            Set ..lastElement=ParentElement
        }
        Set ok=1
    }
    ;$$$DEBUG("checking match, ok=1")
    ;zw atom
    $$$DEBUGMethodEnd
    Quit ok
]]></Implementation>
</Method>

<Method name="skipWhiteSpaceAndComments">
<Description>
methods in here need to do a DIRECT lookup on ..text</Description>
<Implementation><![CDATA[
    #define isWS(%x) $c(32,9,13,10,160)[%x
    $$$DEBUGMethodBegin

    If ..stopAtEOL { 
        Set ws=$CHAR(32,9,160)
    } Else {
        Set ws=$CHAR(32,9,13,10,160)
    }
    $$$DEBUG("StopAtWhiteSpace="_..stopAtWhitespace_",StopAtEOL="_..stopAtEOL)
    If ..stopAtWhitespace Goto readExit

readNextLoop		
	Set ch10=..peek(10),ch=$EXTRACT(ch10,1)
	
	; leading whitespace and comments end up embedded in the next real object
	; so you could end up with a returned object like this
	; object={ 
	;          type:"variable",
	;         value:111,
	;       comment:{
	;                type:"comment",
	;               value:"a comment",
	;          whitespace:{
	;                      type:"whitespace",
	;                     value:"  "
	;                     }
	;          }                
	;
    ;
	;i '..eof(),$$$isWS(ch) s ..whitespace=..readWhitespace() g readNextLoop
    If '..eof(),ws[ch Set ..whitespace=..readWhitespace() Goto readNextLoop
	;s ..currentline=..input.line
    /*i ..commentMode="COS" {
        ;i ch=";" s ..comment=..readLineComment(";") g readNextLoop
        ;s ch2=$e(ch10,1,2),ch3=$e(ch10,1,3)
        ;i ch2="//" s ..comment=..readLineComment("//") g readNextLoop
        ;i ch2="#;" s ..comment=..readLineComment("#;") g readNextLoop
        ;i ch3="##;" s ..comment=..readLineComment("##;") g readNextLoop
        ;;i $lf($lb("//","#;","##"),ch2) s ..comment=..readLineComment(ch2) g readNextLoop
        ;i ch2="/*" s ..comment=..readBlockComment() g readNextLoop
        i ..skipComments(ch10) g readNextLoop
    } elseif ..commentMode="CDEF" {
        ;i $e(ch10,1,3)="///" s ..comment=..readLineComment("///") g readNextLoop
        ;i $e(ch10,1,2)="//" s ..comment=..readLineComment("//") g readNextLoop
        ;i $e(ch10,1,2)="/*" s ..comment=..readBlockComment() g readNextLoop
        i ..skipComments(ch10) g readNextLoop
    } elseif ..commentMode="SQL" {
        ;i $e(ch10,1,2)="--" s ..comment=..readLineComment("--") g readNextLoop
        ;i $e(ch10,1,2)="/*" s ..comment=..readBlockComment() g readNextLoop
        i ..skipComments(ch10) g readNextLoop
    } elseif ..commentMode="XML" {
        ;i $e(ch10,1,4)="<!--" s ..comment=..readXMLBlockComment() g readNextLoop  
        i ..skipComments(ch10) g readNextLoop
    } elseif ..commentMode="JS" {
        ;;i $e(ch10,1,2)="//" s ..comment=..readLineComment("//") g readNextLoop
        ;;i $e(ch10,1,2)="/*" s ..comment=..readBlockComment() g readNextLoop
        i ..skipComments(ch10) g readNextLoop
    } else {
        i ..skipComments(ch10) g readNextLoop
    }*/
    If ..skipComments(ch10) Goto readNextLoop
    Set ..needsWScheck=0
readExit
    $$$DEBUGMethodEnd 
    Quit
]]></Implementation>
</Method>

<Method name="skipComments">
<Description>
Skip over the next set of comments, return 1 if something was done or 0.
ch10 is the next 10 chars in the stream</Description>
<FormalSpec>ch10:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    ;i $e(ch10,1,3)="///" s ..comment=..readLineComment("///") q 1
    ;i $e(ch10,1,2)="//" s ..comment=..readLineComment("//") q 1
    ;i $e(ch10,1,2)="/*" s ..comment=..readBlockComment() q 1
    Quit 0
]]></Implementation>
</Method>

<Method name="newElement">
<FormalSpec>type:%String</FormalSpec>
<ReturnType>PXW.DEV.BNF.Element</ReturnType>
<Implementation><![CDATA[    Quit ##class(PXW.DEV.BNF.Element).%New()
]]></Implementation>
</Method>

<Method name="newAtom">
<FormalSpec>type:%String,value:%String=""</FormalSpec>
<ReturnType>PXW.DEV.Atom</ReturnType>
<Implementation><![CDATA[
 
    $$$DEBUGMethodBegin
	Set a=##class(PXW.DEV.Atom).%New() 
	Set a.type=type_":"_$GET(%path)  
    Set a.value=value
	Set a.col=..stream.col
	Set a.line=..stream.line
	If $ISOBJECT(..whitespace) Set a.whitespace=..whitespace
	If $ISOBJECT(..comment) Set a.comment=..comment
    ;s:..whitespace a.whitespace=..whitespace
    ;s:..comment a.comment=..comment
	Set ..whitespace=""
	Set ..comment=""
    Set ..needsWScheck=1
    Set %atoms=$GET(%atoms)+1
    $$$DEBUGMethodEnd
	Quit a
]]></Implementation>
</Method>

<Method name="readWhitespace">
<ReturnType>PXW.DEV.Atom</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    If ..stopAtEOL { 
        Set ws=$CHAR(32,9,160)
    } Else {
        Set ws=$CHAR(32,9,13,10,160)
    }
    Set o=..newAtom("whitespace",..stream.NextChars(ws))
    $$$DEBUGMethodEnd
	Quit o
]]></Implementation>
</Method>

<Method name="readLineComment">
<FormalSpec>start:%String</FormalSpec>
<ReturnType>PXW.DEV.Atom</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	Set o=..newAtom("linecomment")
	Set o.start=..stream.NextNOTEol($LENGTH(start)) 
	Set n=""
    Do {
        Set morecomments=0
       Set n=n_..stream.NextToEol()

        ; now look to see if the NEXT line has the same type of comment
        ; if it does then add all that to this comment
        Set next50=..peek(50)
        
        ; 
        If $EXTRACT($ZSTRIP(next50,"<WC"),1,$LENGTH(start))=start {
            Set ws=$CHAR(32,9,13,10,160)
           Set n=n_..stream.NextChars(ws)
            Set morecomments=1
        }
    } While morecomments

	Set o.value=n
    $$$DEBUGMethodEnd
	Quit o
]]></Implementation>
</Method>

<Method name="readBlockComment">
<FormalSpec>StartMarker:%String="/*",EndMarker:%String="*/"</FormalSpec>
<ReturnType>PXW.DEV.Atom</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    If ..peek($LENGTH(StartMarker))'=StartMarker Quit ""

	Set o=..newAtom("blockcomment")
	Set o.start=..stream.NextNOTEol($LENGTH(StartMarker))
	Set n=""
	Set eob=0
    Set eml=$LENGTH(EndMarker)
	While '..eof() && 'eob {
		Set ch2=..peek(eml)
		If ch2=EndMarker Set eob=1
		If 'eob {
			Set n=n_..next()
		}
	}
	If eob Set o.end=..stream.NextNOTEol(eml) ; put the */ in the block
	Set o.value=n
    $$$DEBUGMethodEnd
	Quit o
]]></Implementation>
</Method>

<Method name="readXMLBlockComment">
<ReturnType>PXW.DEV.Atom</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	Set o=..newAtom("blockcomment")
	Set o.start=..stream.NextNOTEol(4) ; <!--
	Set n=""
	Set eob=0
	While '..eof() && 'eob {
		Set ch3=..peek(3)
		If ch3="-->" Set eob=1
		If 'eob {
			Set n=n_..next()
		}
	}
	If eob Set o.end=..stream.NextNOTEol(3) ; put the --> in the block
	Set o.value=n
    $$$DEBUGMethodEnd
	Quit o
]]></Implementation>
</Method>

<Method name="recover">
<Description>
Match should be a pair of characters that mark out where we are in the code. Mostly this will be "{}". 
The number of { and } is then counted and when the count becomes -1 that means we have reached 
a good recovery point (eg end of method)
Stop At List should be a list of things that cause the recover to stop (eg $lb($c(13)))
we can only allow 1 char, might need to be a bit cleverer here to deal with cdata blocks in each item in the list</Description>
<FormalSpec><![CDATA[ParentElement:PXW.DEV.Element,&subElement:PXW.DEV.Element,Match:%String,StopAtList:%List]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	$$$DEBUGMethodBegin
    #dim a as %CSP.Broker
	Set subElement=##class(PXW.DEV.Element).%New()
	Set subElement.type="recover"

    Set matchcount=0 
	Set ret=0
	Set r=""
    ; find where we are now (pos) up to the point of failure (lastPos)
    While '..eof(),..stream.pos<..stream.lastPos,$LISTFIND(StopAtList,..peek(1))=0,matchcount>=0 {
        If Match'="" {
            If ..peek(1)=$EXTRACT(Match,1) Set matchcount=matchcount+1
            If ..peek(1)=$EXTRACT(Match,2) Set matchcount=matchcount-1
            If matchcount>=0 {
                Set r=r_..next()
                Set ret=1
            }
        } Else {
            Set r=r_..next()
            Set ret=1
        }
    }
	If ret {
		Set atom=..newAtom("ERROR",r)
		Do subElement.AddPart(atom)
	}	
    
    ; now find from the point of failure up to the next recovery point (a mismatch of {}  or a specific char)
    Set ret=0,r=""
	While '..eof(),$LISTFIND(StopAtList,..peek(1))=0,matchcount>=0 {
        If ..peek(1)=$EXTRACT(Match,1) Set matchcount=matchcount+1
        If ..peek(1)=$EXTRACT(Match,2) Set matchcount=matchcount-1
        If matchcount>=0 {
            Set r=r_..next()
            Set ret=1
        }
	}
	If ret {
		Set atom=..newAtom("ERROR",r)
		Do subElement.AddPart(atom)
		Do ParentElement.AddPart(subElement)
	}	
	$$$DEBUGMethodEnd
	Quit ret
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.Dictionary.AtelierClient">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>PXW.DEV.LIB.REST.Client</Super>
<TimeChanged>67125,77563.398370365</TimeChanged>
<TimeCreated>67125,77563.398370365</TimeCreated>

<Property name="Settings">
<Type>PXW.DEV.Dictionary.AtelierSettings</Type>
</Property>

<Method name="doc">
<Description>
server=server:port:namespace
s sc=##class(PXW.DEV.Dictionary.AtelierClient).doc("LOCAL_USER","PXW.DEV.Dictionary.AtelierClient",.obj)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ServerName:%String,ClassName:%String,*object:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim request as %Net.HttpRequest

    $$$DEBUGMethodBegin
    $$$DEBUG(ClassName)

    Set handler=..%New(ServerName) ;  ..%New(ServerName)
 
    Set ns=handler.Settings.Namespace
    Set url="/api/atelier/v2/"_ns_"/doc/"_handler.EncodeURL(ClassName)_".cls"
    ; s sep="?"
    ;s url=url_sep_xxx,sep="&"
    Set sc=handler.getAsObject(url,.object)

    $$$DEBUGMethodEnd

    Quit sc
]]></Implementation>
</Method>

<Method name="rtn">
<Description>

s sc=##class(PXW.DEV.Dictionary.AtelierClient).rtn("LOCAL_USER","PXW.DEV.Dictionary.AtelierClient.1",.obj)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ServerName:%String,RoutineName:%String,*object:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim request as %Net.HttpRequest
    
    $$$DEBUGMethodBegin
    
    Set handler=..%New(ServerName) ;  ..%New(ServerName)
 
    Set ns=handler.Settings.Namespace
    Set url="/api/atelier/v2/"_ns_"/doc/"_handler.EncodeURL(RoutineName)_".INT"
    ;s sep="?"
    ;s url=url_sep_xxx,sep="&"
    Set sc=handler.getAsObject(url,.object)

    $$$DEBUGMethodEnd

    Quit sc
]]></Implementation>
</Method>

<Method name="inc">
<Description>

s sc=##class(PXW.DEV.Dictionary.AtelierClient).inc("LOCAL_USER","PXW",.obj)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ServerName:%String,RoutineName:%String,*object:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim request as %Net.HttpRequest
    
    $$$DEBUGMethodBegin
    
    Set handler=..%New(ServerName) ;  ..%New(ServerName)
 
    Set ns=handler.Settings.Namespace
    Set url="/api/atelier/v2/"_ns_"/doc/"_handler.EncodeURL(RoutineName)_".INC"
    ;s sep="?"
    ;s url=url_sep_xxx,sep="&"
    Set sc=handler.getAsObject(url,.object)

    $$$DEBUGMethodEnd

    Quit sc
]]></Implementation>
</Method>

<Method name="query">
<Description>
k obj s sc=##class(PXW.DEV.Data.AtelierClient).query("localhost:52773:USER","SELECT * FROM %Dictionary.CompiledMethod WHERE Parent=?",.obj,"PXW.DEV.Data.AtelierClient")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ServerName:%String,SQL:%String,*object:%DynamicObject,parameters...:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim request as %Net.HttpRequest
    
    $$$DEBUGMethodBegin
    $$$DEBUG(SQL)
    
    Set handler=..%New(ServerName) ;  ..%New(ServerName)
    Set request=handler.NetRequest

    Set ns=handler.Settings.Namespace
    Set q={}
    Set q.query=SQL
    Set q.parameters=[]
    For i=1:1:$GET(parameters) Do q.parameters.%Push(parameters(i))

    Do q.%ToJSON(request.EntityBody)
    Set request.ContentType="application/json"
    ;s sc=request.Post("/api/atelier/v2/USER/action/query")
    Set url="/api/atelier/v2/"_ns_"/action/query"
    ; s sep="?"
    Set sc=handler.postAsObject(url,.object)
    ;d ..display(object)
    
    $$$DEBUGMethodEnd
    
    Quit sc
]]></Implementation>
</Method>

<Method name="index">
<Description>
s sc=##class(PXW.DEV.Dictionary.AtelierClient).index("LOCAL_USER","PXW.DEV.Dictionary.AtelierClient",.obj)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ServerName:%String,ClassName:%String,*object:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim request as %Net.HttpRequest

    $$$DEBUGMethodBegin
    $$$DEBUG(ClassName)

    Set handler=..%New(ServerName) ;  ..%New(ServerName)
    Set request=handler.NetRequest

    Set ns=handler.Settings.Namespace
    Set array=[]
    Do array.%Push(ClassName_".cls")

    Do array.%ToJSON(request.EntityBody)
    Set request.ContentType="application/json"
    Set url="/api/atelier/v2/"_ns_"/action/index"
    ;s sep="?"
    ;s url=url_sep_xxx,sep="&"
    Set sc=handler.postAsObject(url,.object)

    $$$DEBUGMethodEnd

    Quit sc
]]></Implementation>
</Method>

<Method name="macroLocation">
<Description>
/:namespace/action/getmacrolocation"

s sc=##class(PXW.DEV.Dictionary.AtelierClient).inc("LOCAL_USER","PXW.DEV.Element.CLS","PXW.DEV.Particle","OK",.obj)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ServerName:%String,RoutineName:%String,MacroName:%String,Includes:%String="",IncludeGens:%String="",*object:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim request as %Net.HttpRequest
    
    $$$DEBUGMethodBegin
    
    Set handler=..%New(ServerName) ;  ..%New(ServerName)
    Set request=handler.NetRequest
 
    Set ns=handler.Settings.Namespace
    Set ops={}
    Set ops.docname=RoutineName
    Set ops.macroname=MacroName
    If Includes'="" {
        Set ops.includes=[]
        For i=1:1:$LENGTH(Includes,",") Do ops.includes.%Push($PIECE(Includes,",",i))
    }
    If IncludeGens'="" {
        Set ops.includegenerators=[]
        For i=1:1:$LENGTH(IncludeGens,",") Do ops.includegenerators.%Push($PIECE(IncludeGens,",",i))
    }
    Do ops.%ToJSON(request.EntityBody)
    Set request.ContentType="application/json"
    Set url="/api/atelier/v2/"_ns_"/action/getmacrolocation"
    Set sc=handler.postAsObject(url,.object)

    $$$DEBUGMethodEnd

    Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.Dictionary.AtelierRS">
<Description>
Make a dynamic query on Atelier behave like a normal resultset</Description>
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77563.407649702</TimeChanged>
<TimeCreated>67125,77563.407649702</TimeCreated>

<Property name="%QueryResultContent">
<Type>%Library.DynamicObject</Type>
</Property>

<Property name="%Iterator">
<Type>%Iterator.Object</Type>
</Property>

<Property name="%Value">
<Type>%Library.DynamicObject</Type>
</Property>

<Property name="SQL">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Method name="%OnNew">
<FormalSpec>object:%DynamicObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set ..%QueryResultContent=object.result.content
    Set ..%Iterator=..%QueryResultContent.%GetIterator()
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="%Next">
<ReturnType>%Library.Integer</ReturnType>
<Implementation><![CDATA[
	If ..%Iterator.%GetNext(.key,.value) {
        Set ..%Value=value
        Quit 1
    } Else { 
        Set ..%Value=""
        Quit 0
    }
]]></Implementation>
</Method>

<Method name="%Get">
<FormalSpec>ColumnName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set val=$PROPERTY(..%Value,ColumnName)
    Quit val
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.Dictionary.AtelierSettings">
<Super>PXW.DEV.LIB.REST.Settings</Super>
<TimeChanged>67125,77563.417546594</TimeChanged>
<TimeCreated>67125,77563.417546594</TimeCreated>

<Property name="Namespace">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DefaultData>AtelierSettingsDefaultData</DefaultData>
<Data name="AtelierSettingsDefaultData">
<Subscript>"AtelierSettings"</Subscript>
<Value name="1">
<Value>Namespace</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="PXW.DEV.Dictionary.ClassDefinitionObject">
<Description>
Crazy caching in here, it all started so simple and then got a bit out of
control!</Description>
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>PXW.DEV.Dictionary.CodeInterface</Super>
<TimeChanged>67128,71080.008506645</TimeChanged>
<TimeCreated>67125,77563.451567935</TimeCreated>

<Parameter name="CodeType">
<Default>CLS</Default>
</Parameter>

<Parameter name="CodeTypeDescription">
<Default>Iris Class Definition</Default>
</Parameter>

<Property name="AtelierSettings">
<Type>PXW.DEV.Dictionary.AtelierSettings</Type>
</Property>

<Property name="ExcludeClassesLike">
<Description>
Set this to a list of strings of classes that should be excluded when listing classes, eg "ui%"
each item in the list will be added to the SQL in the form: AND name NOT LIKE '...'
If % is part of the name then you must escape it like this:
"\%Library%" means "%Library*" 
vs 
"%Library%" means "*Library*"</Description>
<Type>%List</Type>
</Property>

<Property name="ExcludeClassesExtends">
<Description>
Set this to a list of strings of classes that should be excluded when listing classes, eg "ui%"
each item in the list will be added to the SQL in the form: AND (NOT (SUPER [ '...'))</Description>
<Type>%List</Type>
</Property>

<Property name="KnownVariables">
<Description>
Set this up with variables "known" to the system that are probably not going to be dimmed or 
declared anywhere.
EG. %request=%CSP.Request</Description>
<Type>%String</Type>
<Collection>array</Collection>
</Property>

<Method name="ClearCache">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<Implementation><![CDATA[
    ;
    ; create the code that clears the cache that can be called from elsewhere
    Do %code.WriteLine($CHAR(9)_"k ^PXW.Cache(""CDEF""),^PXW.Cache(""CDEFSQL"")")
    ; actually clear the cache now (on compile)
    Kill ^PXW.Cache("CDEF"),^PXW.Cache("CDEFSQL")
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Now">
<ClassMethod>1</ClassMethod>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[    Quit $ZDATETIME($HOROLOG,3)
]]></Implementation>
</Method>

<Method name="Load">
<FormalSpec>Name:%String,*Text:%String,*LastUpdateTime:%TimeStamp</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	q ..GetClassStudioText(Name,.Text,,.LastUpdateTime)
]]></Implementation>
</Method>

<Method name="GetClassStudioText">
<FormalSpec>ClassName:%String,*Text:%String,*linesOfCode:%String,*LastUpdateTime:%TimeStamp</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim iter as %Iterator.Object
    $$$DEBUGMethodBegin

   If ClassName="" Quit $$$ERROR(5001,"ClassName is mandatory")

	Set server=..AtelierSettings.ServerName
	Set sc=##class(PXW.DEV.Dictionary.AtelierClient).doc(server,ClassName,.object)
    If $$$ISOK(sc) {
        Set LastUpdateTime=object.result.ts
        Set content=object.result.content
        Set Text="",sep=""
        Set iter=content.%GetIterator()
        While iter.%GetNext(.key,.value) {
            Set Text=Text_sep_value
            Set sep=$CHAR(13,10)
            Set linesOfCode($INCREMENT(linesOfCode))=value
        }
    }
    $$$DEBUGMethodEnd
	Quit sc
]]></Implementation>
</Method>

<Method name="ListClassDetailsWild">
<Description>
Use this if you prefer to deal with * rather than %</Description>
<FormalSpec>ClassWild:%String,listHidden:%Boolean=0,listGenerated:%Boolean=0</FormalSpec>
<ReturnType>PXW.DEV.Dictionary.AtelierRS</ReturnType>
<Implementation><![CDATA[
    Set cls=ClassWild,escape=""
	If cls["%" {
		Set escape="\"
		Set cls=$REPLACE(cls,"%",escape_"%")
	}
	If cls["_" {
		Set escape=$GET(escape,"\")
		Set cls=$REPLACE(cls,"_",escape_"_")
	}
	Set cls=$REPLACE(cls,"*","%") ; make the selection a LIKE compatible thing

    Quit ..ListClassDetailsLike(cls,escape,listHidden,listGenerated)
]]></Implementation>
</Method>

<Method name="ListClassDetailsLike">
<FormalSpec>ClassLike:%String,escape:%String="",listHidden:%Boolean=0,listGenerated:%Boolean=0</FormalSpec>
<ReturnType>PXW.DEV.Dictionary.AtelierRS</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin

	Set server=..AtelierSettings.ServerName 
	Set sql=""
	Set sql=sql_"SELECT cc.ClassType,cc.Name,to_char($piece(cd.TimeChanged,'.',1),'YYYY-MM-DD HH24:MI:SS') as TimeChanged"
    Set sql=sql_",cc.Super,cc.PrimarySuper,cc.ClassType as SubType "
	Set sql=sql_"	FROM %Dictionary.CompiledClass AS cc"
    Set sql=sql_" INNER JOIN %Dictionary.ClassDefinition AS cd ON cd.ID=cc.ID"
	Set sql=sql_"	WHERE 1=1"
	If $DATA(ClassLike) {
        Set sql=sql_"	  AND cc.name LIKE '"_ClassLike_"'"
	    If escape'="" {
		    Set sql=sql_" ESCAPE '"_escape_"'"
	    }
    }
    If listHidden {
        ; 
    } Else {
        Set sql=sql_" AND cc.Hidden!=1"
    }

    If listGenerated {
        ; 
    } Else {
        Set sql=sql_" AND cc.GeneratedBy IS NULL"
    }

    For i=1:1:$LISTLENGTH(..ExcludeClassesLike) {
        Set exlike=$LISTGET(..ExcludeClassesLike,i)
        If exlike'="" {
            Set sql=sql_" AND (cc.name NOT LIKE '"_exlike_"'"
       	    If exlike["\" {
    		    Set sql=sql_" ESCAPE '\'"
            }
            Set sql=sql_")"
        }
    }
   
    Set qsc=##class(PXW.DEV.Dictionary.AtelierClient).query(server,sql,.obj)
	If $$$ISERR(qsc) $$$ThrowStatus(qsc)
	Set rs=##class(PXW.DEV.Dictionary.AtelierRS).%New(obj)
    $$$DEBUGMethodEnd
	Quit rs
]]></Implementation>
</Method>

<Method name="CacheAll">
<FormalSpec>ClassNameLike:%String,LoggerClass:%String=""</FormalSpec>
<Implementation><![CDATA[
    ;If LoggerClass'="" $$$LOGNew(LoggerClass)
    ;$$$DEBUGtoLOG
    Set rs=..ListClassDetailsLike(.ClassNameLike)
    While rs.%Next() {
        Set cname=rs.%Get("Name") 
        Set ts=rs.%Get("TimeChanged") 
        ;$$$LOG("Checking "_cname_", "_ts)
        ; only GCD so that will force a kill of the others making sure that they will reload if necessary later
        Do ..CacheIfNecessary(cname,"GCD",ts) 
    }
]]></Implementation>
</Method>

<Method name="CacheIfNecessary">
<Description>
ClassName must be in the same case as is it stored on oddDEF (eg PXW.DEV.Data.Xref not PXW.DEV.DATA.XREF)</Description>
<FormalSpec>ClassName:%String,Parts:%String="",TimeStamp:%TimeStamp=""</FormalSpec>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    New %NS Set %NS=..Namespace
    Set fcn=..FullClassName(ClassName)
    Set TimeStamp=$PIECE(TimeStamp,".",1) ; no dp
    If (Parts="") || (Parts["GCD") {
        Set docache=0
        Set timechanged=$GET(^PXW.Cache("CDEF",%NS,$$$UPPER(fcn),"GCD"))
        If timechanged="" Set docache=1
        If TimeStamp'="",TimeStamp]timechanged Set docache=1
        If docache {
            ;$$$LOG("Building "_ClassName_", "_TimeStamp_", "_timechanged)
            $$$DEBUG("Fetching from GCD DB_"_ClassName_" timechanged="_timechanged_" TimeStamp="_TimeStamp)
            Do ..CacheListClassDetails(fcn)
            Set ^PXW.Cache("CDEF",%NS,$$$UPPER(fcn),"GCD")=$SELECT(TimeStamp'="":TimeStamp,1:1)
        }
    }
    If (Parts="") || (Parts["GMD") {
        Set docache=0
        Set timechanged=$GET(^PXW.Cache("CDEF",%NS,$$$UPPER(fcn),"GMD"))
        If timechanged="" Set docache=1
        If TimeStamp'="",TimeStamp]timechanged Set docache=1
        If docache {
            $$$DEBUG("Fetching from GMD DB_"_ClassName_" timechanged="_timechanged_" TimeStamp="_TimeStamp)
            Kill ^PXW.Cache("CDEF",%NS,fcn,"GMD")
            Do ..CacheListMethodDetails(fcn)
            Set ^PXW.Cache("CDEF",%NS,$$$UPPER(fcn),"GMD")=$SELECT(TimeStamp'="":TimeStamp,1:1)
        }
    }
    If (Parts="") || (Parts["GPD") {
        Set docache=0
        Set timechanged=$GET(^PXW.Cache("CDEF",%NS,$$$UPPER(fcn),"GPD"))
        If timechanged="" Set docache=1
        If TimeStamp'="",TimeStamp]timechanged Set docache=1
        If docache {
            Kill ^PXW.Cache("CDEF",%NS,fcn,"GPD")
            $$$DEBUG("Fetching from GPD DB_"_ClassName_" timechanged="_timechanged_" TimeStamp="_TimeStamp)
            Do ..CacheListProperyDetails(fcn)
            Set ^PXW.Cache("CDEF",%NS,$$$UPPER(fcn),"GPD")=$SELECT(TimeStamp'="":TimeStamp,1:1)
        }
    }
    If (Parts="") || (Parts["GAD") {
        Set docache=0
        Set timechanged=$GET(^PXW.Cache("CDEF",%NS,$$$UPPER(fcn),"GAD"))
        If timechanged="" Set docache=1
        If TimeStamp'="",TimeStamp]timechanged Set docache=1
        If docache {
            Kill ^PXW.Cache("CDEF",%NS,fcn,"GAD")
            $$$DEBUG("Fetching from GAD DB_"_ClassName_" timechanged="_timechanged_" TimeStamp="_TimeStamp)
            Do ..CacheListParameterDetails(fcn)
            Set ^PXW.Cache("CDEF",%NS,$$$UPPER(fcn),"GAD")=$SELECT(TimeStamp'="":TimeStamp,1:1)
        }
    }
    If (Parts="") || (Parts["GID") {
        Set docache=0
        Set timechanged=$GET(^PXW.Cache("CDEF",%NS,$$$UPPER(fcn),"GID"))
        If timechanged="" Set docache=1
        If TimeStamp'="",TimeStamp]timechanged Set docache=1
        If docache {
            $$$DEBUG("Fetching from GID DB_"_ClassName_" timechanged="_timechanged_" TimeStamp="_TimeStamp)
            Kill ^PXW.Cache("CDEF",%NS,fcn,"GID")
            Do ..CacheListIndexDetails(fcn)
            Set ^PXW.Cache("CDEF",%NS,$$$UPPER(fcn),"GID")=$SELECT(TimeStamp'="":TimeStamp,1:1)
        }
    }
    If (Parts="") || (Parts["GQD") {
        Set docache=0
        Set timechanged=$GET(^PXW.Cache("CDEF",%NS,$$$UPPER(fcn),"GQD"))
        If timechanged="" Set docache=1
        If TimeStamp'="",TimeStamp]timechanged Set docache=1
        If docache {
            $$$DEBUG("Fetching from GQD DB_"_ClassName_" timechanged="_timechanged_" TimeStamp="_TimeStamp)
            Kill ^PXW.Cache("CDEF",%NS,fcn,"GQD")
            Do ..CacheListQueryDetails(fcn)
            Set ^PXW.Cache("CDEF",%NS,$$$UPPER(fcn),"GQD")=$SELECT(TimeStamp'="":TimeStamp,1:1)
        }
    }
    $$$DEBUGMethodEnd
]]></Implementation>
</Method>

<Method name="GetMethodOverrides">
<Description>
Pass in a method Id (classname||methodname) and get back the name of the class
that its overriding
s %NS="LOCAL_USER" w ##class(PXW.DEV.Dictionary.ClassDefinition).GetMethodOverrides("PXW.DEV.COS.Parser||Parse")</Description>
<FormalSpec>MethodId:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    ; builds an array ^PXW.Cache("CDEF",%NS,classname,methodname,parentclassname)
    Set classname=$PIECE(MethodId,"||",1)
    Set methodname=$PIECE(MethodId,"||",2)
 
    Set overrides=""
    If ..GetClassDetails(classname,,.supers) {
        ; supers=,"~PXW.DEV.COS.Parser~PXW.DEV.Parser~%Library.RegisteredObject~%Library.Base~%Library.SystemBase~"
        For i=1:1:$LENGTH(supers,",") {
            Set scn=$PIECE(supers,",",i)
            If ..GetMethodDetails(scn,methodname,,.origin),origin'="" {
                Set overrides=origin
                Quit
            }
        }
    }
    Quit overrides
]]></Implementation>
</Method>

<Method name="GetPropertyOverrides">
<Description>
Pass in a property Id (classname||propertyname) and get back the name of the class
that its overriding</Description>
<FormalSpec>PropertyId:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    ; builds an array ^PXW.Cache("CDEF",%NS,classname,methodname,parentclassname)
    Set classname=$PIECE(PropertyId,"||",1)
    Set propertyname=$PIECE(PropertyId,"||",2)
    
    Set overrides=""
    If ..GetClassDetails(classname,,.supers) {
        ; supers=,"~PXW.DEV.COS.Parser~PXW.DEV.Parser~%Library.RegisteredObject~%Library.Base~%Library.SystemBase~"
        For i=1:1:$LENGTH(supers,",") {
            Set scn=$PIECE(supers,",",i)
            If ..GetPropertyDetails(scn,propertyname,,,,.origin),origin'="" {
                Set overrides=origin
                Quit
            }
        }
    }
    Quit overrides
]]></Implementation>
</Method>

<Method name="ListProperyDetails">
<FormalSpec>ClassName:%String</FormalSpec>
<ReturnType>PXW.DEV.Dictionary.AtelierRS</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	Set server=..AtelierSettings.ServerName
	Set sql=""
    Set sql=sql_"SELECT parent,Name,RuntimeType,SQLFieldName,Collection,Type,Origin "
    Set sql=sql_"FROM %Dictionary.CompiledProperty "
    Set sql=sql_"WHERE parent='"_ClassName_"'"
	Set qsc=##class(PXW.DEV.Dictionary.AtelierClient).query(server,sql,.obj)
	If $$$ISERR(qsc) $$$ThrowStatus(qsc)
 	Set rs=##class(PXW.DEV.Dictionary.AtelierRS).%New(obj)
    $$$DEBUGMethodEnd
	Quit rs
]]></Implementation>
</Method>

<Method name="CacheListProperyDetails">
<FormalSpec>ClassName:%String,TimeStamp:%TimeStamp=""</FormalSpec>
<Implementation><![CDATA[
 
    Set rs=..ListProperyDetails(ClassName)
    While rs.%Next() {
        Set cn=rs.%Get("parent")
        Set psqlname=rs.%Get("SqlFieldName")
        Set pname=rs.%Get("Name")
        Set data=$LISTBUILD(pname,rs.%Get("RuntimeType"),psqlname,
                    rs.%Get("Collection"),rs.%Get("Type"),rs.%Get("Origin"))            
        If psqlname'="" Set ^PXW.Cache("CDEF",..Namespace,$$$UPPER(cn),"GPD","sqlname",$$$UPPER(psqlname))=data
        Set ^PXW.Cache("CDEF",..Namespace,$$$UPPER(cn),"GPD","propertyname",$$$UPPER(pname))=data
    }
]]></Implementation>
</Method>

<Method name="ListParameterDetails">
<FormalSpec>ClassName:%String</FormalSpec>
<ReturnType>PXW.DEV.Dictionary.AtelierRS</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	Set server=..AtelierSettings.ServerName
	Set sql=""
    Set sql=sql_"SELECT parent,Name,Type,Origin "
    Set sql=sql_"FROM %Dictionary.CompiledParameter "
    Set sql=sql_"WHERE parent='"_ClassName_"'"
	Set qsc=##class(PXW.DEV.Dictionary.AtelierClient).query(server,sql,.obj)
	If $$$ISERR(qsc) $$$ThrowStatus(qsc)
 	Set rs=##class(PXW.DEV.Dictionary.AtelierRS).%New(obj)
    $$$DEBUGMethodEnd
	Quit rs
]]></Implementation>
</Method>

<Method name="CacheListParameterDetails">
<FormalSpec>ClassName:%String,TimeStamp:%TimeStamp=""</FormalSpec>
<Implementation><![CDATA[
 
    Set rs=..ListParameterDetails(ClassName)
    While rs.%Next() {
        Set cn=rs.%Get("parent")
        Set pname=rs.%Get("Name")
        Set data=$LISTBUILD(pname,rs.%Get("Type"),rs.%Get("Origin"))            
        Set ^PXW.Cache("CDEF",..Namespace,$$$UPPER(cn),"GAD",$$$UPPER(pname))=data
    }
]]></Implementation>
</Method>

<Method name="ListMethodDetails">
<FormalSpec>ClassName:%String</FormalSpec>
<ReturnType>PXW.DEV.Dictionary.AtelierRS</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
 	Set server=..AtelierSettings.ServerName
	Set sql=""
    Set sql=sql_"SELECT parent,Name,ReturnType,Origin,Stub " ; stub is undocumented but it seems to be "source name.method name.source type (i=index,a=property)
    Set sql=sql_"FROM %Dictionary.CompiledMethod "
    Set sql=sql_"WHERE parent='"_ClassName_"'"
    ;s sql=sql_"UNION "
    ;s sql=sql_"SELECT parent,Name || 'Open',parent,null "
    ;s sql=sql_"FROM %Dictionary.CompiledIndex "
    ;s sql=sql_"WHERE parent='"_ClassName_"' and _Unique=1"
    Set qsc=##class(PXW.DEV.Dictionary.AtelierClient).query(server,sql,.obj)
	If $$$ISERR(qsc) $$$ThrowStatus(qsc)
 	Set rs=##class(PXW.DEV.Dictionary.AtelierRS).%New(obj)
    $$$DEBUGMethodEnd
	Quit rs
]]></Implementation>
</Method>

<Method name="CacheListMethodDetails">
<FormalSpec>ClassName:%String</FormalSpec>
<Implementation><![CDATA[
    Set rs=..ListMethodDetails(ClassName)
    While rs.%Next() {
        Set cn=rs.%Get("parent")
        Set mname=rs.%Get("Name")
        Set stub=rs.%Get("Stub")
        Set rt=rs.%Get("ReturnType")
        Set data=$LISTBUILD(mname,rt,rs.%Get("Origin"),stub)
        Set ^PXW.Cache("CDEF",..Namespace,$$$UPPER(cn),"GMD",$$$UPPER(mname))=data
    }
]]></Implementation>
</Method>

<Method name="ListIndexDetails">
<FormalSpec>ClassName:%String</FormalSpec>
<ReturnType>PXW.DEV.Dictionary.AtelierRS</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
 	Set server=..AtelierSettings.ServerName
	Set sql=""
    Set sql=sql_"SELECT parent,Name,TypeClass,Origin " ; stub is undocumented but it seems to be "source name.method name.source type (i=index,a=property)
    Set sql=sql_"FROM %Dictionary.CompiledIndex "
    Set sql=sql_"WHERE parent='"_ClassName_"'"
    Set qsc=##class(PXW.DEV.Dictionary.AtelierClient).query(server,sql,.obj)
	If $$$ISERR(qsc) $$$ThrowStatus(qsc)
 	Set rs=##class(PXW.DEV.Dictionary.AtelierRS).%New(obj)
    $$$DEBUGMethodEnd
	Quit rs
]]></Implementation>
</Method>

<Method name="CacheListIndexDetails">
<FormalSpec>ClassName:%String</FormalSpec>
<Implementation><![CDATA[
    Set rs=..ListIndexDetails(ClassName)
    While rs.%Next() {
        Set cn=rs.%Get("parent")
        Set mname=rs.%Get("Name")
        Set tc=rs.%Get("TypeClass")
        Set data=$LISTBUILD(mname,tc,rs.%Get("Origin"))
        Set ^PXW.Cache("CDEF",..Namespace,$$$UPPER(cn),"GID",$$$UPPER(mname))=data
    }
]]></Implementation>
</Method>

<Method name="ListQueryDetails">
<FormalSpec>ClassName:%String</FormalSpec>
<ReturnType>PXW.DEV.Dictionary.AtelierRS</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
 	Set server=..AtelierSettings.ServerName
	Set sql=""
    Set sql=sql_"SELECT parent,Name,Type,Origin " ; stub is undocumented but it seems to be "source name.method name.source type (i=index,a=property)
    Set sql=sql_"FROM %Dictionary.CompiledQuery "
    Set sql=sql_"WHERE parent='"_ClassName_"'"
    Set qsc=##class(PXW.DEV.Dictionary.AtelierClient).query(server,sql,.obj)
	If $$$ISERR(qsc) $$$ThrowStatus(qsc)
 	Set rs=##class(PXW.DEV.Dictionary.AtelierRS).%New(obj)
    $$$DEBUGMethodEnd
	Quit rs
]]></Implementation>
</Method>

<Method name="CacheListQueryDetails">
<FormalSpec>ClassName:%String</FormalSpec>
<Implementation><![CDATA[
    Set rs=..ListQueryDetails(ClassName)
    While rs.%Next() {
        Set cn=rs.%Get("parent")
        Set mname=rs.%Get("Name")
        Set type=rs.%Get("Type")
        Set data=$LISTBUILD(mname,type,rs.%Get("Origin"))
        Set ^PXW.Cache("CDEF",..Namespace,$$$UPPER(cn),"GQD",$$$UPPER(mname))=data
    }
]]></Implementation>
</Method>

<Method name="GetPropertyNameSQL">
<FormalSpec>ClassName:%String,SQLName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    If ClassName="" Quit ""

    Set fcn=..FullClassName(ClassName)
    
 	Set ufield=$$$UPPER(SQLName)
	; sometimes fields have quotes around
	If $EXTRACT(ufield,1)="""",$EXTRACT(ufield,*)="""" Set ufield=$EXTRACT(ufield,2,*-1)

    Do ..CacheIfNecessary(fcn,"GPD")
    ;m data=^PXW.Cache("CDEF",%NS,$$$UPPER(fcn)) $$$DEBUGArray(data)
    Set data=$GET(^PXW.Cache("CDEF",..Namespace,$$$UPPER(fcn),"GPD","sqlname",ufield))
	Set pname=$LISTGET(data,1)

    ; ID or ID1
    If SQLName?1"ID"0.N {
        Set pname="%ID"
    }
 	Quit pname
]]></Implementation>
</Method>

<Method name="GetPropertyTypeSQL">
<FormalSpec>ClassName:%String,SQLName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   If ClassName="" Quit ""

    Set fcn=..FullClassName(ClassName)

 	Set ufield=$$$UPPER(SQLName)
	; sometimes fields have quotes around
	If $EXTRACT(ufield,1)="""",$EXTRACT(ufield,*)="""" Set ufield=$EXTRACT(ufield,2,*-1)

    Do ..CacheIfNecessary(fcn,"GPD")
   
    Set data=$GET(^PXW.Cache("CDEF",..Namespace,$$$UPPER(fcn),"GPD","sqlname",ufield))
	Set type=$LISTGET(data,2)
	Quit type
]]></Implementation>
</Method>

<Method name="GetPropertyDetails">
<Description>
Returns 1 if details were found</Description>
<FormalSpec>ClassName:%String,Name:%String,*RuntimeType:%String,*Collection:%String,*Type:%String,*Origin:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If ClassName="" Quit 0
    Set fcn=..FullClassName(ClassName)

 	Set ufield=$$$UPPER(Name)
	; sometimes fields have quotes around
	If $EXTRACT(ufield,1)="""",$EXTRACT(ufield,*)="""" Set ufield=$EXTRACT(ufield,2,*-1)

    Do ..CacheIfNecessary(fcn,"GPD")

    ;s data=$lb(pname,rs.%Get("RuntimeType"),psqlname,
    ;                    rs.%Get("Collection"),rs.%Get("Type"))            
   
    Set data=$GET(^PXW.Cache("CDEF",..Namespace,$$$UPPER(fcn),"GPD","propertyname",ufield))
    If data="" Quit 0

	Set RuntimeType=$LISTGET(data,2)
    Set Collection=$LISTGET(data,4)
    Set Type=$LISTGET(data,5)
    Set Origin=$LISTGET(data,6)
 	Quit 1
]]></Implementation>
</Method>

<Method name="GetPropertyParameterDetails">
<Description>
Returns 1 if the details were found()</Description>
<FormalSpec>ClassName:%String,PropertyName:%String,ParameterName:%String,*SourceClass:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If ClassName="" Quit 0
    
    Set found=0
    ; find the type of the property
    If ..GetPropertyDetails(ClassName,PropertyName,,,.propertytype) {
        ; find if that class has a parameter that matches
        If ..GetParameterDetails(propertytype,ParameterName,,.parameterorigin) {
            Set found=1
            Set SourceClass=parameterorigin
        } Else {
            ; look to the propertyclass of the main class
            If ..GetClassDetails(ClassName,,,,,,,.propertyclass) {
                If ..GetParameterDetails(propertyclass,ParameterName,,.parameterorigin) {
                    Set found=1
                    Set SourceClass=parameterorigin                           
                }
            }
        }
    } 

    Quit found
]]></Implementation>
</Method>

<Method name="GetMethodDetails">
<Description>
Returns 1 if details were found
Sets ReturnType to the defined return type, to work out more information about the return type use GetMethodReturnType </Description>
<FormalSpec>ClassName:%String,Name:%String,*ReturnType:%String,*Origin:%String,*Stub:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If ClassName="" Quit 0

    Set fcn=..FullClassName(ClassName)

 	Set ufield=$$$UPPER(Name)
	; sometimes fields have quotes around
	If $EXTRACT(ufield,1)="""",$EXTRACT(ufield,*)="""" Set ufield=$EXTRACT(ufield,2,*-1)

    Do ..CacheIfNecessary(fcn,"GMD")
	  
    Set data=$GET(^PXW.Cache("CDEF",..Namespace,$$$UPPER(fcn),"GMD",ufield))
    Set ReturnType=$LISTGET(data,2)
    Set Origin=$LISTGET(data,3)
    Set Stub=$LISTGET(data,4)

    If data="" Quit 0
	Quit 1
]]></Implementation>
</Method>

<Method name="GetMethodReturnType">
<FormalSpec>ClassName:%String,Name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    If ClassName="" Quit 0

    ;s fcn=..FullClassName(ClassName)

	Set ufield=$$$UPPER(Name)
	; sometimes fields have quotes around
	If $EXTRACT(ufield,1)="""",$EXTRACT(ufield,*)="""" Set ufield=$EXTRACT(ufield,2,*-1)

	Set found=..GetMethodDetails(ClassName,Name,.returntype,.origin,.stub)

    ; if the return type is not set see if this was derived from some other thing
    If found,returntype="" {
        ; stub is undocumented but it seems to be "SourceName.MethodName.SourceType (i=index,a=property)"
        Set stype=$PIECE(stub,".",3)
        Set smethod=$PIECE(stub,".",2)
        Set sname=$PIECE(stub,".",1)
        If stype="i" {
            Do ..GetIndexDetails(ClassName,sname,.typeclass)
            If typeclass="" Set typeclass="%Compiler.Type.Index"
            Do ..GetMethodDetails(typeclass,smethod,.returntype)
        } If stype="q" {
            Do ..GetQueryDetails(ClassName,sname,.typeclass)
            Do ..GetMethodDetails(typeclass,smethod,.returntype)
        }
    } 
    ; if the method returns an object handle its probably %Open or %New or an IndexOpen or something that returns itself
    If returntype="%Library.ObjectHandle" Set returntype=ClassName
    Quit returntype
]]></Implementation>
</Method>

<Method name="GetIndexDetails">
<Description>
Returns 1 if details were found</Description>
<FormalSpec>ClassName:%String,Name:%String,*TypeClass:%String,*Origin:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If ClassName="" Quit 0

    Set fcn=..FullClassName(ClassName)

    Set ufield=$$$UPPER(Name)
	; sometimes fields have quotes around
	If $EXTRACT(ufield,1)="""",$EXTRACT(ufield,*)="""" Set ufield=$EXTRACT(ufield,2,*-1)

    Do ..CacheIfNecessary(fcn,"GID")
	  
    Set data=$GET(^PXW.Cache("CDEF",..Namespace,$$$UPPER(fcn),"GID",ufield))
    If data="" Quit 0
    Set TypeClass=$LISTGET(data,2)
    Set Origin=$LISTGET(data,3)
	Quit 1
]]></Implementation>
</Method>

<Method name="GetQueryDetails">
<Description>
Returns 1 if details were found</Description>
<FormalSpec>ClassName:%String,Name:%String,*Type:%String,*Origin:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If ClassName="" Quit 0

    Set fcn=..FullClassName(ClassName)

 	Set ufield=$$$UPPER(Name)
	; sometimes fields have quotes around
	If $EXTRACT(ufield,1)="""",$EXTRACT(ufield,*)="""" Set ufield=$EXTRACT(ufield,2,*-1)

    Do ..CacheIfNecessary(fcn,"GQD")
	  
    Set data=$GET(^PXW.Cache("CDEF",..Namespace,$$$UPPER(fcn),"GQD",ufield))
    If data="" Quit 0
    Set Type=$LISTGET(data,2)
    Set Origin=$LISTGET(data,3)
	Quit 1
]]></Implementation>
</Method>

<Method name="FullClassName">
<ClassMethod>1</ClassMethod>
<FormalSpec>Class:%String,CurrentPackage:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If Class="" Quit ""
	If $EXTRACT(Class,1)="%",$LENGTH(Class,".")=1 Set Class="%Library."_$EXTRACT(Class,2,*)
	If Class'[".",CurrentPackage'="" Set Class=CurrentPackage_"."_Class
	Quit Class
]]></Implementation>
</Method>

<Method name="List">
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>PXW.DEV.Dictionary.AtelierRS</ReturnType>
<Implementation><![CDATA[    q ..ListClassDetailsWild(Name)
]]></Implementation>
</Method>

<Method name="ListClassDetails">
<FormalSpec>ClassName:%String="",SQLTableName:%String=""</FormalSpec>
<ReturnType>PXW.DEV.Dictionary.AtelierRS</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin

	Set server=..AtelierSettings.ServerName
	Set sql=""
    Set sql=sql_"SELECT Name,ClassType,Super,PrimarySuper,to_char($piece(TimeChanged,'.',1),'YYYY-MM-DD HH24:MI:SS') as TimeChanged"
    Set sql=sql_",SqlQualifiedNameQ,IncludeCodeAll,IncludeMGenAll,PropertyClass,ClassType as SubType"
    Set sql=sql_" FROM %Dictionary.CompiledClass "
    Set sql=sql_" WHERE "
    If ClassName'="" Set sql=sql_" Name ='"_ClassName_"'"
    If SQLTableName'="" Set sql=sql_" UPPER(SqlQualifiedNameQ) =UPPER('"_SQLTableName_"')"
	Set qsc=##class(PXW.DEV.Dictionary.AtelierClient).query(server,sql,.obj)
	If $$$ISERR(qsc) $$$ThrowStatus(qsc)
 	Set rs=##class(PXW.DEV.Dictionary.AtelierRS).%New(obj)
    Set rs.SQL=sql
    $$$DEBUGMethodEnd
	Quit rs
]]></Implementation>
</Method>

<Method name="CacheListClassDetails">
<FormalSpec>ClassName:%String="",SQLTableName:%String=""</FormalSpec>
<Implementation><![CDATA[
    Set rs=..ListClassDetails(ClassName,SQLTableName)
    Set count=0
    While rs.%Next() {
        Set cname=rs.%Get("Name")
        Do ..CacheClearClassDetails(cname,0) ; class is updating so tidy up index
        Set sqlname=rs.%Get("SqlQualifiedNameQ")
        Set inc1=rs.%Get("IncludeCodeAll"),inc2=rs.%Get("IncludeMGenAll")
        Set includes="",includegens=""
        If inc1'="" Set sep="" For i=1:1:$LISTLENGTH(inc1) Set includes=includes_sep_$LISTGET($LISTGET(inc1,i),1),sep=","
        If inc2'="" Set sep="" For i=1:1:$LISTLENGTH(inc2) Set includegens=includegens_sep_$LISTGET($LISTGET(inc2,i),1),sep=","
        Set data=$LISTBUILD(cname,rs.%Get("ClassType"),rs.%Get("Super"),rs.%Get("PrimarySuper"),sqlname,includes,includegens,rs.%Get("PropertyClass"))            
        Set ^PXW.Cache("CDEF",..Namespace,$$$UPPER(cname),"GCD","data")=data
        If sqlname'="" Set ^PXW.Cache("CDEFSQL",$$$UPPER(sqlname))=cname
        Set count=count+1
    }
    If count=0,ClassName'="" Do ..CacheClearClassDetails(ClassName,1) ; delete as class has gone
]]></Implementation>
</Method>

<Method name="CacheClearClassDetails">
<FormalSpec>ClassName:%String,ClassGone:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    Set olddata=$GET(^PXW.Cache("CDEF",..Namespace,$$$UPPER(ClassName),"GCD","data"))
    Set oldsqlname=$LISTGET(olddata,5)
    If oldsqlname'="" Kill ^PXW.Cache("CDEFSQL",$$$UPPER(oldsqlname))
    If ClassGone Kill ^PXW.Cache("CDEF",..Namespace,$$$UPPER(ClassName))
    Quit
]]></Implementation>
</Method>

<Method name="GetClassDetails">
<Description>
Pass in a ClassName in any case (eg PXW.dev.dictionary.classdefinition) and Name is returned in the correct case</Description>
<FormalSpec>ClassName:%String,*classtype:%String,*Super:%String,*PrimarySuper:%String,*Name:%String,*IncludeAll:%String,*IncludeGenAll:%String,*PropertyClass:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    
    ; this should not need to be here but I have not sorted out subqueries properly
    If ClassName="" Quit 0
  
    Set fcn=..FullClassName(ClassName)
	; converts a classname to the right case by selecting it in a query
   
    Do ..CacheIfNecessary(fcn,"GCD")
 
    Set data=$GET(^PXW.Cache("CDEF",..Namespace,$$$UPPER(fcn),"GCD","data"))
    If data="" Quit 0
	Set Name=$LISTGET(data,1)
	Set classtype=$LISTGET(data,2)
    Set Super=$LISTGET(data,3)
    Set PrimarySuper=$LISTGET(data,4)
    Set IncludeAll=$LISTGET(data,6)
    Set IncludeGenAll=$LISTGET(data,7)
    Set PropertyClass=$LISTGET(data,8)
	Quit 1
]]></Implementation>
</Method>

<Method name="GetClassName">
<FormalSpec>ClassName:%String,*classtype:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  	Set name="",classtype=""
    Do ..GetClassDetails(ClassName,.classtype,,,.name)
	Quit name
]]></Implementation>
</Method>

<Method name="GetClassNameFromTableName">
<Description>
OwningClassName is the name of the class that the query belongs to. Used when no schema is provided.</Description>
<FormalSpec>SQLTableName:%String,OwningClassName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
   Set table=SQLTableName
   ;i table'[".",'$d(OwningClassName) break
    If table'[".",OwningClassName'="" {
        Set schema=$PIECE(OwningClassName,".",1,*-1)
        Set schema=$TRANSLATE(schema,".","_")
        Set table=schema_"."_table
    }

    ; use a local var as a cache, so that the next time a different process looks at
    ; for the table name it might have been set up
    If '$DATA(%PXWSQLName($$$UPPER(table))) {
        Set classname=$GET(^PXW.Cache("CDEFSQL",$$$UPPER(table)))
        If classname="" {
            Do ..CacheListClassDetails(,table)
          	Set classname=$GET(^PXW.Cache("CDEFSQL",$$$UPPER(table)))
        }
        Set %PXWSQLName($$$UPPER(table))=classname
    } Else {
        Set classname=%PXWSQLName($$$UPPER(table))
    }
	Quit classname
]]></Implementation>
</Method>

<Method name="GetFullTableName">
<Description>
Pass in "f1_data.race" to get the same result back
pass in "race", "f1.data.queryclass" to get back "f1_data.race", its taking the schema from the querying class</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>SQLTableName:%String,OwningClassName:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set table=SQLTableName
    If table'[".",OwningClassName'="" {
        Set schema=$PIECE(OwningClassName,".",1,*-1)
        Set schema=$TRANSLATE(schema,".","_")
        Set table=schema_"."_table
    }
    Quit table ; I am not sure if the default schema can be changed on the calling class, if it CAN then this is not dealing with it...
]]></Implementation>
</Method>

<Method name="GetClassNameFromStoredProc">
<FormalSpec>SQLProcName:%String,*method:%String,This:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    
    ; simple formula to start with
    Set cn=$PIECE(SQLProcName,"_",1,*-1)
    Set cn=$TRANSLATE(cn,"_",".")
    Set classname=..GetClassName(cn)
    Set mn=$PIECE(SQLProcName,"_",*)
    Set method=mn
	Quit classname
]]></Implementation>
</Method>

<Method name="GetClassLastUpdatedNoCache">
<FormalSpec>ClassName:%String</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
</Method>

<Method name="GetParameterDetails">
<FormalSpec>ClassName:%String,Name:%String,*Type:%String,*Origin:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If ClassName="" Quit 0
    Set fcn=..FullClassName(ClassName) 

 	Set ufield=$$$UPPER(Name)
	; sometimes fields have quotes around
	If $EXTRACT(ufield,1)="""",$EXTRACT(ufield,*)="""" Set ufield=$EXTRACT(ufield,2,*-1)

    Do ..CacheIfNecessary(fcn,"GAD")

    ;  s data=$lb(pname,rs.%Get("Type"),rs.%Get("Origin"))            
    ;  s ^PXW.Cache("CDEF",%NS,$$$UPPER(cn),"GAD",$$$UPPER(pname))=data
 
    Set data=$GET(^PXW.Cache("CDEF",..Namespace,$$$UPPER(fcn),"GAD",ufield))
    If data="" Quit 0

    Set Type=$LISTGET(data,2)
    Set Origin=$LISTGET(data,3)
 	Quit 1
]]></Implementation>
</Method>

<Method name="GetParameterOverrides">
<Description>
Pass in a parameter Id (classname||parameter) and get back the name of the class
that its overriding</Description>
<FormalSpec>ParameterId:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set classname=$PIECE(ParameterId,"||",1)
    Set propertyname=$PIECE(ParameterId,"||",2)
    
    Set overrides=""
    If ..GetClassDetails(classname,,.supers) {
        ; supers=,"~PXW.DEV.COS.Parser~PXW.DEV.Parser~%Library.RegisteredObject~%Library.Base~%Library.SystemBase~"
        For i=1:1:$LENGTH(supers,",") {
            Set scn=$PIECE(supers,",",i)
            If ..GetParameterDetails(scn,propertyname,,.origin),origin'="" {
                Set overrides=origin
                Quit
            }
        }
    }
    Quit overrides
]]></Implementation>
</Method>

<Method name="GetClassPath">
<Description><![CDATA[
Get the path of the classes when following a property/method path
Pass in:
    ClassName: name of the start class
    PropertyPath: path of each property to follow.
Sets up array:
    Path(n)=$lb(classname,propertyname,type)
    classname=sourceclass
    propertyname=propertyname on the path
    type=type of property (classname on the next step on the path)

USER>k  s %NS="LOCAL_USER" d ##class(PXW.DEV.Dictionary.ClassDefinition).GetClassPath("PXW.DEV.COS.Object","ChainedMethod.ChainedProperty.Name",.a) zw a
a=3
a(1)=$lb("PXW.DEV.COS.Object","ChainedMethod","PXW.DEV.COS.Objects.Method")
a(2)=$lb("PXW.DEV.COS.Objects.Method","ChainedProperty","PXW.DEV.COS.Objects.Property")
a(3)=$lb("PXW.DEV.COS.Objects.Property","Name","PXW.DEV.Atom")
if some step on the path cannot be found then the array will have blanks]]></Description>
<FormalSpec>ClassName:%String,PropertyPath:%String,*PathArray:%List</FormalSpec>
<Implementation><![CDATA[
	
    Set classname=ClassName
    For i=1:1:$LENGTH(PropertyPath,".") {
        ; the objectchain has the "." and the name
        Set propertyname=$PIECE(PropertyPath,".",i)
        Set found=..GetPropertyDetails(classname,propertyname,.type)
        Set:'found type=..GetMethodReturnType(classname,propertyname)
        Set PathArray($INCREMENT(PathArray))=$LISTBUILD(classname,propertyname,type)
        Set classname=type
    }
]]></Implementation>
</Method>

<Method name="GetClassPathFromTable">
<Description><![CDATA[
Get the path of the classes when following a field path
Pass in:
    TableName: name of the start table
    FieldPath: path of each field to follow (separated by ->)
Sets up array:
    Path(n)=$lb(classname,propertyname,type)
    classname=sourceclass
    propertyname=propertyname on the path
    type=type of property (classname on the next step on the path)

k  s %NS="LOCAL_USER" d ##class(PXW.DEV.Dictionary.ClassDefinition).GetClassPathFromTable("f1_data.result","Race->Circuit->Name",.a)
returns
a=3
a(1)=$lb("f1.data.result","Race","f1.data.race")
a(2)=$lb("f1.data.race","Circuit","f1.data.circuit")
a(3)=$lb("f1.data.circuit","Name","data.model.string")
if some step on the path cannot be found then the array will have blanks]]></Description>
<FormalSpec>TableName:%String,FieldPath:%String,*PathArray:%List</FormalSpec>
<Implementation><![CDATA[
	
    Set classname=..GetClassNameFromTableName(TableName)
    For i=1:1:$LENGTH(FieldPath,"->") {
        ; the objectchain has the "." and the name
        Set fieldname=$PIECE(FieldPath,"->",i)
        Set type=..GetPropertyTypeSQL(classname,fieldname)
        Set PathArray($INCREMENT(PathArray))=$LISTBUILD(classname,fieldname,type)
        Set classname=type
    }
]]></Implementation>
</Method>

<Method name="GetMacroLocation">
<Description>
s cs=##class(PXW.DEV.Dictionary.ClassDefinitionObject).%OpenId("LOCAL_USER")
w cs.GetMacroLocation("PXW.DEV.Element","DEBUGMethodBegin",.doc,.line)
This is only cached in a %VAR because the INC could change and the cache is based
on the CLASS.</Description>
<FormalSpec>ClassUsingMacro:%String,MacroName:%String,*sourceDocument:%String,*lineNumber:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Set server=..AtelierSettings.ServerName
    Set macro=$PIECE(MacroName,"(",1) ; in case full macro gets passed in
    If macro?1"$$$".E {
        Set macro=$PIECE(macro,"$$$",2)
    }
    If '$DATA(%PXWMACLOC(ClassUsingMacro,macro)) {
        If ..GetClassDetails(ClassUsingMacro,,,,,.include,.includegen) {
            Set sourceDocument="",lineNumber=""
            Set sc=##class(PXW.DEV.Dictionary.AtelierClient).macroLocation(server,ClassUsingMacro_".CLS",macro,include,includegen,.obj)
            If $$$ISOK(sc) {
                ; remove the .inc from the document name
                Set %PXWMACLOC(ClassUsingMacro,macro)=$LISTBUILD(obj.result.content.document,obj.result.content.line)
            }
        }
    }
    Set data=$GET(%PXWMACLOC(ClassUsingMacro,macro))
    Set sourceDocument=$LISTGET(data,1),lineNumber=$LISTGET(data,2),found=(sourceDocument'="")
    $$$DEBUGMethodEnd
	Quit found
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DefaultData>ClassDefinitionObjectDefaultData</DefaultData>
<Data name="ClassDefinitionObjectDefaultData">
<Subscript>"ClassDefinitionObject"</Subscript>
<Value name="1">
<Value>AtelierSettings</Value>
</Value>
<Value name="2">
<Value>ExcludeClassesLike</Value>
</Value>
<Value name="3">
<Value>ExcludeClassesExtends</Value>
</Value>
</Data>
<Data name="KnownVariables">
<Attribute>KnownVariables</Attribute>
<Structure>subnode</Structure>
<Subscript>"PXW.DEV.Dictionary.ClassDefinitionObject.KnownVariables"</Subscript>
</Data>
</Storage>
</Class>


<Class name="PXW.DEV.Dictionary.CodeInterface">
<Super>%Library.Persistent</Super>
<TimeChanged>67130,29919.784398756</TimeChanged>
<TimeCreated>67125,77563.478404622</TimeCreated>

<Parameter name="CodeType">
</Parameter>

<Parameter name="CodeTypeDescription">
</Parameter>

<Property name="Namespace">
<Type>PXW.DEV.Dictionary.Namespace</Type>
</Property>

<Property name="Type">
<Type>PXW.DEV.Dictionary.CodeType</Type>
<InitialExpression>..#CodeType</InitialExpression>
</Property>

<Index name="PK">
<Properties>Namespace,Type</Properties>
<Unique>1</Unique>
</Index>

<Method name="RegisterType">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    set sc=$$$OK
    set codetype=..#CodeType
    if codetype'="" {
        set obj=##class(PXW.DEV.Dictionary.CodeType).PKOpen(codetype)
        if '$isobject(obj) {
            set obj=##class(PXW.DEV.Dictionary.CodeType).%New()
            set obj.Name=codetype
        }
        if (obj.InterfaceClass="") {
            set obj.InterfaceClass=..%ClassName(1)
        }
        if (obj.InterfaceClass=..%ClassName(1)) {
            set obj.Description=..#CodeTypeDescription
            set sc=obj.%Save()
        } else {
            set sc=$$$ERROR(5001,"CodeType ("_codetype_") already registered to "_obj.InterfaceClass)
        }
    }
    quit sc
]]></Implementation>
</Method>

<Method name="OpenNamespace">
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String</FormalSpec>
<ReturnType>PXW.DEV.Dictionary.CodeInterface</ReturnType>
<Implementation><![CDATA[
    set object=..PKOpen(Namespace,..#CodeType)
    quit object
]]></Implementation>
</Method>

<Method name="List">
<Description>
Needs to return at least SubType,Name,TimeChanged
The return must be similar to %ResultSet</Description>
<FormalSpec>SearchName:%String</FormalSpec>
<ReturnType>%RegisteredObject</ReturnType>
</Method>

<Method name="Load">
<FormalSpec>Name:%String,*Text:%String,*LastUpdateTime:%TimeStamp</FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^PXW.DEV.Dict9C1D.CodeInterfaceD</DataLocation>
<DefaultData>CodeInterfaceDefaultData</DefaultData>
<IdLocation>^PXW.DEV.Dict9C1D.CodeInterfaceD</IdLocation>
<IndexLocation>^PXW.DEV.Dict9C1D.CodeInterfaceI</IndexLocation>
<StreamLocation>^PXW.DEV.Dict9C1D.CodeInterfaceS</StreamLocation>
<ExtentSize>3</ExtentSize>
<Data name="CodeInterfaceDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Namespace</Value>
</Value>
<Value name="3">
<Value>Type</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>33.3333%</Selectivity>
<AverageFieldSize>34.67</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>3</AverageFieldSize>
</Property>
<Property name="Namespace">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:"LOCAL_USER"</OutlierSelectivity>
<AverageFieldSize>12</AverageFieldSize>
</Property>
<Property name="Type">
<Selectivity>33.3333%</Selectivity>
<AverageFieldSize>5</AverageFieldSize>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="PK">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="PXW.DEV.Dictionary.CodeType">
<Super>%Library.Persistent</Super>
<TimeChanged>67125,77563.478120571</TimeChanged>
<TimeCreated>67125,77563.478120571</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Description">
<Type>%String</Type>
</Property>

<Property name="InterfaceClass">
<Type>%String</Type>
<Parameter name="MAXLEN" value="500"/>
</Property>

<Index name="PK">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^PXW.DEV.Dictionary.CodeTypeD</DataLocation>
<DefaultData>CodeTypeDefaultData</DefaultData>
<IdLocation>^PXW.DEV.Dictionary.CodeTypeD</IdLocation>
<IndexLocation>^PXW.DEV.Dictionary.CodeTypeI</IndexLocation>
<StreamLocation>^PXW.DEV.Dictionary.CodeTypeS</StreamLocation>
<Data name="CodeTypeDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Description</Value>
</Value>
<Value name="3">
<Value>InterfaceClass</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="PXW.DEV.Dictionary.CodeTypeIndex">
<Description>
Use this class for linking code types to various classes for doing specific things</Description>
<Super>%Library.Persistent</Super>
<TimeChanged>67126,55207.137814035</TimeChanged>
<TimeCreated>67125,77563.510878503</TimeCreated>

<Property name="Usage">
<Type>%String</Type>
</Property>

<Property name="CodeType">
<Type>PXW.DEV.Dictionary.CodeType</Type>
<Required>1</Required>
</Property>

<Property name="Class">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="500"/>
</Property>

<Index name="PK">
<IdKey>1</IdKey>
<Properties>Usage,CodeType</Properties>
</Index>

<Method name="RegisterType">
<ClassMethod>1</ClassMethod>
<FormalSpec>Usage:%String,CodeType:%String,Class:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set ct=##class(PXW.DEV.Dictionary.CodeType).%OpenId(CodeType,,.sc)
    quit:'$isobject(ct) sc

    set cti=..PKOpen(Usage,CodeType) 
    if '$isobject(cti) {
        set cti=..%New()
        set cti.Usage=Usage
        set cti.CodeType=ct
    }
    if cti.Class="" set cti.Class=Class
    if cti.Class=Class {
        set sc=cti.%Save()
    } else {
        set sc=$$$ERROR(5001,"CodeType ("_Usage_","_CodeType_") is already linked to "_cti.DisplayPageClass)
    }
    quit sc
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^PXW.DEV.Dict9C1D.CodeTypeIndexD</DataLocation>
<DefaultData>CodeTypeIndexDefaultData</DefaultData>
<IdLocation>^PXW.DEV.Dict9C1D.CodeTypeIndexD</IdLocation>
<IndexLocation>^PXW.DEV.Dict9C1D.CodeTypeIndexI</IndexLocation>
<StreamLocation>^PXW.DEV.Dict9C1D.CodeTypeIndexS</StreamLocation>
<ExtentSize>4</ExtentSize>
<Data name="CodeTypeIndexDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Class</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:</OutlierSelectivity>
<AverageFieldSize>2</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>18</AverageFieldSize>
</Property>
<Property name="Class">
<Selectivity>25.0000%</Selectivity>
<AverageFieldSize>23</AverageFieldSize>
</Property>
<Property name="CodeType">
<Selectivity>33.3333%</Selectivity>
<AverageFieldSize>5</AverageFieldSize>
</Property>
<Property name="Usage">
<Selectivity>50.0000%</Selectivity>
<AverageFieldSize>13</AverageFieldSize>
</Property>
<SQLMap name="PK">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="PXW.DEV.Dictionary.Include">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>PXW.DEV.Dictionary.CodeInterface</Super>
<TimeChanged>67126,58670.048029732</TimeChanged>
<TimeCreated>67125,77563.521566514</TimeCreated>

<Parameter name="CodeType">
<Default>INC</Default>
</Parameter>

<Parameter name="CodeTypeDescription">
<Default>Iris Macro Include</Default>
</Parameter>

<Property name="AtelierSettings">
<Type>PXW.DEV.Dictionary.AtelierSettings</Type>
</Property>

<Method name="GetIncludeStudioText">
<Description>
s %NS="LOCAL_USER" s sc=##class(PXW.DEV.Dictionary.Routine).GetRoutineStudioText("PXW.DEV.Dictionary.Routine.1",.text,.lines,.lastupdate,.summary)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>IncludeName:%String,*Text:%String,*linesOfCode:%String,*LastUpdateTime:%TimeStamp,*Summary:%String,*IsGenerated:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim iter as %Iterator.Object
 
    If IncludeName="" Quit $$$ERROR(5001,"IncludeName is mandatory")

 	Set server=%NS ; $g(%Atelier,"localhost:52773:USER")
	Set sc=##class(PXW.DEV.Dictionary.AtelierClient).inc(server,IncludeName,.object)
    If $$$ISOK(sc) {
        Set content=object.result.content
        Set LastUpdateTime=object.result.ts
        Set Text="",sep=""
        Set iter=content.%GetIterator()
        Set line=0
        While iter.%GetNext(.key,.value) {
            ; the top line is not to be included in the text
            If line=0 {
                Set Summary=value
                If $$$UPPER($PIECE($PIECE($PIECE(Summary,"[",2),"]",1),",",2))="GENERATED" Set IsGenerated=1
            }
            ; ROUTINE PXW.DEV.JS.Parser.1 [Type=INT,Generated]"_$c(13,10)_" ;PXW.DEV.JS.Parser.1"_$c(13,10)_" ;Gen......
            If line>0 {
                Set Text=Text_sep_value Set sep=$CHAR(13,10)
                Set linesOfCode($INCREMENT(linesOfCode))=value
            }
            Set line=line+1 
        }
    }
	Quit sc
]]></Implementation>
</Method>

<Method name="List">
<Description>
Routines=PXW.*
s rs=##class(PXW.DEV.Dictionary.Include).List("PXW*")
Needs to return at least SubType,Name,TimeChanged</Description>
<FormalSpec>Routines:%String</FormalSpec>
<ReturnType>PXW.DEV.Dictionary.AtelierRS</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin

	Set server=..AtelierSettings.ServerName 
	Set sql=""
	Set sql=sql_"select Name,""Date"" as TimeChanged,null as SubType from  %Library.Routine_RoutineList('"_Routines_".INC"_"')"

    Set qsc=##class(PXW.DEV.Dictionary.AtelierClient).query(server,sql,.obj)
  	If $$$ISERR(qsc) $$$ThrowStatus(qsc)
	Set rs=##class(PXW.DEV.Dictionary.AtelierRS).%New(obj)
    $$$DEBUGMethodEnd
	Quit rs
]]></Implementation>
</Method>

<Method name="Load">
<FormalSpec>Name:%String,*Text:%String,*LastUpdateTime:%TimeStamp</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    If Name="" Quit $$$ERROR(5001,"IncludeName is mandatory")

 	Set server=..AtelierSettings.ServerName
	Set sc=##class(PXW.DEV.Dictionary.AtelierClient).inc(server,Name,.object)
    If $$$ISOK(sc) {
        Set content=object.result.content
        Set LastUpdateTime=object.result.ts
        Set Text="",sep=""
        Set iter=content.%GetIterator()
        Set line=0
        While iter.%GetNext(.key,.value) {
            ; the top line is not to be included in the text
            If line=0 {
                Set Summary=value
                If $$$UPPER($PIECE($PIECE($PIECE(Summary,"[",2),"]",1),",",2))="GENERATED" Set IsGenerated=1
            }
            ; ROUTINE PXW.DEV.JS.Parser.1 [Type=INT,Generated]"_$c(13,10)_" ;PXW.DEV.JS.Parser.1"_$c(13,10)_" ;Gen......
            If line>0 {
                Set Text=Text_sep_value Set sep=$CHAR(13,10)
                Set linesOfCode($INCREMENT(linesOfCode))=value
            }
            Set line=line+1 
        }
    }
	Quit sc
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DefaultData>IncludeDefaultData</DefaultData>
<Data name="IncludeDefaultData">
<Subscript>"Include"</Subscript>
<Value name="1">
<Value>AtelierSettings</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="PXW.DEV.Dictionary.Install">
<Super>%RegisteredObject</Super>
<TimeChanged>67126,54643.767981512</TimeChanged>
<TimeCreated>67125,77563.514402578</TimeCreated>

<Method name="Setup">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
    set sc=$$$OK
    ; code interfaces
    set:$$$ISOK(sc) sc=##class(PXW.DEV.Dictionary.ClassDefinitionObject).RegisterType()
    set:$$$ISOK(sc) sc=##class(PXW.DEV.Dictionary.Include).RegisterType()
    set:$$$ISOK(sc) sc=##class(PXW.DEV.Dictionary.Routine).RegisterType()
    ; html display pages
    set:$$$ISOK(sc) sc=##class(PXW.Tools.DEV.Class).RegisterType()
    set:$$$ISOK(sc) sc=##class(PXW.Tools.DEV.Include).RegisterType()
    set:$$$ISOK(sc) sc=##class(PXW.Tools.DEV.Routine).RegisterType()
    ; cross reference builders
    set:$$$ISOK(sc) sc=##class(PXW.Xref.Builders.Class).RegisterType()

    
    if $$$ISOK(sc) {
        Set ns="LOCAL_USER"
        set namespace=##class(PXW.DEV.Dictionary.Namespace).%OpenId(ns)
        if '$isobject(namespace) {
            s namespace=##class(PXW.DEV.Dictionary.Namespace).%New()
            s namespace.Name=ns
        }

        set atelier=##class(PXW.DEV.Dictionary.AtelierSettings).%OpenId(ns)
        if '$ISOBJECT(atelier) {
            Set atelier=##class(PXW.DEV.Dictionary.AtelierSettings).%New()
            Set atelier.ServerName=ns
            Set atelier.ServerAddress="localhost"
            Set atelier.Port=52773
            Set atelier.Namespace="IRISAPP"
            Set atelier.InitiateAuthentication="Basic"
            Set atelier.Username="SYSTEM"
            Set atelier.Password="_SYS"
            Set atelier.ContentType="application/json"
        }

        Set cls=##class(PXW.DEV.Dictionary.ClassDefinitionObject).OpenNamespace(ns)
        If '$ISOBJECT(cls) {
            Set cls=##class(PXW.DEV.Dictionary.ClassDefinitionObject).%New()
            Set cls.Namespace=namespace
            Set cls.AtelierSettings=atelier
            Do cls.KnownVariables.SetAt("%CSP.Request","%request")
            Do cls.KnownVariables.SetAt("%CSP.Session","%session")
        }
        Set sc=cls.%Save()
    }

    if $$$ISOK(sc) {
        Set INC=##class(PXW.DEV.Dictionary.Include).OpenNamespace(ns)
        If '$ISOBJECT(INC) {
            Set INC=##class(PXW.DEV.Dictionary.Include).%New()
            Set INC.Namespace=namespace
            Set INC.AtelierSettings=atelier
        }
        Set sc=INC.%Save()
    }

    if $$$ISOK(sc) {
        Set INT=##class(PXW.DEV.Dictionary.Routine).OpenNamespace(ns)
        If '$ISOBJECT(INT) {
            Set INT=##class(PXW.DEV.Dictionary.Routine).%New()
            Set INT.Namespace=namespace
            Set INT.AtelierSettings=atelier
        }
        Set sc=INT.%Save()
    }

    Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.Dictionary.Namespace">
<Description>
General details about the config of the namespaces</Description>
<Super>%Library.Persistent</Super>
<TimeChanged>67125,77563.545949056</TimeChanged>
<TimeCreated>67125,77563.545949056</TimeCreated>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="Description">
<Type>%String</Type>
</Property>

<Index name="iName">
<IdKey>1</IdKey>
<PrimaryKey>1</PrimaryKey>
<Properties>Name</Properties>
<Unique>1</Unique>
</Index>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^PXW.DEV.Dictionary.NamespaceD</DataLocation>
<DefaultData>NamespaceDefaultData</DefaultData>
<IdLocation>^PXW.DEV.Dictionary.NamespaceD</IdLocation>
<IndexLocation>^PXW.DEV.Dictionary.NamespaceI</IndexLocation>
<StreamLocation>^PXW.DEV.Dictionary.NamespaceS</StreamLocation>
<Data name="NamespaceDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Description</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="PXW.DEV.Dictionary.PythonObject">
<Super>%Persistent</Super>
<TimeChanged>67125,77563.559359309</TimeChanged>
<TimeCreated>67125,77563.559359309</TimeCreated>

<Property name="Namespace">
<Type>%String</Type>
</Property>

<Property name="LibraryLocation">
<Description>
This needs to have the final / so that it can simply be concatenated to the name to give a full file spec without worrying about needing to add / or \ or whatever.
The list is searched in order.</Description>
<Type>%List</Type>
</Property>

<Index name="iPK">
<IdKey>1</IdKey>
<PrimaryKey>1</PrimaryKey>
<Properties>Namespace</Properties>
<Unique>1</Unique>
</Index>

<Method name="SetUp">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Set x=..%New()
    Set x.Namespace="LOCAL_USER"
    Set x.LibraryLocation=$LISTBUILD("/usr/lib/python3.10/")
    Set sc=x.%Save()
]]></Implementation>
</Method>

<Method name="GetModule">
<Description>
s py=##class(PXW.DEV.Dictionary.PythonObject).%OpenId("LOCAL_USER")
s sc=py.GetModule("abc",.text,.lines,.lut)</Description>
<FormalSpec>Name:%String,*Text:%String,*linesOfCode:%String,*LastUpdateTime:%TimeStamp</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim file as %Library.File
    Set Text="",LastUpdateTime="",sep=""
    Set filename=..FindFileName(Name)
    If filename'="" {
        Set stream=##class(%FileCharacterStream).%New()
        Set stream.Filename=filename
        While 'stream.AtEnd {
        Set line=stream.ReadLine()
            Set linesOfCode($INCREMENT(linesOfCode))=line
            Set Text=Text_sep_line
            Set sep=$CHAR(13,10)
        }
        Set lutH=##class(%Library.File).GetFileDateModified(filename)
        If lutH["," {
            Set LastUpdateTime=$ZDATETIME(lutH,3)
        }
    }
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="FindFileName">
<FormalSpec>ModuleName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set ret=""
    Set dirsep="/" ; ONLY FOR UNIX AT THE MOMENT
    Set nopy=$SELECT($$$LOWER($PIECE(ModuleName,".",*))="py":$PIECE(ModuleName,".",1,*-1),1:ModuleName)
    Set undotted=$TRANSLATE(nopy,".",dirsep)
    For i=1:1:$LISTLENGTH(..LibraryLocation) {
        Set dir=$LISTGET(..LibraryLocation,i)
        ; try file directly
        Set filename=dir_undotted_".py"
        If ##class(%Library.File).Exists(filename) {
            Set ret=filename
            Quit ; loop
        }
        ; maybe there is an init file
        Set filename=dir_undotted_dirsep_"__init__.py"
        If ##class(%Library.File).Exists(filename) {
            Set ret=filename
            Quit ; loop
        }
    }
    Quit ret
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^PXW.DEV.Dicti9C1D.PythonObjectD</DataLocation>
<DefaultData>PythonObjectDefaultData</DefaultData>
<IdLocation>^PXW.DEV.Dicti9C1D.PythonObjectD</IdLocation>
<IndexLocation>^PXW.DEV.Dicti9C1D.PythonObjectI</IndexLocation>
<StreamLocation>^PXW.DEV.Dicti9C1D.PythonObjectS</StreamLocation>
<Data name="PythonObjectDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>LibraryLocation</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="PXW.DEV.Dictionary.Routine">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>PXW.DEV.Dictionary.CodeInterface</Super>
<TimeChanged>67126,58226.884311613</TimeChanged>
<TimeCreated>67125,77563.557888027</TimeCreated>

<Parameter name="CodeType">
<Default>INT</Default>
</Parameter>

<Parameter name="CodeTypeDescription">
<Default>Iris Routine INT</Default>
</Parameter>

<Property name="AtelierSettings">
<Type>PXW.DEV.Dictionary.AtelierSettings</Type>
</Property>

<Method name="GetRoutineStudioText">
<Description>
s %NS="LOCAL_USER" s sc=##class(PXW.DEV.Dictionary.Routine).GetRoutineStudioText("PXW.DEV.Dictionary.Routine.1",.text,.lines,.lastupdate,.summary)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RoutineName:%String,*Text:%String,*linesOfCode:%String,*LastUpdateTime:%TimeStamp,*Summary:%String,*IsGenerated:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim iter as %Iterator.Object
 
    If RoutineName="" Quit $$$ERROR(5001,"RoutineName is mandatory")

    Set ^PXW("log",$INCREMENT(^PXW))=RoutineName_" "_$GET(%NS)
	Set server=%NS ; $g(%Atelier,"localhost:52773:USER")
	Set sc=##class(PXW.DEV.Dictionary.AtelierClient).rtn(server,RoutineName,.object)
    If $$$ISOK(sc) {
        Set content=object.result.content
        Set LastUpdateTime=object.result.ts
        Set Text="",sep=""
        Set iter=content.%GetIterator()
        Set line=0
        While iter.%GetNext(.key,.value) {
            ; the top line is not to be included in the text
            If line=0 {
                Set Summary=value
                If $$$UPPER($PIECE($PIECE($PIECE(Summary,"[",2),"]",1),",",2))="GENERATED" Set IsGenerated=1
            }
            ; ROUTINE PXW.DEV.JS.Parser.1 [Type=INT,Generated]"_$c(13,10)_" ;PXW.DEV.JS.Parser.1"_$c(13,10)_" ;Gen......
            If line>0 {
                Set Text=Text_sep_value Set sep=$CHAR(13,10)
                Set linesOfCode($INCREMENT(linesOfCode))=value
            }
            Set line=line+1 
        }
    }
	Quit sc
]]></Implementation>
</Method>

<Method name="List">
<Description>
Routines=PXW.*
</Description>
<FormalSpec>Routines:%String</FormalSpec>
<ReturnType>PXW.DEV.Dictionary.AtelierRS</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin

	Set server=..AtelierSettings.ServerName
	Set sql=""
	Set sql=sql_"select Name,""Date"" as TimeChanged,null as SubType  from  %Library.Routine_RoutineList('"_Routines_".INT"_"')"

   Set qsc=##class(PXW.DEV.Dictionary.AtelierClient).query(server,sql,.obj)
  	If $$$ISERR(qsc) $$$ThrowStatus(qsc)
	Set rs=##class(PXW.DEV.Dictionary.AtelierRS).%New(obj)
    $$$DEBUGMethodEnd
	Quit rs
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DefaultData>RoutineDefaultData</DefaultData>
<Data name="RoutineDefaultData">
<Subscript>"Routine"</Subscript>
<Value name="1">
<Value>AtelierSettings</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="PXW.DEV.Element">
<Description>
The base class for groups of atoms that make up an element.
Elements can be subclassed to store extra data. </Description>
<Super>PXW.DEV.Particle</Super>
<TimeChanged>67125,77562.285990717</TimeChanged>
<TimeCreated>67125,77562.285990717</TimeCreated>

<Parameter name="Base">
<Description>
This needs to be set to the name of the Base class
EG for COS it should be set to PXW.DEV.COS.Element
nothing that extends COS should override this parameter</Description>
<Default>PXW.DEV.Element</Default>
</Parameter>

<Property name="type">
<Type>%String</Type>
<InitialExpression>$ZCONVERT($CLASSNAME(),"U")</InitialExpression>
</Property>

<Method name="AddPart">
<Description>
property parts as temp.mylist;
Property parts As list Of PXW.DEV.Particle [ Private ];</Description>
<FormalSpec>Part:PXW.DEV.Particle</FormalSpec>
<Implementation><![CDATA[
	$$$DEBUG("Adding "_Part.%ClassName(1)_":"_Part.type_":"_$zconvert(Part.ToString(),"O","JSON")_":")
	;d ..parts.Insert(Part)
	; this is faster than the list of objects - not much, 20%, but on dealing with millions of things its something
	Set i=$INCREMENT(%PXWparts(+$THIS))
	Set %PXWparts(+$THIS,i)=Part
]]></Implementation>
</Method>

<Method name="partsGetAt">
<FormalSpec>key:%Integer</FormalSpec>
<ReturnType>PXW.DEV.Particle</ReturnType>
<Implementation><![CDATA[
	#dim %PXWparts as PXW.DEV.Particle
	;q ..parts.GetAt(key)
	Quit $GET(%PXWparts(+$THIS,key))
]]></Implementation>
</Method>

<Method name="partsGetNext">
<FormalSpec><![CDATA[&key:%Integer=""]]></FormalSpec>
<ReturnType>PXW.DEV.Particle</ReturnType>
<Implementation><![CDATA[
	#dim %PXWparts as PXW.DEV.Particle
	;q ..parts.GetNext(.key)
	Set key=$ORDER(%PXWparts(+$THIS,key))
	If key'="" {
		Set obj=%PXWparts(+$THIS,key)
	} Else {
		Set obj=""
	}
	Quit obj
]]></Implementation>
</Method>

<Method name="partsCount">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	;q ..parts.Count()
	Quit +$GET(%PXWparts(+$THIS))
]]></Implementation>
</Method>

<Method name="partsCopy">
<FormalSpec>Source:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
	Set count=$GET(%PXWparts(+Source))
	For i=1:1:count Set %PXWparts(+$THIS,$INCREMENT(%PXWparts(+$THIS)))=%PXWparts(+Source,i)
]]></Implementation>
</Method>

<Method name="partsClear">
<Implementation><![CDATA[	Kill:$DATA(%PXWparts(+$THIS)) %PXWparts(+$THIS)
]]></Implementation>
</Method>

<Method name="%OnClose">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill:$DATA(%PXWparts(+$THIS)) %PXWparts(+$THIS)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetString">
<FormalSpec>Part:PXW.DEV.Element</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If $ISOBJECT(Part) Quit Part.ToString(0)
	Quit ""
]]></Implementation>
</Method>

<Method name="ToString">
<FormalSpec>wspace:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim a as PXW.DEV.Atom
	#dim e as PXW.DEV.Element
	
	Set str=""
	Set akey=""
	For  {
		Set a=..partsGetNext(.akey)
		Quit:akey=""

		Set str=str_a.ToString(wspace)
	}
	Quit str
]]></Implementation>
</Method>

<Method name="ToStringAtomsOnly">
<FormalSpec>wspace:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim a as PXW.DEV.Atom
	#dim e as PXW.DEV.Element
	
	Set str=""
	Set akey=""
	For  {
		Set a=..partsGetNext(.akey)
		Quit:akey=""

		If a.%IsA("PXW.DEV.Atom") Set str=str_a.ToString(wspace)
	}
	Quit str
]]></Implementation>
</Method>

<Method name="write">
<FormalSpec>indent:%String=""</FormalSpec>
<Implementation><![CDATA[
	Set akey=""
	Write indent_"Element="_..type_" "_..%ClassName(1)_" @"_+$THIS,!
	For  {
		Set a=..partsGetNext(.akey)
		Quit:akey=""
		
		Do a.write(indent_".")
	}
]]></Implementation>
</Method>

<Method name="writeFull">
<FormalSpec>indent:%String=""</FormalSpec>
<Implementation><![CDATA[
	Set akey=""
	Write indent_"Element="_..type_" "_..%ClassName(1)_" @"_+$THIS,!
	
	For  {
		Set a=..partsGetNext(.akey)
		Quit:akey=""
		
		Do a.writeFull(indent_".")
	}
]]></Implementation>
</Method>

<Method name="LastAtom">
<ReturnType>PXW.DEV.Atom</ReturnType>
<Implementation><![CDATA[
	#dim element as PXW.DEV.Element
	#dim atom as PXW.DEV.Atom
	Set part=..partsGetAt(..partsCount())
	If part.%IsA("PXW.DEV.Element") Set element=part Quit element.LastAtom()
	Set atom=part
	Quit atom
]]></Implementation>
</Method>

<Method name="FirstAtom">
<ReturnType>PXW.DEV.Atom</ReturnType>
<Implementation><![CDATA[
	#dim element as PXW.DEV.Element
	#dim atom as PXW.DEV.Atom
	Set part=..partsGetAt(1)
	If part.%IsA("PXW.DEV.Element") Set element=part Quit element.FirstAtom()
	Set atom=part
	Quit atom
]]></Implementation>
</Method>

<Method name="findElementTypes">
<Description>
STOP USING THIS - go for findElementsByType or findElementsByClass</Description>
<FormalSpec><![CDATA[ClassName:%String,&OuputArray:%String]]></FormalSpec>
<Implementation><![CDATA[
	If ..%IsA(ClassName) Set OuputArray(+$THIS)=$THIS
	For i=1:1:..partsCount() {
		Set ele=..partsGetAt(i)
		If ele.%IsA("PXW.DEV.Element") {
			Do ele.findElementTypes(ClassName,.OuputArray)
		}
	}
]]></Implementation>
</Method>

<Method name="findFirstElementByType">
<FormalSpec>Type:%String,deep:%Boolean=1</FormalSpec>
<ReturnType>PXW.DEV.Element</ReturnType>
<Implementation><![CDATA[
	Set uType=$$$UPPER(Type)
	Set found=""
	If deep {
		If $$$UPPER(..type)=uType {
			Set found=$THIS
		} Else {
			For i=1:1:..partsCount() {
				Set ele=..partsGetAt(i)
				If ele.%IsA("PXW.DEV.Element") {
					Set found=ele.findFirstElementByType(Type,deep)
					If $ISOBJECT(found) Quit ; quit loop
				}
			}
		}
	} Else {
		For i=1:1:..partsCount() {
			Set ele=..partsGetAt(i)
			If ele.%IsA("PXW.DEV.Element"),$$$UPPER(ele.type)=uType {
				Set found=ele
				Quit ; loop
			}
		}
	}
	Quit found
]]></Implementation>
</Method>

<Method name="findNextElement">
<FormalSpec><![CDATA[&key:%Integer]]></FormalSpec>
<ReturnType>PXW.DEV.Element</ReturnType>
<Implementation><![CDATA[
fnel Set x=..partsGetNext(.key)
	 If x="" Quit x
	 If 'x.%IsA("PXW.DEV.Element") Goto fnel
	 Quit x
]]></Implementation>
</Method>

<Method name="countElements">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	;Set count=0,k=""
	;For  Set x=..findNextElement(.k) Quit:k=""  Set count=count+1
	;Quit count
	Set count=0,k=""
	While $isobject(..findNextElement(.k)) {
		Set count=count+1
	}
	quit count
]]></Implementation>
</Method>

<Method name="findElementsByType">
<Description>
deep = 0 means look only at the children of this object
deep = 1 means go deep until we find what we need but do not go deeper
deep = 2 means go through ALL paths finding all elements of that type</Description>
<FormalSpec><![CDATA[Type:%String,&OutputList:%Library.ListOfObjects,deep:%Boolean=2]]></FormalSpec>
<Implementation><![CDATA[
	Set uType=$$$UPPER(Type)
	If deep=2 {
		If $$$UPPER(..type)=uType {
			If '$ISOBJECT($GET(OutputList)) { 
				Set OutputList=##class(%Library.ListOfObjects).%New()
			}
			Do OutputList.Insert($THIS)
		}
		For i=1:1:..partsCount() {
			Set ele=..partsGetAt(i)
			If ele.%IsA("PXW.DEV.Element") {
				Do ele.findElementsByType(Type,.OutputList,2)
			}
		}
	} ElseIf deep=1 {
		Set godeeper=1
		If $$$UPPER(..type)=uType {
			If '$ISOBJECT($GET(OutputList)) { 
				Set OutputList=##class(%Library.ListOfObjects).%New()
			}
			Do OutputList.Insert($THIS)
			Set godeeper=0
		}
		If godeeper {
			For i=1:1:..partsCount() {
				Set ele=..partsGetAt(i)
				If ele.%IsA("PXW.DEV.Element") {
					Do ele.findElementsByType(Type,.OutputList,1)
				}
			}
		}
	} Else {
		For i=1:1:..partsCount() {
			Set ele=..partsGetAt(i)
			If ele.%IsA("PXW.DEV.Element"),$$$UPPER(ele.type)=uType {
				If '$ISOBJECT($GET(OutputList)) { 
					Set OutputList=##class(%Library.ListOfObjects).%New()
				}
				Do OutputList.Insert(ele)				
			}
		}
	}
]]></Implementation>
</Method>

<Method name="findElementsByClass">
<FormalSpec><![CDATA[ClassName:%String,&OuputArray:%String]]></FormalSpec>
<Implementation><![CDATA[
	If ..%IsA(ClassName) Set OuputArray(+$THIS)=$THIS
	For i=1:1:..partsCount() {
		Set ele=..partsGetAt(i)
		If ele.%IsA("PXW.DEV.Element") {
			Do ele.findElementTypes(ClassName,.OuputArray)
		}
	}
]]></Implementation>
</Method>

<Method name="findElementsByTypePath">
<FormalSpec><![CDATA[Path:%String,&OutputList:%Library.ListOfObjects]]></FormalSpec>
<Implementation><![CDATA[
	
	; find everything on the first step of the path
	Set stepI=1,deep=0
	Set step1=$PIECE(Path,",",stepI)
	If step1="*" Set deep=1,stepI=stepI+1,step1=$PIECE(Path,",",stepI)

	Set list1=##class(%Library.ListOfObjects).%New()
	Do ..findElementsByType(step1,list1,deep)
	
	; go along each step after and find all the sub elements that are in the previous list
	; each time we go along the steps we use the output of the previous step as the input of
	; of the next search
	; list1 from above builds list2, list1 is reset to list2 and it runs again
	; if the step is * this means anything will do (look deep)
	; otherwise just look a the next level
	Set stepI=stepI+1,deep=0
	For si=stepI:1:$LENGTH(Path,",") {
		Set step2=$PIECE(Path,",",si)
		If step2="*" {
			Set deep=1
		} Else {
			Set list2=##class(%Library.ListOfObjects).%New()
			For i=1:1:list1.Count() {
				Set item1=list1.GetAt(i)
				Do item1.findElementsByType(step2,list2,deep)		
			}
			Set list1=list2
			Set deep=0
		}
	}
	Set OutputList=list1
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec>type:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..type=$GET(type)
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.InputStream">
<Description>
based on https://lisperator.net/pltut/parser/input-stream</Description>
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77562.298068029</TimeChanged>
<TimeCreated>67125,77562.298068029</TimeCreated>

<Property name="input">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="pos">
<Type>%Integer</Type>
</Property>

<Property name="line">
<Type>%Integer</Type>
</Property>

<Property name="col">
<Type>%Integer</Type>
</Property>

<Property name="startOfLinePos">
<Type>%Integer</Type>
</Property>

<Property name="lastPos">
<Description>
greatest pos</Description>
<Type>%Integer</Type>
</Property>

<Property name="lastStartOfLinePos">
<Type>%Integer</Type>
</Property>

<Property name="length">
<Type>%Integer</Type>
</Property>

<Property name="eolChar">
<Type>%String</Type>
<InitialExpression>$CHAR(13)</InitialExpression>
</Property>

<Method name="NewString">
<ClassMethod>1</ClassMethod>
<FormalSpec>Code:%String</FormalSpec>
<ReturnType>PXW.DEV.InputStream</ReturnType>
<Implementation><![CDATA[
	Set reader=..%New()
	; make crlf just cr so that its 1 char, I am sure it will make things simpler
	;s flat=Code 
	Set flat=$REPLACE(Code,$CHAR(13,10),reader.eolChar)
	Set reader.input=flat
	Set reader.pos=1
	Set reader.line=1
	Set reader.col=0
	Set reader.length=$LENGTH(Code)
	;s %pxwstreams(+reader)=flat
	Quit reader
]]></Implementation>
</Method>

<Method name="Next">
<Description>
Get the next character, taking into account it might be the EOL</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set ch=$EXTRACT(..input,..pos)
	Set ..pos=..pos+1 
	If ch=..eolChar {
		Set ..line=..line+1,..col=0,..startOfLinePos=..pos+1
	} Else {
		Set ..col=..col+1
	}
    ;s:..startOfLinePos>..lastStartOfLinePos ..lastStartOfLinePos=..startOfLinePos
    Set:..pos>..lastPos ..lastPos=..pos
	Quit ch
]]></Implementation>
</Method>

<Method name="NextMany">
<FormalSpec>number:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pos=..pos
	Set ret=$EXTRACT(..input,pos,pos+number-1)
	Set ..pos=pos+number
	Set ..col=..col+number
	If $FIND(ret,..eolChar) {
		Set crcount=$LENGTH(ret,..eolChar)
		Set ..line=..line+crcount-1
		Set ..col=$LENGTH($PIECE(ret,..eolChar,*))
	}
	Set:..pos>..lastPos ..lastPos=..pos
	Quit ret
]]></Implementation>
</Method>

<Method name="NextNOTEol">
<Description>
Read a single char, the next char is NOT checked to see if it is an EOL</Description>
<FormalSpec>number:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set ch=$EXTRACT(..input,..pos,..pos+number-1)
	Set ..pos=..pos+number
	Set ..col=..col+number
    Set:..pos>..lastPos ..lastPos=..pos
	Quit ch
]]></Implementation>
</Method>

<Method name="NextToEol">
<Description>
returns the string to the EOL but NOT the eol char itself</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set eolpos=$FIND(..input,..eolChar,..pos)
	; no eol so read whole string
	If eolpos=0 {
		Set len=..length-..pos
		Set ret=$EXTRACT(..input,..pos,..pos+len)
		Set ..pos=..pos+len+1
		Set ..col=..col+len+1
	} Else {
		Set len=eolpos-..pos-2
		Set ret=$EXTRACT(..input,..pos,..pos+len)
		Set ..pos=..pos+len+1
		Set ..col=..col+len+1
	}
	Set:..pos>..lastPos ..lastPos=..pos
	Quit ret
]]></Implementation>
</Method>

<Method name="NextChars">
<Description>
returns the string that contains only the given characters</Description>
<FormalSpec>ValidChars:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pos=..pos
	Set peek=$EXTRACT(..input,pos)
    While (peek'="") && (ValidChars[peek) {
		Set pos=pos+1
		Set peek=$EXTRACT(..input,pos)
    }
	If pos>..pos {
		Set ret=..NextMany(pos-..pos)
	} Else {
		Set ret=""
	}
	Set:..pos>..lastPos ..lastPos=..pos
	Quit ret
]]></Implementation>
</Method>

<Method name="Peek">
<FormalSpec>offsetStart:%Integer=0,offsetEnd:%Integer=offsetStart</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set ch=$EXTRACT(..input,..pos+offsetStart,..pos+offsetEnd)
	Quit ch
]]></Implementation>
</Method>

<Method name="PeekToEol">
<Description>
returns the string to the EOL but NOT the eol char itself</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set eolpos=$FIND(..input,..eolChar,..pos)
	; no eol so read whole string
	If eolpos=0 {
		Set len=..length-..pos
		Set ret=$EXTRACT(..input,..pos,..pos+len)
	} Else {
		Set len=eolpos-..pos-2
		Set ret=$EXTRACT(..input,..pos,..pos+len)
	}
	Quit ret
]]></Implementation>
</Method>

<Method name="EOF">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit (..Peek()="")
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
Method GetBookmark(Output bm as %List) As %List
{
	s bm=$lb(..pos,..col,..line,..startOfLinePos)
}

Method GotoBookmark(bm As %List)
{
	s ..pos=$lg(bm,1),..col=$lg(bm,2),..line=$lg(bm,3),..startOfLinePos=$lg(bm,4)
}
*/
]]></Content>
</UDLText>

<Method name="Throw">
<FormalSpec>msg:%String</FormalSpec>
<Implementation><![CDATA[
	Set sc=$$$ERROR(5001,msg_" line:"_..line_" col:"_..col)
	$$$ThrowStatus(sc)
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.LIB.REST.Client">
<Super>%Library.RegisteredObject</Super>
<TimeChanged>67129,60591.381977259</TimeChanged>
<TimeCreated>67125,77563.579412686</TimeCreated>

<Property name="NetRequest">
<Type>%Net.HttpRequest</Type>
</Property>

<Property name="Settings">
<Type>PXW.DEV.LIB.REST.Settings</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>ServerName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set ..Settings=##class(PXW.DEV.LIB.REST.Settings).%OpenId(ServerName,,.opensc)
    $$$ThrowOnError(opensc)

    Do ..SetNetRequest(ServerName)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="EncodeURL">
<FormalSpec>value:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Quit $ZCONVERT(value,"O","URL")
]]></Implementation>
</Method>

<Method name="getAsObject">
<FormalSpec>location:%String,*object:%Library.DynamicAbstractObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set object=""
    Set sc=..NetRequest.Get(location)
    If $$$ISOK(sc) {
        If ..NetRequest.HttpResponse.StatusCode=200 {
            Set data=..NetRequest.HttpResponse.Data
            Set object=##class(%Library.DynamicObject).%FromJSON(data)
            Do ..storecookies()

        } Else {
            Set sc=$$$ERROR(5001,..NetRequest.HttpResponse.StatusLine_" ("_location_")")
        }
    } 
    Quit sc
]]></Implementation>
</Method>

<Method name="postAsObject">
<FormalSpec>location:%String,*object:%Library.DynamicAbstractObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set object=""
    Set ..NetRequest.ContentType="application/json"
    Set sc=..NetRequest.Post(location)
    If $$$ISOK(sc) {
        If ..NetRequest.HttpResponse.StatusCode=200 {
            Set data=..NetRequest.HttpResponse.Data
            Set object=##class(%Library.DynamicObject).%FromJSON(data)
            Do ..storecookies()

        } Else {
            Set sc=$$$ERROR(5001,..NetRequest.HttpResponse.StatusLine_" ("_location_")")
        }
    } 
    Quit sc
]]></Implementation>
</Method>

<Method name="display">
<ClassMethod>1</ClassMethod>
<FormalSpec>object:%Library.DynamicAbstractObject</FormalSpec>
<Implementation><![CDATA[
    Set fmt=##class(%JSON.Formatter).%New()
    Do fmt.FormatToString(object,.out)
    Write out
]]></Implementation>
</Method>

<Method name="storecookies">
<Implementation><![CDATA[
    #dim %session as %CSP.Session
    ; store cookies for later
    Set key=..%ClassName(1)_":"_..NetRequest.Server_":"_..NetRequest.Port
    If $ISOBJECT($GET(%session)) {
        Set max=..NetRequest.GetFullCookieList(.array)
        For i=1:1:max {
            Set cookie=array(i)
            Do %session.Set(key_i,cookie)
        }
        Do %session.Set(key,max)
    } Else {
        Set max=..NetRequest.GetFullCookieList(.array)
        For i=1:1:max {
            Set cookie=array(i)
            Set ^||session(key_i)=cookie
        }
        Set ^||session(key)=max
    }
    ; must be a good request so don't need password any more
    Set ..NetRequest.Password="something else"
]]></Implementation>
</Method>

<Method name="restorecookies">
<Implementation><![CDATA[
    Set key=..%ClassName(1)_":"_..NetRequest.Server_":"_..NetRequest.Port
    If $ISOBJECT($GET(%session)) {
        Set max=%session.Get(key)
        For i=1:1:max {
            // array(index)=$LB(name,domain,path,value,expires,secure)
            ;Method InsertCookie(name As %String, value As %String, path As %String, domain As %String, expires As %String, secure As %Boolean = 0) As %Status
            Set cookie=%session.Get(key_i)
            Set $LISTBUILD(name,domain,path,value,expires,secure)=cookie
            Do ..NetRequest.InsertCookie(name,value,path,domain,expires,secure)
        }
     } Else {
        Set max=$GET(^||session(key))
        For i=1:1:max {
            // array(index)=$LB(name,domain,path,value,expires,secure)
            ;Method InsertCookie(name As %String, value As %String, path As %String, domain As %String, expires As %String, secure As %Boolean = 0) As %Status
            Set cookie=$GET(^||session(key_i))
            Set $LISTBUILD(name,domain,path,value,expires,secure)=cookie
            Do ..NetRequest.InsertCookie(name,value,path,domain,expires,secure)
        }
    }
]]></Implementation>
</Method>

<Method name="SetNetRequest">
<Description>
Server=server:port:namespace</Description>
<FormalSpec>ServerName:%String</FormalSpec>
<Implementation><![CDATA[
    If $ISOBJECT($GET(%netrequest(ServerName))) {
        Set ..NetRequest=%netrequest(ServerName)
    } Else {
        Set netrequest=##class(%Net.HttpRequest).%New()
        Set netrequest.Server=..Settings.ServerAddress ; localhost
        Set netrequest.Port=..Settings.Port ; 52773 ; 1972
        Set netrequest.InitiateAuthentication=..Settings.InitiateAuthentication ; Basic
        Set netrequest.Username=..Settings.Username ; _SYSTEM
        Set netrequest.Password=..Settings.Password ; "pxw123456"
        Set netrequest.ContentType=..Settings.ContentType ; "application/json"
        Set ..NetRequest=netrequest
        Do ..restorecookies()
        Set %netrequest(ServerName)=netrequest
    }
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.LIB.REST.Settings">
<Super>%Library.Persistent</Super>
<TimeChanged>67125,77563.591596863</TimeChanged>
<TimeCreated>67125,77563.591596863</TimeCreated>

<Property name="ServerName">
<Type>%String</Type>
</Property>

<Property name="ServerAddress">
<Description>
localhost</Description>
<Type>%String</Type>
</Property>

<Property name="Port">
<Description>
52773</Description>
<Type>%String</Type>
</Property>

<Property name="InitiateAuthentication">
<Description>
Basic</Description>
<Type>%String</Type>
</Property>

<Property name="Username">
<Description>
_SYSTEM</Description>
<Type>%String</Type>
</Property>

<Property name="Password">
<Description>
pw1971</Description>
<Type>%String</Type>
</Property>

<Property name="ContentType">
<Type>%String</Type>
<InitialExpression>"application/json"</InitialExpression>
</Property>

<Index name="idkey">
<IdKey>1</IdKey>
<PrimaryKey>1</PrimaryKey>
<Properties>ServerName</Properties>
</Index>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^PXW.DEV.LIB.REST.SettingsD</DataLocation>
<DefaultData>SettingsDefaultData</DefaultData>
<IdLocation>^PXW.DEV.LIB.REST.SettingsD</IdLocation>
<IndexLocation>^PXW.DEV.LIB.REST.SettingsI</IndexLocation>
<StreamLocation>^PXW.DEV.LIB.REST.SettingsS</StreamLocation>
<Data name="SettingsDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ServerAddress</Value>
</Value>
<Value name="3">
<Value>Port</Value>
</Value>
<Value name="4">
<Value>InitiateAuthentication</Value>
</Value>
<Value name="5">
<Value>Username</Value>
</Value>
<Value name="6">
<Value>Password</Value>
</Value>
<Value name="7">
<Value>ContentType</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="PXW.DEV.Particle">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>%Library.RegisteredObject</Super>
<TimeChanged>67125,77562.318343378</TimeChanged>
<TimeCreated>67125,77562.318343378</TimeCreated>

<Property name="type">
<Type>%String</Type>
</Property>

<Method name="ToString">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..%ClassName(1)
]]></Implementation>
</Method>
</Class>


<Class name="PXW.DEV.UnitTests.DummyQuery">
<ClassType>view</ClassType>
<TimeChanged>67130,60736.921334494</TimeChanged>
<TimeCreated>67130,59334.833286205</TimeCreated>
<ViewQuery>

    SELECT DISTINCT A.ItemKey1 as Name
            ,a.ItemKey2 as SubName
            ,a.CalledByKey1
    FROM (SELECT b.ItemKey1
                 ,b.ItemKey2
                 ,b.CalledByKey1
                 ,b.CalledByKey2 
                FROM (SELECT * 
                        ,'hello' as ExtraColumn
                        FROM 
                        (SELECT * FROM PXW_XREF.data)
                      ) b) AS a

</ViewQuery>
</Class>


<Class name="PXW.DEV.UnitTests.TestAtelierClient">
<Super>%UnitTest.TestCase</Super>
<TimeChanged>67125,77564.029890881</TimeChanged>
<TimeCreated>67125,77564.029890881</TimeCreated>

<Method name="Test1">
<Implementation><![CDATA[
   
    ; load itself!
    s sc=##class(PXW.DEV.Dictionary.AtelierClient).doc("LOCAL_USER","PXW.DEV.Dictionary.AtelierClient",.obj)
    do $$$AssertEquals(sc,1)
    do $$$AssertEquals($ISOBJECT(obj),1)
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Debuggers.Basic">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77560.143015096</TimeChanged>
<TimeCreated>67125,77560.143015096</TimeCreated>

<Method name="DEBUG">
<Description>
Tends to be called more often with all sorts of data passed in</Description>
<FormalSpec>message:%String</FormalSpec>
<Implementation><![CDATA[	Write message,!
]]></Implementation>
</Method>

<Method name="DEBUGStack">
<Description>
Dump the current stack to the output</Description>
<Implementation><![CDATA[
	For i=0:1:$STACK(-1) {
		Set com=$STACK(i),pla=$STACK(i,"PLACE"),mco=$STACK(i,"MCODE")
		If $LENGTH(com)>$GET(maxcom) Set maxcom=$LENGTH(com)
		If $LENGTH(pla)>$GET(maxpla) Set maxpla=$LENGTH(pla)
	}
	Set $PIECE(spc," ",99)=""
	For i=0:1:$STACK(-1) {
		Set com=$STACK(i),pla=$STACK(i,"PLACE"),mco=$STACK(i,"MCODE")
		Set $EXTRACT(com,maxcom+1)="",$EXTRACT(pla,maxpla+1)=""
		Do ..DEBUG("STACK:"_$JUSTIFY(i,3)_":"_com_":"_pla_":"_mco)
	}
]]></Implementation>
</Method>

<Method name="On">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[	$$$DEBUGSetup(..%ClassName(1))
]]></Implementation>
</Method>

<Method name="Off">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[	$$$DEBUGStop
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Debuggers.BasicToFile">
<Super>PXW.Debuggers.Basic</Super>
<TimeChanged>67125,77560.169895105</TimeChanged>
<TimeCreated>67125,77560.169895105</TimeCreated>

<Property name="currentIO">
<Type>%String</Type>
</Property>

<Property name="file">
<Type>%String</Type>
</Property>

<Method name="DEBUG">
<FormalSpec>message:%String</FormalSpec>
<Implementation><![CDATA[
    Do ..UseFile()
    Try {
        Write message,!
    } Catch e {
    }
    Do ..UseIO()
]]></Implementation>
</Method>

<Method name="SetFilename">
<FormalSpec>Filename:%String</FormalSpec>
<Implementation><![CDATA[
    Do ..UseFile(Filename)
    Do ..UseIO()
]]></Implementation>
</Method>

<Method name="SetDirectory">
<Description>
Sets the default directory of the output, returns the old value</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Directory:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set old=$GET(^PXW.Debuggers("BasicToFile"))
    Set ^PXW.Debuggers("BasicToFile")=Directory
    Quit old
]]></Implementation>
</Method>

<Method name="GetDirectory">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Quit $GET(^PXW.Debuggers("BasicToFile"))
]]></Implementation>
</Method>

<Method name="UseFile">
<Description>
Needs ^PXW.Debuggers("BasicToFile")="/durable/"</Description>
<FormalSpec>ForcedFilename:%String</FormalSpec>
<Implementation><![CDATA[
    If ..file="" {
        If $DATA(ForcedFilename) {
            Set filename=ForcedFilename
        } Else {
            ; allow this to crash if the directory is not set up
            Set filedir=^PXW.Debuggers("BasicToFile") 
            if ##class(%Library.File).DirectoryExists(filedir)=0 {
                set sc=##class(%File).CreateDirectory(^PXW.Debuggers("BasicToFile"),.ret)
                set ^PXW.Debuggers("BasicToFile","dirCreated")=$lb(sc,ret,$h)
            }
            Set filename=filedir_"debug_"_$TRANSLATE($ZDATETIME($HOROLOG,8,1)," :","_")_"_"_$JOB_".txt"
        }
        Set ..file=filename
        Open ..file:"WN"
    } 
    If ..currentIO="" Set ..currentIO=$IO
    Use ..file
]]></Implementation>
</Method>

<Method name="UseIO">
<Implementation><![CDATA[
    Use ..currentIO
    Set ..currentIO=""
]]></Implementation>
</Method>

<Method name="%OnClose">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Close</METHOD> method to 
provide notification that the current object is being closed.

<P>The return value of this method is ignored.]]></Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If ..file'="" {
        Close ..file
        Set ..file=""
    }
    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Debuggers.Console">
<Super>PXW.Debuggers.Basic</Super>
<TimeChanged>67125,77560.194231059</TimeChanged>
<TimeCreated>67125,77560.194231059</TimeCreated>

<Method name="DEBUG">
<FormalSpec>message:%Library.String</FormalSpec>
<Language>objectscript</Language>
<Implementation><![CDATA[
	Set flag=0
	Set severity=-1
	Do ##class(%SYS.System).WriteToConsoleLog(message,flag,severity)
]]></Implementation>
</Method>
</Class>


<Class name="PXW.LIB.SQL.Generator">
<TimeChanged>67125,77561.490452863</TimeChanged>
<TimeCreated>67125,77561.490452863</TimeCreated>

<Method name="GenerateArgsSave">
<ClassMethod>1</ClassMethod>
<FormalSpec>FormalSpec:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$GENERATE($CHAR(9)_"n %args,%PXWCache")
	For i=1:1:$LISTLENGTH(FormalSpec) {
		Set arg=$LISTGET(FormalSpec,i),argname=$LISTGET(arg,1)
		$$$GENERATE($CHAR(9)_"s %args("""_argname_""")=$g("_argname_")")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GenerateEventStart">
<ClassMethod>1</ClassMethod>
<FormalSpec>QueryId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	;$$$GENERATE($CHAR(9)_"s log=##class(PXW.LIB.SQLQuery.Log).%New("""_QueryId_""",.%args,.tLines)")
	;$$$GENERATE($CHAR(9)_"s sc=log.%Save() Throw:$$$ISERR(sc) ##class(%Exception.StatusException).ThrowIfInterrupt(sc)")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GenerateEventFinish">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GenerateArgsReplace">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$GENERATE($CHAR(9)_"set tExecuteArgs = """"")
	$$$GENERATE($CHAR(9)_"for tPtr=1:2:$ListLength(tStatementArgs) {")
	$$$GENERATE($CHAR(9)_"	set tArg = $Case($List(tStatementArgs,tPtr),")
	$$$GENERATE($CHAR(9)_"       ""?"":""$g(%parm(""_$Increment(qcount)_""))"",")
	$$$GENERATE($CHAR(9)_"       ""c"":($List(tStatementArgs,tPtr+1)),")
	$$$GENERATE($CHAR(9)_"       ""v"":%args($List(tStatementArgs,tPtr+1)),:"""") ")
	$$$GENERATE($CHAR(9)_"  Set tExecuteArr($i(tExecuteArr))=tArg ")
	$$$GENERATE($CHAR(9)_"}")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GenerateTLines">
<Description>
Generate the code that generates SQL.

If the code contains certain comments then these will generate different code
--IF condition
--ELSEIF condition
--ELSE
--ENDIF

/*IF condition */
/*ELSEIF condition*/
/*ELSE*/
/*ENDIF*/

If these are found then the SQL between the if/endif is only included if the condition is true.

EXAMPLE: 
SELECT * FROM TABLE1
WHERE 1=1 
--IF param'="" 
   AND PROPERTY=:param
--ENDIF

This will only include the check on PROPERTY if the parameter is set to something other than null.

Don't forget the sql or condition can contain macros:
You could create an include file like this
#define FIELD(%f) $PIECE(%f,"=",1)
#define VALUE(%f) $PIECE(%f,"=",2)
#define SQLFIELD(%f) $PIECE(%f,'=',1)
#define SQLVALUE(%f) $PIECE(%f,'=',2)


EXAMPLE: 
SELECT * FROM TABLE1
WHERE 1=1 
--IF $$$FIELD(param)="FIRSTNAME"
   AND FIRSTNAME=$$$SQLVALUE(:param)
--ENDIF
--IF $$$FIELD(param)="SURNAME"
   AND SURNAME=$$$SQLVALUE(:param)
--ENDIF

This would allow two different searches on one parameter: 
	param="FIRSTNAME=JOHN"
	param="SURNAME=SMITH"
Making sure that the best index is used each time without loads of parameters to the query

YOU could do some really clever search enabling BOTH searches, param="SURNAME=SMITH,FIRSTNAME=JOHN"
BUT not using these built in macros yet.

Possible JSON support needed as a built in thing: param={SURNAME:SMITH,FIRSTNAME:JOHN}</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&tLines:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set commentstart="/"_"*",commentend="*"_"/",commentline="-"_"-"
	Set tKey=""
	Set tab=$CHAR(9)
	Set indent=tab
		
	$$$GENERATE(indent_"s tLines=""""")
	
	For  {
		Set tKey=$ORDER(tLines(tKey),1,sqlcode)
		Quit:tKey=""
		While sqlcode'="" {
			Set usqlcode=$ZSTRIP($ZCONVERT(sqlcode,"U"),"<W")
			If $EXTRACT(usqlcode,1,2)=commentstart,usqlcode[commentend {
				; in start and end comment
				If $EXTRACT(usqlcode,3,4)="IF" {					;/*IF
					Set ifcode=$PIECE($PIECE(sqlcode,commentstart,2),commentend,1)
					;s ifcode=..ChangeMacros(ifcode,"cos")
					$$$GENERATE(indent_ifcode_" {")
					Set sqlcode=$PIECE(sqlcode,commentend,2,*)
					Set indent=indent_tab
				} ElseIf $EXTRACT(usqlcode,3,8)="ELSEIF" {		;/*ELSEIF
					Set ifcode=$PIECE($PIECE(sqlcode,commentstart,2),commentend,1)
					Set indent=$EXTRACT(indent,1,*-1)
					$$$GENERATE(indent_ifcode_" {")
					Set sqlcode=$PIECE(sqlcode,commentend,2,*)
					Set indent=indent_tab
				} ElseIf $EXTRACT(usqlcode,3,6)="ELSE" {			;/*ELSE
					Set indent=$EXTRACT(indent,1,*-1)
					$$$GENERATE(indent_"} else {")
					Set sqlcode=$PIECE(sqlcode,commentend,2,*)
					Set indent=indent_tab
				} ElseIf $EXTRACT(usqlcode,3,7)="ENDIF" {			;/*ENDIF
					Set indent=$EXTRACT(indent,1,*-1)
					$$$GENERATE(indent_"}")
					Set sqlcode=$PIECE(sqlcode,commentend,2,*)
				} Else {
					$$$GENERATE(indent_"s tLines($i(tLines))="_$ZUTIL(144,1,sqlcode)_"")
					Set sqlcode=""
				}
			} ElseIf $EXTRACT(usqlcode,1,2)=commentline {
				; whole line comment
				If $EXTRACT(usqlcode,3,4)="IF" {						;--IF
					Set ifcode=$PIECE(sqlcode,commentline,2,*)
					$$$GENERATE(indent_ifcode_" {")
					Set sqlcode=""
					Set indent=indent_tab
				} ElseIf $EXTRACT(usqlcode,3,8)="ELSEIF" {			;--ELSEIF
					Set ifcode=$PIECE(sqlcode,commentline,2,*)
					Set indent=$EXTRACT(indent,1,*-1)
					$$$GENERATE(indent_"} "_ifcode_" {")
					Set sqlcode=""
					Set indent=indent_tab
				} ElseIf $EXTRACT(usqlcode,3,6)="ELSE" {				;--ELSE
					Set indent=$EXTRACT(indent,1,*-1)
					$$$GENERATE(indent_"} else {")
					Set sqlcode=""
					Set indent=indent_tab
				} ElseIf $EXTRACT(usqlcode,3,7)="ENDIF" {				;--ENDIF
					Set indent=$EXTRACT(indent,1,*-1)
					$$$GENERATE(indent_"}")
					Set sqlcode=""
				} Else {
					;s sqlcode=..ChangeMacros(sqlcode)
					$$$GENERATE(indent_"s tLines($i(tLines))="_$ZUTIL(144,1,sqlcode)_"")
					Set sqlcode=""
				}
			} Else {
				Set beforecomment=$PIECE(sqlcode,commentstart,1)
				;s beforecomment=..ChangeMacros(beforecomment,"sql")
				$$$GENERATE(indent_"s tLines($i(tLines))="_$ZUTIL(144,1,beforecomment)_"")
				Set sqlcode=$PIECE(sqlcode,beforecomment,2,*)
			}
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="PXW.LIB.SQL.Query">
<Super>%Library.SQLQuery</Super>
<TimeChanged>67125,77561.521833382</TimeChanged>
<TimeCreated>67125,77561.521833382</TimeCreated>
<DependsOn>PXW.LIB.SQL.Generator</DependsOn>

<Method name="Func">
<Description>
Func is a method that is used to invoke the query as a function, returning an instance of %SQL.StatementResult.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%SQL.StatementResult</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	;
	Set %code=0
		// don't generate any code if it not for a query
	If %mode="method" Quit $$$OK 
		// %mode is "propertymethod" for a valid query. We don't have any way currently to detect a misuse of a query class
	If '$$$comMemberDefined(%class,$$$cCLASSquery,%property) Quit $$$OK
		// Reset the formal list to the query declaration:
	$$$comSubMemberKeyGetLvar(formal,%class,$$$cCLASSquery,%property,$$$cQUERYmethod,%method,$$$cMETHformalspecparsed)
	$$$comMemberKeyGetLvar(qformal,%class,$$$cCLASSquery,%property,$$$cQUERYformalspecparsed)
	$$$comSubMemberKeySet(%class,$$$cCLASSquery,%property,$$$cQUERYmethod,%method,$$$cMETHformalspecparsed,formal_qformal)
	Set sc=$$SetOneQueryMeth^%occQuery(%class,%property,%method) Quit:$$$ISERR(sc) sc

	$$$comMemberKeyGetLvar(origin,%class,$$$cCLASSquery,%property,$$$cXXXXorigin)
	$$$comMemberKeyGetLvar(query,%class,$$$cCLASSquery,%property,$$$cQUERYsqlquery)

	// preparse the query to construct the actual argument list
	Set query = $ZSTRIP(query,"<W")
	Set tLines = 0 For tPtr = 1:1:$LENGTH(query,$$$NL) { Set tLine = $PIECE(query,$$$NL,tPtr) If tLine '= "" { Set tLines = tLines + 1, tLines(tLines) = tLine } }
	Set sc=$$ExpandMacros^%SYS.DynamicQuery(%class,.tLines) Quit:$$$ISERR(sc) sc

	Do ##class(PXW.LIB.SQL.Generator).GenerateArgsSave(qformal)
	Do ##class(PXW.LIB.SQL.Generator).GenerateTLines(.tLines)
	Do ##class(PXW.LIB.SQL.Generator).GenerateEventStart(%class_"||"_%property)

	$$$GENERATE($CHAR(9)_"set SQLCODE = $$dynamic^%qaqpreparser(.tLines,.tStatementPreparsed,.tStatementArgs)")
	Do ##class(PXW.LIB.SQL.Generator).GenerateArgsReplace()	

	Set tSelectMode = $CASE($$$ucase(%parameter("SELECTMODE")), "RUNTIME": "", "ODBC": 1, "DISPLAY": 2, "LOGICAL": 0, : "")
	$$$GENERATE($CHAR(9)_"try {")
	$$$GENERATE($CHAR(9,9)_"set tSchemaPath = ##class(%SQL.Statement).%ClassPath($classname())")
	$$$GENERATE($CHAR(9,9,9)_"set tStatement = ##class(%SQL.Statement).%New(" _ tSelectMode _ ",tSchemaPath)")
	$$$GENERATE($CHAR(9,9,9)_"do tStatement.prepare(tStatementPreparsed)")
	$$$GENERATE($CHAR(9,9)_"set tResult = tStatement.%Execute(tExecuteArr...)")
	$$$GENERATE($CHAR(9)_"}")
	$$$GENERATE($CHAR(9)_"catch tException { if '$Isobject($Get(tResult)) { set tResult = ##class(%SQL.StatementResult).%New() } set tResult.%SQLCODE=tException.AsSQLCODE(),tResult.%Message=tException.AsSQLMessage() }")
	$$$GENERATE($CHAR(9)_"Quit tResult")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Execute">
<Description>
	Execute is passed parameters for Query
	Returns handle for subsequent operations</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec><![CDATA[&%qHandle:%Binary]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set %code=0
		// don't generate any code if it not for a query
	If %mode="method" Quit $$$OK
		// %mode is "propertymethod" for a valid query. We don't have any way currently to detect a misuse of a query class
	If '$$$comMemberDefined(%class,$$$cCLASSquery,%property) Quit $$$OK
		// Reset the formal list to the query declaration:
	$$$comSubMemberKeyGetLvar(formal,%class,$$$cCLASSquery,%property,$$$cQUERYmethod,%method,$$$cMETHformalspecparsed)
	$$$comMemberKeyGetLvar(qformal,%class,$$$cCLASSquery,%property,$$$cQUERYformalspecparsed)
	$$$comSubMemberKeySet(%class,$$$cCLASSquery,%property,$$$cQUERYmethod,%method,$$$cMETHformalspecparsed,formal_qformal)
	Set sc=$$SetOneQueryMeth^%occQuery(%class,%property,%method) Quit:$$$ISERR(sc) sc
	
	$$$comMemberKeyGetLvar(origin,%class,$$$cCLASSquery,%property,$$$cXXXXorigin)
	$$$comMemberKeyGetLvar(query,%class,$$$cCLASSquery,%property,$$$cQUERYsqlquery)
	// preparse the query to construct the actual argument list
	Set query = $ZSTRIP(query,"<W")
	Set tLines = 0 For tPtr = 1:1:$LENGTH(query,$$$NL) { Set tLine = $PIECE(query,$$$NL,tPtr) If tLine '= "" { Set tLines = tLines + 1, tLines(tLines) = tLine } }
	
	Set sc=$$ExpandMacros^%SYS.DynamicQuery(%class,.tLines) Quit:$$$ISERR(sc) sc
	$$$GENERATE($CHAR(9)_"n %running")

	Do ##class(PXW.LIB.SQL.Generator).GenerateArgsSave(qformal)

	Do ##class(PXW.LIB.SQL.Generator).GenerateTLines(.tLines)
	Do ##class(PXW.LIB.SQL.Generator).GenerateEventStart(%class_"||"_%property)
	$$$GENERATE($CHAR(9)_"set SQLCODE = $$dynamic^%qaqpreparser(.tLines,.tStatementPreparsed,.tStatementArgs)")
	Do ##class(PXW.LIB.SQL.Generator).GenerateArgsReplace()	

	Set tSelectMode = $CASE($$$ucase(%parameter("SELECTMODE")), "RUNTIME": "", "ODBC": 1, "DISPLAY": 2, "LOGICAL": 0, : "")
	$$$GENERATE($CHAR(9)_"try {")
	$$$GENERATE($CHAR(9,9)_"set tSchemaPath = ##class(%SQL.Statement).%ClassPath($classname())")
	$$$GENERATE($CHAR(9,9)_"if ($Isobject($Get(%qHandle(1)))) && (%qHandle(1).%IsA(""%SQL.Statement"")) { set tStatement = %qHandle(1) }")
	$$$GENERATE($CHAR(9,9)_"else {")
	$$$GENERATE($CHAR(9,9,9)_"set tStatement = ##class(%SQL.Statement).%New(" _ tSelectMode _ ",tSchemaPath)")
	$$$GENERATE($CHAR(9,9,9)_"do tStatement.prepare(tStatementPreparsed)")
	$$$GENERATE($CHAR(9,9,9)_"set %qHandle(1) = tStatement")
	
	$$$GENERATE($CHAR(9,9)_"}")
	$$$GENERATE($CHAR(9,9)_"set %qHandle = tStatement.%Execute(tExecuteArr...)") ;" _ $Extract(tExecuteArgs,2,*) _ ")")
	$$$GENERATE($CHAR(9,9)_"If %qHandle.%SQLCODE < 0 { If $isobject($get(%sqlcontext)) { Set %sqlcontext.%SQLCODE = %qHandle.%SQLCODE,%sqlcontext.%Message=%qHandle.%Message set sc = $$$ERROR($$$SQLCode,%qHandle.%SQLCODE,%qHandle.%Message) } } else { set sc = $$$OK }")
	$$$GENERATE($CHAR(9)_"}")
	$$$GENERATE($CHAR(9)_"catch tException { If $isobject($g(%qHandle)),%qHandle.%SQLCODE < 0 { If $isobject($get(%sqlcontext)) { Set %sqlcontext.%SQLCODE = tException.AsSQLCODE(),%sqlcontext.%Message=tException.AsSQLMessage() set sc = $$$ERROR($$$SQLCode,%qHandle.%SQLCODE,%qHandle.%Message) } } else { s sc=tException.AsSQLMessage()} }")
	$$$GENERATE($CHAR(9)_"Quit sc")
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Close">
<Description>
	Close the query associated with the handle</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>%qHandle:%Binary</FormalSpec>
<PlaceAfter>Execute</PlaceAfter>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set %code=0
	 	#; don't generate any code if it not for a query
	If %mode="method" Quit $$$OK
	 	#; Close cursor

	Do ##class(PXW.LIB.SQL.Generator).GenerateEventFinish()
	$$$GENERATE($CHAR(9)_"set %qHandle = """"")
	$$$GENERATE($CHAR(9)_"quit $$$OK")
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[/* direct from SQLQuery */
]]></Content>
</UDLText>

<Method name="Fetch">
<Description><![CDATA[
Fetch the next row of data from the query.
<p><var>qHandle</var> is query-defined data and is typically updated by <b>Fetch</b>.
<p>The <b>Fetch</b> method should set <var>Row</var> to be a $List of 
values corresponding to the columns of the query.  If we are past the end of the data
and no row is returned, <var>Row</var> should be set to null string ("").
If the non-empty row being returned is the last one, <var>AtEnd</var> could be
optionally set to 1, indicating that an additional call to <b>Fetch</b> may be avoided.
<p>
<var>Row</var> may also be subscripted. If any of the columns in the row are stream orefs
then the oref type information is lost in the <var>Row</var> $list encoded value. To retain
the oref type, place the oref into <var>Row(columnNumber)</var>. %Library.ResultSet recognizes
this form and will extract the column value as the subscripted value. ]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec><![CDATA[&%qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>Execute</PlaceAfter>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set %code=0
		#; don't generate any code if it not for a query
	If %mode="method" Quit $$$OK

	$$$GENERATE($CHAR(9)_"if %qHandle.%Next(.sc) { Set Row="""" For colPtr=1:1:%qHandle.%ResultColumnCount { Set Row=Row_$listbuild(%qHandle.%GetData(colPtr)) } } Else { Set Row="""",AtEnd=1 If $isobject($get(%sqlcontext)) { Set %sqlcontext.%SQLCODE = %qHandle.%SQLCODE, %sqlcontext.%Message = %qHandle.%Message i $$$ISOK(sc) { s %sqlcontext.%ROWCOUNT = %qHandle.%ROWCOUNT } else { s %sqlcontext.%Message=%qHandle.%Message } } }")
	$$$GENERATE($CHAR(9)_"QUIT sc")
	Set fcode=0
	Set fcode=fcode+1,fcode(fcode)="	Set RowSet="""",ReturnCount=0,AtEnd=0,columnCount=%qHandle.%ResultColumnCount,tStatus = $$$OK"
	Set fcode=fcode+1,fcode(fcode)="	Do {"
	Set fcode=fcode+1,fcode(fcode)="		Set next = %qHandle.%Next(.tStatus)"
	Set fcode=fcode+1,fcode(fcode)="		If next { Set ReturnCount = ReturnCount+1 For colPtr=1:1:columnCount { Set RowSet=RowSet_$listbuild(%qHandle.%GetData(colPtr)) } } Else { Set AtEnd=1 If $isobject($g(%sqlcontext)) { Set %sqlcontext.%SQLCODE = %qHandle.%SQLCODE, %sqlcontext.%Message = %qHandle.%Message If $$$ISOK(tStatus) { Set %sqlcontext.RowCount=%qHandle.%ROWCOUNT } Else { Set %sqlcontext.%Message=%qHandle.%Message } } }"
	Set fcode=fcode+1,fcode(fcode)="	} While (next) && (ReturnCount'=FetchCount) && (($length(RowSet)+($length(RowSet)\ReturnCount))'>24000)"
	Set fcode=fcode+1,fcode(fcode)="	Quit tStatus"

	Merge $$$tEXTcode(%property_"FetchRows")=fcode
	;zw %method
 	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FetchRows">
<Description>
	FetchRows returns the next FetchCount rows in the query
	Updates handle for subsequent operations
	Returns $list for row or  "" if no more rows</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec><![CDATA[&%qHandle:%Binary,FetchCount:%Integer=0,&RowSet:%List,&ReturnCount:%Integer,&AtEnd:%Integer]]></FormalSpec>
<GenerateAfter>Fetch</GenerateAfter>
<PlaceAfter>Execute</PlaceAfter>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
 Set %code=0
 Merge %code=$$$tEXTcode(%property_"FetchRows")
 Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
 GetInfo()
	Reimplementation of %Query.GetInfo for SQL queries. A different call to ^%SYS.DynamicQuery is used to allow for
	an information only compile of the query to construct query information.
*/
]]></Content>
</UDLText>

<Method name="GetInfo">
<Description><![CDATA[
Returns information about the query. It is used by the various <b>ResultSet</b> objects.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec><![CDATA[&colinfo:%List,&parminfo:%List,&idinfo:%List,&%qHandle:%Binary,extoption:%Integer=0,extinfo:%List]]></FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If %mode="method" Quit $$$OK
	$$$GENERATE("	$$$SQLQuerySQLInfoItem("_$$$QuoteName(%class)_","_$$$QuoteName(%property)_",1,""colinfo"")")
	$$$GENERATE("	$$$SQLQuerySQLInfoItem("_$$$QuoteName(%class)_","_$$$QuoteName(%property)_",2,""parminfo"")")
	$$$GENERATE("	$$$SQLQuerySQLInfoItem("_$$$QuoteName(%class)_","_$$$QuoteName(%property)_",3,""idinfo"")")
	$$$GENERATE("	If extoption {")
	$$$GENERATE("		$$$SQLQuerySQLInfoItem("_$$$QuoteName(%class)_","_$$$QuoteName(%property)_",4,""extinfo"")")
	$$$GENERATE("	}")
	$$$GENERATE("	Quit $$$OK")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SendODBC">
<Description>
Fetch and send a series of rows for the ODBC/JDBC server. For internal use only.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec><![CDATA[&%qHandle:%Binary,&array:%String,qacn:%Integer,&%qrc:%Integer,&piece:%Boolean,ColumnCount:%Integer]]></FormalSpec>
<GenerateAfter>FetchODBC,Fetch</GenerateAfter>
<PlaceAfter>Execute</PlaceAfter>
<ProcedureBlock>1</ProcedureBlock>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set %code=0
	If %mode="method" Quit $$$OK
	$$$GENERATE($CHAR(9)_"kill array(qacn) set piece = 0, %qrc = %qHandle.%SendODBC()") 
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetODBCInfo">
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec><![CDATA[&colinfo:%List,&parminfo:%List,&qHandle:%Binary]]></FormalSpec>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set %code=0
		#; don't generate any code if it's not for a query
	If %mode="method" Quit $$$OK
	$$$comClassKeyGetLvar(schema,%class,$$$cCLASSsqlschemaname)
	$$$comMemberKeyGetLvar(proc,%class,$$$cCLASSquery,%property,$$$cQUERYsqlname)
	Set SCHEMAQ = $$quoter^%occClass($$$ucase(schema))
	Set PROCQ = $$quoter^%occClass($$$ucase(proc))
		#; Generate code to check to see if the GetInfo data has already been compiled...
		#; Metadata versions are currently as follows:
		#;   DPV2695 (07/11/2006) - %protocol cleanup - remove all %protocol < 39 code
		#; 		Version 1: %protocol < 15; NO LONGER SUPPORTED!! Old colinfo (in colinfo1) and Old parminfo (parminfo2) (metadata1)
		#; 		Version 2: %protocol < 31, >14; New colinfo (in colinfo) and Old parminfo (parminfo2) (metadata2)
		#; 		Version 3: %protocol < 41, >30; New colinfo (in colinfo) and new parminfo (parminfo) (metadata3)
		#; 		Version 4: %protocol > 40; (current version) New colinfo (in colinfo)+bstr and new parminfo (parminfo) (metadata4)
	$$$GENERATE("	set version = $Select($Get(%protocol,41)>40:4,1:3)")
	$$$GENERATE("	$$$SQLQueryOdbcItem("_SCHEMAQ_","_PROCQ_",4,""metadata"")")
	$$$GENERATE("	Set colcount=$li(metadata,2),cmdlen=colcount*10,parmcount=$li(metadata,3+cmdlen),pmdlen=parmcount*6,parminfo=$li(metadata,cmdlen+3,cmdlen+pmdlen+3)")
	$$$GENERATE("	If version=4 {")
	$$$GENERATE("		Set colinfo=$li(metadata,2,2+cmdlen)")
	$$$GENERATE("	} Else {")
	$$$GENERATE("		Set colinfo=$li(metadata,2,2)")
	$$$GENERATE("		For i=0:1:colcount-1 Set colinfo=colinfo_$list(metadata,3+(i*10),11+(i*10))")
	$$$GENERATE("	}")
	$$$GENERATE("	Quit $$$OK")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Prepare">
<Description><![CDATA[
Prepare the query for execution. For static queries, this method probably just
returns $$$OK. For dynamic queries this method will set up the information
returned by <b>GetInfo</b>. It is used by the various <b>ResultSet</b> objects.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary,statement:%String,containid:%Integer=0,optional:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[$$$OK
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.Analyse">
<Super>PXW.Tools.Page</Super>
<TimeChanged>67125,77563.738483424</TimeChanged>
<TimeCreated>67125,77563.738483424</TimeCreated>

<Parameter name="ToolType">
<Default>Code</Default>
</Parameter>

<Method name="WriteMainBody">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Do ..HREFFrom(.itemtype,.itemk1,.itemk2,.flags)
	If itemk1="",itemk2="" {
		Write "Nothing to search for"
	} Else {
		Do ..WriteAnalysis(itemtype,itemk1,itemk2,flags)
	}
]]></Implementation>
</Method>

<Method name="WriteAnalysis">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemtype:%String,itemk1:%String,itemk2:%String,flags:%String</FormalSpec>
<Implementation><![CDATA[
	Set rs=##class(PXW.Xref.AnalysisQueries).GetFunc(%NS,itemtype,itemk1,itemk2,flags)
	;s newflags=flags
	Write "<table filename='Analysis_"_itemk1_"'>"
	Write "		<thead>",!
	Write "			<tr>",!
	Write "				<th>Item Key1</th>",!
	Write "				<th>Item Key2</th>",!
	Write "				<th>Line Number</th>",!
	Write "				<th>Description</th>",!
	Write "			</tr>",!
	Write "		</thead>",!
	Write "		<tbody>",!
	Write "		",! 
	While rs.%Next() {
		Write "<tr>"
		; WHAT ABOUT XREF ON ROUTINES????
		If rs.ItemType="CLS" {
			Write "<td><a class='CDEFClassName' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.ItemKey1)_"'>"_..EscapeHTML(rs.ItemKey1)_"</a></td>"
			Write "<td><a class='CDEFMember' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.ItemKey1,rs.ItemKey2)_"'>"_..EscapeHTML(rs.ItemKey2)_"</a></td>"
			Write "<td><a class='CDEFMember' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.ItemKey1,rs.ItemKey2,rs.LineNumber)_"'>"_..EscapeHTML(rs.LineNumber)_"</a></td>"
		} Else {
			Write "<td>"_..EscapeHTML(rs.ItemKey1)_"</td>"
			Write "<td>"_..EscapeHTML(rs.ItemKey2)_"</td>"
			Write "<td>"_..EscapeHTML(rs.LineNumber)_"</td>"
		} 
		Write "<td>"_..EscapeHTML(rs.Description)_"</td>"
		Write "</tr>",!
	}
	Write "</tbody></table>"
]]></Implementation>
</Method>

<Method name="WriteNav">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[	Write "<a href='"_##class(PXW.Tools.DEV.XrefBuild).HREFTo()_"'>Build Xref/Analysis</a>"
]]></Implementation>
</Method>

<Method name="HREFFrom">
<Description>
This shoud output some variables, getting the data from %request</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*ItemType:%String,*ItemKey1:%String,*ItemKey2:%String,Flags:%String</FormalSpec>
<Implementation><![CDATA[
	Set ItemType=%request.Get("IT")
	Set ItemKey1=%request.Get("IK1")
	Set ItemKey2=%request.Get("IK2")
	Set Flags=%request.Get("F")
]]></Implementation>
</Method>

<Method name="HREFTo">
<Description>
This should return a string of the href to this page based on the input parameters</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ItemType:%String="",ItemKey1:%String="",ItemKey2:%String="",Flags:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set href=##super()
	Set sep="&"
	If ItemType'="" Set href=href_sep_"IT="_..EscapeURL(ItemType),sep="&"
	If ItemKey1'="" Set href=href_sep_"IK1="_..EscapeURL(ItemKey1),sep="&"
	If ItemKey2'="" Set href=href_sep_"IK2="_..EscapeURL(ItemKey2),sep="&"
	If Flags'="" Set href=href_sep_"F="_..EscapeURL(Flags),sep="&"
	Quit href
]]></Implementation>
</Method>

<Method name="GetTitle">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Do ..HREFFrom(.itemtype,.itemk1,.itemk2)
	Quit "Analysis of "_itemtype_" "_itemk1_":"_itemk2
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.Analysis.COS">
<Super>PXW.Tools.DEV.HTML.output</Super>
<TimeChanged>67125,77563.918971283</TimeChanged>
<TimeCreated>67125,77563.918971283</TimeCreated>

<Property name="This">
<Type>%String</Type>
</Property>

<Property name="ThisMethod">
<Type>%String</Type>
</Property>

<Property name="displaying">
<Type>%String</Type>
</Property>

<Property name="ClassServer">
<Type>PXW.DEV.Dictionary.ClassDefinitionObject</Type>
</Property>

<Method name="begin">
<Implementation><![CDATA[	Set ..displaying=""
]]></Implementation>
</Method>

<Method name="middle">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[	Do ..writeElement(element)
]]></Implementation>
</Method>

<Method name="end">
</Method>

<Method name="writeElement">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
	If element.type="OneClassmember" {
        ; a class memeber element is like this:
        ; Element=OneClassmember PXW.DEV.BNF.Element @1835 
        ; .Element=ClassMethod PXW.DEV.BNF.Element @1893
        ; ..type=keyword:/UdlStatement/ClassDefinition/ClassMemberSection/ClassMemberList/OneClassmember/ClassMethod
        ; .. Method
        ; ..Element=MethodName PXW.DEV.BNF.Element @1910
        ; ...Element=ClassItemIdentifier PXW.DEV.BNF.Element @1946
        Set item=element.partsGetAt(1)
        Set nameE=item.partsGetAt(2)
        If $LISTFIND($LISTBUILD("PropertyName","MethodName","ClassParameterName","IndexName","TriggerName","ForeignkeyName","StorageName","QueryName","XdataName"),nameE.type) {
            Set name=nameE.ToString(0)
            Set ..ThisMethod=name
      	}
		;d ..Reset()
        ;;w "<pre>RESET</pre>"
		;$$$DEBUG("Resetting")
		;;s ..ReturnType=element.ReturnType
        Set ..Analyser=##class(PXW.DEV.BNF.Analyse.COS).%New(..ClassServer)
        Set ..Analyser.This=..This
		Do ..Analyser.middle(element)
        ;zw ..Analyser


		/*m warnings=..Analyser.ElementWarnings
		s akey="" 
		f  {
			s akey=$o(warnings(akey))
			q:akey=""

			s line=warnings(akey)
			; new section
			i ..displaying="" {
				s ..displaying=..This
				d ..output("<br>")
			}
			s html="<span class='CDEFClassName'>"_$ZCONVERT(..This,"O","HTML")_"</span>:"
			s html=html_"<a class='COSObjectMember' href='"_##class(PXW.Tools.DEV.Class).HREFTo(..This,..ThisMethod)_"'>"_$ZCONVERT(..ThisMethod,"O","HTML")_"</a>"
			w !
			d ..output(html)
			d ..output($zconvert(" "_line,"O","HTML"))
		}*/
	} 

	
	For  {
		Set a=element.partsGetNext(.akey)
		Quit:akey=""
		
		If a.%IsA("PXW.DEV.Element") {
			Do ..writeElement(a)
		} Else {
			Do ..writeAtom(a)
		}
	}
]]></Implementation>
</Method>

<Method name="writeAtom">
<Description>
The only method that should actually do any output during the middle processing.
This does not really write code, its just writing the description of the errors/warnings it finds.
In fact should it be working this way at all? </Description>
<FormalSpec>atom:PXW.DEV.Atom</FormalSpec>
<Implementation><![CDATA[
	If $ISOBJECT(..Analyser),$DATA(..Analyser.ElementWarnings(+atom)) {
		Set line=..Analyser.ElementWarnings(+atom)
		; new section
		If ..displaying="" {
			Set ..displaying=..This
			Do ..output("<br>")
		}
        Set html="<span class='CDEFClassName'>"_$ZCONVERT(..This,"O","HTML")_"</span>:"
        Set html=html_"<a class='COSObjectMember' href='"_##class(PXW.Tools.DEV.Class).HREFTo(..This,..ThisMethod)_"'>"_$ZCONVERT(..ThisMethod,"O","HTML")_"</a>"
        Write !
        Do ..output(html)
        Do ..output($ZCONVERT(" "_line,"O","HTML"))
	}
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.ChangeNS">
<Super>PXW.Tools.Page</Super>
<TimeChanged>67125,77563.771242754</TimeChanged>
<TimeCreated>67125,77563.771242754</TimeCreated>

<Method name="WriteHeadForm">
<Description>
Calling page is passed in so you can decide what to display on the form/if anything.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Page:%String</FormalSpec>
<Implementation><![CDATA[
    &html<
					<form id=toolsFormHome action='PXW.Tools.DEV.ChangeNS.cls'>
					<fieldset id=toolsChangeNS>
						<legend>Namespace</legend>
						<input type=hidden name=%NS value='#(%NS)#'>
						<input type=submit value='#(%NS)#'>
					</fieldset>
				</form>
    >
]]></Implementation>
</Method>

<Method name="WriteMainBody">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[

	Set rs=##class(%ResultSet).%New(..%ClassName(1)_":SelectNS")
	$$$THROWONERROR(sc,rs.Execute())

    Write "<table>"
    Write "<thead><tr><th>Name</th><th>Address</th><th>NameSpace</th></thead>"
    Write "<tbody>"
	While rs.Next() {
		Set name=rs.Data("ServerName")
        Set address=rs.Data("ServerAddress")
        Set ns=rs.Data("Namespace")
        Write "<tr>"
        Write "<td><a href='"_..HREFTo(name)_"'>"_..EscapeHTML(name)_$SELECT(name=%NS:"*",1:"")_"</a></td>"
        Write "<td>"_..EscapeHTML(address)_"</td>"
        Write "<td>"_..EscapeHTML(ns)_"</td>"
        Write "</tr>"
	}
    Write "</tbody></table>"
]]></Implementation>
</Method>

<Method name="HREFTo">
<Description>
This should return a string of the href to this page based on the input parameters</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>NewServer:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..%ClassName(1)_".cls?%NS="_..EscapeURL(NewServer)
]]></Implementation>
</Method>

<Query name="SelectNS">
<Type>%SQLQuery</Type>
<SqlQuery>    SELECT ServerName,ServerAddress,NameSpace FROM PXW_DEV_Dictionary.AtelierSettings</SqlQuery>
</Query>
</Class>


<Class name="PXW.Tools.DEV.ChangeStyle">
<Super>PXW.Tools.Page</Super>
<TimeChanged>67125,77563.791041514</TimeChanged>
<TimeCreated>67125,77563.791041514</TimeCreated>

<Method name="WriteMainBody">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	&html<
		<div class=section1>
			<h1>Section (H1) header</h1>
			This DIV is section1.
			<div class=section2> 
				<h2 id="Selection">Selection</h2>
				#(..WriteStyleChangeSelection())#
			</div>
			<div class=section2> 
				<h2 id="ExampleTable">Example table (h2) header</h2>
				#(..WriteExampleTable())#
			</div>
			<!--<div class=section2> 
				<h2 id="ExampleXref">Example X-Ref</h2>
				#(..WriteExampleXref())#
			</div>-->
				<div class=section2 >
					<h2 id="ExampleCode">Example Code</h2>
					#(..WriteExampleCode())#
				</div>
				<div class=section2 >
					<h2 id="VariableHilite">Variable high light colours</h2>
					#(..WriteHilite())#
				</div>
		<!-- /*</div> -->
		</div>

	>
]]></Implementation>
</Method>

<Method name="WriteNav">
<Description>
Output 1 Anchor tag for each option in the navigation. Use the scratch variable for anything you want to get from BODY</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[
	&html<
		<a href="#Selection">Selection</a>
		<a href="#ExampleTable">Example Table</a>
		<a href="#ExampleCode">Example Code</a>
		<!--<a href="#ExampleXref">Example X-Ref</a> -->
		<a href="#VariableHilite">Variable Highlights</a>
		<hr>
		<a href="#">Nav 1 (no style)</a>		
		<a href="#">Nav 2 (no style)</a>
		<a href="#">These are simple links</a>
	>
]]></Implementation>
</Method>

<Method name="WriteHilite">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[

	Write "<table>"
	For i=1:1:9 {
		Write "<tr>"
		Write "<td><span class=hiliteGET"_i_">variable</span></td>"
		Write "<td><span class=hiliteSET"_i_">variable</span></td>"
		Write "</tr>"
	}
	Write "</table>"
	Quit ""
]]></Implementation>
</Method>

<Method name="WriteExampleCode">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	New %NS
	Set %NS="LOCAL_USER"
	Set debug="",bookmark="",hiliteline=""

	; find something to hilite
	Set itemtype="CLS"
	Set itemk1=##class(PXW.Tools.DEV.ExampleClass).%ClassName(1)
	Set itemk2="ThingType"
	Set calledByCommand="SelectCommand"
	Set (calledByKey1,windowSize,flags)=""
	Set rs=##class(PXW.Xref.Queries).GetFunc(%NS,itemtype,itemk1,itemk2,calledByCommand,calledByKey1,windowSize,flags)
	While rs.%Next() {
		If rs.CalledByKey1=itemk1, rs.CalledByKey2="WriteStuff",hiliteline="" {
			Set hiliteline=rs.LineNumber
			Set bookmark=rs.CalledByKey2
		}
	}
	Do ##class(PXW.Tools.DEV.Class).WriteClass(##class(PXW.Tools.DEV.ExampleClass).%ClassName(1),debug,bookmark,hiliteline,.nav)
	Quit ""
]]></Implementation>
</Method>

<Method name="WriteExampleXref">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	New %NS
	Set %NS="LOCAL_USER"
	Set itemtype="CLS"
	Set itemk1=##class(PXW.Tools.DEV.ExampleClass).%ClassName(1)
	Set itemk2="ThingType"
	Set (calledByCommand,calledByKey1,calledByKey2,windowSize,flags)=""
	Do ##class(PXW.Tools.DEV.Xref).WriteXRef(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize,flags)
	Quit ""
]]></Implementation>
</Method>

<Method name="WriteExampleTable">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	&HTML<
		<table>
			<thead>
				<tr>
					<th>Number column</th>
					<th>Text column <a href="#">link</a></th>
					<th><a href="#">Link column</a></th>
					<th>Comment column</th>
					<th>Sub table</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>1</td>
					<td>Text data</td>
					<td><a href="#">Link data</a></td>
					<td><span class=comment>Comment in a span</span></td>
					<td>
						<table>
							<thead>
								<tr>
									<th>Sub head</th>
									<th>Sub column2</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Sub data</td>
									<td>sub data2</td>
								</tr>
								<tr>
									<td>more data</td>
									<td>more data</td>
								</tr>
								<tr>
									<td>more data</td>
									<td>more data</td>
								</tr>
							</tbody>
						</table>
					</td>
				</tr>
				<tr>
					<td>2</td>
					<td>Longer text data</td>
					<td><a href="#">Link data</a></td>
					<td><div class=comment>Comment in a div</span></td>
					<td>
						<table>
							<thead>
								<tr>
									<th>Sub head</th>
									<th>Sub column2</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Sub data</td>
									<td>sub data2</td>
								</tr>
								<tr>
									<td>more data</td>
									<td>more data</td>
								</tr>
								<tr>
									<td>more data</td>
									<td>more data</td>
								</tr>
							</tbody>
						</table>
					</td>
				</tr>
				<tr class=hiliterow>
					<td>3</td>
					<td>This row is higlighted by putting tr class=hiliterow</td>
					<td><a href="#">Link data</a></td>
					<td><div class=comment>Comment in a div</span></td>
					<td>
						<table>
							<thead>
								<tr>
									<th>Sub head</th>
									<th>Sub column2</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>xxx xxxxxxxx</td>
									<td>xxxxxx xxx x</td>
								</td>
								<tr>
									<td>yyyy y yyyyy</td>
									<td>yyy yyyyyyy</td>
								</tr>
							</tbody>
						</table>
					</td>
				</tr>
				<tr class=warningrow>
					<td>4</td>
					<td>This row is higlighted by putting tr class=warningrow</td>
					<td><a href="#">Link data</a></td>
					<td><div class=comment>Comment about why the row has a warning</span></td>
					<td>
					<!--	<table>
							<thead>
								<tr>
									<th>Sub head</th>
									<th>Sub column2</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Sub data</td>
									<td>sub data2</td>
								</tr>
							</tbody>
						</table>
						-->
					</td>
				<tr class=errorrow>
					<td>5</td>
					<td>This row is higlighted by putting tr class=errorrow</td>
					<td><a href="#">Link data</a></td>
					<td><div class=comment>Comment about why the row is in error</span></td>
					<td>
					</td>
				</tr>
				<tr class=goodrow>
					<td>6</td>
					<td>This row is higlighted by putting tr class=goodrow</td>
					<td><a href="#">Link data</a></td>
					<td><div class=comment>Comment about why the row is good</span></td>
					<td>
					</td>
				</tr>
				<tr >
					<td>7</td>
					<td class=CDEFClassName>ClassName</td>
					<td class=CDEFClassName><a class=CDEFClassName href="#">LinkClassName</a></td>
					<td><div class=comment>These cells have class=CDEFClassName</span></td>
					<td>
					</td>
				</tr>
				<tr >
					<td>8</td>
					<td class=CDEFClassName>ClassName</td>
					<td class=CDEFClassName><a class=CDEFClassName href="#">LinkClassName</a></td>
					<td><div class=comment>These cells have class=CDEFClassName</span></td>
					<td>
					</td>
				</tr>
				<tr>
					<td>9</td>
					<td class=CDEFMember>MethodName</td>
					<td class=CDEFMember><a class=CDEFMember href="#">LinkMethodName</a></td>
					<td><div class=comment>These cells have class=CDEFMember</span></td>
					<td>
					</td>
				</tr>
				<tr>
					<td>10</td>
					<td class=CDEFMember>MethodName</td>
					<td class=CDEFMember><a class=CDEFMember href="#">LinkMethodName</a></td>
					<td><div class=comment>These cells have class=CDEFMember</span></td>
					<td>
					</td>
				</tr>
				<tr>
					<td>11</td>
					<td class=gooddata>good data</td>
					<td class=gooddata><a href="#">LinkMethodName</a></td>
					<td><div class=comment>These cells have class=gooddata</span></td>
					<td>
					</td>
				</tr>
				<tr>
					<td>12</td>
					<td class=warningdata>warning data</td>
					<td class=warningdata><a href="#">LinkMethodName</a></td>
					<td><div class=comment>These cells have class=warningdata</span></td>
					<td>
					</td>
				</tr>
				<tr>
					<td>13</td>
					<td class=errordata>error data</td>
					<td class=errordata><a href="#">LinkMethodName</a></td>
					<td><div class=comment>These cells have class=errordata</span></td>
					<td>
					</td>
				</tr>
				<tr>
					<td>14</td>
					<td class=hilitedata>hilite data</td>
					<td class=hilitedata><a href="#">LinkMethodName</a></td>
					<td><div class=comment>These cells have class=hilitedata</span></td>
					<td>
					</td>
				</tr>
			</tbody>
		</table>
	>
	Quit ""
]]></Implementation>
</Method>

<Method name="WriteStyleChangeSelection">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set rs=##class(%ResultSet).%New("%Library.ClassDefinition:SubclassOf")
    $$$THROWONERROR(sc,rs.Execute(##class(PXW.Tools.Styles.super).%ClassName(1)))
	Set current=$SELECT($ISOBJECT($GET(%STYLE)):%STYLE.%ClassName(1),1:"")
	Write "<table>"
	Write "<thead>"
	Write "<tr><th>Name</th></tr>"
	Write "</thead>"
	Write "<tbody>"
	While rs.Next() {
		Set name=rs.Data("Name")
		Set class=""
		If name=current Set class="hiliterow"
		Write "<tr class='"_class_"'>"
		Write "<td><a href='"_..HREFTo(name)_"'>"_name_$SELECT(name=current:"*",1:"")_"</a></td>"
        Write "</tr>"
	}
	Write "</tbody>"
	Write "</table>"
	Quit ""
]]></Implementation>
</Method>

<Method name="HREFTo">
<ClassMethod>1</ClassMethod>
<FormalSpec>NewStyle:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    If NewStyle["PXW.Tools.Styles" Set NewStyle=$PIECE(NewStyle,"PXW.Tools.Styles.",2)
    Quit ##super()_"&%STYLE="_..EscapeURL(NewStyle)
]]></Implementation>
</Method>

<Method name="WriteScripts">
<Description>
Write out extra javascript here, the SCRIPT tags are already in place</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Do ##class(PXW.Tools.DEV.Class).WriteScripts()
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.Class">
<Super>PXW.Tools.DEV.CodeDisplayPage</Super>
<TimeChanged>67128,68264.042224566</TimeChanged>
<TimeCreated>67125,77563.79382254</TimeCreated>

<Parameter name="CodeType">
<Default>CLS</Default>
</Parameter>

<Method name="WriteMainBody">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[
	Do ..HREFFrom(.cls,.path,.instance,.linenumber,.debug,.PropertyParameter)
	If cls["*" Do ..WriteClassDir(cls) Quit

	Set ocls=..GetClassToLoad(cls,path,.bookmark,,.PropertyParameter)
	If ocls'=cls {
		Write "<p>Redirected from "_..EscapeHTML(cls)_"</p>"
	} 
	;zw ocls,debug,bookmark,linenumber
	Do ..WriteClass(ocls,debug,bookmark,linenumber,.scratch) 
	Quit
]]></Implementation>
</Method>

<Method name="GetClassToLoad">
<Description>
/
If this class does not have the definition of what we are looking at then this returns the name of the class it might be inherited from, otherwise it returns null</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>cls:%String,path:%String,*bookmark:%String,*method:%String,PropertyParameter:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set ClassServer=##class(PXW.DEV.Dictionary.ClassDefinitionObject).OpenNamespace(%NS)
	; table name?
	Set method=""
	If PropertyParameter'="" {
		If ClassServer.GetPropertyParameterDetails(cls,path,PropertyParameter,.ocls) {
			Set method=PropertyParameter
			Set bookmark=method
		}
	} ElseIf cls["_" {
		If path'="" {
			Do ClassServer.GetClassPathFromTable(cls,path,.array)
			Set ocls=$LISTGET(array(array),1),bookmark=$LISTGET(array(array),2)
			If ocls="" Set ocls=cls
		} Else {
			Set ocls=ClassServer.GetClassNameFromTableName(cls)
			If ocls'="" {
				Set bookmark=$PIECE(path,"->",*)
			}
			If ocls="" {
				Set ocls=ClassServer.GetClassNameFromStoredProc(cls,.method)
				If ocls'="" {
					Set bookmark=method
				}
			}
		}
	} Else {
		; remove unwanted gaps at the start
		While $EXTRACT(path,1)="." { Set path=$EXTRACT(path,2,*) }
		If path'="" {
			Do ClassServer.GetClassPath(cls,path,.array)
			Set ocls=$LISTGET(array(array),1),(bookmark,method)=$LISTGET(array(array),2)
			If ocls="" Set ocls=cls
		} Else {
			Set ocls=cls
			Set (bookmark,method)=$PIECE(path,".",*)
		}
		Set bookmark=$TRANSLATE(bookmark,"#","") ; remove # from parameter
	}
	
	; work out if its in a superclass              
	If method'="" {
		If ClassServer.GetMethodDetails(ocls,method,,.origin,.stub) {
			If stub'="" {
				If $PIECE(stub,".",*)="q" {
					; method belongs to a query
					Set (bookmark,method)=$PIECE(stub,".",1)
				} ElseIf $PIECE(stub,".",*)="a" {
					; method belongs to a property
					Set (bookmark,method)=$PIECE(stub,".",1)
				} ElseIf $PIECE(stub,".",*)="i" {
					; method belongs to an index
					Set (bookmark,method)=$PIECE(stub,".",1)
				}
			} 
			If origin'="" {
				Set ocls=origin
			}
		} ElseIf ClassServer.GetPropertyDetails(ocls,method,,,,.origin) {
			Set ocls=origin
		} ElseIf $EXTRACT(method,1)="#",ClassServer.GetParameterDetails(ocls,$EXTRACT(method,2,*),,.origin) {
			Set ocls=origin
		}
	}
	Quit ocls
]]></Implementation>
</Method>

<Method name="WriteClass">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[ClassName:%String,Debug:%String,bookMark:%String="",hiliteLineNo:%Integer,&scratch]]></FormalSpec>
<Implementation><![CDATA[
	New %path
	Kill %pxw1
	#dim ele,element as PXW.DEV.Element
	Set zh=$ZHOROLOG
    Set output=##class(PXW.Tools.DEV.HTML.bnf).%New()
	Set output.ClassServer=##class(PXW.DEV.Dictionary.ClassDefinitionObject).OpenNamespace(%NS)

	Set showPaths=0
    Write "<pre>"
	If +Debug=1 $$$DEBUGNew(##class(PXW.Tools.Debugger).%ClassName(1))
	;If Debug["$TIME" $$$DEBUGNew(##class(PXW.Debuggers.Timing).%ClassName(1))
	If Debug["$FILE" $$$DEBUGNew(##class(PXW.Debuggers.BasicToFile).%ClassName(1)) 
	If Debug["$PATHS" Set showPaths=1,%path="" ; no need to set any output its just for tooltips
	
	Set sc=output.ClassServer.GetClassStudioText(ClassName,.text,.linesOfCode,.timestamp)
	Set zh(1,"load")=$ZHOROLOG-zh,zh=$ZHOROLOG

	If $$$ISOK(sc) {
		If Debug'="" {
			; display the original text from the server
			Write "<pre>"
			;w text
			Set ln=""
			For  {
				Set ln=$ORDER(linesOfCode(ln))
				Quit:ln=""
				Write !,"<span class=nocopy>"_ln_":"_"</span>"_..EscapeHTML(linesOfCode(ln))
			}
			Write "</pre>"
		}
		Set zh(2,"display")=$ZHOROLOG-zh,zh=$ZHOROLOG

        Set element=##class(PXW.DEV.Element).%New()
		If Debug["$NEW" {
			Write "running in new mode"
        	;s x=##class(PXW.DEV.BNF.Run.ClassDefinitionAuto).%New()
		} Else {
			Set x=##class(PXW.DEV.BNF.Run.ClassDefinition).%New()
		}
        Set x.stream=##class(PXW.DEV.InputStream).NewString(text)
		Set zh=$ZHOROLOG

		Set output.This=ClassName
		Set output.HiLiteLine=hiliteLineNo
		Set output.BookMark=bookMark
		Set output.showPaths=showPaths
        Do output.begin()
		Set scratch=output
		Set zh(4,"render")=$ZHOROLOG-zh,zh=$ZHOROLOG

		Set element=##class(PXW.DEV.Element).%New()
		While x.cheese(element) {
			;d element.write("")
			Do output.middle(element)
			;zw output.Analyser
			Set element=##class(PXW.DEV.Element).%New()
		}
		Do output.end()

		Set zh(5,"render end")=$ZHOROLOG-zh,zh=$ZHOROLOG

		;Set xref=##class(PXW.Xref.Build).%New()
		;zw ClassName,timestamp
		;Do xref.xrefClassIfNecessary(%NS,ClassName,timestamp,0,text)
		do ##class(PXW.Xref.Build).Build(%NS,"CLS",ClassName)

		Set zh(6,"xref")=$ZHOROLOG-zh,zh=$ZHOROLOG
		Kill element,x,output

	} Else {
		Do ..WriteStatus(sc)
		Set xref=##class(PXW.Xref.Build).%New()
		Do xref.xrefClassIfNecessary(ClassName,"",0)

	}
	If Debug["$TIME" {
		
		Set s="" For  Set s=$ORDER(%pxwstrings(s),1,n) Quit:s=""  Set %pxwstringsX(n,s)=""
		Write "<pre>" ZWrite %pxwstrings,%pxwstringsX,%pxw1,%RBCOUNT Write "</pre>"
		Set totaltime=0,totalcalls=0
		Set rs=##clasS(%Library.ResultSet).%New("PXW.Debuggers.Timing:SelectResults")
		$$$THROWONERROR(sc,rs.%Execute())
		&html<<table filename="Timings.csv">
			<tr><th>ClassName</th><th>MethodName</th><th>TotalTime</th><th>CountOfCalls</th><th>AverageTime</th><th>PercentageOfTime</th></tr>>
		While rs.%Next() {
			Set time=rs.Get("TotalTime"),totaltime=totaltime+time
			Set calls=rs.Get("CountOfCalls"),totalcalls=totalcalls+calls
			Write "<tr>"
			Write "<td>"_..EscapeHTML(rs.Get("ClassName"))_"</td>"
			Write "<td>"_"<a href='"_..HREFTo(rs.Get("ClassName"),rs.Get("MethodName"))_"'>"_..EscapeHTML(rs.Get("MethodName"))_"</a>"_"</td>"
			Write "<td style='text-align:right;'>"_$JUSTIFY(time,0,6)_"</td>"
			Write "<td style='text-align:right;'>"_calls_"</td>"
			Write "<td style='text-align:right;'>"_$JUSTIFY(rs.Get("AverageTime"),0,6)_"</td>"
			Write "<td style='text-align:right;'>"_$JUSTIFY(rs.Get("PercentageOfTime"),0,6)_"</td>"
			Write "</tr>",!
		}
		Write "<tr>"
		Write "<td>Total"_"</td>"
		Write "<td>"_"</td>"
		Write "<td style='text-align:right;'>"_$JUSTIFY(totaltime,0,6)_"</td>"
		Write "<td style='text-align:right;'>"_totalcalls_"</td>"
		Write "<td style='text-align:right;'>"_""_"</td>"
		Write "<td style='text-align:right;'>"_""_"</td>"
		Write "</tr>",!
		&html<</table>>
	} Else {
		;w "<pre>" zw %pxwstrings,%pxwstringsX,%pxw1 
		;w !,"$s="_$s
		;w "</pre>"
		
	}
	If Debug="$FILE" {
		ZWrite %pxwdebug
	}
	;d %session.EndSession()
	;zw zh
    Write "</pre>"
]]></Implementation>
</Method>

<Method name="WriteNav">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[
	
	If $ISOBJECT($GET(scratch)) {
		Set output=scratch
		While output.NextIndexItemByName(.name,.type,.anchor,.error) {
				;w "<tr>"
				;w "<td>"
				If error="" {
					;w "<span class=toolsMainBodyNavItem>"
					Write "<a onclick='HiliteElement("""_anchor_"SPAN"");' class='"_"CDEF"_type_"' href=#"_anchor_">"_..EscapeHTML(name)_"</a>"
					;w "</span>"
				} Else {
					;w "<span class=toolsMainBodyNavItem>"
					Write "<a onclick='HiliteElement("""_anchor_"SPAN"");' class='"_output.#WarningClass_"' href=#"_anchor_">"_..EscapeHTML(name)_"</a>"
					;w "</span>"
				}
				;w "</td>"
				;w "<td>"_..EscapeHTML(type)_"</td>"
				;w "<td>"_..EscapeHTML(anchor)_"</td>"
				;w "</tr>",!
		}
		Write "<hr>"
	}
    Write "<a href=# onclick='MakeStringsInteresting(); '>Strings</a>"
]]></Implementation>
</Method>

<Method name="methodAName">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit "method"_Name
]]></Implementation>
</Method>

<Method name="propertyAName">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit "property"_Name
]]></Implementation>
</Method>

<Method name="HREFFrom">
<ClassMethod>1</ClassMethod>
<FormalSpec>*Class:%String,*Path:%String,*InstanceClass:%String,*LineNumber:%Integer,*Debug:%String,*PropertyParameter:%String</FormalSpec>
<Implementation><![CDATA[
	#define ReqGet(%name) %request.Get(%name)
	Set Class=$$$ReqGet("C")
	Set Path=$$$ReqGet("P")
	Set InstanceClass=$$$ReqGet("I")
	Set LineNumber=$$$ReqGet("LN")
	Set Debug=$$$ReqGet("DEBUG")
	Set PropertyParameter=$$$ReqGet("PP")
]]></Implementation>
</Method>

<Method name="HREFTo">
<Description>
Class=name of base class to display
Path=name of properties/methods to follow (eg .race.circuit.name)
Caller class is the class that is being displayed (not the class of my code doing the call)
PropertyParameter is the name of the parameter from the property definition (eg property x as %String(XMLNAME=xxx); - "XMLNAME" will be in PP)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Class:%String,Path:%String="",LineNumber:%Integer="",NameSpace:%String="",CallerClass:%String="",PropertyParameter:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If NameSpace'="",$DATA(%NS) Set ons=%NS
	Set href=##super()
	If $DATA(ons) Set %NS=ons
	Set sep="&"
	
	Set cls=Class,instance=""

	Set package=""
	If CallerClass'="" Set package=$PIECE(CallerClass,".",1,*-1)

	Set cls=##class(PXW.DEV.Dictionary.ClassDefinitionObject).FullClassName(cls,package)

	/*
	; method is provided so try to go to the actual origin of it
	i $$$UPPER(Type)="METHOD" {
		s mdef=##class(%Dictionary.CompiledMethod).%OpenId(cls_"||"_Name)
		i $isobject(mdef) {
			i mdef.Origin'=cls {
				s cls=mdef.Origin,instance=Class
			}
		}
	}
	; go to origin of property
	i $$$UPPER(Type)="PROPERTY" {
		s pdef=##class(%Dictionary.CompiledProperty).%OpenId(cls_"||"_Name)
		i $isobject(pdef) {
			i pdef.Origin'=cls {
				s cls=pdef.Origin,instance=Class
			}
		}
	}
	*/
	
	Set href=href_sep_"C="_..EscapeURL(cls),sep="&"
	If instance'="" Set href=href_sep_"I="_..EscapeURL(instance),sep="&"
	If LineNumber'="" Set href=href_sep_"LN="_..EscapeURL(LineNumber),sep="&"
	If PropertyParameter'="" Set href=href_sep_"PP="_..EscapeURL(PropertyParameter),sep="&"
	Set href=href_sep_"P="_..EscapeURL(Path),sep="&"

	; if it looks like a stored proc then make it put the bookmark in
	; zw Class
	;i Class["_",Class_".",Path="" s Path=1 

	; must go last
	;i Path'="" s href=href_"#bookmark"
	; always put the bookmark on, because the link to stored procedures is not working correctly yet
	Set href=href_"#bookmark"
	; do not add anything here
	Quit href
]]></Implementation>
</Method>

<Method name="GetTitle">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Do ..HREFFrom(.class,.name,,,,.pp)

	Set class=..GetClassToLoad(class,name,,.method,pp)
	;i $$$UPPER(type)="METHOD" {
	;	q class_":"_name_"()"
	;}
	;i $$$UPPER(type)="PROPERTY" {
	;	q class_":"_name_""
	;}
	If method'="" {
		Quit class_":"_method_""
	} Else {
		Quit class
	}
]]></Implementation>
</Method>

<Method name="WriteClassDir">
<ClassMethod>1</ClassMethod>
<FormalSpec>Class:%String</FormalSpec>
<Implementation><![CDATA[
	ZWrite %NS,Class
	Set ClassServer=##class(PXW.DEV.Dictionary.ClassDefinitionObject).%OpenId(%NS)
	Set rs=ClassServer.ListClassDetailsWild(Class,1)

	Write "<table>"
	Write "<thead>"
	Write "<tr><th>Type</th><th>Name</th><th>Modified</th></tr>"
	Write "</thead><tbody>"
	While rs.%Next() {
		Write "<tr>"
		Write "<td>"_..EscapeHTML(rs.%Get("ClassType"))_"</td>"
		Write "<td>"
			Write "<a class='CDEFClassName' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.%Get("Name"))_"'>"
			Write ..EscapeHTML(rs.%Get("Name")) 
			Write "</a>"
		Write "</td>"
		Write "<td>"_..EscapeHTML(rs.%Get("TimeChanged"))_"</td>"
		Write "</tr>",!
	}
	Write "</tbody></table>"
]]></Implementation>
</Method>

<Method name="WriteScripts">
<Description>
Write out extra javascript here, the SCRIPT tags are already in place</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Write "function edit(clsname) {"
	Write " 	var editor=window.frames['editor'];",!
	Write "		debugger; ",!
	Write "		if (!editor) {",!
	Write "			editor=window.open('/cloudstudio/CloudStudio.PXW.cls?C='+clsname+'.cls','editor');",!
	Write "		}",!
	Write "",!
	Write "",!
	Write "",!
	Write "",!
	Write "",!
	Write "}",!

	Write "var hiliterun=1;"
	Write "function HiliteSets(id) {",!
	Write "    var objs=document.getElementsByTagName('span');",!
	Write "    var cls='hiliteSET'+hiliterun;",!
	Write "    var clsf='hiliteGET'+hiliterun;",!
	Write "    for (var i=0; i<objs.length; i++) {",!
	Write "      if (objs[i].getAttribute('varid')==id) objs[i].className=cls; //",! ;objs[i].className+' '+cls;",!
	Write "      if (objs[i].getAttribute('fetchid')==id) objs[i].className=clsf; //",! ;objs[i].className+' '+cls;",!
	Write "    }",!
	Write "    hiliterun=hiliterun+1; if (hiliterun>9) hiliterun=1;",!
	Write "}",!


	Write "function HiliteElement(id) {",!
	Write "    var obj=document.getElementById(id);",!
	Write "    obj.className='hilite';",!
	Write "}",!


	Write "function MakeStringsInteresting(id) {",!
	Write "    var objs=document.getElementsByTagName('span');",!
	Write "    var clsOFF='unInteresting'",!
	Write "    var clsHALF='quiteInteresting'",!
	Write "    var clsON='veryInteresting'",!
	Write "    for (var i=0; i<objs.length; i++) {",!
	Write "      if (objs[i].className=='EmbeddedCOS') {",!
	Write "          objs[i].className=objs[i].className+' '+clsOFF; //",! ;objs[i].className+' '+cls;",!
	Write "      }",!
	Write "      if (objs[i].className=='EmbeddedPython') {",!
	Write "          objs[i].className=objs[i].className+' '+clsOFF; //",! ;objs[i].className+' '+cls;",!
	Write "      }",!
	Write "      if (objs[i].className=='COSString') {",!
	Write "          objs[i].className=objs[i].className+' '+clsON; //",! ;objs[i].className+' '+cls;",!
	Write "      }",!
	Write "      if (objs[i].className=='whitespace') {",!
	Write "          objs[i].className=objs[i].className+' '+clsHALF; //",! ;objs[i].className+' '+cls;",!
	Write "      }",!
	Write "    }",!
	Write "}",!


 /*
	write "function showUndefs() {",!
	write "		for (var s=0; s<document.styleSheets.length; s++) {",!
	write "			var ss=document.styleSheets[s];",!
	write "			var rules;",!
	write "			if (ss.rules) rules=ss.rules;",!
	write "			if (ss.cssRules) rules=ss.cssRules;",!
	write "			for (var r=0; r<rules.length; r++) {",!
	write "				var rule=rules[r];",!
	write "				if (rule.selectorText) {",!
	write "					if (rule.selectorText=='.unset') rule.style.backgroundColor='darkcyan';",!
	write "				}",!
	write "			}",!
	write "		}",!
	write "	}",!

	write "function showTypos() {",!
	write "		for (var s=0; s<document.styleSheets.length; s++) {",!
	write "			var ss=document.styleSheets[s];",!
	write "			var rules;",!
	write "			if (ss.rules) rules=ss.rules;",!
	write "			if (ss.cssRules) rules=ss.cssRules;",!
	write "			for (var r=0; r<rules.length; r++) {",!
	write "				var rule=rules[r];",!
	write "				if (rule.selectorText) {",!
	write "					if (rule.selectorText.indexOf('.typo')>-1) rule.style.backgroundColor='#F0E0C0';",!
	write "				}",!
	write "			}",!
	write "		}",!
	write "	}",!

	write "function showSubscripts() {",!
	write "		for (var s=0; s<document.styleSheets.length; s++) {",!
	write "			var ss=document.styleSheets[s];",!
	write "			var rules;",!
	write "			if (ss.rules) rules=ss.rules;",!
	write "			if (ss.cssRules) rules=ss.cssRules;",!
	write "			for (var r=0; r<rules.length; r++) {",!
	write "				var rule=rules[r];",!
	write "				if (rule.selectorText) {",!
	write "					if (rule.selectorText=='.subscript') rule.style.backgroundColor='pink';",!
	write "				}",!
	write "			}",!
	write "		}",!
	write "	}",!

	&js<
	function AutoIndent() {
		var objs=document.getElementsByTagName('span');
	    for (var i=0; i!=objs.length; i++) {
		    var indent=objs[i].getAttribute('indent');
		    if ((indent!='')&&(indent!=null)) {
			    var str="";
			    for (var j=0; j!=parseInt(indent); j++) str=str+"&nbsp;&nbsp;&nbsp;&nbsp;";
			    objs[i].innerHTML=str;
		    }
	    }
	}
	>
	*/
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.Code">
<Description>
Redirects to the correct viewer based on the type of code to be viewed</Description>
<Super>PXW.Tools.Page</Super>
<TimeChanged>67125,79627.461343911</TimeChanged>
<TimeCreated>67125,77563.792598539</TimeCreated>

<Method name="WriteMainBody">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[

    Do ..HREFFrom(.CodeReference,.utype,.name)

    ; no type so do lookup
    If utype="" {
        Do ..WriteCodeList(utype,name)
    } Else {
        ; name is not known
        If name["*" {
            Do ..WriteCodeList(utype,name)
        } Else {
            ;Do ..WriteCode(utype,name)
            w "No direct link yet"
        }
    }
]]></Implementation>
</Method>

<Method name="WriteCodeList">
<ClassMethod>1</ClassMethod>
<FormalSpec>Type:%String,Name:%String</FormalSpec>
<Implementation><![CDATA[
    Write "<table>"
    Write "<thead>"
    Write "<tr><th>Type</th><th>SubType</th><th>Name</th><th>Modified</th></tr>"
    Write "</thead><tbody>"
    

    Set rs=##class(%Library.ResultSet).%New(..%ClassName(1)_":"_"SelectTypes")
    Set sc=rs.Execute(%NS,Type)
    While rs.%Next() {
        set typ=rs.%Get("Type")
        set page=rs.%Get("Page")
        Set interface=##class(PXW.DEV.Dictionary.CodeInterface).%OpenId(rs.%Get("ID"))
        Set rs2=interface.List(Name)
        While rs2.%Next() {
            Write "<tr>"
            Write "<td>"_..EscapeHTML(typ)_"</td>"
            Write "<td>"_..EscapeHTML(rs2.%Get("SubType"))_"</td>"
            Write "<td>"
            if page="" {
                Write "<span title='CodeType ("_typ_") has no display page defined'>"
                Write ..EscapeHTML(rs2.%Get("Name")) 
                write "</span>"
                
            } else {
                Write "<a class='CDEFClassName' href='"_$CLASSMETHOD(page,"HREFToNameOnly",rs2.%Get("Name"))_"'>"
                Write ..EscapeHTML(rs2.%Get("Name")) 
                Write "</a>"
            }
            Write "</td>"
            Write "<td>"_..EscapeHTML(rs2.%Get("TimeChanged"))_"</td>"
            Write "</tr>",!
        }
	}
    
	Write "</tbody></table>"
]]></Implementation>
</Method>

<Method name="WriteNav">
<Description>
Output 1 Anchor tag for each option in the navigation. Use the scratch variable for anything you want to get from BODY</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[
   Do ..HREFFrom(.CodeReference)
    Set type=$PIECE(CodeReference,".",*)
    Set utype=$$$UPPER(type)

    If ##class(PXW.DEV.Dictionary.CodeType).%ExistsId(utype) {
        Set name=$PIECE(CodeReference,".",1,*-1)
    } Else {
        Set name=CodeReference
        Set utype=""
    }
    Set rs=##class(%Library.ResultSet).%New(..%ClassName(1)_":"_"SelectTypes")
    Set sc=rs.Execute(%NS,"")
    While rs.%Next() {
        Set cref=name_"."_rs.%Get("Type")
        Write "<a href='"_..HREFTo(cref)_"'>"_..EscapeHTML(cref)_"</a>"
    }
]]></Implementation>
</Method>

<Query name="SelectTypes">
<Type>PXW.LIB.SQL.Query</Type>
<FormalSpec>Namespace:%String,Type:%String</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>    SELECT ci.ID
        , ci.Namespace
        , ci.Type
        , cti.Class as Page
      FROM PXW_DEV_Dictionary.CodeInterface as ci
      LEFT OUTER JOIN PXW_DEV_Dictionary.CodeTypeIndex as cti
                    ON cti.Usage='CodeDisplay' AND cti.CodeType=ci.Type
      WHERE ci.Namespace=:Namespace
        AND ((:Type IS NULL) OR (ci.Type=:Type))</SqlQuery>
</Query>

<Method name="WriteMainBodyold">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[
	Do ..HREFFrom(.CodeReference)

    Set type=$PIECE(CodeReference,".",*)
    ; most likely being used to view m code?
    If type="" Set type="INT",CodeReference=CodeReference_".INT"
    Set utype=$$$UPPER(type)
    If utype="CLS" {
        Set cls=$PIECE(CodeReference,".",1,*-1)
    	If cls["*" Do ##class(PXW.Tools.DEV.Class).WriteClassDir(cls) Quit
        Do ##class(PXW.Tools.DEV.Class).WriteClass(cls,"","","",.scratch)
    } ElseIf utype="INT" {
        Set rtn=$PIECE(CodeReference,".",1,*-1)
        If rtn["*" Do ##class(PXW.Tools.DEV.Routine).WriteRoutineDir(rtn) Quit
        Set rtn=$PIECE(CodeReference,".",1,*-1)
        Do ##class(PXW.Tools.DEV.Routine).WriteRoutine(rtn)
    } ElseIf utype="INC" {
        Set inc=$PIECE(CodeReference,".",1,*-1)
        If inc["*" Do ##class(PXW.Tools.DEV.Include).WriteIncludeDir(inc) Quit
        Set inc=$PIECE(CodeReference,".",1,*-1)
        Do ##class(PXW.Tools.DEV.Include).WriteInclude(rtn)
    } Else {
        Write !,"UNKNOWN TYPE ("_type_") "_CodeReference,!
        Write "try "
        Write "<ul>"
        Write "<li><a href='"_..HREFTo(CodeReference_".CLS")_"'>"_..EscapeHTML(CodeReference_".CLS")_"</a></li>"
        Write "<li><a href='"_..HREFTo(CodeReference_".INT")_"'>"_..EscapeHTML(CodeReference_".INT")_"</a></li>"
        Write "<li><a href='"_..HREFTo(CodeReference_".INC")_"'>"_..EscapeHTML(CodeReference_".INC")_"</a></li>"
        Write "</ul>"
    }
	Quit
]]></Implementation>
</Method>

<Method name="WriteHeadForm">
<ClassMethod>1</ClassMethod>
<FormalSpec>Page:%String</FormalSpec>
<Implementation><![CDATA[
    Set CR=""
    If Page=..%ClassName(1) {
        Do ..HREFFrom(.CR)
    } ElseIf Page="PXW.Tools.DEV.Class" {
        Do ##class(PXW.Tools.DEV.Class).HREFFrom(.CR)
        Set CR=$PIECE(CR,".",1,*-1)
        If CR'="" Set CR=CR_".*"
    }
   &html<
    <form id=toolsFormCodeReference action='PXW.Tools.DEV.Code.cls'>
					<fieldset id=toolsCodeReference>
						<legend>Code reference</legend>
						<input type=hidden name=IFRAME value='0'>
						<input type=hidden name=%NS value='#(%NS)#'>
						<input accesskey=R placeholder="Class.Name.cls" size=20
							title='Enter Code Reference:#($CHAR(10))#routine.INT, package.name.CLS'
						type=text id=toolInputCodeReference name=CR value='#(CR)#' size=10>
						<input type=submit value='Go'>
					</fieldset>
				</form>
    >
]]></Implementation>
</Method>

<Method name="HREFFrom">
<ClassMethod>1</ClassMethod>
<FormalSpec>*CodeReference:%String,*CodeType:%String,*Name:%String</FormalSpec>
<Implementation><![CDATA[
	#define ReqGet(%name) %request.Get(%name)
	Set CodeReference=$$$ReqGet("CR")

    Set type=$PIECE(CodeReference,".",*)
    Set utype=$$$UPPER(type)

    If ##class(PXW.DEV.Dictionary.CodeType).%ExistsId(utype) {
        Set nam=$PIECE(CodeReference,".",1,*-1)
    } Else {
        Set nam=CodeReference
        Set utype=""
    }
    set CodeType=utype
    set Name=nam
]]></Implementation>
</Method>

<Method name="HREFTo">
<ClassMethod>1</ClassMethod>
<FormalSpec>CodeReference:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If $DATA(%NS) Set ons=%NS
	Set href=##super()
	If $DATA(ons) Set %NS=ons
	Set sep="&"
	Set href=href_sep_"CR="_..EscapeURL(CodeReference),sep="&"
	Quit href
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.CodeDisplayPage">
<Super>PXW.Tools.Page</Super>
<TimeChanged>67125,79553.150680572</TimeChanged>
<TimeCreated>67125,77563.805810266</TimeCreated>

<Parameter name="CodeType">
</Parameter>

<Parameter name="ToolType">
<Default>Code</Default>
</Parameter>

<Method name="RegisterType">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set sc=$$$OK 
    set codetype=..#CodeType
    if codetype'="" {
        s sc=##class(PXW.DEV.Dictionary.CodeTypeIndex).RegisterType("CodeDisplay",codetype,..%ClassName(1))
    }
    quit sc
]]></Implementation>
</Method>

<Method name="HREFToNameOnly">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    q ..HREFTo(Name)
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.ExampleClass">
<Description>
Example class used by the ChangeStyle function to show what code looks like in the given style.</Description>
<Super>%Library.Persistent</Super>
<TimeChanged>67125,77563.852043483</TimeChanged>
<TimeCreated>67125,77563.852043483</TimeCreated>

<Property name="ThingType">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100"/>
</Property>

<Method name="WriteStuff">
<Description>
This is the description of the method.</Description>
<FormalSpec>a1:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    ; Show various types of code
    w "This is a bit of "_a1_" code."
    s x=..ThingType_" "_a1

    s count=0
     &SQL(SELECT 
            -- sql comment
            exalias.ThingType,
            COUNT(*) as CountOfReferences
            INTO :type,:count
        FROM PXW_Tools_DEV.ExampleClass as exalias
        WHERE ThingType=:a1)
    
    s ^PXW("ExampleClass",..%ClassName(1))=$lb($$$OK,99,type,count)

    &html<This is the result of the query <br>
            for #(a1)#: #(count)#>
]]></Implementation>
</Method>

<XData name="xmlstuff">
<Data><![CDATA[
<data>
        <!-- xml comment -->
        <row type='str'><cell>d1</cell></row>
    </data>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^PXW.Tools.DEV.ExampleClassD</DataLocation>
<DefaultData>ExampleClassDefaultData</DefaultData>
<IdLocation>^PXW.Tools.DEV.ExampleClassD</IdLocation>
<IndexLocation>^PXW.Tools.DEV.ExampleClassI</IndexLocation>
<StreamLocation>^PXW.Tools.DEV.ExampleClassS</StreamLocation>
<Data name="ExampleClassDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ThingType</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="PXW.Tools.DEV.HTML.bnf">
<Super>PXW.Tools.DEV.HTML.output</Super>
<TimeChanged>67130,60003.065305232</TimeChanged>
<TimeCreated>67125,77563.954560845</TimeCreated>

<Parameter name="CommentClass">
<Description>
Set this to a style class name</Description>
<Default>CDEFComment</Default>
</Parameter>

<Parameter name="WarningClass">
<Default>Warning</Default>
</Parameter>

<Property name="Style">
<Description>
Set this to 0 if the descriptions are to be displayed as HTML</Description>
<Type>PXW.Tools.Styles.super</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="atomTypeToCSS">
<Description>
Internal array</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="Analyser">
<Type>PXW.DEV.BNF.Analyse.COS</Type>
</Property>

<Property name="Index">
<Description>
Array of the items to add to an index, use the AddToIndex and NextIndexItems to access
</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="IndexError">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="xmlIndent">
<Description>
keep track of indent when displaying XML</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="showPaths">
<Description>
Set this to put the paths in the tooltip (useful for debugging)</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ThisLabel">
<Description>
Used when looking at routines</Description>
<Type>%String</Type>
</Property>

<Property name="ThisType">
<Description>
CLS,INT,INC</Description>
<Type>%String</Type>
</Property>

<Property name="ThisItemType">
<Description>
Property/method etc</Description>
<Type>%String</Type>
</Property>

<Property name="HiliteLabel">
<Description>
Set HiliteLabel to the name of the label you are trying to look at</Description>
<Type>%String</Type>
</Property>

<Property name="HilitePlus">
<Description>
If HiliteLabel is set then set this to the relative line numer you want to highlight</Description>
<Type>%Integer</Type>
</Property>

<Property name="ClassServer">
<Type>PXW.DEV.Dictionary.ClassDefinitionObject</Type>
</Property>

<Property name="XMLPath">
<Description>
maintained by xml elements</Description>
<Type>%String</Type>
</Property>

<Property name="WithAnalyser">
<Description>
THIS FEELS WRONG, COME BACK </Description>
<Type>PXW.DEV.BNF.Analyse.SQL</Type>
</Property>

<Property name="PythonAnalyser">
<Type>PXW.DEV.BNF.Analyse.Python</Type>
</Property>

<Method name="AddToIndex">
<FormalSpec>Name:%String,Type:%String,Anchor:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set data=$LISTBUILD(Name,Type,Anchor)
    Set ..Index("Name",$$$UPPER(Name)_"||"_Type)=data
    Set ..Index("Type",Type_"||"_$$$UPPER(Name))=data
    Set ..Index("Seq",$INCREMENT(..Index("Seq")))=data
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="AddToIndexError">
<FormalSpec>Name:%String,Error:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    If Name'="" {
        Set data=$LISTBUILD(Error)
        Set ..IndexError("Name",Name)=data
    }
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="NextIndexItemByName">
<Description>
Call in a loop using byref parameters to get the index out
while x.NextIndexItem(.name,.type) {

}</Description>
<FormalSpec><![CDATA[&Name:%String="",&Type:%String="",&Anchor:%String="",&Error:%String=""]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Set key=$GET(..Index("NameKey"))
    Set key=$ORDER(..Index("Name",key),1,data)
    If key'="" {
        Set Name=$LISTGET(data,1),Type=$LISTGET(data,2),Anchor=$LISTGET(data,3)
        Set Error=$GET(..IndexError("Name",Name))
    }
    Set ..Index("NameKey")=key
    Quit (key'="")
]]></Implementation>
</Method>

<Method name="%OnNew">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    If $ISOBJECT($GET(%STYLE)) {
        Set ..Style=%STYLE 
    } Else {
        Set ..Style=##class(PXW.Tools.Styles.super).%New()
    }
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="output">
<Description>
Output the html directly to destination. No escaping or other formatting is done.</Description>
<FormalSpec>html:%String,newLine:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	If ..WriteMode {
		If html'="" Write html If newLine Write !
		;s ^PXW("out",$i(^PXW))=html
	} Else {
		Set ..htmlout=..htmlout_html	
	}
]]></Implementation>
</Method>

<Method name="begin">
<Implementation><![CDATA[	Do ..output("<pre>")
]]></Implementation>
</Method>

<Method name="end">
<Implementation><![CDATA[	Do ..output("</pre>")
]]></Implementation>
</Method>

<Method name="middle">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    Do ..resetWrappers()
    ; can't do this here as the ENTIRE class will be analysed all at once
    ;i $isobject(..Analyser) d ..Analyser.middle(element)
    Do ..writeElement(element)
]]></Implementation>
</Method>

<Method name="writeElement">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    #dim a as PXW.DEV.Atom
    #dim cref as PXW.DEV.Element
    ;#dim cdefelement as PXW.DEV.ClassDefinition.Element
    $$$DEBUGMethodBegin
    ;w !,element.type
    /* CDEF */
    
    If element.%IsA("PXW.DEV.BNF.Elements.ClassDefinition") {
        Do ..writeElementClassDefinition(element)
    } ElseIf element.%IsA("PXW.DEV.BNF.Elements.COS") {
        Do ..writeElementCOS(element)
    } ElseIf element.%IsA("PXW.DEV.BNF.Elements.SQL") {
        Do ..writeElementSQL(element)
    } ElseIf element.%IsA("PXW.DEV.BNF.Elements.Python") {
        Do ..writeElementPython(element)
    }

    /* JS */
    If element.type="JsBody" {
        Do ..wrapElementHTML(element,"<span class='EmbeddedJS'>","</span>")
    }

    /* SQL */

    If element.type="SqlBody" {
        Do ..wrapElementHTML(element,"<span class='EmbeddedSQL'>","</span>")
    }


    If element.type="ClassQueryBody" {
       Do ..wrapElementHTML(element,"<span class='EmbeddedSQL'>","</span>")
    }

    /* XML including Storage */
    If element.type="ClassXdata" {
        ;w ! d element.write()
    }

    If element.type="XdataName" {
        Set oldXMLPath=..XMLPath
        Set ..XMLPath=..XMLPath_"/"_element.ToString(0)
    }

    If element.type="XmlData" {
        Set tagnameE=element.findFirstElementByType("XmlTagName",1)
        If $ISOBJECT(tagnameE) {
            Set oldXMLPath=..XMLPath
            Set ..XMLPath=..XMLPath_"/"_tagnameE.ToString(0)
        }
    }
    If element.type="XmlTagName" {
        Do ..wrapElementHTML(element,"<span class='XMLTag' title='"_..XMLPath_"'>","</span>")
    }

    If element.type="XmlAttribute" {
        Set attnameE=element.findFirstElementByType("XmlAttributeName")
        If $ISOBJECT(attnameE) {
            Set oldXMLPath=..XMLPath
            Set ..XMLPath=..XMLPath_"/"_attnameE.ToString(0)
            Do ..wrapElementHTML(attnameE,"<span class='XMLAttribute'>","</span>")
        }
    }

    If element.type="XmlAttributeValue" {
        If ..XMLPath="/UrlMap/Routes/Route/Call" {
            Set callname=element.ToString(0)
            Set callname=$TRANSLATE(callname,"'""","") ; get rid of quotes
            Do ..wrapElementHTML(element,"<a class='COSObjectMember' href='"_..HREFToClass(..This,callname)_"'>","</a>")
        } Else {
            Do ..wrapElementHTML(element,"<span class='XMLTag' title='"_..XMLPath_"'>","</span>")
        }
    }
    
    If element.type="XmlCdataText" {
        If ..XMLPath="/file/bnf/data" {
            Do ..writeElementBNF1(element)
        }

    }

    /* HTML */
    If element.type="HtmlBody" {
        Do ..wrapElementHTML(element,"<span class='EmbeddedXML'>","</span>")
    }
    ;if element.type="StorageXmlData" {
    ;    w "<pre>" d element.write() w "</pre>"
    ;}

	For  {
		Set a=element.partsGetNext(.akey)
		Quit:akey=""

		If a.%IsA("PXW.DEV.Atom") {
            Set type=$PIECE(a.type,":",1)
            If type="ClassReference" {
            	Do ..wrapAtomHTML(a,"<a class='CDEFClassName' href='"_..HREFToClass(a.value)_"'>","</a>")
            }
            If type="ClassName" {
            	Do ..wrapAtomHTML(a,"<a class='CDEFClassName' href='"_..HREFToClass(a.value)_"'>","</a>")
            }
            If type="identifier" {
            	;d ..wrapAtomHTML(a,"<span class='keyword'>","</span>")
            }
            If type="Keyword" {
            	Do ..wrapAtomHTML(a,"<span class='keyword'>","</span>")
            }
            If type="CDEFKeyword" {
            	Do ..wrapAtomHTML(a,"<span class='CDEFkeyword'>","</span>")
            }

            /* COS */
            If type="VariableSet" {
                Set varname=a.value
	    		Set cssclass="COSVariableSet"
    			If $ISOBJECT(..Analyser),..Analyser.IsParameterVariable(varname) Set cssclass="COSVariableParameterSet"
                Do ..wrapAtomHTML(a,"<span class='"_cssclass_"' varid='"_varname_"' onclick=""HiliteSets('"_varname_"');"">","</span>")
            } ElseIf type="Variable" {
                Set varname=a.value
                Set cssclass="COSVariable"
                If $ISOBJECT(..Analyser),..Analyser.IsParameterVariable(varname) Set cssclass="COSVariableParameter"
                Do ..wrapAtomHTML(a,"<span class='"_cssclass_"' fetchid='"_varname_"' onclick=""HiliteSets('"_varname_"');"">","</span>")
            } ElseIf type="ObjectVariable" {
                Set varname=a.value
                Set cssclass="COSVariable"
                If $ISOBJECT(..Analyser),..Analyser.IsParameterVariable(varname) Set cssclass="COSVariableParameter"
                Do ..wrapAtomHTML(a,"<span class='"_cssclass_"' fetchid='"_varname_"' onclick=""HiliteSets('"_varname_"');"">","</span>")
            } ElseIf type="String" {
                Do ..wrapInnerAtomHTML(a,"<span class='COSString'>","</span>")
            } ElseIf type="Number" {
                Do ..wrapAtomHTML(a,"<span class='COSNumber'>","</span>")
            }

            /* JS - old style parser */
       		If type="JSCOMMAND" {
                Do ..wrapAtomHTML(a,"<span class='JSCommand'>","</span>")
            } ElseIf type="JSVAR" {
                Set varname=a.ToString(0)
                Set cssclass="JSVariable"
                Do ..wrapAtomHTML(a,"<span class='"_cssclass_"' fetchid='"_varname_"' onclick=""HiliteSets('"_varname_"');"">","</span>")			
            } ElseIf type="JSSTRING" {
                Do ..wrapAtomHTML(a,"<span class='JSString'>","</span>")
            } ElseIf type="JSREGEX" {
                Do ..wrapAtomHTML(a,"<span class='JSRegex'>","</span>")
            }




            If type="ERROR" {
                Do ..wrapAtomHTML(a,"<span class='"_..#WarningClass_"'>","</span>")
                Do ..AddToIndexError(..ThisMethod,a.value)
            }

            Do:..showPaths ..wrapAtomHTML(a,"<span title='"_a.type_"'>","</span>")

 
		}
	}

    Do ##super(element)
    If $GET(oldXMLPath)'="" {
        Set ..XMLPath=oldXMLPath
    }
    $$$DEBUGMethodEnd
]]></Implementation>
</Method>

<Method name="writeElementBNF1">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    #dim parser as PXW.DEV.BNF.super
    Set input=element.ToString()
    If input["::=" {
       	Set parser=##class(PXW.DEV.BNF.Compilers.BNF1safe).%New()
    } Else {
        ; try different parser
        Set parser=##class(PXW.DEV.BNF.Compilers.BNF2safe).%New()
    }    
    Set parser.stream=##class(PXW.DEV.InputStream).NewString(element.ToString())
    Set subElement=##class(PXW.DEV.Element).%New()
    If parser.File(subElement) {
    	Do ..wrapElementBNF1Loop(subElement)
        Do element.partsClear()
        Do element.AddPart(subElement)
    } Else {

    }
]]></Implementation>
</Method>

<Method name="wrapElementBNF1Loop">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    If element.type="Definition" {
        Set labatom=element.FirstAtom()
        Set lab=labatom.value
        If lab=..HiliteLabel {
            ;d ..wrapAtomHTML(labatom,"<span class='hilite'>","</span>")
            ;d ..wrapAtomHTML(labatom,"<a name='bookmark'>","</a>")
            Do ..wrapAtomHTML(labatom,"<a name='Bookmark' class='hilite'>","</a>")
            If ..HilitePlus'="" Set ..HiLiteLine=labatom.line+..HilitePlus
        } Else {
            Set labname=$TRANSLATE("LAB"_..ThisMethod_lab,"$^%_","")
            Do ..wrapAtomHTML(labatom,"<a id='"_labname_"' class='COSLabelDef' name='"_labname_"'>","</a>")
            Do ..AddToIndex(..ThisMethod_" : "_lab,"XDataName",labname)
        }
    }

   If element.type="Call" {
        Set atom=element.FirstAtom()
        Set lab=atom.value
        Set labname=$TRANSLATE("LAB"_..ThisMethod_lab,"$^%_","")
        Do ..wrapAtomHTML(atom,"<a onclick='HiliteElement("""_labname_""");'  class='COSLabel' href='#"_labname_"'>","</a>")
    }

    For  {
        Set a=element.partsGetNext(.akey)
        Quit:akey=""

        If a.%IsA("PXW.DEV.Element") {
            Do ..wrapElementBNF1Loop(a)
        }
    }
]]></Implementation>
</Method>

<Method name="writeElementSQL">
<FormalSpec>element:PXW.DEV.BNF.Elements.SQL</FormalSpec>
<Implementation><![CDATA[
    /*If element.type="StoredProcCall" {
        Set spNameE=element.findFirstElementByType("StoredProcName",0)
        If $ISOBJECT(spNameE) {
            Set spname=spNameE.ToString(0)
            Do ..wrapElementHTML(spNameE,"<a class='COSObjectMember' href='"_..HREFToClass(spname)_"'>","</a>")
        }
    }
    */
    If element.type="StoredProcName" {
            Set spname=element.ToString(0)
            Do ..wrapElementHTML(element,"<a class='COSObjectMember' href='"_..HREFToClass(spname)_"'>","</a>")
    }

    If element.type="QuerySpecification" {
		#dim WithCommandE as PXW.DEV.Element
		Set WithCommandE=element.findFirstElementByType("WithCommand")
		If $ISOBJECT(WithCommandE) {
			Set withAnalyser=##class(PXW.DEV.BNF.Analyse.SQL).%New()
			Set withAnalyser.ClassServer=..ClassServer
			Do withAnalyser.WithCommand(WithCommandE)
			Set ..WithAnalyser=withAnalyser
		}
	}

    If element.type="WithCommand" {
	    Do element.findElementsByType("WithClause",.withlist)
	    For i=1:1:withlist.Count() {
		    Set withE=withlist.GetAt(i)
			Set aliasE=withE.findFirstElementByType("AliasName")	    
		    If $ISOBJECT(aliasE) {
			    Set aliasname="alias"_aliasE.ToString(0)
			    Do ..wrapElementHTML(aliasE,"<span class='SQLTableAliasSet' title='show alias usage' varid='"_aliasname_"' onclick=""HiliteSets('"_$$$UPPER(aliasname)_"');"">","</span>")
		    }	    
        }
    }


    If element.type="DerivedColumn" {
        ; work out what this column is called
        ; either from the AS clause or if its just referencing 
        ; a single column, that column is the name
        ; then create an ID for it so it can be highlighted
        #dim col as PXW.DEV.Element
		Set col=element
		Set classtxt="class='SQLColumn'"
        Set colname="colxxxx"

        Set asclause=col.findFirstElementByType("AsClause",0)
        If $ISOBJECT(asclause) {
            Set colnameE=asclause.findFirstElementByType("ColumnName",0)
            If $ISOBJECT(colnameE) {
                Set colname="col"_$$$UPPER(colnameE.ToString(0))
            }
        } Else {
            Kill colrefs
            ; if the column is just a reference to another column
            Do col.findElementsByType("ColumnReference",.colrefs,2)
            If $ISOBJECT($GET(colrefs)),colrefs.Count()=1 {
                Set colnameE=colrefs.GetAt(1).findFirstElementByType("ColumnName",0)
                If $ISOBJECT(colnameE) {
                    Set colname="col"_$$$UPPER(colnameE.ToString(0))
                }
            }
        }
        If ..BookMark'="",$$$UPPER(colname)=$$$UPPER("col"_..BookMark) {
            Set classtxt="class='hilite'"
        }
		Do ..wrapElementHTML(col,"<span "_classtxt_" fetchid='"_$$$UPPER(colname)_"'>","</span>")        
    }

    If element.type="SelectCommand" {
        #dim subAnalyser as PXW.DEV.BNF.Analyse.SQL
        Set sqlanalyse=##class(PXW.DEV.BNF.Analyse.SQL).%New(..ClassServer)
        Set sqlanalyse.This=..This
        Do sqlanalyse.checkElement(element)
        Set cref=""
        While sqlanalyse.NextColumnReference(.cref,.fulltable,.fieldname) {
            Set aliasNameE=cref.findFirstElementByType("AliasName",1) ; hmm, in a group, can we promote in bnf?
            Set columnNameE=cref.findFirstElementByType("ColumnName",0)
            ;zw cref,fulltable,fieldname
            If fulltable'="" {
                Do ..FollowImplicitJoins(cref,fulltable)
            } Else {
                Set colname="col"_$$$UPPER(fieldname)
                Set withAnalyser="",subAnalyser=""
                If $ISOBJECT(..WithAnalyser) {
                    If $ISOBJECT(aliasNameE) {
                        Set aliasname=aliasNameE.ToString(0)
                        
                        Set subAnalyser=$GET(..WithAnalyser.WithClauseAnalysis(aliasname))
                        If $ISOBJECT(subAnalyser) {
                            ; how to deal with a with select that has select * from multiple tables...?
                            Set fulltable=$GET(subAnalyser.SelectedColumnsByName(fieldname))
                            If fulltable="" Set fulltable=$GET(subAnalyser.SelectedColumnsByName("*"))
                        } Else {
                            ; not a with reference,
                        }
                    } Else {
                        ; no table alias, what to do?
                    }
                }
                If fulltable'="" {
	                Do ..FollowImplicitJoins(cref,fulltable)
                } Else {
	                Do ..wrapElementHTML(columnNameE,"<span class='COSObjectMember' title='still unable to determine class, possibly because of subquery' fetchid='"_$$$UPPER(colname)_"' onclick=""HiliteSets('"_$$$UPPER(colname)_"');"">","</span>")
                }
            }
            If $ISOBJECT(aliasNameE) {
                Set aliasname="alias"_aliasNameE.ToString(0)
                Do ..wrapElementHTML(aliasNameE,"<span class='SQLTableAlias' title='show alias usage' fetchid='"_$$$UPPER(aliasname)_"' onclick=""HiliteSets('"_$$$UPPER(aliasname)_"');"">","</span>")
            }
        }
    }

    If element.type="InsertCommand" {
        Set sqlanalyse=##class(PXW.DEV.BNF.Analyse.SQL).%New(..ClassServer)
        Set sqlanalyse.This=..This
        Do sqlanalyse.checkElement(element)
        Set columnNameE=""
        While sqlanalyse.NextColumnReference(.columnNameE,.fulltable,.fieldname) {
            ;s aliasNameE=cref.findFirstElementByType("AliasName",1) ; hmm, in a group, can we promote in bnf?
            ;s columnNameE=cref.findFirstElementByType("ColumnName",0)
            If fulltable'="" {
                Do ..wrapElementHTML(columnNameE,"<a class='COSObjectMember' href='"_..HREFToClass(fulltable,columnNameE.ToString(0))_"'>","</a>")            
            } Else {
                ; should always be a name
              ;  s colname="col"_$$$UPPER(fieldname),aname=""
               ; d ..wrapElementHTML(columnNameE,"<span class='COSObjectMember' title='unable to determine class, possibly because of subquery' fetchid='"_$$$UPPER(colname)_"' onclick=""HiliteSets('"_$$$UPPER(colname)_"');"">","</span>")
            }
            ;i $ISOBJECT(aliasNameE) {
            ;    s aliasname="alias"_aliasNameE.ToString(0)
            ;    d ..wrapElementHTML(aliasNameE,"<span class='COSObjectMember' title='show alias usage' fetchid='"_$$$UPPER(aliasname)_"' onclick=""HiliteSets('"_$$$UPPER(aliasname)_"');"">","</span>")
            ;}
        }
    }
    
    If element.type="DeleteCommand" {
        Set sqlanalyse=##class(PXW.DEV.BNF.Analyse.SQL).%New(..ClassServer)
        Set sqlanalyse.This=..This
        Do sqlanalyse.checkElement(element)
        Set columnNameE=""
        While sqlanalyse.NextColumnReference(.columnNameE,.fulltable,.fieldname) {
            ;s aliasNameE=cref.findFirstElementByType("AliasName",1) ; hmm, in a group, can we promote in bnf?
            ;s columnNameE=cref.findFirstElementByType("ColumnName",0)
            If fulltable'="" {
                Do ..wrapElementHTML(columnNameE,"<a class='COSObjectMember' href='"_..HREFToClass(fulltable,columnNameE.ToString(0))_"'>","</a>")            
            } Else {
                ; should always be a name
              ;  s colname="col"_$$$UPPER(fieldname),aname=""
               ; d ..wrapElementHTML(columnNameE,"<span class='COSObjectMember' title='unable to determine class, possibly because of subquery' fetchid='"_$$$UPPER(colname)_"' onclick=""HiliteSets('"_$$$UPPER(colname)_"');"">","</span>")
            }
            ;i $ISOBJECT(aliasNameE) {
            ;    s aliasname="alias"_aliasNameE.ToString(0)
            ;    d ..wrapElementHTML(aliasNameE,"<span class='COSObjectMember' title='show alias usage' fetchid='"_$$$UPPER(aliasname)_"' onclick=""HiliteSets('"_$$$UPPER(aliasname)_"');"">","</span>")
            ;}
        }
    }

    If element.type="DirectTable" {
        Set direct=element
        If $ISOBJECT(direct) {
            Set tablenameE=direct.findFirstElementByType("TableName",0)
            If $ISOBJECT(tablenameE) {
                Set tablename=tablenameE.ToString(0)
                ; is it a reference to a WITH?
                ;zw tablename,..WithAnalyser
                If tablename'="", tablename'[".", $ISOBJECT(..WithAnalyser), $GET(..WithAnalyser.WithClauseAnalysis(tablename))'="" {
	                Set aliasname="alias"_tablename
             	   Do ..wrapElementHTML(tablenameE,"<span class='SQLTableAlias' title='show alias usage' varid='"_aliasname_"' onclick=""HiliteSets('"_$$$UPPER(aliasname)_"');"">","</span>")
                } Else {
	                Do ..wrapAtomHTML(tablenameE,"<a class='CDEFClassName' href='"_..HREFToClass(tablename)_"'>","</a>")
                }
            }
        }
    }

    If element.type="TableAlias" {
            ;s aliasname="alias"_element.ToString(0)
            ;d ..wrapElementHTML(element,"<span class='SQLTableAliasSet' title='show alias usage' fetchid='"_$$$UPPER(aliasname)_"' onclick=""HiliteSets('"_$$$UPPER(aliasname)_"');"">","</span>")
    }

    If element.type="TableAsClause" {
        Set aliasE=element.findFirstElementByType("AliasName")
        If $ISOBJECT(aliasE) {
            Set aliasname="alias"_aliasE.ToString(0)
            Do ..wrapElementHTML(aliasE,"<span class='SQLTableAliasSet' title='show alias usage' varid='"_$$$UPPER(aliasname)_"' onclick=""HiliteSets('"_$$$UPPER(aliasname)_"');"">","</span>")
        }
    }
]]></Implementation>
</Method>

<Method name="writeElementCOS">
<FormalSpec>element:PXW.DEV.BNF.Elements.COS</FormalSpec>
<Implementation><![CDATA[
    ;#define
    If element.type="CosDirective" {
        Set keywordatom=element.FirstAtom()
        Set defineE=element.findFirstElementByType("CosDirectiveDefine",0)
        If '$ISOBJECT(defineE) Set defineE=element.findFirstElementByType("CosDirectiveDefonearg",0)
        If $ISOBJECT(defineE) {
            If ..ThisType="INC" {
                Set nameE=defineE.findFirstElementByType("CosDirectiveDefineName",0)
                If $ISOBJECT(nameE) {
                    Set name=nameE.ToString(0)
                    Set count=##class(PXW.Xref.Queries).GetCount(%NS,"INC",..This,name)
                    Set anchor="anchor"_name_nameE.type
                    ;Set ..ThisMethod=name
                    If ..BookMark'="",$$$UPPER(name)=$$$UPPER(..BookMark) {
                        ;d ..wrapElementHTML(element,"<a name='bookmark'>","</a>")
                        Set anchor="bookmark" ;
                        Do ..wrapElementHTML(nameE,"<span class='hilite'>","</span>")
                    }
                    Do ..AddToIndex(name,"MAC",anchor)
                    Do ..wrapElementHTML(element,"<a name='"_anchor_"'>","</a>") ; anchor goes before the member (ie before the comment)

                    Set menu="<div class='CDEFItemMenu  nocopy'>"
                    Set menu=menu_"<a class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("INC",..This,name)_"'>Xref ("_count_") </a>"
                    Set menu=menu_"</div>"
                    Do ..wrapAtomHTML(keywordatom,menu,"")
                }
            }
        }
    }
    
    ; ##class()
    If element.type="ClassExpression" {
        Set classnameele=element.findFirstElementByType("ClassReference",0)
        Set classname=classnameele.ToString(0)
		Do ..FollowObjectChainForType(element,classname)
    }

    If $LISTFIND($LISTBUILD("ThisObject","ThisObjectDirectProperty","ThisObjectSet","ThisObjectDirectPropertySet"),element.type) {
        If ..This'="" {
            Set classname=..This
            If classname'="" Do ..FollowObjectChainForType(element,classname)
        }
    }
    ; known variable
    If ",Variable,VariableSet,ObjectVariable,"[(","_element.type_","),$ISOBJECT(..Analyser) {
        Set variablename=element.ToStringAtomsOnly(0)
        ; variable could be something like {*} or {field}  so the name above (using atoms only) will not find anything
        ; don't worry about that at the moment!
        If variablename'="" {
            ; when working out a type use the #DIM type if there is one
            Set classname=$GET(..Analyser.DimmedTypes(variablename))
            If classname="" Set classname=$GET(..Analyser.VariablesTypes(variablename))
            If classname'="" Do ..FollowObjectChainForType(element,classname)
        }
    }
    
    If element.type="LabelDefinition" {
        Set labatom=element.FirstAtom()
        Set lab=labatom.value
        Set ..ThisLabel=lab
        If lab=..HiliteLabel {
            ;d ..wrapAtomHTML(labatom,"<span class='hilite'>","</span>")
            ;d ..wrapAtomHTML(labatom,"<a name='bookmark'>","</a>")
            Do ..wrapAtomHTML(labatom,"<a name='Bookmark' class='hilite'>","</a>")
            If ..HilitePlus'="" Set ..HiLiteLine=labatom.line+..HilitePlus
        } Else {
            Set labname=$TRANSLATE("LAB"_..ThisMethod_lab,"$^%_","")
            Do ..wrapAtomHTML(labatom,"<a class='COSLabelDef' name='"_labname_"'>","</a>")
        }
    }

   If element.type="LabelReference" {
        Set lab=element.ToString(0)
        If lab["^" {
            Do ..wrapElementHTML(element,"<a class='COSLabel' href='"_..HREFToClass(lab)_"'>","</a>")
        } Else {
            Set labname=$TRANSLATE("LAB"_..ThisMethod_lab,"$^%_","")
            Do ..wrapElementHTML(element,"<a class='COSLabel' href='#"_labname_"'>","</a>")
        }
    }


    If element.type="CosCodeBlock" {
        Do ..wrapElementHTML(element,"<span class='EmbeddedCOS'>","</span>")
    }

    If element.type="PythonImport" {
        ;d element.write()
        Set stringE=element.findFirstElementByType("String")
        If $ISOBJECT(stringE) {
            Set atom=stringE.FirstAtom()
            If $ISOBJECT(atom) {
                Do ..wrapAtomHTML(atom,"<a class='CDEFClassName' href='"_..HREFToPython(atom.value)_"'>","</a>")
                Set atom.type="pythonimport"
            }
        }       
    }

    If (element.type="GlobalRef") || (element.type="GlobalRefSet") {
        Set setting=0
        If element.type="GlobalRefSet" Set setting=1
        Set fullrefE=element.findFirstElementByType("GlobalRefFull",0)
        If $ISOBJECT(fullrefE) {
            ; On a global clicking on the ^ will take directly to the XREF since we don't
            ; have any other details about the global at the moment.
            ; Clicking on the name of the global highlights it like a regular variable
            Set globalElement=fullrefE.findFirstElementByType("GlobalName",0)
            Set upa=fullrefE.FirstAtom() ; ^ is always at the start
            Set namea=globalElement ;.ToStringAtomsOnly()
            ;d ..wrapAtomHTML(upa,"<a class='COSGlobalSet' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("GBL",globalElement.Name.ToString(0),globalElement.KeysForXref())_"'>","</a>")
            Set subsE=fullrefE.findFirstElementByType("SubscriptParameterList",0),subs=""
            If $ISOBJECT(subsE),$ISOBJECT(..Analyser) Set subs=..Analyser.SimplifySubscripts(subsE)
            If $ISOBJECT(namea) {
                Do ..wrapAtomHTML(upa,"<a class='COSGlobalSet' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("GBL",namea.ToStringAtomsOnly(0),subs)_"'>","</a>")
                Set varname="GLOBAL"_namea.ToStringAtomsOnly(0)
                If setting {
                    Do ..wrapAtomHTML(namea,"<span class='COSGlobalSet' varid='"_varname_"' onclick=""HiliteSets('"_varname_"');"">","</span>")
                        } Else {
                    Do ..wrapAtomHTML(namea,"<span class='COSGlobal' fetchid='"_varname_"' onclick=""HiliteSets('"_varname_"');"">","</span>")
                }
            }
        } Else {
            ; not sure what we can do with naked refs here (other than make them stand out as a bad thing)
        }
	}

    If element.type="Macrocall" {
        Set atom=element.partsGetAt(2)
        If $ISOBJECT(atom) {
            Set name=atom.ToString(0)
            If name'="" {
                If $ISOBJECT(..Analyser) {
                    ;zw ..Analyser,name
                    If '$DATA(..Analyser.DefinedMacros(name)) {
                        Do ..wrapAtomHTML(atom,"<a href='"_..HREFToInclude(,element.ToString(0))_"'>","</a>")
                    } Else {
                        Do ..wrapAtomHTML(atom,"<span title'Local macro'>","</span>")
                    }
                } Else {
                    Do ..wrapAtomHTML(atom,"<a href='"_..HREFToInclude(,element.ToString(0))_"'>","</a>")
                }
            }
        }
    }

    If element.type="CosDirectiveIncludeName" {
        Do ..wrapElementHTML(element,"<a href='"_..HREFToInclude(element.ToString(0))_"'>","</a>")
    }
]]></Implementation>
</Method>

<Method name="writeElementPython">
<Description>
Note that all the elements in here are being wrapped by CDEF and COS style spans, it gives nice colours 
but its a bit confusing, really we need some common styles that work for any language.</Description>
<FormalSpec>element:PXW.DEV.BNF.Elements.Python</FormalSpec>
<Implementation><![CDATA[
    If element.type="File" {
       Do ..wrapElementHTML(element,"<span class='EmbeddedPython'>","</span>")
    }

    If element.type="ClassDefRaw" {
        Set nameatom=element.partsGetAt(2) ; should be 2
        If $ISOBJECT(nameatom) {
            Set aname="pyClassName"_nameatom.value
            Do ..AddToIndex(nameatom.value,"Class",aname)
            Do ..wrapAtomHTML(nameatom,"<span id='"_aname_"' class='CDEFClassName'>","</span>")
        }
	}

    If element.type="FunctionDef" {
		Set ..PythonAnalyser=##class(PXW.DEV.BNF.Analyse.Python).%New()
        Set ..PythonAnalyser.This=..This
        Do ..PythonAnalyser.middle(element)

        Set nameatom=element.partsGetAt(2) ; should be 2
        If $ISOBJECT(nameatom) {
           Do ..wrapAtomHTML(nameatom,"<span class='CDEFMember'>","</span>")
        }
	}

    If element.type="FunctionDefRaw" {
        Set nameatom=element.partsGetAt(2) ; should be 2
        If $ISOBJECT(nameatom) {
            Set aname="pyDefName"_nameatom.value
            Do ..AddToIndex(nameatom.value,"MethodName",aname)
             Do ..wrapAtomHTML(nameatom,"<span id='"_aname_"' class='CDEFMember'>","</span>")
        }
	}

    If element.type="ImportStmt" {
        Set nameE=element.findFirstElementByType("DottedName")
        If $ISOBJECT(nameE) {
            Set name=nameE.ToString(0)
            Do ..wrapElementHTML(nameE,"<a class='CDEFClassName' href='"_..HREFToPython(name)_"'>","</a>")
        }
    }

    If element.type="ImportFrom" {
        Set nameE=element.findFirstElementByType("DottedAsNames")
        If $ISOBJECT(nameE) {
            Set name=nameE.ToString(0)
            Do ..wrapElementHTML(nameE,"<a class='CDEFClassName' href='"_..HREFToPython(name)_"'>","</a>")
        }
    }

    If element.type="StarTarget" {
        Set varname=element.ToString(0)
        Set cssclass="COSVariable"
        If $ISOBJECT(..PythonAnalyser),..PythonAnalyser.IsParameterVariable(varname) Set cssclass="COSVariableParameter"
        Do ..wrapElementHTML(element,"<span class='"_cssclass_"' varid='"_varname_"' onclick=""HiliteSets('"_varname_"');"">","</span>")
    }

    If element.type="Param" {
        Set varname=element.ToString(0)
        Set cssclass="COSVariable"
        If $ISOBJECT(..PythonAnalyser),..PythonAnalyser.IsParameterVariable(varname) Set cssclass="COSVariableParameter"
        Do ..wrapElementHTML(element,"<span class='"_cssclass_"' varid='"_varname_"' onclick=""HiliteSets('"_varname_"');"">","</span>")
    }

    If element.type="Atom" {
        For  {
            Set a=element.partsGetNext(.akey)
            Quit:akey=""

            If a.%IsA("PXW.DEV.Atom") {
                Set type=$PIECE(a.type,":",1)
                If type="Identifier" {
                    Set varname=a.value
                    Set cssclass="COSVariable"
                    If $ISOBJECT(..Analyser),..Analyser.IsParameterVariable(varname) Set cssclass="COSVariableParameter"
                    If $ISOBJECT(..PythonAnalyser),..PythonAnalyser.IsParameterVariable(varname) Set cssclass="COSVariableParameter"
                    Do ..wrapAtomHTML(a,"<span class='"_cssclass_"' fetchid='"_varname_"' onclick=""HiliteSets('"_varname_"');"">","</span>")
                } 
            }
        }
	}
]]></Implementation>
</Method>

<Method name="writeElementClassDefinition">
<FormalSpec>element:PXW.DEV.BNF.Elements.ClassDefinition</FormalSpec>
<Implementation><![CDATA[
    If element.type="IncludeName" {
        Do ..wrapElementHTML(element,"<a href='"_..HREFToInclude(element.ToString(0))_"'>","</a>")
    }

    If element.type="OneClassmember" {
        ; a class memeber element is like this:
        ; Element=OneClassmember PXW.DEV.BNF.Element @1835 
        ; .Element=ClassMethod PXW.DEV.BNF.Element @1893
        ; ..type=keyword:/UdlStatement/ClassDefinition/ClassMemberSection/ClassMemberList/OneClassmember/ClassMethod
        ; .. Method
        ; ..Element=MethodName PXW.DEV.BNF.Element @1910
        ; ...Element=ClassItemIdentifier PXW.DEV.BNF.Element @1946
        Set item=element.partsGetAt(1)
        Set typeE=item.partsGetAt(1)
        Set ..ThisItemType=typeE.ToString(0)
        Set nameE=item.partsGetAt(2)
        If $LISTFIND($LISTBUILD("PropertyName","MethodName","ClassParameterName","IndexName","TriggerName","ForeignkeyName","StorageName","QueryName","XdataName"),nameE.type) {
            Set name=nameE.ToString(0)
            Set anchor="anchor"_name_nameE.type
            Set ..ThisMethod=name
            If ..BookMark'="",$$$UPPER(name)=$$$UPPER(..BookMark) {
                ;d ..wrapElementHTML(element,"<a name='bookmark'>","</a>")
                Do ..wrapElementHTML(nameE,"<span id='"_anchor_"SPAN' class='hilite'>","</span>") 
                Set anchor="bookmark" ;
            } Else {
                Do ..wrapElementHTML(nameE,"<span id='"_anchor_"SPAN'>","</span>")
            }
            
            Do ..AddToIndex(name,nameE.type,anchor)
            Do ..wrapElementHTML(element,"<a name='"_anchor_"'></a>","") ; anchor goes before the member (ie before the comment)
        }
    }
    If element.type="ClassDefinition" {
        Set keywordatom=element.FirstAtom()
        Set count=##class(PXW.Xref.Queries).GetCount(%NS,"CLS",..This)
        Set menu="<div class='CDEFItemMenu nocopy'>"
        Set menu=menu_"<a class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,)_"'>Xref ("_count_") </a>"
        Set overriddenby=##class(PXW.Xref.Queries).GetCount(%NS,"CLS",..This,"_class","_Extends")
        If overriddenby>0 {
            Set menu=menu_"<a class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,"","_Extends")_"'>Extended "_overriddenby_" </a>"
        }
        Set menu=menu_"</div>"
        Do ..wrapAtomHTML(keywordatom,menu,"")

        ;}
    }

    If element.type="AttributeViewquery" {
        Set queryE=element.findFirstElementByType("ClassQueryBody")
        ;s formatter=##class(PXW.DEV.BNF.Format.SQL).%New()
        ;d formatter.formatElement(queryE)
        If $ISOBJECT(queryE) {
            Do ..wrapElementHTML(queryE,"<div>","</div>")
        }
    }
    If element.type="ClassProperty" {
        Set keywordatom=element.FirstAtom()
        Set nameelement=element.findFirstElementByType("PropertyName")
        If $ISOBJECT(nameelement) {
            Set name=nameelement.ToString(0)
            Set count=##class(PXW.Xref.Queries).GetCount(%NS,"CLS",..This,name)
            Set menu="<div class='CDEFItemMenu nocopy'>"
            Set menu=menu_"<a class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,name)_"'>Xref ("_count_") </a>"
            Set overrides=..ClassServer.GetPropertyOverrides(..This_"||"_name)
            If overrides'="" {
                Set menu=menu_"<a class='CDEFOption' href='"_..HREFToClass(overrides,name)_"'>Override </a>"
            }
            Set overriddenby=##class(PXW.Xref.Queries).GetCount(%NS,"CLS",..This,name,"_Override")
            If overriddenby>0 {
                Set menu=menu_"<a class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,name,"_Override")_"'>Overridden "_overriddenby_" </a>"
            }
            Set menu=menu_"</div>"
            Do ..wrapAtomHTML(keywordatom,menu,"")
        }
    }
    If element.type="ClassParameter" {
        Set keywordatom=element.FirstAtom()
        Set nameelement=element.findFirstElementByType("ClassParameterName")
        If $ISOBJECT(nameelement) {
            Set name=nameelement.ToString(0)
            Set count=##class(PXW.Xref.Queries).GetCount(%NS,"CLS",..This,name)
            Set menu="<div class='CDEFItemMenu  nocopy'>"
            Set menu=menu_"<a class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,name)_"'>Xref ("_count_") </a>"
            Set overrides=..ClassServer.GetParameterOverrides(..This_"||"_name)
            If overrides'="" {
                Set menu=menu_"<a class='CDEFOption' href='"_..HREFToClass(overrides,name)_"'>Override </a>"
            }
            Set overriddenby=##class(PXW.Xref.Queries).GetCount(%NS,"CLS",..This,name,"_Override")
            If overriddenby>0 {
                Set menu=menu_"<a class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,name,"_Override")_"'>Overridden "_overriddenby_" </a>"
            }
            Set menu=menu_"</div>"
            Do ..wrapAtomHTML(keywordatom,menu,"")
        }
    }
    If $LISTFIND($LISTBUILD("ClassMethod","ClassClassMethod"),element.type) {
        Set keywordatom=element.FirstAtom()
        Set nameelement=element.findFirstElementByType("MethodName")
        If $ISOBJECT(nameelement) {
            Set name=nameelement.ToString(0)
            Set count=##class(PXW.Xref.Queries).GetCount(%NS,"CLS",..This,name)
            Set menu="<div class='CDEFItemMenu  nocopy'>"
            Set menu=menu_"<a class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,name)_"'>Xref ("_count_") </a>"
            Set overrides=..ClassServer.GetMethodOverrides(..This_"||"_name)
            If overrides'="" {
                Set menu=menu_"<a class='CDEFOption' href='"_..HREFToClass(overrides,name)_"'>Override </a>"
            }
            Set overriddenby=##class(PXW.Xref.Queries).GetCount(%NS,"CLS",..This,name,"_Override")
            If overriddenby>0 {
                ;d ..wrapElementHTML(keywordatom,"<a class='CDEFOption nocopy' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,name)_"'>Overridden "_overriddenby_" </a>","")
                Set menu=menu_"<a class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,name,"_Override")_"'>Overridden "_overriddenby_" </a>"
            }
            Set menu=menu_"</div>"
            Do ..wrapAtomHTML(keywordatom,menu,"")
        }
    }
    If element.type="ClassQuery" {
        Set keywordatom=element.FirstAtom()
        Set nameelement=element.findFirstElementByType("QueryName")
        If $ISOBJECT(nameelement) {
            Set name=nameelement.ToString(0)
            Set count=##class(PXW.Xref.Queries).GetCount(%NS,"CLS",..This,name)
            Set menu="<div class='CDEFItemMenu nocopy'>"
            Set menu=menu_"<a class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,name)_"'>Xref ("_count_") </a>"
            ; not sure if/how I recognise overridden QUERIES
            /*Set overrides=..ClassServer.GetPropertyOverrides(..This_"||"_name)
            If overrides'="" {
                Set menu=menu_"<a class='CDEFOption' href='"_..HREFToClass(overrides,name)_"'>Override </a>"
            }*/
            Set overriddenby=##class(PXW.Xref.Queries).GetCount(%NS,"CLS",..This,name,"_Override")
            If overriddenby>0 {
                Set menu=menu_"<a class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,name,"_Override")_"'>Overridden "_overriddenby_" </a>"
            }
            Set menu=menu_"</div>"
            Do ..wrapAtomHTML(keywordatom,menu,"")
        }
    }
    If element.type="ClassIndex" {
        Set keywordatom=element.FirstAtom()
        Set nameelement=element.findFirstElementByType("IndexName")
        If $ISOBJECT(nameelement) {
            Set name=nameelement.ToString(0)
            Set count=##class(PXW.Xref.Queries).GetCount(%NS,"CLS",..This,name)
            Set menu="<div class='CDEFItemMenu nocopy'>"
            Set menu=menu_"<a title='This does NOT show where its used as a index in SQL, only where its used as Unique Open method' class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,name)_"'>Xref ("_count_") </a>"
            ; not sure if indices even can be overridden
            /*Set overrides=..ClassServer.GetPropertyOverrides(..This_"||"_name)
            If overrides'="" {
                Set menu=menu_"<a class='CDEFOption' href='"_..HREFToClass(overrides,name)_"'>Override </a>"
            }*/
            Set overriddenby=##class(PXW.Xref.Queries).GetCount(%NS,"CLS",..This,name,"_Override")
            If overriddenby>0 {
                Set menu=menu_"<a class='CDEFOption' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("CLS",..This,name,"_Override")_"'>Overridden "_overriddenby_" </a>"
            }
            Set menu=menu_"</div>"
            Do ..wrapAtomHTML(keywordatom,menu,"")
        }
    }

    /*
    Element=TypeClassReference PXW.DEV.BNF.Element @134
    .Element=ClassReference PXW.DEV.BNF.Element @310
    ..type=ClassReference:
    .. %String
    .Element=TypeParameters PXW.DEV.BNF.Element @208
    ..type=punctuation:
    .. (
    ..Element=TypeParametersList PXW.DEV.BNF.Element @86
    ...Element=TypeParameterItem PXW.DEV.BNF.Element @385
    ....Element=ClassItemIdentifier PXW.DEV.BNF.Element @347
    .....type=ClassItemIdentifier:
    ..... MAXLEN
    ....type=punctuation:
    .... =
    ....Element=Number PXW.DEV.BNF.Element @309
    .....type=Number:
    ..... 1
    ..type=punctuation:
    .. )
    */
    If element.type="TypeClassReference" {
        Set crefE=element.findFirstElementByType("ClassReference",0)
        If $ISOBJECT(crefE) {
            Set class=crefE.ToString(0)
        
            Set paramE=element.findFirstElementByType("TypeParameters",0)
            If $ISOBJECT(paramE) {
                Set list=##class(%ListOfObjects).%New()
                Do paramE.findElementsByType("ClassItemIdentifier",list,2)
                For i=1:1:list.Count() {
                    Set itemE=list.GetAt(i)
                    If $LISTFIND($LISTFROMSTRING("Property","Relationship"),..ThisItemType) {
                        Do ..wrapElementHTML(itemE,"<a href='"_..HREFToClass(..This,..ThisMethod,itemE.ToString(0))_"'>","</a>")
                    } Else {
                        Do ..wrapElementHTML(itemE,"<a href='"_..HREFToClass(class,itemE.ToString(0))_"'>","</a>")
                    }
                }
            }
        }
    }


    If element.type="ClassItemIdentifier" {
        Do ..wrapElementHTML(element,"<span class='CDEFMember'>","</span>")
    }

    If element.type="FormalSpecList" {
        Do ..wrapElementHTML(element,"<span class='CDEFFormalSpecList'>","</span>")
    }
    If element.type="FormalSpecItem" {
        Do ..wrapElementHTML(element," <span class='CDEFFormalSpecItem'>","</span>") ; note the space BEFORE the span starts, ensures the new item wraps onto next line if necessary
    }


    If element.type="OneClassmember" {
	    Set ..Analyser=##class(PXW.DEV.BNF.Analyse.COS).%New(..ClassServer)
        Set ..Analyser.This=..This
        Do ..Analyser.middle(element)
	}
]]></Implementation>
</Method>

<Method name="FollowObjectChainForType">
<FormalSpec>ParentElement:PXW.DEV.Element,StartClassName:%String</FormalSpec>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    If (ParentElement.type="ThisObject") || (ParentElement.type="ThisObjectSet") {
        Set this=ParentElement.findFirstElementByType("ThisObjectSelf",0) ; ..property
        If $ISOBJECT(this) {
            Set objectchain=this.findFirstElementByType("ObjectChainNoDot",0)
        } Else {
            Set this=ParentElement.findFirstElementByType("ThisObjectThis",0) ; $this.property
            If $ISOBJECT(this) {
                Set objectchain=this.findFirstElementByType("ObjectChain",0)
            }
        }
    } ElseIf (ParentElement.type="ThisObjectDirectProperty") || (ParentElement.type="ThisObjectDirectPropertySet") {
        Set objectchain=ParentElement.findFirstElementByType("ObjectChainItem",0) ; i%property
    } Else {
        Set objectchain=ParentElement.findFirstElementByType("ObjectChain",1) ; var.property
    }
    Set path=""
    While $IsObject(objectchain) {
        
        Set propertyatom=""
        ; the objectchain has the "." and the name
        For  {
            Set a=objectchain.partsGetNext(.akey)
            Quit:akey=""

            If a.%IsA("PXW.DEV.Atom"),a.value'="." {
                Set propertyatom=a
            }
        }

        Set path=path_"."_propertyatom.value
		Do ..wrapAtomHTML(propertyatom,"<a class='COSObjectMember' href='"_..HREFToClass(StartClassName,path)_"'>","</a>")

        Set objectchain=objectchain.findFirstElementByType("ObjectChain",0) 
    }
    $$$DEBUGMethodEnd
]]></Implementation>
</Method>

<Method name="FollowImplicitJoins">
<FormalSpec>ColumnReference:PXW.DEV.Element,fulltable:%String</FormalSpec>
<Implementation><![CDATA[
    #dim crefimpE as PXW.DEV.Element

    ; SELECT Race->Circuit->Location 
    ;Element=ColumnReference PXW.DEV.BNF.Element @121511
    ;.Element=ColumnName PXW.DEV.BNF.Element @121378
    ;..type=ColumnName:
    ;.. Race
    ;.Element=ColumnReferenceImplicit PXW.DEV.BNF.Element @121631
    ;..Element=ColumnReferenceImplicitRep8 PXW.DEV.BNF.Element @121505
    ;...type=punctuation:
    ;... ->
    ;...Element=ColumnName PXW.DEV.BNF.Element @120864
    ;....type=ColumnName:
    ;.... Circuit
    ;...type=punctuation:
    ;... ->
    ;...Element=ColumnName PXW.DEV.BNF.Element @121266
    ;....type=ColumnName:
    ;.... Location
    
    ;Set aliasNameE=ColumnReference.findFirstElementByType("AliasName",1) ; hmm, in a group, can we promote in bnf?
    
    Set columnNameE=ColumnReference.findFirstElementByType("ColumnName",0)
    Set crefimpE=ColumnReference.findFirstElementByType("ColumnReferenceImplicit",0)
    Do ..wrapElementHTML(columnNameE,"<a class='COSObjectMember' href='"_..HREFToClass(fulltable,columnNameE.ToString(0))_"'>","</a>")
    If $ISOBJECT(crefimpE) {
        Set fulref=columnNameE.ToString(0)_"->"
        Set cols=##class(%ListOfObjects).%New()
        Do crefimpE.findElementsByType("ColumnName",.cols,2)
        For i=1:1:cols.Count() {
            Set ij=cols.GetAt(i)
            Set fulref=fulref_ij.ToString(0)
            Do ..wrapElementHTML(ij,"<a class='COSObjectMember' href='"_..HREFToClass(fulltable,fulref)_"'>","</a>")
            Set fulref=fulref_"->"
        }
    }
]]></Implementation>
</Method>

<Method name="wrapCommentBlock">
<Description>
Here is line 1 of the description
Here is line 2 
below is a comment block that is not related </Description>
<FormalSpec>Element:PXW.DEV.Element,preValue:%String="",postValue:%String="",subAtom:PXW.DEV.Atom</FormalSpec>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    Set isFirstCall=0
    ; atom is what is being wrapped
    ; subatom is what we are currently processing
    ;i '$d(subAtom) { s subAtom=Element.partsGetAt(1),isFirstCall=1 }
    If '$DATA(subAtom) { Set subAtom=Element.FirstAtom(),isFirstCall=1 }
    If 
    ; this is going it do a load of inserts of the comment block as PRE the first atom
    Do ..wrapElementHTML(Element,preValue,"")
	If $ISOBJECT(subAtom.whitespace) {
		Do ..wrapCommentBlock(Element,,,subAtom.whitespace)
        ; clear the whitespace as we are don't want it out again
        Set subAtom.whitespace=""
	}
	If $ISOBJECT(subAtom.comment) {
		Do ..wrapCommentBlock(Element,,,subAtom.comment)
        ; clear the comment as we are don't want it out again
        Set subAtom.comment=""
	}
	
	If 'isFirstCall {
        If ..Style.CDEFDescriptionsAsText {
            Do ..wrapAtomHTML(Element,..html(subAtom.start_subAtom.value_subAtom.end),"")
        } Else {
            ; output the comment as HTML (ie do not turn it into html)
            ; also remove any /// (which simply means do not output the start and end of the atom)
            If 'isFirstCall Do ..wrapAtomHTML(Element,subAtom.value,"")
        }
    }

    ; don't forget ALL of this is PRE the atom, including the post value!
    Do ..wrapAtomHTML(Element,postValue,"")
    $$$DEBUGMethodEnd
]]></Implementation>
</Method>

<Method name="writeAtom">
<Description>
the only method that should actually do any output during the middle processing</Description>
<FormalSpec>atom:PXW.DEV.Atom,preValue:%String="",postValue:%String="",isWhitespace:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
    /* XML (and storage) */
    Set type=$PIECE(atom.type,":",1)
    If type="XmlTagSA" {   ; <
        Set ..xmlIndent=..xmlIndent+1
    } ElseIf type="XmlTagEB" {  ; >
        Set ..xmlIndent=..xmlIndent-1
    } ElseIf type="XmlTagSC" {  ; />
        Set ..xmlIndent=..xmlIndent-1
    }
	If isWhitespace {
		; make the indent out of tabs
        Set indent=""
		Set $PIECE(indent,$CHAR(9),..xmlIndent+1)=""
		Set atom.value=$REPLACE(atom.value,$CHAR(13),$CHAR(13)_indent)
	}	
    Do ##super(atom,preValue,postValue,isWhitespace)
    $$$DEBUGMethodEnd
]]></Implementation>
</Method>

<Method name="HREFToClass">
<FormalSpec>Class:%String,Method:%String="",PropertyParameter:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Quit ##class(PXW.Tools.DEV.Class).HREFTo(Class,Method,,%NS,..This,PropertyParameter)
]]></Implementation>
</Method>

<Method name="HREFToInclude">
<FormalSpec>Include:%String="",MacroName:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Quit ##class(PXW.Tools.DEV.Include).HREFTo(Include,..This,MacroName) ; ,Method,,%NS,..This)
]]></Implementation>
</Method>

<Method name="HREFToPython">
<FormalSpec>Module:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Quit ##class(PXW.Tools.DEV.PythonModule).HREFTo(Module)
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.HTML.output">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77563.930580098</TimeChanged>
<TimeCreated>67125,77563.930580098</TimeCreated>

<Parameter name="CommentClass">
<Description>
Set this to a style class name</Description>
</Parameter>

<Parameter name="WarningClass">
<Description>
Set this to a style class name</Description>
</Parameter>

<Property name="This">
<Description>
Name of the main thing being written</Description>
<Type>%String</Type>
</Property>

<Property name="ThisMethod">
<Description>
Name of the sub thing being written</Description>
<Type>%String</Type>
</Property>

<Property name="Analyser">
<Type>PXW.DEV.BNF.Compilers.analyser</Type>
</Property>

<Property name="WriteMode">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="Embedded">
<Description>
Does this need things like the PRE tags?</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="htmlout">
<Type>%String</Type>
</Property>

<Property name="HiLiteLine">
<Description>
If the atom is on this line (number) then we should highlight it</Description>
<Type>%Integer</Type>
</Property>

<Property name="BookMark">
<Description>
Set this to the name of something to bookmark (highlight and anchor)</Description>
<Type>%String</Type>
</Property>

<Property name="pre">
<Description>
complicated structure, best to use wrapAtomHTML method to update</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="post">
<Description>
complicated structure, best to use wrapAtomHTML method to update</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="preI">
<Description>
complicated structure, best to use wrapInnerAtomHTML method to update</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="postI">
<Description>
complicated structure, best to use wrapInnerAtomHTML method to update</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="wrapInnerAtomHTML">
<FormalSpec>atom:PXW.DEV.Atom,pre:%String,post:%String</FormalSpec>
<Implementation><![CDATA[
    Set n=$GET(..preI(+atom)),n=n+1,..preI(+atom,n)=pre,..preI(+atom)=n
    Set n=$GET(..postI(+atom)),n=n+1,..postI(+atom,n)=post,..postI(+atom)=n
]]></Implementation>
</Method>

<Method name="wrapAtomHTML">
<FormalSpec>atom:PXW.DEV.Atom,pre:%String,post:%String</FormalSpec>
<Implementation><![CDATA[
    Set n=$GET(..pre(+atom)),n=n+1,..pre(+atom,n)=pre,..pre(+atom)=n
    Set n=$GET(..post(+atom)),n=n+1,..post(+atom,n)=post,..post(+atom)=n
]]></Implementation>
</Method>

<Method name="wrapElementHTML">
<FormalSpec>element:PXW.DEV.Element,pre:%String,post:%String</FormalSpec>
<Implementation><![CDATA[
	; on elements don't wrap the whitespace
	Set n=$GET(..pre(+element)),n=n+1,..pre(+element,n)=pre,..pre(+element)=n
    ;set atom=element.FirstAtom()
	Set n=$GET(..post(+element)),n=n+1,..post(+element,n)=post,..post(+element)=n
]]></Implementation>
</Method>

<Method name="output">
<Description>
Output the html directly to destination. No escaping or other formatting is done.</Description>
<FormalSpec>html:%String</FormalSpec>
<Implementation><![CDATA[
	If ..WriteMode {
		Write html
		;s ^PXW("out",$i(^PXW))=html
	} Else {
		Set ..htmlout=..htmlout_html	
	}
]]></Implementation>
</Method>

<Method name="resetWrappers">
<Implementation><![CDATA[	Kill ..pre,..post,..preI,..postI
]]></Implementation>
</Method>

<Method name="html">
<FormalSpec>string:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $ZCONVERT(string,"O","HTML")
]]></Implementation>
</Method>

<Method name="writeElement">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
	Set n=+$GET(..pre(+element))
    For i=1:1:n Do ..output($GET(..pre(+element,i)))
	For  {
		Set a=element.partsGetNext(.akey)
		Quit:akey=""
		
		If a.%IsA("PXW.DEV.Element") {
			Do ..writeElement(a)
		} Else {
			Do ..writeAtom(a)
		}
	}
    Set n=+$GET(..post(+element))
    For i=n:-1:1 Do ..output($GET(..post(+element,i)))
]]></Implementation>
</Method>

<Method name="writeAtom">
<Description>
the only method that should actually do any output during the middle processing</Description>
<FormalSpec>atom:PXW.DEV.Atom,preValue:%String="",postValue:%String="",isWhitespace:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	If $ISOBJECT(atom.whitespace) {
		Do ..writeAtom(atom.whitespace,"<span class=whitespace>","</span>",1)
	}
	If $ISOBJECT(atom.comment) {
		Do ..writeAtom(atom.comment,"<span class='"_..#CommentClass_"'>","</span>")
	}

	; add hilite on whitespace (OR ANYTHING) that is NOT going over more than 1 line
	If ..HiLiteLine'="",atom.line=..HiLiteLine,atom.value'[$CHAR(13) {
		Set preValue="<span class='hilite'>"_preValue
		Set postValue=postValue_"</span>"
	}
	
	If $ISOBJECT(..Analyser),$DATA(..Analyser.ElementWarnings(+atom)) {
		Set line=..Analyser.ElementWarnings(+atom)
		Set preValue="<span class='"_..#WarningClass_"' title='"_$ZCONVERT(line,"O","HTML")_"'>"_preValue
		Set postValue=postValue_"</span>"
	}

    Set n=+$GET(..pre(+atom))
    For i=1:1:n Do ..output($GET(..pre(+atom,i)))
    Do ..output(preValue_..html(atom.start))
	    Set n=+$GET(..preI(+atom))
	    For i=1:1:n Do ..output($GET(..preI(+atom,i)))
	    Do ..output(..html(atom.value))
	    Set n=+$GET(..postI(+atom))
	    For i=n:-1:1 Do ..output($GET(..postI(+atom,i)))
	Do ..output(..html(atom.end)_postValue)
    Set n=+$GET(..post(+atom))
    For i=n:-1:1 Do ..output($GET(..post(+atom,i)))
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.Include">
<Super>PXW.Tools.DEV.CodeDisplayPage</Super>
<TimeChanged>67129,60754.838557683</TimeChanged>
<TimeCreated>67125,77563.836021025</TimeCreated>

<Parameter name="CodeType">
<Default>INC</Default>
</Parameter>

<Method name="WriteMainBody">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[
	Do ..HREFFrom(.inc,.cc,.macro,.debug)

	If inc["*" Do ..WriteIncludeDir(inc) Quit
    If inc="",cc'="" {
		Set inc=..GetIncludeFileName(.macro)
    }
    If inc'="" {
	    Do ..WriteInclude(inc,macro,debug,.scratch)
    }
]]></Implementation>
</Method>

<Method name="GetIncludeFileName">
<ClassMethod>1</ClassMethod>
<FormalSpec>*macroname</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Do ..HREFFrom(.inc,.cc,.macroname)
    If inc="",cc'="" {
        Set cs=##class(PXW.DEV.Dictionary.ClassDefinitionObject).%OpenId(%NS)
		Set macroname=$PIECE(macroname,"(",1)
		If macroname?1"$$$" Set macroname=$PIECE(macroname,"$$$",2)
        If cs.GetMacroLocation(cc,macroname,.inc,.line) {
            ;w !,"Macro "_macro_" for "_cc_" found "_inc
            If $PIECE(inc,".",*)="inc" Set inc=$PIECE(inc,".",1,*-1)
        } Else {
        }
    }
	Quit inc
]]></Implementation>
</Method>

<Method name="WriteInclude">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Include:%String,MacroToHilite:%Integer="",Debug:%String,&scratch]]></FormalSpec>
<Implementation><![CDATA[
	New %path
	If $PIECE(Include,".",*)="INC" Set Include=$PIECE(Include,".",1,*-1)

	Set sc=##class(PXW.DEV.Dictionary.Include).GetIncludeStudioText(Include,.text,.linesOfCode)
	If $$$ISOK(sc) {
		;s parser=##class(PXW.DEV.ClassDefinition.Parser).NewFromString(text)

		Write "<pre>"
		Set output=##class(PXW.Tools.DEV.HTML.bnf).%New()
		Set output.This=Include
		Set output.ThisType="INC"
        Set output.BookMark=MacroToHilite
		; we can attempt to analyse as if it was COS
		Set output.Analyser=##class(PXW.DEV.BNF.Analyse.COS).%New()
		Set output.Analyser.ClassServer=##class(PXW.DEV.Dictionary.ClassDefinitionObject).OpenNamespace(%NS)
		Set scratch=output
		If Debug="$PATHS" Set output.showPaths=1,%path=""

		Set element=##class(PXW.DEV.Element).%New()
        Set x=##class(PXW.DEV.BNF.Run.COS).%New()
        Set x.stream=##class(PXW.DEV.InputStream).NewString(text)
		Try {
			Set ok=x.CosCodeBlock(element)
			If 'ok $$$ThrowStatus($$$ERROR(5001,"Could not parse"))
			Set x.element=element

			; can this be moved back into the output.middle method?
			Do output.Analyser.middle(element)

			Do output.middle(element)
	
		} Catch e {
			Do ..WriteStatus(e.AsStatus())
		}
		;zw zh
		Write "</pre>"
	} Else {
		Do ..WriteStatus(sc)
	}
]]></Implementation>
</Method>

<Method name="WriteIncludeDir">
<ClassMethod>1</ClassMethod>
<FormalSpec>Routine:%String</FormalSpec>
<Implementation><![CDATA[
	; if the input contains % then escape it
	Set rtn=Routine,escape=""
	/*i rtn["%" {
		s escape="\"
		s cls=$replace(cls,"%",escape_"%")
	}
	i cls["_" {
		s escape=$g(escape,"\")
		s cls=$replace(cls,"_",escape_"_")
	}
	s cls=$replace(cls,"*","%") ; make the selection a LIKE compatible thing
	*/
	Set rs=##class(PXW.DEV.Dictionary.Include).ListIncludes(rtn,escape)
	 
	Write "<table>"
	Write "<thead>"
	Write "<tr><th>Type</th><th>Name</th><th>Modified</th></tr>"
	Write "</thead><tbody>"
	While rs.%Next() {
		Write "<tr>"
		Write "<td>"_..EscapeHTML(rs.%Get("Lang"))_"</td>"
		Write "<td>"
			Write "<a class='COSObjectsClass' href='"_##class(PXW.Tools.DEV.Include).HREFTo(rs.%Get("Name"))_"'>"
			Write ..EscapeHTML(rs.%Get("Name")) 
			Write "</a>"
		Write "</td>"
		Write "<td>"_..EscapeHTML(rs.%Get("Date"))_"</td>"
		Write "</tr>",!
	}
	Write "</tbody></table>"
]]></Implementation>
</Method>

<Method name="WriteNav">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[
	
	If $ISOBJECT($GET(scratch)) {
		Set output=scratch
		While output.NextIndexItemByName(.name,.type,.anchor,.error) {
				;w "<tr>"
				;w "<td>"
				If error="" {
					Write "<a class='"_"CDEF"_type_"' href=#"_anchor_">"_..EscapeHTML(name)_"</a>"
				} Else {
					Write "<a class='"_output.#WarningClass_"' href=#"_anchor_">"_..EscapeHTML(name)_"</a>"
				}
				;w "</td>"
				;w "<td>"_..EscapeHTML(type)_"</td>"
				;w "<td>"_..EscapeHTML(anchor)_"</td>"
				;w "</tr>",!
		}
		Write "<hr>"
	}
    Write "<span class=button href=# onclick='MakeStringsInteresting(); '>Strings</span>"
]]></Implementation>
</Method>

<Method name="HREFTo">
<ClassMethod>1</ClassMethod>
<FormalSpec>Include:%String="",CallingClass:%String="",Macro:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set href=##super()
	Set sep="&"
	If Include'="" Set href=href_sep_"I="_..EscapeURL(Include)
    If CallingClass'="" Set href=href_sep_"CC="_..EscapeURL(CallingClass)
    If Macro'="" {
        If Macro?1"$$$".E {
            Set href=href_sep_"M="_..EscapeURL($PIECE(Macro,"$$$",2))
        } Else {
            Set href=href_sep_"M="_..EscapeURL(Macro)
        }
    }

	; must go last
	If Macro'="" Set href=href_"#BookMark"
	Quit href
]]></Implementation>
</Method>

<Method name="HREFFrom">
<ClassMethod>1</ClassMethod>
<FormalSpec>*Include:%String,*CallingClass:%String,*Macro:%String,*Debug:%String</FormalSpec>
<Implementation><![CDATA[
	Set Include=%request.Get("I")
	Set CallingClass=%request.Get("CC")
	Set Macro=%request.Get("M")
	Set Debug=%request.Get("DEBUG")
]]></Implementation>
</Method>

<Method name="GetTitle">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set inc=..GetIncludeFileName(.macro)
	Set inc=inc_".INC"
	If $GET(macro)'="" Set inc=inc_":"_macro
	Quit inc
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.PythonModule">
<Super>PXW.Tools.Page</Super>
<TimeChanged>67125,77563.84768234</TimeChanged>
<TimeCreated>67125,77563.84768234</TimeCreated>

<Parameter name="ToolType">
<Default>Code</Default>
</Parameter>

<Method name="WriteMainBody">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[
	Do ..HREFFrom(.cls,.debug)
    Set bookmark=""
    Set linenumber=""
	Do ..WriteClass(cls,debug,bookmark,linenumber,.scratch) 
	Quit
]]></Implementation>
</Method>

<Method name="HREFFrom">
<ClassMethod>1</ClassMethod>
<FormalSpec>*Class:%String,*Debug:%String</FormalSpec>
<Implementation><![CDATA[
	#define ReqGet(%name) %request.Get(%name)
	Set Class=$$$ReqGet("C")
    Set Debug=$$$ReqGet("DEBUG")
]]></Implementation>
</Method>

<Method name="HREFTo">
<ClassMethod>1</ClassMethod>
<FormalSpec>Class:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set href=##super()
	Set sep="&"
	Set href=href_sep_"C="_..EscapeURL(Class)
    Quit href
]]></Implementation>
</Method>

<Method name="WriteClass">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[ClassName:%String,Debug:%String,bookMark:%String="",hiliteLineNo:%Integer,&scratch]]></FormalSpec>
<Implementation><![CDATA[
	New %path
	Kill %pxw1
	#dim ele,element as PXW.DEV.Element
	Set zh=$ZHOROLOG
    Set output=##class(PXW.Tools.DEV.HTML.bnf).%New()
	Set output.ClassServer=##class(PXW.DEV.Dictionary.ClassDefinitionObject).%OpenId(%NS)

	Set showPaths=0
    Write "<pre>"
	If +Debug=1 $$$DEBUGNew(##class(PXW.Debuggers.Tools).%ClassName(1))
	If Debug["$TIME" $$$DEBUGNew(##class(PXW.Debuggers.Timing).%ClassName(1))
	If Debug["$FILE" $$$DEBUGNew(##class(PXW.Debuggers.BasicToFile).%ClassName(1)) 
	If Debug["$PATHS" Set showPaths=1,%path="" ; no need to set any output its just for tooltips
	
	;s sc=output.ClassServer.GetClassStudioText(ClassName,.text,.linesOfCode,.timestamp)
    Set pythonserver=##class(PXW.DEV.Dictionary.PythonObject).%OpenId(%NS)
    Set sc=pythonserver.GetModule(ClassName,.text,.linesOfCode,.lastUpdate)
	Set zh(1,"load")=$ZHOROLOG-zh,zh=$ZHOROLOG

	If $$$ISOK(sc) {
		If Debug'="" {
			; display the original text from the server
			Write "<pre>"
            Write "loaded",!
			;zw text,linesOfCode
			Set ln=""
			For  {
				Set ln=$ORDER(linesOfCode(ln))
				Quit:ln=""
				Write !,"<span class=nocopy>"_ln_":"_"</span>"_..EscapeHTML(linesOfCode(ln))
			}
			Write "</pre>"
		}
		Set zh(2,"display")=$ZHOROLOG-zh,zh=$ZHOROLOG

        Set element=##class(PXW.DEV.Element).%New()
		If Debug["$NEW" {
			Write "running in new mode"
        	;s x=##class(PXW.DEV.BNF.Run.ClassDefinitionAuto).%New()
		} Else {
			Set x=##class(PXW.DEV.BNF.Run.Python).%New()
		}
        Set x.stream=##class(PXW.DEV.InputStream).NewString(text)
		Set zh=$ZHOROLOG

		Set output.This=ClassName
		Set output.HiLiteLine=hiliteLineNo
		Set output.BookMark=bookMark
		Set output.showPaths=showPaths
        Do output.begin()
		Set scratch=output
		Set zh(4,"render")=$ZHOROLOG-zh,zh=$ZHOROLOG

		Set element=##class(PXW.DEV.Element).%New()
        /*		while x.cheese(element) {
			;d element.write("")
			d output.middle(element)
			;zw output.Analyser
			s element=##class(PXW.DEV.Element).%New()
		}*/
        If x.File(element) {
        	If Debug["$OUTFILE" {
                $$$DEBUGNew(##class(PXW.Debuggers.BasicToFile).%ClassName(1)) 
                #dim deb as PXW.Debuggers.BasicToFile=%pxwdebug
                Do deb.UseFile() Do element.writeFull() Do deb.UseIO()
            }
            Do output.middle(element)
		    Do output.end()
        } Else {
            Write "Failed to parse",!
            Do element.write()
            Do output.middle(element)
    	    Do output.end()
        }

		Set zh(5,"render end")=$ZHOROLOG-zh,zh=$ZHOROLOG

		;Set xref=##class(PXW.Xref.Build).%New()
		;zw ClassName,timestamp
		;d xref.xrefClassIfNecessary(%NS,ClassName,timestamp,0,text)

		;Set zh(6,"xref")=$ZHOROLOG-zh,zh=$ZHOROLOG
		Kill element,x,output

	} Else {
		Do ..WriteStatus(sc)
		;s xref=##class(PXW.Xref.Build).%New()
		;d xref.xrefClassIfNecessary(ClassName,"",0)

	}
	If Debug["$TIME" {
		
		Set s="" For  Set s=$ORDER(%pxwstrings(s),1,n) Quit:s=""  Set %pxwstringsX(n,s)=""
		Write "<pre>" ZWrite %pxwstrings,%pxwstringsX,%pxw1,%RBCOUNT Write "</pre>"
		Set totaltime=0,totalcalls=0
		Set rs=##clasS(%Library.ResultSet).%New("PXW.Debuggers.Timing:SelectResults")
		$$$THROWONERROR(sc,rs.%Execute())
		&html<<table filename="Timings.csv">
			<tr><th>ClassName</th><th>MethodName</th><th>TotalTime</th><th>CountOfCalls</th><th>AverageTime</th><th>PercentageOfTime</th></tr>>
		While rs.%Next() {
			Set time=rs.Get("TotalTime"),totaltime=totaltime+time
			Set calls=rs.Get("CountOfCalls"),totalcalls=totalcalls+calls
			Write "<tr>"
			Write "<td>"_..EscapeHTML(rs.Get("ClassName"))_"</td>"
			Write "<td>"_"<a href='"_..HREFTo(rs.Get("ClassName"),rs.Get("MethodName"))_"'>"_..EscapeHTML(rs.Get("MethodName"))_"</a>"_"</td>"
			Write "<td style='text-align:right;'>"_$JUSTIFY(time,0,6)_"</td>"
			Write "<td style='text-align:right;'>"_calls_"</td>"
			Write "<td style='text-align:right;'>"_$JUSTIFY(rs.Get("AverageTime"),0,6)_"</td>"
			Write "<td style='text-align:right;'>"_$JUSTIFY(rs.Get("PercentageOfTime"),0,6)_"</td>"
			Write "</tr>",!
		}
		Write "<tr>"
		Write "<td>Total"_"</td>"
		Write "<td>"_"</td>"
		Write "<td style='text-align:right;'>"_$JUSTIFY(totaltime,0,6)_"</td>"
		Write "<td style='text-align:right;'>"_totalcalls_"</td>"
		Write "<td style='text-align:right;'>"_""_"</td>"
		Write "<td style='text-align:right;'>"_""_"</td>"
		Write "</tr>",!
		&html<</table>>
	} Else {
		;w "<pre>" zw %pxwstrings,%pxwstringsX,%pxw1 
		;w !,"$s="_$s
		;w "</pre>"
		
	}
	If Debug="$FILE" {
		ZWrite %pxwdebug
	}
	;d %session.EndSession()
	;zw zh
    Write "</pre>"
]]></Implementation>
</Method>

<Method name="WriteNav">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[
	
	If $ISOBJECT($GET(scratch)) {
		Set output=scratch
		While output.NextIndexItemByName(.name,.type,.anchor,.error) {
				;w "<tr>"
				;w "<td>"
				If error="" {
					;w "<span class=toolsMainBodyNavItem>"
					Write "<a onclick='HiliteElement("""_anchor_"SPAN"");' class='"_"CDEF"_type_"' href=#"_anchor_">"_..EscapeHTML(name)_"</a>"
					;w "</span>"
				} Else {
					;w "<span class=toolsMainBodyNavItem>"
					Write "<a onclick='HiliteElement("""_anchor_"SPAN"");' class='"_output.#WarningClass_"' href=#"_anchor_">"_..EscapeHTML(name)_"</a>"
					;w "</span>"
				}
				;w "</td>"
				;w "<td>"_..EscapeHTML(type)_"</td>"
				;w "<td>"_..EscapeHTML(anchor)_"</td>"
				;w "</tr>",!
		}
		Write "<hr>"
	}
    Write "<a href=# onclick='MakeStringsInteresting(); '>Strings</a>"
]]></Implementation>
</Method>

<Method name="WriteScripts">
<Description>
Write out extra javascript here, the SCRIPT tags are already in place</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Write "function edit(clsname) {"
	Write " 	var editor=window.frames['editor'];",!
	Write "		debugger; ",!
	Write "		if (!editor) {",!
	Write "			editor=window.open('/cloudstudio/CloudStudio.PXW.cls?C='+clsname+'.cls','editor');",!
	Write "		}",!
	Write "",!
	Write "",!
	Write "",!
	Write "",!
	Write "",!
	Write "}",!

	Write "var hiliterun=1;"
	Write "function HiliteSets(id) {",!
	Write "    var objs=document.getElementsByTagName('span');",!
	Write "    var cls='hiliteSET'+hiliterun;",!
	Write "    var clsf='hiliteGET'+hiliterun;",!
	Write "    for (var i=0; i<objs.length; i++) {",!
	Write "      if (objs[i].getAttribute('varid')==id) objs[i].className=cls; //",! ;objs[i].className+' '+cls;",!
	Write "      if (objs[i].getAttribute('fetchid')==id) objs[i].className=clsf; //",! ;objs[i].className+' '+cls;",!
	Write "    }",!
	Write "    hiliterun=hiliterun+1; if (hiliterun>9) hiliterun=1;",!
	Write "}",!


	Write "function HiliteElement(id) {",!
	Write "    var obj=document.getElementById(id);",!
	Write "    obj.className='hilite';",!
	Write "}",!


	Write "function MakeStringsInteresting(id) {",!
	Write "    var objs=document.getElementsByTagName('span');",!
	Write "    var clsOFF='unInteresting'",!
	Write "    var clsHALF='quiteInteresting'",!
	Write "    var clsON='veryInteresting'",!
	Write "    for (var i=0; i<objs.length; i++) {",!
	Write "      if (objs[i].className=='EmbeddedPython') {",!
	Write "          objs[i].className=objs[i].className+' '+clsOFF; //",! ;objs[i].className+' '+cls;",!
	Write "      }",!
	Write "      if (objs[i].className=='COSString') {",!
	Write "          objs[i].className=objs[i].className+' '+clsON; //",! ;objs[i].className+' '+cls;",!
	Write "      }",!
	Write "      if (objs[i].className=='whitespace') {",!
	Write "          objs[i].className=objs[i].className+' '+clsHALF; //",! ;objs[i].className+' '+cls;",!
	Write "      }",!
	Write "    }",!
	Write "}",!


 /*
	write "function showUndefs() {",!
	write "		for (var s=0; s<document.styleSheets.length; s++) {",!
	write "			var ss=document.styleSheets[s];",!
	write "			var rules;",!
	write "			if (ss.rules) rules=ss.rules;",!
	write "			if (ss.cssRules) rules=ss.cssRules;",!
	write "			for (var r=0; r<rules.length; r++) {",!
	write "				var rule=rules[r];",!
	write "				if (rule.selectorText) {",!
	write "					if (rule.selectorText=='.unset') rule.style.backgroundColor='darkcyan';",!
	write "				}",!
	write "			}",!
	write "		}",!
	write "	}",!

	write "function showTypos() {",!
	write "		for (var s=0; s<document.styleSheets.length; s++) {",!
	write "			var ss=document.styleSheets[s];",!
	write "			var rules;",!
	write "			if (ss.rules) rules=ss.rules;",!
	write "			if (ss.cssRules) rules=ss.cssRules;",!
	write "			for (var r=0; r<rules.length; r++) {",!
	write "				var rule=rules[r];",!
	write "				if (rule.selectorText) {",!
	write "					if (rule.selectorText.indexOf('.typo')>-1) rule.style.backgroundColor='#F0E0C0';",!
	write "				}",!
	write "			}",!
	write "		}",!
	write "	}",!

	write "function showSubscripts() {",!
	write "		for (var s=0; s<document.styleSheets.length; s++) {",!
	write "			var ss=document.styleSheets[s];",!
	write "			var rules;",!
	write "			if (ss.rules) rules=ss.rules;",!
	write "			if (ss.cssRules) rules=ss.cssRules;",!
	write "			for (var r=0; r<rules.length; r++) {",!
	write "				var rule=rules[r];",!
	write "				if (rule.selectorText) {",!
	write "					if (rule.selectorText=='.subscript') rule.style.backgroundColor='pink';",!
	write "				}",!
	write "			}",!
	write "		}",!
	write "	}",!

	&js<
	function AutoIndent() {
		var objs=document.getElementsByTagName('span');
	    for (var i=0; i!=objs.length; i++) {
		    var indent=objs[i].getAttribute('indent');
		    if ((indent!='')&&(indent!=null)) {
			    var str="";
			    for (var j=0; j!=parseInt(indent); j++) str=str+"&nbsp;&nbsp;&nbsp;&nbsp;";
			    objs[i].innerHTML=str;
		    }
	    }
	}
	>
	*/
]]></Implementation>
</Method>

<Method name="GetTitle">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Do ..HREFFrom(.class)
	Set method=""
	If method'="" {
		Quit class_":"_method_""
	} Else {
		Quit class
	}
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.Routine">
<Super>PXW.Tools.DEV.CodeDisplayPage</Super>
<TimeChanged>67125,77563.851648025</TimeChanged>
<TimeCreated>67125,77563.851648025</TimeCreated>

<Parameter name="CodeType">
<Default>INT</Default>
</Parameter>

<Method name="WriteMainBody">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Do ..HREFFrom(.rtn,.lbl,.plus,.debug)
	If rtn["*" Do ..WriteRoutineDir(rtn) Quit

	
	Do ..WriteRoutine(rtn,lbl,plus,.debug)
]]></Implementation>
</Method>

<Method name="WriteRoutine">
<ClassMethod>1</ClassMethod>
<FormalSpec>Routine:%String,Label:%String="",Plus:%String="",Debug:%String=""</FormalSpec>
<Implementation><![CDATA[
	If $PIECE(Routine,".",*)="INT" Set Routine=$PIECE(Routine,".",1,*-1)

	Set zh=$ZHOROLOG
	Set sc=##class(PXW.DEV.Dictionary.Routine).GetRoutineStudioText(Routine,.text,.linesOfCode)
	Set zh(1)=$ZHOROLOG-zh,zh=$ZHOROLOG
	If $$$ISOK(sc) {
		;s parser=##class(PXW.DEV.ClassDefinition.Parser).NewFromString(text)

		Write "<pre>"
		Set output=##class(PXW.Tools.DEV.HTML.bnf).%New()
		Set output.HiliteLabel=Label
		Set output.HilitePlus=Plus

		If Debug="$PATHS" Set output.showPaths=1

		Set element=##class(PXW.DEV.Element).%New()
        Set x=##class(PXW.DEV.BNF.Run.COS).%New()
        Set x.stream=##class(PXW.DEV.InputStream).NewString(text) 
		Set zh(2)=$ZHOROLOG-zh,zh=$ZHOROLOG
		Try {
			Set ok=x.CosCodeBlock(element)
			If 'ok $$$ThrowStatus($$$ERROR(5001,"Could not parse"))
			Set zh(3)=$ZHOROLOG-zh,zh=$ZHOROLOG
			Set x.element=element

			Set zh(4)=$ZHOROLOG-zh,zh=$ZHOROLOG
			Do output.middle(element)
			Set zh(5)=$ZHOROLOG-zh,zh=$ZHOROLOG

		} Catch e {
			Do ..WriteStatus(e.AsStatus())
		}
		ZWrite zh
		Write "</pre>"
	} Else {
		Do ..WriteStatus(sc)
	}
]]></Implementation>
</Method>

<Method name="WriteRoutineDir">
<ClassMethod>1</ClassMethod>
<FormalSpec>Routine:%String</FormalSpec>
<Implementation><![CDATA[
	; if the input contains % then escape it
	Set rtn=Routine,escape=""
	/*i rtn["%" {
		s escape="\"
		s cls=$replace(cls,"%",escape_"%")
	}
	i cls["_" {
		s escape=$g(escape,"\")
		s cls=$replace(cls,"_",escape_"_")
	}
	s cls=$replace(cls,"*","%") ; make the selection a LIKE compatible thing
	*/
	Set rs=##class(PXW.DEV.Dictionary.Routine).ListRoutines(rtn,escape)
	 
	Write "<table>"
	Write "<thead>"
	Write "<tr><th>Type</th><th>Name</th><th>Modified</th></tr>"
	Write "</thead><tbody>"
	While rs.%Next() {
		Write "<tr>"
		Write "<td>"_..EscapeHTML(rs.%Get("Lang"))_"</td>"
		Write "<td>"
			Write "<a class='COSObjectsClass' href='"_##class(PXW.Tools.DEV.Routine).HREFTo(rs.%Get("Name"))_"'>"
			Write ..EscapeHTML(rs.%Get("Name")) 
			Write "</a>"
		Write "</td>"
		Write "<td>"_..EscapeHTML(rs.%Get("Date"))_"</td>"
		Write "</tr>",!
	}
	Write "</tbody></table>"
]]></Implementation>
</Method>

<Method name="HREFTo">
<ClassMethod>1</ClassMethod>
<FormalSpec>Routine:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set href=##super()

	Set rtn=Routine,lbl="",plus=""
	If Routine["^" {
		Set rtn=$PIECE(Routine,"^",2)
		Set labelplus=$PIECE(Routine,"^",1)
		Set lbl=$PIECE(labelplus,"+",1)
		Set plus=$PIECE(labelplus,"+",2)
	}

	Set sep="&"
	Set href=href_sep_"R="_..EscapeURL(rtn)
	If lbl'="" Set href=href_sep_"L="_..EscapeURL(lbl)
	If plus'="" Set href=href_sep_"P="_..EscapeURL(plus)
	If lbl'="" Set href=href_"#Bookmark"
	Quit href
]]></Implementation>
</Method>

<Method name="HREFFrom">
<ClassMethod>1</ClassMethod>
<FormalSpec>*Routine:%String,*Label:%String,*Plus:%String,*Debug:%String</FormalSpec>
<Implementation><![CDATA[
	Set Routine=%request.Get("R")
	Set Label=%request.Get("L")
	Set Plus=%request.Get("P")
	Set Debug=%request.Get("DEBUG")
]]></Implementation>
</Method>

<Method name="GetTitle">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Do ..HREFFrom(.rtn)
	Quit rtn
]]></Implementation>
</Method>

<Method name="WriteScripts">
<Description>
Write out extra javascript here, the SCRIPT tags are already in place</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Write "var hiliterun=1;"
	Write "function HiliteSets(id) {",!
	Write "    var objs=document.getElementsByTagName('span');",!
	Write "    var cls='hiliteSET'+hiliterun;",!
	Write "    var clsf='hiliteGET'+hiliterun;",!
	Write "    for (var i=0; i<objs.length; i++) {",!
	Write "      if (objs[i].getAttribute('varid')==id) objs[i].className=cls; //",! ;objs[i].className+' '+cls;",!
	Write "      if (objs[i].getAttribute('fetchid')==id) objs[i].className=clsf; //",! ;objs[i].className+' '+cls;",!
	Write "    }",!
	Write "    hiliterun=hiliterun+1; if (hiliterun>8) hiliterun=1;",!
	Write "}",!
 /*
	write "function showUndefs() {",!
	write "		for (var s=0; s<document.styleSheets.length; s++) {",!
	write "			var ss=document.styleSheets[s];",!
	write "			var rules;",!
	write "			if (ss.rules) rules=ss.rules;",!
	write "			if (ss.cssRules) rules=ss.cssRules;",!
	write "			for (var r=0; r<rules.length; r++) {",!
	write "				var rule=rules[r];",!
	write "				if (rule.selectorText) {",!
	write "					if (rule.selectorText=='.unset') rule.style.backgroundColor='darkcyan';",!
	write "				}",!
	write "			}",!
	write "		}",!
	write "	}",!

	write "function showTypos() {",!
	write "		for (var s=0; s<document.styleSheets.length; s++) {",!
	write "			var ss=document.styleSheets[s];",!
	write "			var rules;",!
	write "			if (ss.rules) rules=ss.rules;",!
	write "			if (ss.cssRules) rules=ss.cssRules;",!
	write "			for (var r=0; r<rules.length; r++) {",!
	write "				var rule=rules[r];",!
	write "				if (rule.selectorText) {",!
	write "					if (rule.selectorText.indexOf('.typo')>-1) rule.style.backgroundColor='#F0E0C0';",!
	write "				}",!
	write "			}",!
	write "		}",!
	write "	}",!

	write "function showSubscripts() {",!
	write "		for (var s=0; s<document.styleSheets.length; s++) {",!
	write "			var ss=document.styleSheets[s];",!
	write "			var rules;",!
	write "			if (ss.rules) rules=ss.rules;",!
	write "			if (ss.cssRules) rules=ss.cssRules;",!
	write "			for (var r=0; r<rules.length; r++) {",!
	write "				var rule=rules[r];",!
	write "				if (rule.selectorText) {",!
	write "					if (rule.selectorText=='.subscript') rule.style.backgroundColor='pink';",!
	write "				}",!
	write "			}",!
	write "		}",!
	write "	}",!

	&js<
	function AutoIndent() {
		var objs=document.getElementsByTagName('span');
	    for (var i=0; i!=objs.length; i++) {
		    var indent=objs[i].getAttribute('indent');
		    if ((indent!='')&&(indent!=null)) {
			    var str="";
			    for (var j=0; j!=parseInt(indent); j++) str=str+"&nbsp;&nbsp;&nbsp;&nbsp;";
			    objs[i].innerHTML=str;
		    }
	    }
	}
	>
	*/
]]></Implementation>
</Method>

<Method name="WriteStyles">
<Description>
Write out extra styles here, the STYLE tags are already in place</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	;.block { background-color:#f0f0f0; }
	;.comment { color:green; }
 	;.comment .typo { background:none; }
 	;.description { border:1px dotted green; color:black; margin-left:50px; }
	;.description .html { color:black; }
	;.description .typo { background-color:#FFEECC; }
	;.error { background-color:red; color:white; }
	;.endofsection { border-bottom:1px dotted silver; width:100%; }
	;.external { font-weight:bold; }
	;.fetch { cursor:pointer; }
	;PRE.formattedtext { white-space: pre-wrap;       /* css-3 */
	;				white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
 	;				white-space: -pre-wrap;      /* Opera 4-6 */
 	;				white-space: -o-pre-wrap;    /* Opera 7 */
 	;				word-wrap: break-word;       /* Internet Explorer 5.5+ */
	;			}
	;A.global:visited { color:red; }
	;.global { color:red; }
	;.hiddennew { display:none; }
	&html<
	.hiliteSET { background-color:lightgreen; }
	.hiliteSET1 { background-color:#EFEF00; } /* don't like this (numbers on each class) but cant get .parameters .parameters selector to work */
	.hiliteSET2 { background-color:#DF00DF; }
	.hiliteSET3 { background-color:#00CFCF; }
	.hiliteSET4 { background-color:#BFBF00; }
	.hiliteSET5 { background-color:#AF00AF; }
	.hiliteSET6 { background-color:#009F9F; }
	.hiliteSET7 { background-color:#8F8F00; }
	.hiliteSET8 { background-color:#7F007F; }
	.hiliteGET1 { background-color:#FEFFBF; } /* don't like this (numbers on each class) but cant get .parameters .parameters selector to work */
	.hiliteGET2 { background-color:#FFBFFE; } /* colours by http://www.2createawebsite.com/build/hex-colors.html */
	.hiliteGET3 { background-color:#BFFFFE; }
	.hiliteGET4 { background-color:#FEFFBF; }
	.hiliteGET5 { background-color:#FFBFFE; }
	.hiliteGET6 { background-color:#BFFFFE; }
	.hiliteGET7 { background-color:#FEFFBF; }
	.hiliteGET8 { background-color:#FFBFFE; }
	>
	;.html { color:darkgreen; }
	;.html .tag { color:purple; }
	;.html .comment { color:darkgreen; font-style:italic;}
	;.html .cos { color:black; }
	;.html .typo { background-color:#FFEECC; }
	;.KILL { font-weight:bold; }
	;.known { cursor:hand; }
	;.label { color:blue; }
	;.line { }
	;.macro { color:darkblue; }
	;.MERGE { font-weight:bold; }
	;.method { border-top:1px dotted silver; margin-top:20px; }
	;.method .description { color:#006000; margin-left:50px; }
	;.notcalled { color:#8080ff; }
	;.pattern { color:darkorange; }
	;.postconditional { background-color:#e8e8e8; }
	;.SET { font-weight:bold; }
	;.sql { color:darkcyan; }
	;.string { color:purple; }
	;.string .typo { background-color:#FFEECC; }
	;.subscript { }
	;.unknownclass { background-color:#FFDDDD; }
	;.unnewed { /* background-color:cyan;*/ }
	;.unset { /* background-color:cyan;*/ }
	
	;.formalspectable { width:100%; font-size:0.75em; }
	;.formalspectable td { border-bottom:1px solid black; width:33%; white-space:pre; }

	/*.parameters:hover { border:1px dotted black; }*/
	/* these need to be here (rather than in my preferred alphabetical order) because the .typo thing
	   has to come after the typo one above */
	;.parameters1:hover { background-color:#EFEFFF; } /* don't like this but cant get .parameters .parameters selector to work */
	;.parameters1:hover .typo { background-color:transparent; }
	;.parameters2:hover { background-color:#DFFFDF; }
	;.parameters3:hover { background-color:#FFCFCF; }
	;.parameters4:hover { background-color:#BFBFFF; }
	;.parameters5:hover { background-color:#AFFFAF; }
	;.parameters6:hover { background-color:#FF9F9F; }
	;.parameters7:hover { background-color:#8F8FFF; }
	;.parameters8:hover { background-color:#7FFF7F; }
	
	;pre.example {
    ;	border: 1px solid black;
    ;	font-family: courier new,courier,monospace;
    ;	text-align: left;
    ;	margin-top: 5px;
    ;	margin-bottom: 5px;
    ;	padding-left: 10px; padding-top: 0px; padding-bottom: 0px;
	;	background: #F0F0F0; 
	;	overflow-x: auto;
    ;}

 	;.tabledescription { }
	;.tabledescription .html { color:black; }
	;.tabledescription .typo { background-color:#FFEECC; }
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.Xref.Output">
<Super>PXW.Xref.BuildOutput</Super>
<TimeChanged>67125,77563.936231323</TimeChanged>
<TimeCreated>67125,77563.936231323</TimeCreated>

<Method name="batchStart">
<FormalSpec>CountOfThings:%Integer</FormalSpec>
<Implementation><![CDATA[	Write !,"Started Batch, count="_CountOfThings
]]></Implementation>
</Method>

<Method name="processStart">
<FormalSpec>classname:%Library.String</FormalSpec>
<Implementation><![CDATA[
	
	Write !,"<a class='COSObjectsProperty' href='"_##class(PXW.Tools.DEV.Class).HREFTo(classname)_"'>"_..EscapeHTML(classname)_"</a>"
	Write *-3
	Quit
]]></Implementation>
</Method>

<Method name="processStatus">
<FormalSpec>classname:%Library.Persistent,Status:%Status</FormalSpec>
<Implementation><![CDATA[
	If $$$ISERR(Status) {
		Set txt=$SYSTEM.Status.GetErrorText(Status)
		Write "<span style='color:red;'>" 
		Write ..EscapeHTML(txt)
		Write "</span>"
	}
]]></Implementation>
</Method>

<Method name="batchStatus">
<FormalSpec>CountOfThings:%Integer,Status:%Status</FormalSpec>
<Implementation><![CDATA[	Write !,"Completed Batch, count="_CountOfThings
]]></Implementation>
</Method>

<Method name="EscapeHTML">
<Description>
This method converts input HTML text into Escaped HTML text.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>in:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ Quit $ZCONVERT(in,"O","HTML")
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.Xref">
<Super>PXW.Tools.Page</Super>
<TimeChanged>67125,77563.882630018</TimeChanged>
<TimeCreated>67125,77563.882630018</TimeCreated>

<Parameter name="ToolType">
<Default>Code</Default>
</Parameter>

<Method name="WriteMainBody">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Do ..HREFFrom(.itemtype,.itemk1,.itemk2,.calledByCommand,.calledByKey1,.calledByKey2,.windowSize,.flags)
	If itemk1="",itemk2="",calledByKey1="",calledByKey2="" {
		Write "Nothing to search for"
	} Else {
		Do ..WriteXRef(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize,flags)
	}
]]></Implementation>
</Method>

<Method name="WriteXRef">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemtype:%String,itemk1:%String,itemk2:%String,calledByCommand:%String,calledByKey1:%String,calledByKey2:%String,windowSize:%String,flags:%String</FormalSpec>
<Implementation><![CDATA[
	If flags["SUPER" {
		Set rs=##class(PXW.Xref.Queries).GetSuperFunc(%NS,itemtype,itemk1,itemk2,calledByCommand,calledByKey1,windowSize,flags)
	} Else {
		Set rs=##class(PXW.Xref.Queries).GetFunc(%NS,itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize,flags)
	}
	;w "<pre>" zw rs w "</pre>"
	Set showk3=$SELECT(flags[",SHOWK3":1,1:"")
	Set newflags=flags
	Set newflags=$REPLACE(newflags,",BY ITEM","")
	Set newflags=$REPLACE(newflags,",BY CALLED","")
	Write "<table filename='XREF_"_itemk1_"'>"
	Write "		<thead>",!
	Write "			<tr>",!
	Write "				<th><a href='"_(..HREFTo(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize,newflags_",BY ITEM"))_"'>Item Key1</a></th>",!
	Write "				<th><a href='"_(..HREFTo(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize,newflags_",BY ITEM"))_"'>Item Key2</a></th>",!
	Write "				<th>Mode</th>",!
	Write "				<th>Called By Type</th>",!
	Write "				<th><a href='"_(..HREFTo(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize,newflags_",BY CALLED"))_"'>Called By Key1</a></th>",!
	Write "				<th><a href='"_(..HREFTo(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize,newflags_",BY CALLED"))_"'>Called By Key2</a></th>",!
	Write:showk3 "				<th><a href='"_(..HREFTo(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize,newflags_",BY CALLED"))_"'>Called By Key3</a></th>",!
	Write "				<th>Code</th>",!
	Write "			</tr>",!
	Write "		</thead>",!
	Write "		<tbody>",!
	Write "		",! 
	While rs.%Next() {
		Write "<tr>"
		; WHAT ABOUT XREF ON ROUTINES????
		Write "<td class='CDEFClassName'>"_..EscapeHTML(rs.ItemKey1)_"</td>"
		Write "<td><a class='CDEFMember' href='"_..HREFTo(rs.ItemType,rs.ItemKey1,rs.ItemKey2)_"'>"_..EscapeHTML(rs.ItemKey2)_"</a></td>"
		Write "<td>"_..EscapeHTML(rs.CalledByCommand)_"</td>"
		Write "<td>"_..EscapeHTML(rs.CalledByType)_"</td>"
		Write "<td class='CDEFClassName'>"_..EscapeHTML(rs.CalledByKey1)_"</td>"
		Write "<td>"
			If rs.CalledByType="CLS" {
				;w "<a class='COSObjectsMethod' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.CalledByKey1,rs.CalledByKey2,rs.CalledByKey3)_"'>"
				Write "<a class='CDEFMember' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.CalledByKey1,rs.CalledByKey2,rs.LineNumber)_"'>"
				Write ..EscapeHTML(rs.CalledByKey2)
				Write "</a>"
			} /* elseif rs.CalledByType="QRY" {
				w "<a class='COSObjectsQuery' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.CalledByKey1,rs.CalledByKey2,rs.CalledByKey3)_"'>"
				w ..EscapeHTML(rs.CalledByKey2)
				w "</a>"
			} elseif rs.CalledByType="VEW" {
				w "<a class='COSObjectsMethod' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.CalledByKey1,rs.CalledByKey2,rs.CalledByKey3)_"'>"
				w ..EscapeHTML(rs.CalledByKey2)
				w "</a>"
			} elseif rs.CalledByType="PRP" {
				w "<a class='COSObjectsProperty' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.CalledByKey1,rs.CalledByKey2,rs.CalledByKey3)_"'>"
				w ..EscapeHTML(rs.CalledByKey2)
				w "</a>"
			} */ Else {
				Write ..EscapeHTML(rs.CalledByKey2)
			} 
		Write "</td>"
		Write:showk3 "<td>"_..EscapeHTML(rs.CalledByKey3)_"</td>"
		Write "<td><pre>"
			Set ws=windowSize-1
			Set mid=rs.LineNumber,rel=rs.CalledByKey3
			If mid=0 Set mid=1
			Set from=mid-ws,relfrom=rel-ws
			Set to=mid+ws
			Set pieces=$LENGTH(rs.CallingCode,$CHAR(13,10))
			Set piece=0
			If from<1 Set relfrom=relfrom-from+1,from=1
			If relfrom<0 Set from=from-relfrom,piece=piece-relfrom ; do not display code before the method start
			For i=from:1:to {
				Set piece=piece+1
				If piece<=pieces {
					If ws>0,i=mid Write "<span class='hilite'>"
					Write ..EscapeHTML($PIECE(rs.CallingCode,$CHAR(13,10),piece))_"<br>"
					If ws>0,i=mid Write "</span>"
				}
			}
		Write "</pre></td>"
		
		
		Write "</tr>",!
	}
	Write "</tbody></table>"
]]></Implementation>
</Method>

<Method name="WriteNav">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Do ..HREFFrom(.itemtype,.itemk1,.itemk2,.calledByCommand,.calledByKey1,.calledByKey2,.windowSize,.flags)
	Write "<a href='"_##class(PXW.Tools.DEV.XrefBuild).HREFTo()_"'>Build Xref</a>"
	Write "<a href='"_..HREFTo(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize+1,flags)_"'>Window +</a>"
	If windowSize>0 Write "<a href='"_..HREFTo(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize-1,flags)_"'>Window -</a>"
	If itemk2'="" Write "<a href='"_..HREFTo(itemtype,itemk1,"","","",windowSize,flags)_"'>All "_itemk1_"</a>"
	If flags'["EXTERNAL" Write "<a href='"_..HREFTo(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize,flags_",EXTERNAL")_"'>External Only</a>"
	If flags["EXTERNAL" Write "<a href='"_..HREFTo(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize,$REPLACE(flags,",EXTERNAL",""))_"'>Include Internal</a>"
	If flags'["SUPER" Write "<a href='"_..HREFTo(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize,flags_",SUPER")_"'>Include Super</a>"
	If flags["SUPER" Write "<a href='"_..HREFTo(itemtype,itemk1,itemk2,calledByCommand,calledByKey1,calledByKey2,windowSize,$REPLACE(flags,",SUPER",""))_"'>Exclude Super</a>"

	&html<
		<form action='PXW.Tools.DEV.Xref.cls'>
			<fieldset>
				<legend id=PXWToolsDEVXreflegend>PXW.Tools.DEV.Xref</legend>
				<input type=hidden name=IFRAME value='0'>
				<input type=hidden name='%NS' value='#($GET(%NS))#'>
				<table>
				
				<tr><td class=prompt>ItemType</td>
				<td><input type=text name=IT value='#(itemtype)#'></td>
				</tr>
				<tr><td class=prompt>ItemKey1</td>
				<td><input type=text name=IK1 value='#(itemk1)#'></td>
				</tr>
				<tr><td class=prompt>ItemKey2</td>
				<td><input type=text name=IK2 value='#(itemk2)#'></td>
				</tr>
				<tr><td class=prompt>Mode</td>
				<td><input type=text name=CBC value='#(calledByCommand)#'></td>
				</tr>
				<tr><td class=prompt>CalledByKey1</td>
				<td><input type=text name=CBK1 value='#(calledByKey1)#'></td>
				</tr>
				<tr><td class=prompt>CalledByKey2</td>
				<td><input type=text name=CBK2 value='#(calledByKey2)#'></td>
				</tr>
				<tr><td class=prompt>WindowSize</td>
				<td><input type=text name=WS value='#(windowSize)#'></td>
				</tr>
				<tr><td class=prompt>Flags</td>
				<td><input type=text name=F value='#(flags)#'></td>
				</tr>
				<tr><td>&nbsp;</td><td><input type=submit></td>
				</tr>
				</table>
			</fieldset>
		</form>
	>
	Write "<a title='To get an idea of what the parameters can do' href='"_##class(PXW.Tools.DEV.Class).HREFTo("PXW.Xref.Queries","Get")_"'>Show query</a>",!
]]></Implementation>
</Method>

<Method name="HREFFrom">
<Description>
This shoud output some variables, getting the data from %request</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*ItemType:%String,*ItemKey1:%String,*ItemKey2:%String,*CalledByCommand:%String,CalledByKey1:%String,CalledByKey2:%String,WindowSize:%Integer=0,*Flags:%String</FormalSpec>
<Implementation><![CDATA[
	Set ItemType=%request.Get("IT")
	Set ItemKey1=%request.Get("IK1")
	Set ItemKey2=%request.Get("IK2")
	Set CalledByCommand=%request.Get("CBC")
	Set CalledByKey1=%request.Get("CBK1")
	Set CalledByKey2=%request.Get("CBK2")
	Set WindowSize=+%request.Get("WS")
	Set Flags=%request.Get("F")
]]></Implementation>
</Method>

<Method name="HREFTo">
<Description>
This should return a string of the href to this page based on the input parameters</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ItemType:%String="",ItemKey1:%String="",ItemKey2:%String="",CalledByCommand:%String="",CalledByKey1:%String="",CalledByKey2:%String="",WindowSize:%Integer="",Flags:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set href=##super()
	Set sep="&"
	If ItemType'="" Set href=href_sep_"IT="_..EscapeURL(ItemType),sep="&"
	If ItemKey1'="" Set href=href_sep_"IK1="_..EscapeURL(ItemKey1),sep="&"
	If ItemKey2'="" Set href=href_sep_"IK2="_..EscapeURL(ItemKey2),sep="&"
	If CalledByCommand'="" Set href=href_sep_"CBC="_..EscapeURL(CalledByCommand),sep="&"
	If CalledByKey1'="" Set href=href_sep_"CBK1="_..EscapeURL(CalledByKey1),sep="&"
	If CalledByKey2'="" Set href=href_sep_"CBK2="_..EscapeURL(CalledByKey2),sep="&"
	If WindowSize'="" Set href=href_sep_"WS="_..EscapeURL(WindowSize),sep="&"
	If Flags'="" Set href=href_sep_"F="_..EscapeURL(Flags),sep="&"
	Quit href
]]></Implementation>
</Method>

<Method name="GetTitle">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Do ..HREFFrom(.itemtype,.itemk1,.itemk2)
	Quit "Xref of "_itemtype_" "_itemk1_":"_itemk2
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.XrefBuild">
<Super>PXW.Tools.Page</Super>
<TimeChanged>67129,59942.01448508</TimeChanged>
<TimeCreated>67125,77563.887739919</TimeCreated>

<Method name="xrefPackage">
<Description>
d ##class(PXW.Tools.DEV.BuildAllXref).xrefPackage("eng")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Package:%String,Force:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pack=$p(Package,"*",1)_"*"
	Job ##class(PXW.Xref.Build).Build(%NS,"",pack,Force)
	Hang 1
	Write !,"Submitted to background."
	Set sc=$$$OK
	Quit sc
]]></Implementation>
</Method>

<Method name="WriteMainBody">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Do ..HREFFrom(.package,.force,.background)
	&html<
	<fieldset>
		<form id=formRoutine action='PXW.Tools.DEV.XrefBuild.cls'>
			<input type=hidden name=IFRAME value='0'>
			<u>P</u>ackage 
			<input accesskey=P 
				title='Enter Package name'
			type=text id=inputPackage name=P ovalue='#(package)#' value='' size=10>
			Force <input type='checkbox' name="F" value=1 #($SELECT(force:"checked",1:""))#>
			<input type=hidden name="%NS" value='#(%NS)#'>
			<input type=submit value='Go'>
		</form>
	</fieldset>
	>

	If package'="" {
        If package="*" Set package=""
		Write "<pre>"
		Write "Clearing Cache" Do ##class(PXW.DEV.Dictionary.ClassDefinitionObject).ClearCache()
		Set sc=..xrefPackage(package,force)
		Do ..WriteStatus(sc)
		Write "</pre>"
	} 

	write "<table>"
	w "<thead>"
	w "<tr>"
	w "<th>ID</th>"
	w "<th>PID</th>"
	w "<th>StartDateTime</th>"
	w "<th>EndDateTime</th>"
	w "<th>SearchName</th>"
	w "<th>CurrentlyBuilding</th>"
	w "<th>Total</th>"
	w "<th>Built</th>"
	w "<th>Errors</th>"
	w "<th>Skipped</th>"
	w "<th>Status</th>"
	w "</tr>"
	w "</thead>"
	w "<tbody>"

	s rs=##class(%Library.ResultSet).%New(..%ClassName(1)_":"_"SelectStatus")
	$$$ThrowOnError(rs.Execute())
	while rs.%Next() {
		s rowclass=""
		s enddatetime=rs.%Get("EndDateTime")
		s running=rs.%Get("Running")
		i running s rowclass=" class=goodrow"
		i 'running,enddatetime="" s rowclass="class=errorrow"
		w "<tr "_rowclass_">"
		w "<td>"_..EscapeHTML(rs.%Get("ID"))_"</td>"
		w "<td>"_..EscapeHTML(rs.%Get("ProcessId"))_"</td>"
		w "<td>"_..EscapeHTML(rs.%Get("StartDateTime"))_"</td>"
		w "<td>"_..EscapeHTML(rs.%Get("EndDateTime"))_"</td>"
		w "<td>"_..EscapeHTML(rs.%Get("RequestSearchName"))_"</td>"
		w "<td>"_..EscapeHTML(rs.%Get("CurrentlyBuilding"))_"</td>"
		w "<td>"_..EscapeHTML(rs.%Get("Total"))_"</td>"
		w "<td>"_..EscapeHTML(rs.%Get("TotalBuilt"))_"</td>"
		w "<td>"_..EscapeHTML(rs.%Get("TotalErrors"))_"</td>"
		w "<td>"_..EscapeHTML(rs.%Get("TotalSkipped"))_"</td>"
		w "<td>"_..EscapeHTML(rs.%Get("Status"))_"</td>"
		w "</tr>"
		
	}

	w "</tbody>"
	w "</table>"
]]></Implementation>
</Method>

<Query name="SelectStatus">
<Type>%Library.SQLQuery</Type>
<SqlQuery>	SELECT top 25 * FROM PXW_Xref.BuildStatus ORDER BY ID DESC</SqlQuery>
</Query>

<Method name="HREFFrom">
<Description>
This shoud output some variables, getting the data from %request</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*Package:%String,*force:%Boolean,*background:%Boolean</FormalSpec>
<Implementation><![CDATA[
	Set Package=%request.Get("P")
	Set force=+%request.Get("F")
    Set background=+%request.Get("B")
]]></Implementation>
</Method>

<Method name="HREFTo">
<Description>
This should return a string of the href to this page based on the input parameters
Package will build the entire package
MethodId will build just the method
DEBUG - only makes sense when building a single method</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Package:%String="",Force:%Boolean=0,Background:%Boolean=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set href=##super()
	Set sep="&"
	If Package'="" Set href=href_sep_"P="_..EscapeURL(Package),sep="&"
	If Force'="" Set href=href_sep_"F="_..EscapeURL(Force),sep="&"
	If Background'="" Set href=href_sep_"B="_..EscapeURL(Background),sep="&"
	Quit href
]]></Implementation>
</Method>

<Method name="WriteNav">
<Description>
Output 1 Anchor tag for each option in the navigation. Use the scratch variable for anything you want to get from BODY</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[	Write "<a href='"_##class(PXW.Tools.DEV.XrefBuildProblems).HREFTo("")_"'>Problems</a>"
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.XrefBuildProblems">
<Super>PXW.Tools.Page</Super>
<TimeChanged>67125,77563.893892821</TimeChanged>
<TimeCreated>67125,77563.893892821</TimeCreated>

<Method name="WriteMainBody">
<Description>
ID, BuildStatus, ItemKey1, ItemType, LastUpdate, NameSpace</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	;d ..HREFFrom()

	Set rs=##class(PXW.Xref.Queries).BuildProblemsFunc(%NS)
	;w "<pre>" zw rs w "</pre>"
	Write "<table filename='XREF_probems'>"
		&html<
		<thead>
			<tr>
                <th>Item Type</th>
				<th>Item Key1</th>
				<th>Last Update</th>
				<th>Build Status</th>
			</tr>
		</thead>
		<tbody>
		>
	While rs.%Next() {
		Write "<tr>"
		Write "<td class=''>"_..EscapeHTML(rs.ItemType)_"</td>"
		Write "<td>"
			If rs.ItemType="CLS" {
				Write "<a class='CDEFClassName' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.ItemKey1,,,)_"'>"
				Write ..EscapeHTML(rs.ItemKey1)
				Write "</a>"
			} Else {
				Write ..EscapeHTML(rs.ItemKey1)
			}
		Write "</td>"
		Write "<td>"_..EscapeHTML(rs.LastUpdate)_"</td>"
		Set txt=$SYSTEM.Status.GetErrorText(rs.BuildStatus)
        Write "<td>"_..EscapeHTML(txt)_"</td>"
		Write "</tr>",!
	}
	Write "</tbody></table>"
]]></Implementation>
</Method>

<Method name="WriteNav">
<Description>
Output 1 Anchor tag for each option in the navigation. Use the scratch variable for anything you want to get from BODY</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[	Write "<a href='"_##class(PXW.Tools.DEV.XrefBuild).HREFTo()_"'>Build Xref</a>"
]]></Implementation>
</Method>

<Method name="HREFTo">
<Description>
This should return a string of the href to this page based on the input parameters</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>NameSpace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    ; note that NameSpace is always %NS
	Quit ##super()
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.DEV.XrefPackage">
<Super>PXW.Tools.Page</Super>
<TimeChanged>67125,77563.897115674</TimeChanged>
<TimeCreated>67125,77563.897115674</TimeCreated>

<Method name="WriteMainBody">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Do ..HREFFrom(.itemPackage,.calledByPackage,.windowSize)
	
	Write "<ul>"
	Write "<li><a href='"_..HREFTo(itemPackage,calledByPackage,windowSize+1)_"'>Window +</li>"
	If windowSize>0 Write "<li><a href='"_..HREFTo(itemPackage,calledByPackage,windowSize-1)_"'>Window -</li>"
	Write "</ul>"

    If itemPackage="" {
        If calledByPackage'="" {
            Do ..WriteSummary(calledByPackage)
        } Else {
            Write "Called By Package is required"
        }
    } Else {
        If calledByPackage'="" {
            Do ..WriteDetail(itemPackage,calledByPackage,windowSize)
        } Else {
            Write "Did you mean get a summary of what "_itemPackage_" calls? "
            Set calledByPackage=itemPackage
            Write "<a href='"_..HREFTo("",calledByPackage)_"'>Click here to see summary</a>"
        }
    }
]]></Implementation>
</Method>

<Method name="WriteSummary">
<ClassMethod>1</ClassMethod>
<FormalSpec>CalledByPackage:%String</FormalSpec>
<Implementation><![CDATA[
    Set rs=##class(PXW.Xref.Queries).PackageSummaryFunc(%NS,CalledByPackage)
	;w "<pre>" zw rs w "</pre>"
	Write "<table border=1>"
		&html<
			<tr>
				<th>Item Package</th>
				<th>Called By Package</th>
			</tr>
		>
	While rs.%Next() {
		Write "<tr>"
		Write "<td>"_..EscapeHTML(rs.ItemPackage)_"</td>"
		Write "<td>"
        
            Write "<a href='"_..HREFTo(rs.ItemPackage,rs.CalledByPackage)_"'>"
			Write ..EscapeHTML(rs.CalledByPackage)
			Write "</a>"        Write "</td>"		
		Write "</tr>",!
	}
	Write "</table>"
]]></Implementation>
</Method>

<Method name="WriteDetail">
<ClassMethod>1</ClassMethod>
<FormalSpec>ItemPackage:%String,CalledByPackage:%String,WindowSize:%Integer</FormalSpec>
<Implementation><![CDATA[
    Set rs=##class(PXW.Xref.Queries).PackageDetailFunc(%NS,ItemPackage,CalledByPackage,WindowSize)
	;w "<pre>" zw rs w "</pre>"
	Write "<table border=1>"
		&html<
			<tr>
				<th>Item Key1</th>
				<th>Item Key2</th>
				<th>Mode</th>
				<th>Called By Key1</th>
				<th>Called By Key2</th>
				<th>Code</th>
			</tr>
		>
	While rs.%Next() {
		Write "<tr>"
		; WHAT ABOUT XREF ON ROUTINES????
		Write "<td class='COSObjectsClass'>"_..EscapeHTML(rs.ItemKey1)_"</td>"
		Write "<td class='COSObjectsMethod'>"_..EscapeHTML(rs.ItemKey2)_"</td>"
		Write "<td>"_..EscapeHTML(rs.CalledByCommand)_"</td>"
		Write "<td class='COSObjectsClass'>"_..EscapeHTML(rs.CalledByKey1)_"</td>"
		Write "<td>"
			If rs.CalledByType="CLS" {
				;w "<a class='COSObjectsMethod' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.CalledByKey1,"METHOD",rs.CalledByKey2,rs.CalledByKey3)_"'>"
				Write "<a class='COSObjectsMethod' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.CalledByKey1,rs.CalledByKey2,rs.LineNumber)_"'>"
				Write ..EscapeHTML(rs.CalledByKey2)
				Write "</a>"
			} /*elseif rs.CalledByType="QRY" {
				w "<a class='COSObjectsQuery' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.CalledByKey1,"QUERY",rs.CalledByKey2,rs.CalledByKey3)_"'>"
				w ..EscapeHTML(rs.CalledByKey2)
				w "</a>"
			} elseif rs.CalledByType="VEW" {
				w "<a class='COSObjectsMethod' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.CalledByKey1,"METHOD",rs.CalledByKey2,rs.CalledByKey3)_"'>"
				w ..EscapeHTML(rs.CalledByKey2)
				w "</a>"
			} elseif rs.CalledByType="PRP" {
				w "<a class='COSObjectsProperty' href='"_##class(PXW.Tools.DEV.Class).HREFTo(rs.CalledByKey1,"PROPERTY",rs.CalledByKey2,rs.CalledByKey3)_"'>"
				w ..EscapeHTML(rs.CalledByKey2)
				w "</a>"
			}*/ Else {
				Write ..EscapeHTML(rs.CalledByKey2)
			}
		Write "</td>"
		
		Write "<td><pre>"
			Set ws=WindowSize-1
			Set mid=rs.LineNumber
			If mid=0 Set mid=1
			Set from=mid-ws
			Set to=mid+ws
			Set pieces=$LENGTH(rs.CallingCode,$CHAR(13,10))
			If from<1 Set from=1
			Set piece=0
			For i=from:1:to {
				Set piece=piece+1
				If piece<=pieces {
					If ws>0,i=mid Write "<span class='hilite'>"
					Write ..EscapeHTML(i_" "_$PIECE(rs.CallingCode,$CHAR(13,10),piece))_"<br>"
					If ws>0,i=mid Write "</span>"
				}
			}
		Write "</pre></td>"
		
		
		Write "</tr>",!
	}
	Write "</table>"
]]></Implementation>
</Method>

<Method name="HREFFrom">
<Description>
This shoud output some variables, getting the data from %request</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*ItemPackage:%String,*CalledByPackage:%String,WindowSize:%Integer=0</FormalSpec>
<Implementation><![CDATA[
	Set ItemPackage=%request.Get("IP")
	Set CalledByPackage=%request.Get("CBP")
	Set WindowSize=+%request.Get("WS")
]]></Implementation>
</Method>

<Method name="HREFTo">
<Description>
This should return a string of the href to this page based on the input parameters</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ItemPackage:%String,CalledByPackage:%String,WindowSize:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set href=..%ClassName(1)_".cls"
	Set sep="?"
	If ItemPackage'="" Set href=href_sep_"IP="_..EscapeURL(ItemPackage),sep="&"
	If CalledByPackage'="" Set href=href_sep_"CBP="_..EscapeURL(CalledByPackage),sep="&"
	If WindowSize'="" Set href=href_sep_"WS="_..EscapeURL(WindowSize),sep="&"
	Quit href
]]></Implementation>
</Method>

<Method name="GetTitle">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Do ..HREFFrom(.itemPackage,.calledByPackage,.windowSize)
	Quit "Xref of "_itemPackage_" called by "_calledByPackage
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.Debugger">
<Super>PXW.Debuggers.Basic</Super>
<TimeChanged>67125,77563.749521771</TimeChanged>
<TimeCreated>67125,77563.749521771</TimeCreated>
</Class>


<Class name="PXW.Tools.Index">
<Super>PXW.Tools.Page</Super>
<TimeChanged>67125,77563.745085209</TimeChanged>
<TimeCreated>67125,77563.745085209</TimeCreated>

<Method name="WriteMainBody">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	
	Set rs=##class(%ResultSet).%New("%Library.ClassDefinition:SubclassOf")
	$$$THROWONERROR(sc,rs.Execute(##class(PXW.Tools.Page).%ClassName(1)))
	
	While rs.Next() {
		Set name=rs.Data("Name")
		Do ..WriteForm(name)
	}
]]></Implementation>
</Method>

<Method name="WriteNav">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	Set rs=##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	$$$THROWONERROR(sc,rs.Execute(##class(PXW.Tools.Page).%ClassName(1)))
	
	While rs.Next() {
		Set name=rs.Data("Name")
		Set HREFto=##class(%Dictionary.MethodDefinition).%OpenId(name_"||HREFTo")
		If HREFto { 
			Set type=$PARAMETER(name,"ToolType")
			Set css="toolTypeInternal"
			If $$$UPPER(type)="CODE" Set css="toolTypeCode"
			Set aname=$TRANSLATE(name,".","")_"anchor"
			Set legname=$TRANSLATE(name,".","")_"legend"
			Write "<a onclick='HiliteElement("""_legname_""");' class='"_css_"' href=#"_$TRANSLATE(aname,".","")_">"_name_"</a>"
		}
	}
]]></Implementation>
</Method>

<Method name="WriteForm">
<Description>
This is a quick way of dumping out a form from the spec of the method HREFto
What really needs to happen is each tool has a proper definition of the fields it requires.
Possibly even just a method called WriteForm that dumps the form. Note that DEV.PXW.Tools kind of has this
capability already, its just unused!
Doing it this way for speed of development.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ClassName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	; if there is no HREFto method then we cannot link to this.
	Set HREFto=##class(%Dictionary.MethodDefinition).%OpenId(ClassName_"||HREFTo")
	If HREFto="" Quit 1
	Set type=$PARAMETER(ClassName,"ToolType")
	Set css="toolTypeInternal"
	If $$$UPPER(type)="CODE" Set css="toolTypeCode"	
	Set aname=$TRANSLATE(ClassName,".","")_"anchor"
	Set legname=$TRANSLATE(ClassName,".","")_"legend"
	&html<
	<div id="#(aname)#" class=#(css)#>
		<form action='#(ClassName)#.cls'>
			<fieldset>
				<legend id=#(legname)#>#(ClassName)#</legend>
				<input type=hidden name=IFRAME value='0'>
				<input type=hidden name='%NS' value='#($GET(%NS))#'>
				<table>
				>
				Set FS=HREFto.FormalSpec
				For i=1:1:$LENGTH(FS,",") {
					Set VAR=$PIECE($PIECE(FS,",",i),":",1)
					Set TYP=$PIECE($PIECE(FS,",",i),":",2)
					Set DEF=$PIECE(TYP,"=",2),TYP=$PIECE(TYP,"=",1)
					; if this is not a default parameter name output it
					If VAR'?1"P"1N {
						; the url code is normally the capital letters/numbers of the variable name,
						; if I find one thats not I will deal with this later
						Set VNAME=$TRANSLATE(VAR,"abcdefghijklmnopqrstuvwxyz")
						Set DEF=$TRANSLATE(DEF,"""")
						&html<<tr><td class=prompt>#(VAR)#</td>>
						If TYP="%Boolean" {
							&html<<td><input type=checkbox name=#(VNAME)# value=1 #($SELECT(DEF=1:"checked",1:""))#></td>>
						} Else {
							&html<<td><input type=text name=#(VNAME)# value='#(DEF)#'></td>>
						}
						&html<<td>#(TYP)#</td>
							</tr>>
					}
				}
				Set DESC=HREFto.Description
				; get the stuff between <dl> and </dl>
				Set DESC=$PIECE($PIECE(DESC,"<dl>",2),"</dl>",1)
				
				&html<<tr><td>&nbsp;</td><td><input type=submit></td><td>&nbsp;</td></tr>
					</table>
			</fieldset>
		</form>
	</div>
	>
	Quit 1
]]></Implementation>
</Method>

<Method name="GetTitle">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit "All tools"
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.Page">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>%CSP.Page</Super>
<TimeChanged>67125,77563.757737909</TimeChanged>
<TimeCreated>67125,77563.757737909</TimeCreated>

<Parameter name="ToolType">
<Description>
What type of tool this is:
Code tools are used for display/searching code
Internal tools are used for changing things about the tool itself</Description>
<Default>Internal</Default>
</Parameter>

<Method name="OnPreHTTP">
<Description><![CDATA[
Event handler for <b>PreHTTP</b> event: this is invoked before
the HTTP headers for a CSP page have been sent.  All changes to the
<class>%CSP.Response</class> class, such as adding cookies, HTTP headers,
setting the content type etc. must be made from within the OnPreHTTP() method.
Also changes to the state of the CSP application such as changing
%session.EndSession or %session.AppTimeout must be made within the OnPreHTTP() method.
It is prefered that changes to %session.Preserve are also made in the OnPreHTTP() method
as this is more efficient, although it is supported in any section of the page.
Return <b>0</b> to prevent <method>OnPage</method> from being called.]]></Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	#dim %request as %CSP.Request
	#dim %session as %CSP.Session
	#dim %response as %CSP.Response

	Set %NS=%request.Get("%NS","LOCAL_USER")
	Set style=%request.Get("%STYLE")
	Set:style="" style=%request.GetCookie("PXWSTYLE")
	Set:style="" style=$GET(^PXW("TOOLSv2","PXWSTYLE"))
	Set:style="" style="Basic"

	Set styleclass=style
	If styleclass'["." Set styleclass="PXW.Tools.Styles."_style
	Try {
		Set %STYLE=$SYSTEM.OBJ.New(styleclass)
	} Catch {
		Set %STYLE=##class(PXW.Tools.Styles.Basic).%New()
		Set style="Basic"
	}
	Set expires="Mon, 31 Dec 2035 12:00:00 GMT"
	Do %response.SetCookie("PXWSTYLE",style,expires)
	Quit 1
]]></Implementation>
</Method>

<Method name="HREFFrom">
<Description>
This shoud output some variables, getting the data from %request</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[	;s Class=%request.Get("C")
]]></Implementation>
</Method>

<Method name="HREFTo">
<Description>
This should return a string of the href to this page based on the input parameters</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set href=..%ClassName(1)_".cls"
	Set sep="?"
	Set href=href_sep_"%NS="_..EscapeURL($GET(%NS,"LOCAL_USER")),sep="&"
	;s href=href_sep_"C="_..EscapeURL(cls),sep="&"
	Quit href
]]></Implementation>
</Method>

<Method name="OnPage">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set startmem=$STORAGE
	#dim e as %Exception.SystemException
	Set zh=$ZHOROLOG
	Set title=..GetTitle()	
	&html<<html>
		<title>#(title)#</title>
	>

	; overall style

	Do %STYLE.WriteStyles()

	; styles for this page
	Write "<style>"
	Do ..WriteStyles()
	Write "</style>",!

	Write "<script language=javascript>",!
	Do ..WriteScripts()
	
	Write "function HiliteElement(id) {",!
	Write "    var obj=document.getElementById(id);",!
	Write "    obj.className='hilite';",!
	Write "}",!


	Write "/*****************************************************************/",!
	Write "/// Any tables with a filename attribute is downloadable",!
	Write "/// eg: <table filename='download'>",!
	Write "function makeTablesExportable() {",!
	Write "    var elements=document.getElementsByTagName('TABLE');",!
	Write "    for (var e=elements.length-1; e>-1; e--) {",!
	Write "      var table=elements[e];",!
	Write "      var filename=table.getAttribute('filename');",!
	Write "      if (filename!=null) {",!
	Write "          var tid=table.id;",!
	Write "          if (tid=='') {",!
	Write "              tid='table'+e;",!
	Write "              table.id=tid;",!
	Write "          }",!
	Write "          var bc=document.createElement(""button"");",!
	Write "          bc.textContent=""download csv"";",!
	Write "          bc.setAttribute('pxwFile',filename);",!
	Write "          bc.setAttribute('pxwTable',tid);",!
	Write "          bc.className='noPrint';",!
	Write "          bc.addEventListener('click',exportButtonEventCSV);",!
	Write "          table.appendChild(bc);",!
	Write "      }",!
	Write "   }",!
	Write "}",!
	Write " ",!
	Write " ",!
	Write "function exportButtonEventCSV() {",!
	Write "  var file=this.getAttribute('pxwFile');",!
	Write "  var tid=this.getAttribute('pxwTable');",!
	Write "  var table=document.getElementById(tid)",!
	Write "  htmlToCSV(table,file+"".csv"");",!
	Write "}",!
	Write " ",!
	Write "",!
	Write "function htmlToCSV(table, filename) {",!
	Write "  var q = String.fromCharCode(34);",!
	Write "  var tab = "",""; //String.fromCharCode(9);",!
	Write "  var cr=""\n"";",!
	Write "  var data = [];",!
	Write "  var rows = table.querySelectorAll(""tr"");",!
	Write " ",!
	Write "  for (var i = 0; i < rows.length; i++) {",!
	Write "     var row = [], cols = rows[i].querySelectorAll(""td, th"");",!
	Write "     for (var j = 0; j < cols.length; j++) {",!
	Write "        //var str=cols[j].innerText;",!
	Write "        var str=cols[j].textContent;",!
	Write "        var esc=str.replace(/""/g,'""""');",!
	Write "        if (esc.includes(tab) || esc.includes(cr)) {",!
	Write "            esc='""'+esc+'""';",!
	Write "         }",!
	Write "         row.push(esc);",!
	Write "     }",!
	Write "     data.push(row.join(tab));",!
	Write "   }",!
	Write "   downloadCSVFile(data.join(""\n""), filename);",!
	Write "}",!
	Write " ",!
	Write "function downloadCSVFile(csv, filename) {",!
	Write "  var csv_file, download_link;",!
	Write "   csv_file = new Blob([csv], {type: ""text/csv""});",!
	Write "   download_link = document.createElement(""a"");",!
	Write "   download_link.download = filename;",!
	Write "   download_link.href = window.URL.createObjectURL(csv_file);",!
	Write "   download_link.style.display = ""none"";",!
	Write "   document.body.appendChild(download_link);",!
	Write "   download_link.click();",!
	Write "}",!
	Write " ",!
	Write "/*****************************************************************/",!	
	Write "function bodyonload() {",!
	Write "   var nav=document.getElementById('toolsMainBodyNav');",!
	Write "   var tmp=document.getElementById('toolsMainBodyNavTEMP');",!
	Write "   nav.innerHTML=tmp.innerHTML;",!
	Write "   makeTablesExportable();",!
	;                                                          #($s(..WriteBodyOnLoad():"",1:"WriteBodyOnLoad ERROR"))#
	Write "}",!

	Write "</script>",!
	
	&html<
	<body  onload='bodyonload();'>
		<div id=toolsHead>
			<div id=toolsForms>
				<form id=toolsFormHome action='PXW.Tools.Index.cls'>
					<fieldset id=toolsHome>
					<legend>Home</legend>
						<input type=hidden name=%NS value='#(%NS)#'>
						<input type=submit value='Home'>
					</fieldset>
				</form>
				#(..WriteHeadForms())#
			</div>
		</div>
		<!-- <div id=toolsMenu>
			<ul id=divMainMenuUL>
			</ul>
		</div>-->
		<div id=toolsTitle>
			<h1>#(title)#</h1>
		</div>
	>
	Write "<div id=toolsMainBody><div id=toolsMainBodyContainer>"
	Write "<div id=toolsMainBodyNav> waiting" 
		; empty for now
	Write "</div>"
	Write "<div id=toolsMainBodyContent>"
	Write "<div id="_$TRANSLATE(..%ClassName(1),".","")_">" ; div for setting up style for specific functions
	Try {
		Do ..WriteMainBody(.scratch)
	} Catch e {
		Do ..WriteStatus(e.AsStatus())
	}
	Write "</div>" ; function specific
	Write "</div>" ; content
	Write "<div id=toolsMainBodyNavTEMP>" 
	Write "<nav>"
		Do ..WriteNav(.scratch) ; this is called AFTER the main body so that the main body could build some sort of index from the content
		               ; but the styling will probably put it BEFORE the content on screen
	Write "</nav>"
	Write "</div>" ; nav
	Write "</div></div>" ; conainer mainbody

	&html<<div id=toolsFooter>
				<span id=toolsFooterDTH>datetimeh=#($HOROLOG)#</span> 
				<span id=toolsFooterDT>datetime=#($ZDATETIME($HOROLOG,3))#</span> 
				<span id=toolsFooterTIM>processtime=#($ZHOROLOG-zh)#</span> 
				<span id=toolsFooterPID>$job=#($JOB)#</span>
				<span id=toolsFooterMEM>$s=#(startmem-$STORAGE)#</span>
			</div>>
	&html<</body></html>>
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="WriteMainBody">
<Description>
use scratch to get anything you want to pass to the nav</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
<Implementation><![CDATA[	Write $THIS
]]></Implementation>
</Method>

<Method name="WriteNav">
<Description>
Output 1 Anchor tag for each option in the navigation. Use the scratch variable for anything you want to get from BODY</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&scratch]]></FormalSpec>
</Method>

<Method name="mainmenu">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	;	<li><a href=#(##class(DEV.PXW.NSchange).HREFto())#>#($g(%NS))#</a></li>
	;		#($s('TOOLSHELP:$s(..WriteMainMenuOptions():"",1:"WriteMainMenuOptions ERROR"),1:""))#
]]></Implementation>
</Method>

<Method name="GetTitle">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..%ClassName(1)
]]></Implementation>
</Method>

<Method name="WriteStyles">
<Description>
Write out extra styles here, the STYLE tags are already in place</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="WriteScripts">
<Description>
Write out extra javascript here, the SCRIPT tags are already in place</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="WriteStatus">
<ClassMethod>1</ClassMethod>
<FormalSpec>sc:%Status</FormalSpec>
<Implementation><![CDATA[
	New %NS Set %NS="LOCAL_USER" ; default error back home
    If $$$ISOK(sc) {
        Write "OK"
    } Else {
        Do $SYSTEM.Status.DecomposeStatus(sc,.err)
        ;s code=$g(err(1,"code"))
        Set caller=$GET(err(1,"caller"))
        Set txt=..EscapeHTML(err(1))
        If caller'="" {
			Set alink="<a class='COSLabel' href='"_##class(PXW.Tools.DEV.Routine).HREFTo(caller)_"'>"_..EscapeHTML(caller)_"</a>"
            If txt[caller {
				Set txt=$REPLACE(txt,caller,alink)
			} Else {
				Set txt=txt_" goto: "_alink
			}
        } 
        Write "<pre style='color:red;'>" Write txt Write "</pre>"	
    }
]]></Implementation>
</Method>

<Method name="WriteHeadForms">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set rs=##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	$$$THROWONERROR(sc,rs.Execute(##class(PXW.Tools.Page).%ClassName(1)))
	
	While rs.Next() {
		Set name=rs.Data("Name")
		Set headform=##class(%Dictionary.MethodDefinition).%OpenId(name_"||WriteHeadForm")
		If $ISOBJECT(headform) {
			Set order=$SELECT(name?1"PXW.Tools"1.E:1,1:2)
			Set index(order,name)=name
		}
	}
	Set k1="",k2=""
	For  {
		Set k1=$ORDER(index(k1))
		Quit:k1=""

		For  {
			Set k2=$ORDER(index(k1,k2),1,name)
			Quit:k2=""
			
			Do $CLASSMETHOD(name,"WriteHeadForm",..%ClassName(1))
		}
	}
	Quit ""
]]></Implementation>
</Method>

<Method name="WriteHeadForm">
<Description>
Calling page is passed in so you can decide what to display on the form/if anything.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Page:%String</FormalSpec>
<Implementation><![CDATA[

	Quit
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.Styles.Basic">
<Super>PXW.Tools.Styles.super</Super>
<TimeChanged>67125,77563.958928154</TimeChanged>
<TimeCreated>67125,77563.958928154</TimeCreated>

<Method name="WriteStyles">
<Implementation><![CDATA[
    &html<
    <style> /*-- extra style --*/

	/* https://www.w3schools.com/css/css3_box-sizing.asp */
	* {
 		box-sizing: border-box;
	}

	:root {
		/* background colours: ;*/
		--bgNormal: #FFFFFF;
		--bgAlternate1: #EEEEEE;
		--bgAlternate2: #DDDDDD;
		--bgAlternate3: #FFFFFF;
		--bgHover: #CCCCCC;
		--bgHilite: #fff793;
		--bgWarning: #ffd893;
		--bgError: #ffb3b3;
		--bgGood: #b3ffb3;

		/* foreground colours: ;*/
		--fgNormal: black;
		--fgProgramName: #2EA990;
		--fgProgramLabel: #ACAC7A;
		--fgProgramKeyword: #6586DF;
		--fgCodeKeyword: black;
		--fgCodeVariable: #6DA2FF;
		--fgCodeVariableGlobal: #64c9ff;
		--fgCodeArgument: #ff75f4;
		--fgCodeLabel: #ACAC7A;
		--fgCodeString: #2e8122; 
		--fgCodeNumber: #B4955C; 
		--fgComment: #2e8122;
		--fgInlineOption: silver;
	}	


	html { height: 100%;}
	body {border:0; margin:0; padding:0; background-color: var(--bgNormal); color: var(--fgNormal); height: 100%; display: flex; flex-direction: column;
			font-family: Arial, Helvetica, sans-serif; font-size: small;} 
	a { text-decoration:none;  color: inherit;}
	a:visited { text-decoration:none; color: inherit; }
	a:hover { text-decoration:none;  color: inherit; }
	a:active { text-decoration:none;  color: inherit; }
	pre { margin:0px; tab-size:4; font-size: medium;}


	#toolsMainTop { }
	#toolsHead { }
	#toolsHead form { display:inline; margin: 0px; padding:0px; border:0px; }
	#toolsHead form fieldset { display:inline;  }
	#toolsMenu {}
	#toolsTitle {}
	#toolsMainBody { flex-grow: 1;overflow:auto;}
	#toolsMainBodyContainer {  width:100%; display:flex; height:100%; }
	#toolsMainBodyNav {  order:1;  display:block; vertical-align: top; height: 100%; width: 15%; padding:10px; overflow: auto; background-color: var(--bgAlternate1);  transition:width 0.25s ease-in-out;transition-delay:1s;}
	/*#toolsMainBodyNav:Hover {  width: 30%; }*/
	#toolsMainBodyNav a { width: 100%; display: block;}
	#toolsMainBodyNavTEMP {  display:none; }
	#toolsMainBodyContent { order:2; display:block; vertical-align: top; height: 100%; width: 85%; overflow: auto;}
	#toolsMainBodyContent .section1 {  display:block; margin:10px 0px 0px 0px;}
	#toolsMainBodyContent .section1 .comment { border:0; padding-left:20px;}
	#toolsMainBodyContent .section2 {  display:block; margin:10px 0px 0px 0px;}
	#toolsMainBodyContent .section2 .comment { border:0; padding-left:10px;}
	#toolsMainBodyContent .section3 {  display:block; margin:5px 0px 0px 0px; background-color: var(--bgAlternate2) ;}
	#toolsMainBodyContent .section3 .comment { border:0; padding-left:10px;}

	/* The intention  of the sections is that they are containers so it goes like this*/
	/* content 
		section1
			section2
			section2
				section3
			section2
	*/

	#toolsFooter { }
	table { width: 100%;}
	table thead, table tfoot { position: sticky;  background: var(--bgAlternate2); color: var(--fgNormal);}
	table thead { inset-block-start: 0;} /* top */
	table tfoot { inset-block-end: 0;} /* bottom */
	table tbody tr:nth-child(odd) {
 		background-color: var(--bgAlternate1);
  		color: var(--fgNormal);
	}
	
	table tbody tr { vertical-align:top;}
	table tbody tr:Hover { background-color: var(--bgHover);  }

	.nocopy	{
		-webkit-user-select: none;
		-khtml-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		-o-user-select: none;
		user-select: none;
	}

	.unInteresting {
		-webkit-user-select: none;
		-khtml-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		-o-user-select: none;
		user-select: none;
	}
	.quiteInteresting {
		-webkit-user-select: text;
		-khtml-user-select: text;
		-moz-user-select: text;
		-ms-user-select: text;
		-o-user-select: text;
		user-select: text;
	}
	.veryInteresting {
		-webkit-user-select: text;
		-khtml-user-select: text;
		-moz-user-select: text;
		-ms-user-select: text;
		-o-user-select: text;
		user-select: text;
		font-weight:bold; font-size:1.1em;
	}

	.treeItemName {
		display: inline-block;
		font-weight: bold;
		min-width: 100px;
	}

	.treeItemValue {
		min-width: 100px;
	}

	/* END of style of the app */
	/* Start of nav */
	#toolsMainBodyNav .CDEFPropertyName::after  { white-space: nowrap;  content: " property"; color:silver;}
	#toolsMainBodyNav .CDEFMethodName::after {  white-space: nowrap; content: " method"; color:silver;}
	#toolsMainBodyNav .CDEFClassParameterName::after  { white-space: nowrap; content: " parameter"; color:silver;}
	#toolsMainBodyNav .CDEFQueryName::after  { white-space: nowrap; content: " query"; color:silver;}
	#toolsMainBodyNav .CDEFStorageName::after  { white-space: nowrap; content: " storage"; color:silver;}
	#toolsMainBodyNav .CDEFIndexName::after  { white-space: nowrap; content: " index"; color:silver;}
	#toolsMainBodyNav .CDEFXdataName::after  { white-space: nowrap; content: " xdata"; color:silver;}
	
	/* END of nav */

	/* Start of style for the code display */

	.comment { color: var(--fgComment); }

	.EmbeddedJS { background-color: var(--bgAlternate1); display:inline-block;}
	.EmbeddedSQL { background-color: var(--bgAlternate1); display:inline-block; vertical-align: top;}
	.EmbeddedXML { background-color: var(--bgAlternate1); display:inline-block;}
	.EmbeddedPython { background-color: var(--bgAlternate1); display:inline-block;}

	.CDEFComment { color: var(--fgComment); }
   	.CDEFClassName, a.CDEFClassName  { color: var(--fgProgramName);}
	.CDEFMember, a.CDEFMember, a.CDEFMember:visited {color: var(--fgProgramLabel);}
	.CDEFKeyword { color: var(--fgProgramKeyword);}

    .KeyWord { color: var(--fgCodeKeyword);}
	.Warning { border-style:solid; border-color:red; border-width:1px 5px 1px 5px;}

	.CDEFItemMenu { background-color: var(--bgAlternate3);}
	.CDEFOption, .CDEFOption:visited { color: var(--fgInlineOption);}
	.CDEFOption:hover { background-color: var(--bgAlternate2); }

    .CDEFFormalSpecList { display: inline-block; white-space: wrap; max-width: 75%;  vertical-align:top;}
    .CDEFFormalSpecItem {  white-space:nowrap; background-color: var(--bgAlternate1); }

	.COSGlobal, a.COSGlobal, a.COSGlobal:Visited {color: var(--fgCodeVariableGlobal);}
	.COSGlobalSet, a.COSGlobalSet, a.COSGlobalSet:visited {color: var(--fgCodeVariableGlobal); font-weight:bold;}

	.COSObjectMember, a.COSObjectMember, a.COSObjectMember:visited {color: var(--fgCodeLabel);}

	.COSVariable { color:var(--fgCodeVariable);}
	.COSVariableSet { color:var(--fgCodeVariable); font-weight:bold; }
	.COSVariableParameter { color: var(--fgCodeArgument);}
	.COSVariableParameterSet { color: var(--fgCodeVariable); font-weight:bold;}

	.COSString { color: var(--fgCodeString); }
	.COSNumber { color: var(--fgCodeNumber); }

	.COSLabel, a.COSLabel, a.COSLabel:visited { color: var(--fgCodeLabel);}
	.COSLabelDef { color:var(--fgCodeLabel); font-weight: bold;}

	.XMLTag { color: var(--fgProgramKeyword); }
	.XMLAttribute { color:var(--fgCodeVariable); }
	.XMLString { color: var(--fgCodeString); }

	.SQLColumn:hover { background-color: var(--bgAlternate2);}
	.SQLTableAlias { color: var(--fgCodeVariable);}
	.SQLTableAliasSet { color: var(--fgCodeVariable); font-weight:bold;}

	@keyframes blinker {
	from {opacity: 1.0;}
	to {opacity: 0.1;}
	}

	.hilite {  background-color: /*#505050;*/ var(--bgHilite); border-bottom:1px solid yellow;
		animation-name: blinker;
		animation-duration: 1s;
		animation-iteration-count:20;
		animation-timing-function:ease-in-out;
		animation-direction: alternate;		
	}
	
	.hiliterow td { background-color: var(--bgHilite); }
	.goodrow td { background-color: var(--bgGood); }
	.warningrow td { background-color: var(--bgWarning); }
	.errorrow td { background-color: var(--bgError); }
	.hilitedata { background-color: var(--bgHilite); }
	.gooddata  { background-color: var(--bgGood); }
	.warningdata { background-color: var(--bgWarning); }
	.errordata { background-color: var(--bgError); }
	
	.hiliteSET1 { background-color:#ffcc00; } 
	.hiliteSET2 { background-color:#ff0000; }
	.hiliteSET3 { background-color:#0000ff; }
	.hiliteSET4 { background-color:#00cc00; }
	.hiliteSET5 { background-color:#800080; }
	.hiliteSET6 { background-color:#00ccb4; }
	.hiliteSET7 { background-color:#be00cc; }
	.hiliteSET8 { background-color:#b30000; }
	.hiliteSET9 { background-color:none; }
	.hiliteGET1 { background-color:#cca300; } 
	.hiliteGET2 { background-color:#cc0000; } 
	.hiliteGET3 { background-color:#0000cc; }
	.hiliteGET4 { background-color:#009900; }
	.hiliteGET5 { background-color:#660066; }
	.hiliteGET6 { background-color:#009987; }
	.hiliteGET7 { background-color:#8e0099; }
	.hiliteGET8 { background-color:#860000; }
	.hiliteGET9 { background-color:none; }
	
	/* End of code display */


 	</style>
	>
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.Styles.Green">
<Super>PXW.Tools.Styles.super</Super>
<TimeChanged>67125,77563.967194429</TimeChanged>
<TimeCreated>67125,77563.967194429</TimeCreated>

<Property name="CDEFMenuInline">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Method name="WriteStyles">
<Implementation><![CDATA[
    &html<
    <style> /*-- extra style --*/
    /* https://css-tricks.com/old-timey-terminal-styling/ */
	/* https://www.w3schools.com/css/css3_box-sizing.asp */
	* {
 		box-sizing: border-box;
	}

	:root {
		/* background colours: ;*/
		--bgNormal: #FFFFFF;
		--bgAlternate1: #EEEEEE;
		--bgAlternate2: #DDDDDD;
		--bgAlternate3: #FFFFFF;
		--bgHover: #67BD5A;
		--bgHilite: #57BD4A;
		--bgWarning: #47AD3A;
		--bgError: #379D2A;
		--bgGood: #b3ffb3;

		/* foreground colours: ;*/
		--fgNormal: #67BD5A;
		--fgInverse: black;
		--fgProgramName: #2EA990;
		--fgProgramLabel: #ACAC7A;
		--fgProgramKeyword: #6586DF;
		--fgCodeKeyword: black;
		--fgCodeVariable: #6DA2FF;
		--fgCodeVariableGlobal: #64c9ff;
		--fgCodeArgument: #ff75f4;
		--fgCodeLabel: #ACAC7A;
		--fgCodeString: #2e8122; 
		--fgCodeNumber: #B4955C; 
		--fgComment: #2e8122;
		--fgInlineOption: silver;
	}	
    body {
        background-color: black;
        background-image: radial-gradient(rgba(0, 75, 0, 0.75), black 120% );
        height: 100vh;
        margin: 0;
        overflow: hidden;
        padding: 2rem;
        color: /*white;*/ #67BD5A; 
        font: 1.3rem Inconsolata, monospace;
        text-shadow: 0 0 5px #C8C8C8;

        border:0; margin:0; padding:0; height: 100%; display: flex; flex-direction: column;
    }
    body::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: repeating-linear-gradient(0deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.15) 1px, transparent 1px, transparent 2px);
        pointer-events: none;
    }
    
    /*::selection {
        background: #0080FF;
        text-shadow: none;
    }*/


	html { height: 100%;}
	/*body {border:0; margin:0; padding:0; background-color:#1E1E1E; color:white; height: 100%; display: flex; flex-direction: column;} */
	a { text-decoration:none;  color: inherit;}
	a:visited { text-decoration:none; color: inherit; }
	a:hover { text-decoration:none;  color: inherit; }
	a:active { text-decoration:none;  color: inherit; }
	pre { margin:0px; tab-size:4;}


	#toolsMainTop { }
	#toolsHead { }
	#toolsHead form { display:inline; margin: 0px; padding:0px; border:0px; }
	#toolsHead form fieldset { display:inline;  }
	#toolsMenu {}
	#toolsTitle {}
	#toolsMainBody { flex-grow: 1;overflow:auto;}
	#toolsMainBodyContainer {  width:100%; display:flex; height:100%; }
	#toolsMainBodyNav {  order:1;  display:block; vertical-align: top; height: 100%; width: 15%; margin:0px; overflow: auto; }
	#toolsMainBodyNav a { width: 100%; display: block;}
	#toolsMainBodyNavTEMP {  display:none; }
	#toolsMainBodyContent { order:2; display:block; vertical-align: top; height: 100%; width: 85%; overflow: auto;}
	#toolsFooter { }

	table thead, table tfoot { position: sticky;  background: black;}
	table thead { inset-block-start: 0;} /* top */
	table tfoot { inset-block-end: 0;} /* bottom */
	table tbody tr:nth-child(odd) {
 		/*background-color:#2E2E2E;
  		color: #fff;*/
	}
	table tbody tr:Hover { background-color:var(--bgHover); color: var(--fgInverse);}

	.nocopy	{
		-webkit-user-select: none;
		-khtml-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		-o-user-select: none;
		user-select: none;
	}

	.unInteresting {
		-webkit-user-select: none;
		-khtml-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		-o-user-select: none;
		user-select: none;
	}
	.quiteInteresting {
		-webkit-user-select: text;
		-khtml-user-select: text;
		-moz-user-select: text;
		-ms-user-select: text;
		-o-user-select: text;
		user-select: text;
	}
	.veryInteresting {
		-webkit-user-select: text;
		-khtml-user-select: text;
		-moz-user-select: text;
		-ms-user-select: text;
		-o-user-select: text;
		user-select: text;
		font-weight:bold; font-size:1.1em;
	}

	/* END of style of the app */
	/* Start of nav */
	#toolsMainBodyNav .CDEFPropertyName::after  {  content: ".pty"; /* color:silver;*/}
	#toolsMainBodyNav .CDEFMethodName::after {  content: ".mtd"; /* color:silver;*/}
	#toolsMainBodyNav .CDEFClassParameterName::after  {  content: ".par"; /*color:silver;*/}
	#toolsMainBodyNav .CDEFQueryName::after  {  content: ".qry"; /*color:silver;*/}
	#toolsMainBodyNav .CDEFStorageName::after  {  content: ".stg"; /*color:silver;*/}
	#toolsMainBodyNav .CDEFIndexName::after  {  content: ".idx"; /*color:silver;*/}
	#toolsMainBodyNav .CDEFXdataName::after  {  content: ".xda"; /*color:silver;*/}
	
	/* END of nav */

	/* Start of style for the code display */

	.EmbeddedJS { /*background-color:#404040*/; display:inline-block;}
	.EmbeddedSQL {/*background-color:#404040;*/ display:inline-block; vertical-align: top;}
	.EmbeddedXML {/*background-color:#404040;*/ display:inline-block;}

	.CDEFComment { color:#67BD5A; }
   	.CDEFClassName, a.CDEFClassName  { /*color:#4EC9B0;*/}
	.CDEFMember, a.CDEFMember, a.CDEFMember:visited {/*color:#DCDCAA;*/}
	.CDEFKeyword { /*color:#85A6FF;*/}

    .KeyWord { /*color:white;*/}
	.Warning { /*border-style:solid; border-color:red; border-width:1px 5px 1px 5px; */ background-color:#67BD5A; color:black;}

	.CDEFItemMenu {/* background-color:#0E0E0E;*/ }
	.CDEFOption, .CDEFOption:visited { /* color:silver; */ background-color:#67BD5A; color:black;}
	.CDEFOption:hover { /*background-color:#3e3e3e;*/ background-color:#67BD5A; color:black; }

    .CDEFFormalSpecList { display: inline-block; white-space: wrap; max-width: 75%;  vertical-align:top;}
    .CDEFFormalSpecItem {  white-space:nowrap; /*background-color:#2E2E2E;*/ }

	.COSGlobal, a.COSGlobal, a.COSGlobal:Visited {/*color:#64c9ff;*/}
	.COSGlobalSet, a.COSGlobalSet, a.COSGlobalSet:visited {/*color:#64c9ff;*/ font-weight:bold;}

	.COSObjectMember, a.COSObjectMember, a.COSObjectMember:visited {/*color:#DCDCAA;*/}

	.COSVariable { /*color:#ade2ff;*/}
	.COSVariableSet { /*color:#ade2ff;*/ font-weight:bold; }
	.COSVariableParameter { /*color:#ff75f4;*/}
	.COSVariableParameterSet { /*color:#ff75f4;*/ font-weight:bold;}

	.COSString { /*color:#d4b57c;*/ }
	.COSNumber { /*color:#d4b57c; */}

	.COSLabel, a.COSLabel, a.COSLabel:visited { /*color:#DCDCAA;*/}
	.COSLabelDef { /*color:#DCDCAA;*/ font-weight: bold;}

	.XMLTag { /*color:#85a6ff;*/ }
	.XMLAttribute { /*color:#ade2ff;*/ }
	.XMLString { /*color:#d4b57c;*/ }

	.SQLColumn:hover { background-color: #585858;}
	.SQLTableAlias { /*color:#ade2ff;*/}
	.SQLTableAliasSet {/* color:#ade2ff;*/ font-weight:bold;}


	@keyframes blinker {
	from {opacity: 1.0;}
	to {opacity: 0.0;}
	}

	.hilite {  /*background-color: #505050; border-bottom:1px solid yellow;*/ 
		text-decoration:blink;
		animation-name: blinker;
		animation-duration: 0.6s;
		animation-iteration-count:infinite;
		animation-timing-function:ease-in-out;
		animation-direction: alternate;	
	}

	.hiliterow td { background-color: var(--bgHilite); color: var(--fgInverse); }
	.goodrow td { background-color: var(--bgGood); color: var(--fgInverse);}
	.warningrow td { background-color: var(--bgWarning); color: var(--fgInverse);}
	.errorrow td { background-color: var(--bgError); color: var(--fgInverse);}

	.hilitedata { background-color: var(--bgHilite); color: var(--fgInverse); }
	.gooddata  { background-color: var(--bgGood); color: var(--fgInverse);}
	.warningdata { background-color: var(--bgWarning); color: var(--fgInverse);}
	.errordata { background-color: var(--bgError); color: var(--fgInverse); }

	.hiliteSET1 { background-color:#ffcc00; } 
	.hiliteSET2 { background-color:#ff0000; }
	.hiliteSET3 { background-color:#0000ff; }
	.hiliteSET4 { background-color:#00cc00; }
	.hiliteSET5 { background-color:#800080; }
	.hiliteSET6 { background-color:#00ccb4; }
	.hiliteSET7 { background-color:#be00cc; }
	.hiliteSET8 { background-color:#b30000; }
	.hiliteSET9 { background-color:none; }
	.hiliteGET1 { background-color:#cca300; } 
	.hiliteGET2 { background-color:#cc0000; } 
	.hiliteGET3 { background-color:#0000cc; }
	.hiliteGET4 { background-color:#009900; }
	.hiliteGET5 { background-color:#660066; }
	.hiliteGET6 { background-color:#009987; }
	.hiliteGET7 { background-color:#8e0099; }
	.hiliteGET8 { background-color:#860000; }
	.hiliteGET9 { background-color:none; }
	
	/* End of code display */


    /*.CDEFElement { font-family: monospace; white-space: pre;}
	.CDEFDescription { color:#67BD5A; }
	

    .CDEFKeyWord { color:white;}
    .CDEFClassName, a.CDEFClassName  { color:#4EC9B0;}
    .CDEFName, a.CDEFName { color:#DCDCAA;} 
    .CDEFFormalSpecVar { color:#ff75f4;}
    .CDEFString { color:#d4b57c; }
	
	.COSCommand { color:#ffffff;}
	.COSComment { color:#80bd66;}
	.COSDescription { margin-left:20px; background-color: #303030; color:#80bd66;}
	.COSVariable { color:#ade2ff;}
	.COSVariableSet { color:#ade2ff; font-weight:bold; }
	.COSObject {color:#ade2ff;} 
	.COSObjectParameter {color:#ff75f4;}  
	.COSObjectsClass, a.COSObjectsClass, a.COSObjectsClass:visited {color:#4EC9B0;}
	.COSObjectsMethod, a.COSObjectsMethod, a.COSObjectsMethod:visited {color:#DCDCAA;}
	.COSObjectsProperty, a.COSObjectsProperty, a.COSObjectsProperty:visited {color:#DCDCAA;}
	.COSObjectsQuery, a.COSObjectsQuery, a.COSObjectsQuery:visited {color:#DCDCAA;}
	.COSLabel { color:#DCDCAA; }
	.COSFunction { color:#85a6ff; }
	.COSString { color:#d4b57c; }
	.COSWarning { border-style:solid; border-color:red; border-width:1px 5px 1px 5px;}

	.SQLComment { color:#80bd66;}
	.SQLCommand { color:#ffffff;}
	.SQLWarning { border:1px solid red;}

	.JSCommand { color:#C0C0C0;}
	.JSComment { color:#80bd66;}
	.JSVariable { color:#ade2ff;}
	.JSString { color:#d4b57c; }
	.JSWarning { border:1px solid red;}
	.JSRegex { color:yellow; }





	*/
	</style>
	>
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.Styles.Hip">
<Super>PXW.Tools.Styles.super</Super>
<TimeChanged>67125,77563.970783636</TimeChanged>
<TimeCreated>67125,77563.970783636</TimeCreated>

<Method name="WriteStyles">
<Implementation><![CDATA[
    &html<
    <style> /*-- extra style --*/

	/* https://www.w3schools.com/css/css3_box-sizing.asp */
	* {
 		box-sizing: border-box;
	}

	:root {
		/* background colours: ;*/
		--bgNormal: #1E1E1E;
		--bgAlternate1: #2E2E2E;
		--bgAlternate2: #3E3E3E;
		--bgAlternate3: black;
		--bgHover: #3E3E3E;
		--bgHilite:#6b6b1d;
		--bgWarning: #f3a488;
		--bgError: #9f3d3d;
		--bgGood: #225922;

		/* foreground colours: ;*/
		--fgNormal: white;
		--fgAlternate: black;
		--fgProgramName: #4EC9B0;
		--fgProgramLabel: #DCDCAA;
		--fgProgramKeyword: #6596FF;
		--fgCodeKeyword: white;
		--fgCodeVariable: #ade2ff;
		--fgCodeVariableGlobal: #64c9ff;
		--fgCodeArgument: #ff75f4;
		--fgCodeLabel: #DCDCAA;
		--fgCodeString: #D4B57C; 
		--fgCodeNumber: #D4B57C; 
		--fgComment: #378D2A;
		--fgInlineOption: silver;
	}	


	html { height: 100%;}
	body {border:0; margin:0; padding:0; background-color: var(--bgNormal); color: var(--fgNormal); height: 100%; display: flex; flex-direction: column;
			font-family: Arial, Helvetica, sans-serif; font-size: small;} 
	a { text-decoration:none;  color: inherit;}
	a:visited { text-decoration:none; color: inherit; }
	a:hover { text-decoration:none;  color: inherit; }
	a:active { text-decoration:none;  color: inherit; }
	pre { margin:0px; tab-size:4; font-size: medium;}


	#toolsMainTop { }
	#toolsHead { }
	#toolsHead form { display:inline; margin: 0px; padding:0px; border:0px; }
	#toolsHead form fieldset { display:inline;  }
	#toolsMenu {}
	#toolsTitle {}
	#toolsMainBody { flex-grow: 1;overflow:auto;}
	#toolsMainBodyContainer {  width:100%; display:flex; height:100%; }
	#toolsMainBodyNav {  order:1;  display:block; vertical-align: top; height: 100%; width: 15%; padding:10px; overflow: auto; background-color: var(--bgAlternate1);  transition:width 0.25s ease-in-out;transition-delay:1s;}
	/*#toolsMainBodyNav:Hover {  width: 30%; }*/
	#toolsMainBodyNav a { width: 100%; display: block;}
	#toolsMainBodyNavTEMP {  display:none; }
	#toolsMainBodyContent { order:2; display:block; vertical-align: top; height: 100%; width: 85%; overflow: auto;}
	#toolsMainBodyContent .section1 {  display:block; margin:10px 0px 0px 0px;}
	#toolsMainBodyContent .section1 .comment { border:0; padding-left:20px;}
	#toolsMainBodyContent .section2 {  display:block; margin:10px 0px 0px 0px;}
	#toolsMainBodyContent .section2 .comment { border:0; padding-left:10px;}
	#toolsMainBodyContent .section3 {  display:block; margin:5px 0px 0px 0px; background-color: var(--bgAlternate2) ;}
	#toolsMainBodyContent .section3 .comment { border:0; padding-left:10px;}

	/* The intention  of the sections is that they are containers so it goes like this*/
	/* content 
		section1
			section2
			section2
				section3
			section2
	*/

	#toolsFooter { }
	table { width: 100%;}
	table thead, table tfoot { position: sticky;  background: var(--bgAlternate3);}
	table thead { inset-block-start: 0;} /* top */
	table tfoot { inset-block-end: 0;} /* bottom */
	table tbody tr:nth-child(odd) {
 		background-color: var(--bgAlternate1);
  		color: var(--fgNormal);
	}
	
	table tbody tr { vertical-align:top;}
	table tbody tr:Hover { background-color: var(--bgHover);  }

	.nocopy	{
		-webkit-user-select: none;
		-khtml-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		-o-user-select: none;
		user-select: none;
	}

	.unInteresting {
		-webkit-user-select: none;
		-khtml-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		-o-user-select: none;
		user-select: none;
	}
	.quiteInteresting {
		-webkit-user-select: text;
		-khtml-user-select: text;
		-moz-user-select: text;
		-ms-user-select: text;
		-o-user-select: text;
		user-select: text;
	}
	.veryInteresting {
		-webkit-user-select: text;
		-khtml-user-select: text;
		-moz-user-select: text;
		-ms-user-select: text;
		-o-user-select: text;
		user-select: text;
		font-weight:bold; font-size:1.1em;
	}

	.treeItemName {
		display: inline-block;
		font-weight: bold;
		min-width: 200px;
	}

	.treeItemNameBranch {
		display: inline-block;
		font-weight: bold;
		text-decoration: underline;
		min-width: 200px;
	}

	.treeItemValue {
		min-width: 100px;
	}

	/* END of style of the app */
	/* Start of nav */
	#toolsMainBodyNav .CDEFPropertyName::after  { white-space: nowrap;  content: " property"; color:silver;}
	#toolsMainBodyNav .CDEFMethodName::after {  white-space: nowrap; content: " method"; color:silver;}
	#toolsMainBodyNav .CDEFClassParameterName::after  { white-space: nowrap; content: " parameter"; color:silver;}
	#toolsMainBodyNav .CDEFQueryName::after  { white-space: nowrap; content: " query"; color:silver;}
	#toolsMainBodyNav .CDEFStorageName::after  { white-space: nowrap; content: " storage"; color:silver;}
	#toolsMainBodyNav .CDEFIndexName::after  { white-space: nowrap; content: " index"; color:silver;}
	#toolsMainBodyNav .CDEFXdataName::after  { white-space: nowrap; content: " xdata"; color:silver;}
	
	/* END of nav */

	/* Start of style for the code display */

	.comment { color: var(--fgComment); }

	.EmbeddedJS { background-color: var(--bgAlternate1); display:inline-block;}
	.EmbeddedSQL { background-color: var(--bgAlternate1); display:inline-block; vertical-align: top;}
	.EmbeddedXML { background-color: var(--bgAlternate1); display:inline-block;}
	.EmbeddedPython { background-color: var(--bgAlternate1); display:inline-block;}

	.CDEFComment { color: var(--fgComment); }
   	.CDEFClassName, a.CDEFClassName  { color: var(--fgProgramName);}
	.CDEFMember, a.CDEFMember, a.CDEFMember:visited {color: var(--fgProgramLabel);}
	.CDEFKeyword { color: var(--fgProgramKeyword);}

    .KeyWord { color:var(--fgCodeKeyword);}
	.Warning { border-style:solid; border-color:red; border-width:1px 5px 1px 5px;}

	.CDEFItemMenu { background-color: var(--bgAlternate3);}
	.CDEFOption, .CDEFOption:visited { color: var(--fgInlineOption);}
	.CDEFOption:hover { background-color: var(--bgAlternate2); }

    .CDEFFormalSpecList { display: inline-block; white-space: wrap; max-width: 75%;  vertical-align:top;}
    .CDEFFormalSpecItem {  white-space:nowrap; background-color: var(--bgAlternate1); }

	.COSGlobal, a.COSGlobal, a.COSGlobal:Visited {color: var(--fgCodeVariableGlobal);}
	.COSGlobalSet, a.COSGlobalSet, a.COSGlobalSet:visited {color: var(--fgCodeVariableGlobal); font-weight:bold;}

	.COSObjectMember, a.COSObjectMember, a.COSObjectMember:visited {color: var(--fgCodeLabel);}

	.COSVariable { color:var(--fgCodeVariable);}
	.COSVariableSet { color:var(--fgCodeVariable); font-weight:bold; }
	.COSVariableParameter { color: var(--fgCodeArgument);}
	.COSVariableParameterSet { color: var(--fgCodeVariable); font-weight:bold;}

	.COSString { color: var(--fgCodeString); }
	.COSNumber { color: var(--fgCodeNumber); }

	.COSLabel, a.COSLabel, a.COSLabel:visited { color: var(--fgCodeLabel);}
	.COSLabelDef { color:var(--fgCodeLabel); font-weight: bold;}

	.XMLTag { color: var(--fgProgramKeyword); }
	.XMLAttribute { color:var(--fgCodeVariable); }
	.XMLString { color: var(--fgCodeString); }

	.SQLColumn:hover { background-color: var(--bgAlternate2);}
	.SQLTableAlias { color: var(--fgCodeVariable);}
	.SQLTableAliasSet { color: var(--fgCodeVariable); font-weight:bold;}

	@keyframes blinker {
	from {opacity: 1.0;}
	to {opacity: 0.1;}
	}

	.hilite {  background-color: /*#505050;*/ var(--bgHilite); border-bottom:1px solid yellow;
		animation-name: blinker;
		animation-duration: 1s;
		animation-iteration-count:20;
		animation-timing-function:ease-in-out;
		animation-direction: alternate;		
	}
	
	.hiliterow td { background-color: var(--bgHilite); }
	.goodrow td { background-color: var(--bgGood); }
	.warningrow td { background-color: var(--bgWarning); }
	.errorrow td { background-color: var(--bgError); }
	.hilitedata { background-color: var(--bgHilite); }
	.gooddata  { background-color: var(--bgGood); }
	.warningdata { background-color: var(--bgWarning); }
	.errordata { background-color: var(--bgError); }
	
	.hiliteSET1 { background-color:#ffcc00; } 
	.hiliteSET2 { background-color:#ff0000; }
	.hiliteSET3 { background-color:#0000ff; }
	.hiliteSET4 { background-color:#00cc00; }
	.hiliteSET5 { background-color:#800080; }
	.hiliteSET6 { background-color:#00ccb4; }
	.hiliteSET7 { background-color:#be00cc; }
	.hiliteSET8 { background-color:#b30000; }
	.hiliteSET9 { background-color:none; }
	.hiliteGET1 { background-color:#cca300; } 
	.hiliteGET2 { background-color:#cc0000; } 
	.hiliteGET3 { background-color:#0000cc; }
	.hiliteGET4 { background-color:#009900; }
	.hiliteGET5 { background-color:#660066; }
	.hiliteGET6 { background-color:#009987; }
	.hiliteGET7 { background-color:#8e0099; }
	.hiliteGET8 { background-color:#860000; }
	.hiliteGET9 { background-color:none; }
	
	/* End of code display */


 	</style>
	>
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.Styles.StarTrek">
<Super>PXW.Tools.Styles.super</Super>
<TimeChanged>67125,77563.994129129</TimeChanged>
<TimeCreated>67125,77563.994129129</TimeCreated>

<Property name="CDEFDescriptionsAsText">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="CDEFMenuInline">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Method name="WriteStyles">
<Implementation><![CDATA[
    &html<
    <style> /*-- extra style --*/
	/* https://www.w3schools.com/css/css3_box-sizing.asp */
	* {
 		box-sizing: border-box;
	}

	/* https://codepen.io/Mokurunner/details/wvyKJy */
	:root {
		--lcars1: #FFDD99;
		--lcars2: #FFCC66;
		--lcars3: #FF9933;
		--lcars4: #664466;
		--lcars5: #CC99CC;
		--lcars6: #99CCFF;
		--lcars7: #3366CC;
		--lcars8: #006699;

		--bgHilite:#878700;
		--bgWarning: #f3a488;
		--bgError: #7b2c2c;
		--bgGood: #225922;
	}	


	body {border:0; margin:0; padding:0; background-color:#1E1E1E; color:white; height: 100%; 
	        display: flex; flex-direction: column;
					font-family:helvetica;  font-stretch:ultra-condensed; font-weight: bold;
			}
	a { text-decoration:none;  color: inherit;}
	a:visited { text-decoration:none; color: inherit; }
	a:hover { text-decoration:none;  color: inherit; }
	a:active { text-decoration:none;  color: inherit; }
	pre { margin:0px; tab-size:4; font-weight: normal;}

	::-webkit-scrollbar {
	  width: 20px;
	}

	/* Track */
	::-webkit-scrollbar-track {
	  /*box-shadow: inset 0 0 5px grey;  */
	  border: 1px solid var(--lcars8);
	  border-radius: 10px;
	}
	 
	/* Handle */
	::-webkit-scrollbar-thumb {
	  background: var(--lcars8); 
	  border-radius: 10px;
	}

	/* Handle on hover */
	::-webkit-scrollbar-thumb:hover {
	  background: #b30000; 
	}
	::-webkit-scrollbar-corner {
	  background:black;
	}
	#toolsMainTop { }
	#toolsHead { 
		margin:0px;
		border-color: var(--lcars1);
		border-style: solid;
		/*border-width: 0px 0px 0px 100px;*/
		border-width: 0px 0px 10px 100px;
		border-radius: 0px 0px 0px 50px; 
		padding: 0px;
		background-color: black;
		
	  }
	
	/* trying to get the border to overlap the container border so we get the curve on the inside */
	#toolsForms { margin-left:-20px; 
		/*border-radius: 0px 0px 0px 20px; */
		border-radius: 0px 0px 0px 20px; 
		padding: 20px;
		background-color: black;
	}

	#toolsHead form { display:inline; margin: 0px; padding:0px; border:0px; }
	/*#toolsHead form fieldset { display:inline;  }
	*/

	#toolsHead form fieldset { display:inline; 
					background-color: var(--lcars1); color:white; 
					border-color: var(--lcars1);
					border-style: solid;
					border-width: 20px 20px 0px 20px;
					border-radius: 20px 20px 20px 20px; 
					vertical-align: bottom;
					padding: 0px;
					}
	#toolsHead form fieldset legend { display:none;}
	/*#toolsHead fieldset { margin: 0px; padding:0px; border:0px;}*/
	#toolsHead form fieldset input { 
					background-color: var(--lcars1); color:black; 
					/*text-transform: uppercase;*/
					 font-weight: bold; font-stretch:ultra-condensed;
					border:0px;
					}
	#toolsMenu { display:none;
		margin-top:10px;
		background-color: var(--lcars1);
		width:100px; min-height: 100px;
		border-width: 0px 0px 0px 100px;
		border-radius: 50% 0px 0px 0px;
		padding:0px;
	}


	#toolsTitle { 
		margin-top:10px;
		border-color: var(--lcars2);
		border-style: solid;
		border-width: 0px 10px 0px 100px;
		border-radius: 100pt 0px 0px 0px;
		background-color: var(--lcars2);
		padding: 0px; 
		text-align: right;
	  }
	#toolsTitle h1 {
		margin:0px 10px 0px 10px;
		border:0px;
		padding:0px 10px 0px 10px;
		text-align: right;
		text-transform: uppercase;
		background-color:black;
		display:inline;		
	}



	#toolsMainBody { 
		background-color: var(--lcars2);
		padding: 0px;
		flex-grow: 1;
		overflow: hidden;
	  }

	#toolsMainBodyContainer {  width:100%; display:flex; height:100%; }
	#toolsMainBodyNav {  order:1;  display:block; vertical-align: top; height: 100%; width: 20%;
					background-color: var(--lcars2);
					padding-top:20px;
					overflow-x: clip; overflow-y: auto;}
	#toolsMainBodyNav a { text-transform: uppercase; text-align: right; color:black; 
	                 width:100%; display: block; 
					 min-height:5%; 
					 border-top: 4px solid black;
					 padding-top:30px; 
					  font-weight: bold;
						
					 }



	#toolsMainBodyContent { order:2; display:block; vertical-align: top;
					 height: 100%; width: 80%; 
					 	margin: 0;
						background-color: black;
						border-radius:10px 0px 0px 0px; 
						border-width: 20px 0px 20px 20px;
						border-style: solid;
						border-color:black;
						padding:0px 20px 0px 0px;
						/*padding:20px 0px 0px 10px;*/
						 overflow: auto;}

	/*#toolsMainBodyContent div { display:inline; width:200px; }*/
	#PXWTools div { display: inline-block; width: 48%;}

	#toolsMainBodyContent fieldset { /*display:inline; width:45%;*/
					background-color: black; color:white; 
					/*border-color: var(--lcars3);*/
					border-style: solid;
					border-width: 20px 50px 0px 0px;
					border-radius: 0px 20px 0px 0px; 
					vertical-align: bottom;
					padding: 0px 0px 30px 0px;
					margin: 0px 0px 30px 0px;
					}
	#toolsMainBodyContent .toolTypeInternal form fieldset {  
					border-color: var(--lcars4);
					}

	#toolsMainBodyContent .toolTypeCode form fieldset {  
					border-color: var(--lcars5);
					}

	#toolsMainBodyContent fieldset legend { margin-left:20px;
			font-weight: bold;
		text-transform: uppercase;}

	/*#toolsMainBodyContent form { margin: 0px; padding:0px; border:0px;}*/
	#toolsMainBodyContent form fieldset input { 
					background-color: #f7c64a; color:black; 
					text-transform: uppercase;
					font-weight: bold; font-stretch:ultra-condensed;/*font-family:helvetica; */
					border:0px;
					}
	#toolsMainBodyContent .section1 {  display:block; margin:10px 0px 0px 0px; inset-block-start: 0;}

	#toolsMainBodyContent .section1 .comment { border:0; padding-left:20px;}
	#toolsMainBodyContent .section2 {  display:block; margin:10px 0px 0px 0px;
										border-color: var(--lcars6);
										border-radius: 0px 20px 0px 0px;
										border-width: 0px 40px 0px 0px;
										border-style: solid;
	}
	#toolsMainBodyContent .section2 h2 { background-color: var(--lcars6);
						text-transform: uppercase;
						border-radius: 20px 0 0 20px;
						padding-left: 20px;		
						color:black;								
	}

	#toolsMainBodyContent .section2:nth-child(odd) {  border-color: var(--lcars7);}
	#toolsMainBodyContent .section2:nth-child(odd) h2 {  background-color: var(--lcars7);}


	#toolsMainBodyContent .section2 .comment { border:0; padding-left:10px;}
	#toolsMainBodyContent .section3 {  display:block; margin:5px 0px 0px 0px;}
	#toolsMainBodyContent .section3 .comment { border:0; padding-left:10px;}

	#toolsFooter {
		background-color: var(--lcars2);
		color:black;
		text-align: right;
		font-weight: bold;
		text-transform: uppercase;
	}

	#toolsFooter span {
		border-left:10px solid black;
		padding:0px 20px 0px 20px;
	}

	table { font-weight: bold;
	 		background-color: black; color:white; 
			/*margin-top: 20px;*/
			/*border-color: var(--lcars8);
			border-style: solid;
			border-width: 20px 50px 0px 0px;
			border-radius: 0px 20px 0px 0px; */
			width: 100%; 
	}
	tbody tr:nth-child(odd) {
 		background-color:#2E2E2E;
  		color: #fff;
	}
	table thead, table tfoot { position: sticky;  background: var(--lcars8);}
	table thead { inset-block-start: 0; }
	table thead tr th  { text-transform: uppercase; }
	table thead tr th a { 
					background-color: var(--lcars3); color:white; 
					border-color: var(--lcars3);
					border-style: solid;
					border-width: 2px 10px 2px 10px;
					border-radius: 10px 10px 10px 10px; 
					vertical-align: bottom; 
					padding: 0px;  margin-left:5px;
					text-align:right;
					width:75px;
					white-space: nowrap;}
	/*.CDEFOption:hover { background-
	table tfoot { inset-block-end: 0;} /* bottom */
	table tbody tr:Hover { background-color:#3e3e3e;  }

	#toolsMainBodyNavTEMP {  display:none; }

	#toolsMainBodyContent form fieldset table { 
					border:0px;
	}

	table tbody tr:Hover { background-color:#3e3e3e;  }

	.nocopy	{
		-webkit-user-select: none;
		-khtml-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		-o-user-select: none;
		user-select: none;
	}

	.unInteresting {
		-webkit-user-select: none;
		-khtml-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
		-o-user-select: none;
		user-select: none;
	}
	.quiteInteresting {
		-webkit-user-select: text;
		-khtml-user-select: text;
		-moz-user-select: text;
		-ms-user-select: text;
		-o-user-select: text;
		user-select: text;
	}
	.veryInteresting {
		-webkit-user-select: text;
		-khtml-user-select: text;
		-moz-user-select: text;
		-ms-user-select: text;
		-o-user-select: text;
		user-select: text;
		font-weight:bold; font-size:1.1em;
	}

	/* END of style of the app */


	/* Start of nav */
	#toolsMainBodyNav .CDEFPropertyName  {background-color: var(--lcars1);  }
	#toolsMainBodyNav .CDEFMethodName { background-color: var(--lcars2);}
	#toolsMainBodyNav .CDEFClassParameterName  {  background-color: var(--lcars3);}
	#toolsMainBodyNav .CDEFQueryName  {  background-color: var(--lcars4);}
	#toolsMainBodyNav .CDEFIndexName  { background-color: var(--lcars5);} 
	#toolsMainBodyNav .CDEFStorageName  {  background-color: var(--lcars5);}
	#toolsMainBodyNav .CDEFXdataName  { background-color: var(--lcars6);}
	#toolsMainBodyNav .toolTypeInternal  { background-color: var(--lcars4); }
	#toolsMainBodyNav .toolTypeCode  { background-color: var(--lcars5); }	
	#toolsMainBodyNav .warning { background-color: red;}
	/* END of nav */
	/* Start of style for the code display */


	.EmbeddedJS { background-color:#404040; display:inline-block;}
	.EmbeddedSQL { background-color:#404040; display:inline-block; vertical-align: top;}
	.EmbeddedXML { background-color:#404040; display:inline-block;}
	.EmbeddedPython { background-color:#404040; display:inline-block;}

	.CDEFComment { color:#67BD5A; }
   	.CDEFClassName, a.CDEFClassName  { color:#4EC9B0;}
	.CDEFMember, a.CDEFMember, a.CDEFMember:visited {color:#DCDCAA;}
	.CDEFKeyword { color:#85A6FF;}

    .KeyWord { color:white;}
	.Warning { border-style:solid; border-color:red; border-width:1px 5px 1px 5px;}

	.CDEFItemMenu { background-color:black; margin-top:20px; display:block; } 
	a.CDEFOption, a.CDEFOption:visited { 
					background-color: var(--lcars3); color:black; 
					border-color: var(--lcars3);
					border-style: solid;
					border-width: 10px 10px 0px 10px;
					border-radius: 10px 10px 10px 10px; 
					vertical-align: bottom; 
					padding: 0px;  margin-left:5px;
					text-align:right;
					text-transform: uppercase;
					font-weight: bold;  font-size: 0.9em;
					width:75px;}
	/*.CDEFOption:hover { background-color:#3e3e3e; }*/

    .CDEFFormalSpecList { display: inline-block; white-space: wrap; max-width: 75%;  vertical-align:top;}
    .CDEFFormalSpecItem {  white-space:nowrap; background-color:#2E2E2E; }

	.COSGlobal, a.COSGlobal, a.COSGlobal:Visited {color:#64c9ff;}
	.COSGlobalSet, a.COSGlobalSet, a.COSGlobalSet:visited {color:#64c9ff; font-weight:bold;}

	.COSObjectMember, a.COSObjectMember, a.COSObjectMember:visited {color:#DCDCAA;}

	.COSVariable { color:#ade2ff;}
	.COSVariableSet { color:#ade2ff; font-weight:bold; }
	.COSVariableParameter { color:#ff75f4;}
	.COSVariableParameterSet { color:#ff75f4; font-weight:bold;}

	.COSString { color:#d4b57c; }
	.COSNumber { color:#d4b57c; }

	.COSLabel, a.COSLabel, a.COSLabel:visited { color:#DCDCAA;}
	.COSLabelDef { color:#DCDCAA; font-weight: bold;}

	.XMLTag { color:#85a6ff; }
	.XMLAttribute { color:#ade2ff; }
	.XMLString { color:#d4b57c; }

	.SQLColumn:hover { background-color: #585858;}
	.SQLTableAlias { color:#ade2ff;}
	.SQLTableAliasSet { color:#ade2ff; font-weight:bold;}

	@keyframes blinker {
		0% {opacity: 1.0;}
		5% { opacity: 0.0;}
		10% { opacity: 1.0;}
		15% { opacity: 0.0;}
		20% { opacity: 1.0;}
		25% { opacity: 0.0;}
		30% { opacity: 1.0;}
		100% { opacity: 1.0;}
	}

	.hilite {  background-color: #505050; border-bottom:1px solid yellow;
		animation-name: blinker;
		animation-duration: 2s;
		animation-iteration-count:4;
	}

	.hiliterow td { background-color: var(--bgHilite); }
	.goodrow td { background-color: var(--bgGood); }
	.warningrow td { background-color: var(--bgWarning); }
	.errorrow td { background-color: var(--bgError); }
	.hilitedata { background-color: var(--bgHilite); }
	.gooddata  { background-color: var(--bgGood); }
	.warningdata { background-color: var(--bgWarning); }
	.errordata { background-color: var(--bgError); }


	.hiliteSET1 { background-color:#ffcc00; } 
	.hiliteSET2 { background-color:#ff0000; }
	.hiliteSET3 { background-color:#0000ff; }
	.hiliteSET4 { background-color:#00cc00; }
	.hiliteSET5 { background-color:#800080; }
	.hiliteSET6 { background-color:#00ccb4; }
	.hiliteSET7 { background-color:#be00cc; }
	.hiliteSET8 { background-color:#b30000; }
	.hiliteSET9 { background-color:none; }
	.hiliteGET1 { background-color:#cca300; } 
	.hiliteGET2 { background-color:#cc0000; } 
	.hiliteGET3 { background-color:#0000cc; }
	.hiliteGET4 { background-color:#009900; }
	.hiliteGET5 { background-color:#660066; }
	.hiliteGET6 { background-color:#009987; }
	.hiliteGET7 { background-color:#8e0099; }
	.hiliteGET8 { background-color:#860000; }
	.hiliteGET9 { background-color:none; }
	

	</style>
	>
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Tools.Styles.super">
<Super>%Library.RegisteredObject</Super>
<TimeChanged>67125,77563.993875439</TimeChanged>
<TimeCreated>67125,77563.993875439</TimeCreated>

<Property name="CDEFDescriptionsAsText">
<Description>
If this is 1 then the descriptions are output as text (IE what was typed, with leading ///) 
if 0 the descriptions are treated as HTML so formatting can take place (special tags are not dealt with yet)</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="CDEFMenuInline">
<Description>
If this is 1 then menu options are placed next to the thing that is most applicable
If 0 then the options are grouped together in a menu holder for placement elsewhere</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="WriteStyles">
</Method>
</Class>


<Class name="PXW.Xref.AnalysisData">
<Owner>_PUBLIC</Owner>
<Super>%Library.Persistent</Super>
<TimeChanged>67129,60901.920067162</TimeChanged>
<TimeCreated>67125,77563.633051276</TimeCreated>

<Property name="NameSpace">
<Type>%String</Type>
<InitialExpression>$g(%NS)</InitialExpression>
<Required>1</Required>
</Property>

<Property name="ItemType">
<Type>%String</Type>
</Property>

<Property name="ItemKey1">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1024"/>
</Property>

<Property name="ItemKey2">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1024"/>
</Property>

<Property name="LineNumber">
<Type>%Integer</Type>
</Property>

<Property name="Description">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1024"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^PXW.Xref.AnalysisDataD</DataLocation>
<DefaultData>AnalysisDataDefaultData</DefaultData>
<IdLocation>^PXW.Xref.AnalysisDataD</IdLocation>
<IndexLocation>^PXW.Xref.AnalysisDataI</IndexLocation>
<StreamLocation>^PXW.Xref.AnalysisDataS</StreamLocation>
<ExtentSize>15654</ExtentSize>
<Data name="AnalysisDataDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NameSpace</Value>
</Value>
<Value name="3">
<Value>ItemType</Value>
</Value>
<Value name="4">
<Value>ItemKey1</Value>
</Value>
<Value name="5">
<Value>ItemKey2</Value>
</Value>
<Value name="6">
<Value>LineNumber</Value>
</Value>
<Value name="7">
<Value>Description</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:</OutlierSelectivity>
<AverageFieldSize>2</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,16,$lb("-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000"),$lb(21,21,21,21,21,21,21,21,21,21,21,21,21,21,21),$lb(758198320,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,758198320))</Histogram>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>4</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,1,0,$lb(29890,30875,38326,39951,40730,48371,49501,50542,51576,52327,53530,54892,55744,57295,58707,60096),$lb(0,1,1,0,1,1,0,1,1,1,1,1,1,1,0),"")</Histogram>
</Property>
<Property name="Description">
<Selectivity>0.0126%</Selectivity>
<OutlierSelectivity>.256115:"Short command "</OutlierSelectivity>
<AverageFieldSize>37.61</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb(" %CK NO TYPE SPECIFIED ON FORMAL SPEC"," ARGS NO TYPE SPECIFIED ON FORMAL SPEC"," CHANGE OF TYPE ON THEADER FROM %ZEN.COMPONENT.HGROUP TO %ZEN.COMPONENT.VGROUP"," DERIVED TYPE OF TSENSORINFO (%LIBRARY.STRING) DIFFERS TO DIMMED TYPE (%LIBRARY.DYNAMICOBJECT)"," HSTMT NO TYPE SPECIFIED ON FORMAL SPEC"," OPTION NO TYPE SPECIFIED ON FORMAL SPEC"," PROPERTY NO TYPE SPECIFIED ON FORMAL SPEC"," RETURN TYPE IS NOT SET, DERIVED TYPE="," RETURN TYPE=CLARA, DERIVED TYPE=%DEEPSEE.EXTENSIONS.CLUSTERS.CLARA"," SHORT COMMAND"," SHORT COMMAND"," SHORT COMMAND"," SHORT COMMAND"," TFIELDS SET BUT NOT USED"," TUSERNAME SET BUT NOT USED"," {WEBPORT} SET BUT NOT USED"),$lb(1,1,1,1,1,1,1,12,1,15,15,15,1,2,1),$lb(539312971,625167136,1095911251,1095911251,1128808782,1128808782,1145393737,1145393737,1213420621,1213420621,1330664521,1330664521,1347571536,1347571536,1380275285,541676320,1027820609,1380275285,1397247826,0,0,0,0,0,0,1397247826,1413892421,1179206988,1431520594,1414878021,2069316930,544954181))</Histogram>
</Property>
<Property name="ItemKey1">
<Selectivity>0.0718%</Selectivity>
<OutlierSelectivity>.055396:"%SYSTEM.Dictionary"</OutlierSelectivity>
<AverageFieldSize>26.49</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb(" %API.ATELIER.V1"," %CSP.UI.SQL.LINKWIZARDRESULTPAGE"," %DEEPSEE.MODEL.NODE"," %DEEPSEE.RESULTSET"," %DICTIONARY.XDATADEFINITION"," %LIBRARY.SQLGATEWAYCONNECTION"," %NET.REMOTE.OBJECT"," %STUDIO.SOURCECONTROL.CHANGE"," %SYS.PTOOLS.STATSSQL"," %SYSTEM.SQL.FUNCTIONS"," %ZEN.PROXYOBJECT"," %ZEN.SVGCOMPONENT.COMPASSBUTTONS"," ENS.ENTERPRISE.PORTAL.MSGFILTER.SAVEDSEARCH"," ENSLIB.EDI.XML.PROP"," PXW.DEV.BNF.GEN.PYTHON"," PXW.XREF.BUILDERS.CLASS"),$lb(2,2,10,3,2,2,2,3,5,2,6,1,4,1,5),$lb(539312464,1095780654,1129533486,1129533486,1145390416,1297040453,1380275029,1162170451,1229149257,1145652052,1279869522,1279869522,1313166382,1313166382,1398035780,1414874185,1498623568,777016399,1413827886,1398362964,1514491438,1347571544,1398163267,626672974,1162761006,776293972,1279869486,1162761036,1347966766,1145394734,1481786694,542136407))</Histogram>
</Property>
<Property name="ItemKey2">
<Selectivity>0.0210%</Selectivity>
<OutlierSelectivity>.014388:"%LockId"</OutlierSelectivity>
<AverageFieldSize>15.9</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb(" %ACQUIRELOCK"," %FINDCOMPUTEDMEMBERBYNAME"," %ONNEW"," %UNCONFIGURE"," BUILDMODEL"," COMSTORAGESUBSUBSUBMEMBERGET"," DEFMEMBERKEYKILL"," FETCH"," GETDETAILPANE"," GETYAXISTYPE"," LOCALADDRPORT"," ONUPDATE"," RECORDCURRENTPRODUCTIONSETTINGS"," SETSENSOR"," TESTMULT"," ZTRAPCOMMAND309SUB"),$lb(2,2,2,1,1,1,1,1,4,1,1,1,1,1,1),$lb(539312451,1094930773,1179209284,1179209284,1330531909,1330531909,1431192399,626347587,1112885580,1112885580,1129270611,1129270611,1145390669,1145390669,1178948675,1178948675,1195725892,1145394241,1497454665,1195725913,1280262977,1280262977,1330533712,1330533712,1380270927,1380270927,1397052499,1397052499,1413829460,1413829460,1515475521,542790738))</Histogram>
</Property>
<Property name="ItemType">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:"CLS"</OutlierSelectivity>
<AverageFieldSize>5</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb(" CLS"," CLS"," CLS"," CLS"," CLS"," CLS"," CLS"," CLS"," CLS"," CLS"," CLS"," CLS"," CLS"," CLS"," CLS"," CLS"),$lb(5,5,5,5,5,5,5,5,5,5,5,5,5,5,5),$lb(541281363,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,541281363))</Histogram>
</Property>
<Property name="LineNumber">
<Selectivity>0.0677%</Selectivity>
<OutlierSelectivity>.006475:27</OutlierSelectivity>
<AverageFieldSize>3.55</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,1,0,$lb(10,40,65,86,118,153,207,277,343,434,578,744,1141,1980,4579,22431),$lb(0,0,0,0,1,0,1,0,0,0,0,0,1,0,0),"")</Histogram>
</Property>
<Property name="NameSpace">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:"LOCAL_USER"</OutlierSelectivity>
<AverageFieldSize>12</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb(" LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"," LOCAL_USER"),$lb(12,12,12,12,12,12,12,12,12,12,12,12,12,12,12),$lb(541871939,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,541871939))</Histogram>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-972</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="PXW.Xref.AnalysisQueries">
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77563.640733837</TimeChanged>
<TimeCreated>67125,77563.640733837</TimeCreated>

<Query name="Get">
<Type>PXW.LIB.SQL.Query</Type>
<FormalSpec>NameSpace:%String,ItemType:%String="",ItemKey1:%String="",ItemKey2:%String="",Flags:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT NameSpace,ItemType,ItemKey1,ItemKey2,LineNumber,Description
	       --,PXW_Xref.Queries_GetCode(NameSpace,CalledByType,CalledByKey1,CalledByKey2,CalledByKey3,ItemKey1,ItemKey2,LineNumber,:WindowSize) AS CallingCode 
	FROM PXW_Xref.AnalysisData
	WHERE NameSpace=:NameSpace
	--IF ItemType'=""
		AND ItemType=:ItemType
	--ENDIF 
	--IF ItemKey1'="" 
		--IF $E(ItemKey1,*)="*" 
			AND ItemKey1 %STARTSWITH $PIECE(:ItemKey1,'*',1)
		--ELSE
			AND ItemKey1 %INLIST $LISTFROMSTRING(:ItemKey1)
		--ENDIF
	--ENDIF 
	--IF ItemKey2'=""
		--IF ItemKey2["*"
			AND UPPER(ItemKey2) LIKE (UPPER(:ItemKey2))
		--ELSE 
			AND UPPER(ItemKey2) %INLIST $LISTFROMSTRING(UPPER(:ItemKey2))
		--ENDIF
	--ENDIF
		ORDER BY 
    		ItemKey1,ItemKey2</SqlQuery>
</Query>
</Class>


<Class name="PXW.Xref.Build">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>%Library.RegisteredObject</Super>
<TimeChanged>67129,60099.999868623</TimeChanged>
<TimeCreated>67125,77563.63941657</TimeCreated>

<Method name="Build">
<Description>
do ##class(PXW.Xref.Build).Build("LOCAL_USER","","PXW*")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace:%String,Type:%String,SearchName:%String,Force:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill ^||PXWXrefBuild
	Set sc=$$$OK
	Try {
		; if the name has a * that means do everything starting with that string, not true wildcard, just counts as a package
		; * is valid on its own (it means build all)
		Set buildmany=(SearchName["*")
		Set package=$SELECT(buildmany:$PIECE(SearchName,"*",1),1:"")
		If buildmany=1 {
			Set status=##class(PXW.Xref.BuildStatus).%New()
			Set status.RequestNamespace=Namespace
			Set status.RequestType=Type
			Set status.RequestSearchName=SearchName
			Set status.RequestForce=Force
			Do status.Start()
			$$$ThrowOnError(status.%Save())
		}
		Set rs=##class(%Library.ResultSet).%New(..%ClassName(1)_":"_"SelectTypes")
		Set sc=rs.Execute(Namespace,Type)
		While rs.%Next() {
			Set typ=rs.%Get("Type")
			If Force,buildmany'="" {
				Do ..DeleteAnalysisCalledByTypeKey1Package(Namespace,typ,package)
				Do ..DeleteCalledByTypeKey1Package(Namespace,typ,package)
				Do ..DeleteLastUpdateCalledByTypeKey1Package(Namespace,typ,package)
			}
			Set builderClass=rs.%Get("Builder")
			If builderClass'="" {
				Set interface=##class(PXW.DEV.Dictionary.CodeInterface).%OpenId(rs.%Get("ID"))
				If $DATA(status) {
					Set status.CurrentlyBuilding="Searching "_Namespace_" : "_typ_" : "_SearchName
					$$$ThrowOnError(status.%Save())
				}
				Set rs2=interface.List(SearchName)
				While rs2.%Next() {
					Set timechanged=rs2.%Get("TimeChanged")
					Set name=rs2.%Get("Name")
					Set ^||PXWXrefBuild(interface.%Id(),$INCREMENT(count))=$LISTBUILD(typ,name,timechanged,builderClass)
				}
			}
		}

		Set:$DATA(status) status.Total=$GET(count)
		Set iid=""
		For  {
			Set iid=$ORDER(^||PXWXrefBuild(iid))
			Quit:iid=""
			Set interface=##class(PXW.DEV.Dictionary.CodeInterface).%OpenId(iid)
			Set key=""
			For  {
				Set key=$ORDER(^||PXWXrefBuild(iid,key),1,data)
				Quit:key=""
				Set $LISTBUILD(typ,name,timechanged,builderClass)=data
				If builderClass'="" {
					If $DATA(status) {
						Set status.CurrentlyBuilding=Namespace_" : "_typ_" : "_name
						$$$ThrowOnError(status.%Save())
					}
					s bs=..BuildIfNecessary(interface,Namespace,typ,name,timechanged,builderClass,Force) 
					i bs=1 {
						Set:$DATA(status) status.TotalBuilt=status.TotalBuilt+1
					} elseif bs="" {
						set:$DATA(status) status.TotalSkipped=status.TotalSkipped+1
					} Else {
						Set:$DATA(status) status.TotalErrors=status.TotalErrors+1
					}
				}
			}
		}
	} Catch except {
		Set sc=except.AsStatus()
	}
	If $DATA(status) {
		Set status.CurrentlyBuilding=""
		Set status.Status=sc
		Do status.End()
		$$$ThrowOnError(status.%Save())
	}
	Quit sc
]]></Implementation>
</Method>

<Method name="BuildIfNecessary">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>CodeInterface:PXW.DEV.Dictionary.CodeInterface,Namespace:%String,Type:%String,Name:%String,TimeChanged:%TimeStamp,BuilderClass:%String,Force:%Boolean</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set savesc=""
	Set built=""
	Set text=""

	Set builder=$SYSTEM.OBJ.New(BuilderClass)
	Set LastUpdate=##class(PXW.Xref.LastUpdated).OpenOrNew(Namespace,Type,Name)
	If Force || LastUpdate.NeedsUpdate(TimeChanged) {
		s ^PXW("BIF",$i(^PXW))=Name_"*"_LastUpdate.LastUpdate_"*"_TimeChanged
		Set sc=CodeInterface.Load(Name,.text)
		Set zh=$ZHOROLOG
		Do ..DeleteAnalysisCalledByTypeKey1(Namespace,Type,Name)
 		Do ..DeleteCalledByTypeKey1(Namespace,Type,Name)
		Set sc=builder.Build(Namespace,Name,text)
		If $$$ISOK(sc) {
			Do LastUpdate.%SetModified(1) ; because the lastupdate table is cleared via SQL as part of the build so ensure it saves again
			Set LastUpdate.LastUpdate=TimeChanged
			Set LastUpdate.BuildStatus=sc
			Set LastUpdate.BuiltAt=$ZDATETIME($HOROLOG,3)
			Set LastUpdate.CheckedAt=LastUpdate.BuiltAt
			Set LastUpdate.BuildProcessTime=$ZHOROLOG-zh
			Set savesc=LastUpdate.%Save()
			Set built=1
		} Else {
			Do LastUpdate.%SetModified(1)
			Set LastUpdate.LastUpdate=""
			Set LastUpdate.BuildStatus=sc
			Set LastUpdate.CheckedAt=$ZDATETIME($HOROLOG,3)
			Set LastUpdate.BuildProcessTime=$ZHOROLOG-zh
			Set savesc=LastUpdate.%Save()
			Set built=0
		}
	} Else {
		If 'Force {
			Set built=""
		}
		Set LastUpdate.CheckedAt=$ZDATETIME($HOROLOG,3)
		Set savesc=LastUpdate.%Save()
	}
	Quit built
]]></Implementation>
</Method>

<Query name="SelectTypes">
<Type>PXW.LIB.SQL.Query</Type>
<FormalSpec>Namespace:%String,Type:%String</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>    SELECT ci.ID
        , ci.Namespace
        , ci.Type
        , cti.Class as Builder
      FROM PXW_DEV_Dictionary.CodeInterface as ci
      LEFT OUTER JOIN PXW_DEV_Dictionary.CodeTypeIndex as cti
                    ON cti.Usage='XrefBuilder' AND cti.CodeType=ci.Type
      WHERE ci.Namespace=:Namespace
        AND ((:Type IS NULL) OR (ci.Type=:Type))</SqlQuery>
</Query>

<Method name="DeleteAnalysisCalledByTypeKey1Package">
<ClassMethod>1</ClassMethod>
<FormalSpec>NameSpace:%String,ItemType:%String,ItemByKey1:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	Set jrnsts=$$CURRENT^%NOJRN()
	Do $SYSTEM.SQL.Util.SetOption("AutoCommit",0,.acsts)
	Do DISABLE^%NOJRN
	Set sc=$$$OK
	If $$$ISOK(sc) {
		&SQL(DELETE %NOLOCK FROM PXW_Xref.AnalysisData
			WHERE  NameSpace=:NameSpace AND ItemType=:ItemType AND ItemKey1 %STARTSWITH :ItemKey1)
        $$$DEBUG($GET(%msg))
	    If SQLCODE<0 Set sc=$$$ERROR(5001,%msg)
    }
	Do $SYSTEM.SQL.Util.SetOption("AutoCommit",acsts)
	Do:jrnsts ENABLE^%NOJRN
    $$$DEBUGMethodEnd
	Quit sc
]]></Implementation>
</Method>

<Method name="DeleteAnalysisCalledByTypeKey1">
<ClassMethod>1</ClassMethod>
<FormalSpec>NameSpace:%String,ItemType:%String,ItemKey1:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	Set jrnsts=$$CURRENT^%NOJRN()
	Do $SYSTEM.SQL.Util.SetOption("AutoCommit",0,.acsts)
	Do DISABLE^%NOJRN
	Set sc=$$$OK
	If $$$ISOK(sc) {
		&SQL(DELETE %NOLOCK FROM PXW_Xref.AnalysisData
			WHERE NameSpace=:NameSpace AND ItemType=:ItemType AND ItemKey1=:ItemKey1)
        $$$DEBUG($GET(%msg))
        If SQLCODE<0 Set sc=$$$ERROR(5001,%msg)
   	}

	Do $SYSTEM.SQL.Util.SetOption("AutoCommit",acsts)
	Do:jrnsts ENABLE^%NOJRN

    $$$DEBUGMethodEnd
	Quit sc
]]></Implementation>
</Method>

<Method name="DeleteCalledByTypeKey1Package">
<ClassMethod>1</ClassMethod>
<FormalSpec>NameSpace:%String,CalledByType:%String,CalledByKey1:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	Set jrnsts=$$CURRENT^%NOJRN()
	Do $SYSTEM.SQL.Util.SetOption("AutoCommit",0,.acsts)
	Do DISABLE^%NOJRN
	Set sc=$$$OK
	If $$$ISOK(sc) {
		&SQL(DELETE %NOLOCK FROM PXW_Xref.Data
			WHERE  NameSpace=:NameSpace AND CalledByType=:CalledByType AND CalledByKey1 %STARTSWITH :CalledByKey1)
        $$$DEBUG($GET(%msg))
	    If SQLCODE<0 Set sc=$$$ERROR(5001,%msg)
    }
	Do $SYSTEM.SQL.Util.SetOption("AutoCommit",acsts)
	Do:jrnsts ENABLE^%NOJRN
    $$$DEBUGMethodEnd
	Quit sc
]]></Implementation>
</Method>

<Method name="DeleteLastUpdateCalledByTypeKey1Package">
<ClassMethod>1</ClassMethod>
<FormalSpec>NameSpace:%String,CalledByType:%String,CalledByKey1:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	Set jrnsts=$$CURRENT^%NOJRN()
	Do $SYSTEM.SQL.Util.SetOption("AutoCommit",0,.acsts)
	Do DISABLE^%NOJRN
	Set sc=$$$OK
	If $$$ISOK(sc) {
		&SQL(DELETE %NOLOCK FROM PXW_Xref.LastUpdated
				WHERE NameSpace=:NameSpace AND ItemType=:CalledByType AND ItemKey1 %STARTSWITH :CalledByKey1)
        $$$DEBUG($GET(%msg))
	    If SQLCODE<0 Set sc=$$$ERROR(5001,%msg)
    }
	Do $SYSTEM.SQL.Util.SetOption("AutoCommit",acsts)
	Do:jrnsts ENABLE^%NOJRN
    $$$DEBUGMethodEnd
	Quit sc
]]></Implementation>
</Method>

<Method name="DeleteCalledByTypeKey1">
<ClassMethod>1</ClassMethod>
<FormalSpec>NameSpace:%String,CalledByType:%String,CalledByKey1:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$DEBUGMethodBegin
	Set jrnsts=$$CURRENT^%NOJRN()
	Do $SYSTEM.SQL.Util.SetOption("AutoCommit",0,.acsts)
	Do DISABLE^%NOJRN
	Set sc=$$$OK
	If $$$ISOK(sc) {
		&SQL(DELETE %NOLOCK FROM PXW_Xref.Data
			WHERE NameSpace=:NameSpace AND CalledByType=:CalledByType AND CalledByKey1=:CalledByKey1)
        $$$DEBUG($GET(%msg))
        If SQLCODE<0 Set sc=$$$ERROR(5001,%msg)
   	}


	If $$$ISOK(sc) {
		&SQL(DELETE %NOLOCK FROM PXW_Xref.LastUpdated
			WHERE NameSpace=:NameSpace AND ItemType=:CalledByType AND ItemKey1=:CalledByKey1)
        $$$DEBUG($GET(%msg))
	    If SQLCODE<0 Set sc=$$$ERROR(5001,%msg)
    }
	Do $SYSTEM.SQL.Util.SetOption("AutoCommit",acsts)
	Do:jrnsts ENABLE^%NOJRN

    $$$DEBUGMethodEnd
	Quit sc
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Xref.BuildOutput">
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77563.670788242</TimeChanged>
<TimeCreated>67125,77563.670788242</TimeCreated>

<Method name="batchStart">
<FormalSpec>CountOfThings:%Integer</FormalSpec>
<Implementation><![CDATA[	Write !,"Started Batch, count="_CountOfThings
]]></Implementation>
</Method>

<Method name="processStart">
<FormalSpec>classname:%Library.String</FormalSpec>
<Implementation><![CDATA[
	
	Write !,classname
	Quit
]]></Implementation>
</Method>

<Method name="processStatus">
<FormalSpec>classname:%Library.Persistent,Status:%Status</FormalSpec>
<Implementation><![CDATA[
	If $$$ISERR(Status) {
		Set txt=$SYSTEM.Status.GetErrorText(Status)
		Write !,txt
	}
]]></Implementation>
</Method>

<Method name="batchStatus">
<FormalSpec>CountOfThings:%Integer,Status:%Status</FormalSpec>
<Implementation><![CDATA[	Write !,"Completed Batch, count="_CountOfThings
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Xref.BuildOutputJob">
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77563.669938514</TimeChanged>
<TimeCreated>67125,77563.669938514</TimeCreated>

<Method name="batchStart">
<FormalSpec>CountOfThings:%Integer</FormalSpec>
<Implementation><![CDATA[
    Kill ^IRISTEMP.PXWXref($JOB)
    Set ^IRISTEMP.PXWXref($JOB,"1.STARTED")=$ZDATETIME($HOROLOG,3)
    Set ^IRISTEMP.PXWXref($JOB,"1.TOTAL")=CountOfThings
    Set ^IRISTEMP.PXWXref($JOB,"3.ERROR")=0
    Set ^IRISTEMP.PXWXref($JOB,"3.OK")=0

    Set j="" 
    For  {
        Set j=$ORDER(^IRISTEMP.PXWXref(j))
        Quit:j=""

        If $DATA(^IRISTEMP.PXWXref(j,"9.FINISHED")) {
            Kill ^IRISTEMP.PXWXref(j)
        }
    }
]]></Implementation>
</Method>

<Method name="processStart">
<FormalSpec>classname:%Library.String</FormalSpec>
<Implementation><![CDATA[
	
	Set ^IRISTEMP.PXWXref($JOB,"2.PROCESSING")=classname
]]></Implementation>
</Method>

<Method name="processStatus">
<FormalSpec>classname:%Library.Persistent,Status:%Status</FormalSpec>
<Implementation><![CDATA[
	If $$$ISERR(Status) {
        Set ^IRISTEMP.PXWXref($JOB,"3.ERROR")=^IRISTEMP.PXWXref($JOB,"3.ERROR")+1
	} Else {
        Set ^IRISTEMP.PXWXref($JOB,"2.PROCESSING")=""
        Set ^IRISTEMP.PXWXref($JOB,"3.OK")=^IRISTEMP.PXWXref($JOB,"3.OK")+1
    }
]]></Implementation>
</Method>

<Method name="batchStatus">
<FormalSpec>CountOfThings:%Integer,Status:%Status</FormalSpec>
<Implementation><![CDATA[
	Set ^IRISTEMP.PXWXref($JOB,"9.DONE")=CountOfThings
    Set ^IRISTEMP.PXWXref($JOB,"9.FINISHED")=$ZDATETIME($HOROLOG,3)
]]></Implementation>
</Method>

<Method name="%OnClose">
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
    ; object closed without being finished
    If '$DATA(^IRISTEMP.PXWXref($JOB,"9.FINISHED")) {
        Set ^IRISTEMP.PXWXref($JOB,"9.FINISHED")="UNEXPECTED OBJECT CLOSE"
    }
]]></Implementation>
</Method>

<Method name="DisplayStatus">
<Description>
d ##class(PXW.Xref.BuildOutputJob).DisplayStatus()</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[    ZWrite ^IRISTEMP.PXWXref
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Xref.BuildStatus">
<Super>%Library.Persistent</Super>
<TimeChanged>67128,70435.620600715</TimeChanged>
<TimeCreated>67127,60814.170623794</TimeCreated>

<Property name="RequestNamespace">
<Type>%String</Type>
</Property>

<Property name="RequestType">
<Type>%String</Type>
</Property>

<Property name="RequestSearchName">
<Type>%String</Type>
</Property>

<Property name="RequestForce">
<Type>%String</Type>
</Property>

<Property name="Total">
<Type>%Integer</Type>
</Property>

<Property name="TotalBuilt">
<Type>%Integer</Type>
</Property>

<Property name="TotalErrors">
<Type>%Integer</Type>
</Property>

<Property name="TotalSkipped">
<Type>%Integer</Type>
</Property>

<Property name="StartDateTime">
<Type>%TimeStamp</Type>
</Property>

<Property name="EndDateTime">
<Type>%TimeStamp</Type>
</Property>

<Property name="ProcessId">
<Type>%String</Type>
<InitialExpression>$JOB</InitialExpression>
</Property>

<Property name="CurrentlyBuilding">
<Type>%String</Type>
<Parameter name="MAXLEN" value="500"/>
</Property>

<Property name="Status">
<Type>%Library.Status</Type>
</Property>

<Property name="Running">
<Type>%Boolean</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {*}=##class(PXW.Xref.BuildStatus).GetIsRunning({ProcessId}) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
</Property>

<Method name="Start">
<Implementation><![CDATA[
    Set ..StartDateTime=$ZDATETIME($HOROLOG,3)
    Lock +^PXW.Xref.BuildStatus.Proc($JOB)
]]></Implementation>
</Method>

<Method name="End">
<Implementation><![CDATA[
    Set ..EndDateTime=$ZDATETIME($HOROLOG,3)
    Lock -^PXW.Xref.BuildStatus.Proc($JOB)
]]></Implementation>
</Method>

<Method name="%OnClose">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Lock -^PXW.Xref.BuildStatus.Proc($JOB)
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetIsRunning">
<ClassMethod>1</ClassMethod>
<FormalSpec>PID:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Set isrunning=0
    Lock +^PXW.Xref.BuildStatus.Proc(PID):0 Else  Set isrunning=1
    Quit isrunning
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^PXW.Xref.BuildStatusD</DataLocation>
<DefaultData>BuildStatusDefaultData</DefaultData>
<IdLocation>^PXW.Xref.BuildStatusD</IdLocation>
<IndexLocation>^PXW.Xref.BuildStatusI</IndexLocation>
<StreamLocation>^PXW.Xref.BuildStatusS</StreamLocation>
<ExtentSize>2</ExtentSize>
<Data name="BuildStatusDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>RequestNamespace</Value>
</Value>
<Value name="3">
<Value>RequestType</Value>
</Value>
<Value name="4">
<Value>RequestSearchName</Value>
</Value>
<Value name="5">
<Value>RequestForce</Value>
</Value>
<Value name="6">
<Value>Total</Value>
</Value>
<Value name="7">
<Value>TotalBuilt</Value>
</Value>
<Value name="8">
<Value>TotalErrors</Value>
</Value>
<Value name="9">
<Value>StartDateTime</Value>
</Value>
<Value name="10">
<Value>EndDateTime</Value>
</Value>
<Value name="11">
<Value>ProcessId</Value>
</Value>
<Value name="12">
<Value>CurrentlyBuilding</Value>
</Value>
<Value name="13">
<Value>Status</Value>
</Value>
<Value name="14">
<Value>TotalSkipped</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:</OutlierSelectivity>
<AverageFieldSize>2</AverageFieldSize>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>3</AverageFieldSize>
</Property>
<Property name="CurrentlyBuilding">
<Selectivity>50.0000%</Selectivity>
<AverageFieldSize>40</AverageFieldSize>
</Property>
<Property name="EndDateTime">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:</OutlierSelectivity>
<AverageFieldSize>2</AverageFieldSize>
</Property>
<Property name="ProcsessId">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:988</OutlierSelectivity>
<AverageFieldSize>5</AverageFieldSize>
</Property>
<Property name="RequestForce">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:1</OutlierSelectivity>
<AverageFieldSize>3</AverageFieldSize>
</Property>
<Property name="RequestNamespace">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:"LOCAL_USER"</OutlierSelectivity>
<AverageFieldSize>12</AverageFieldSize>
</Property>
<Property name="RequestSearchName">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:"PXW.*"</OutlierSelectivity>
<AverageFieldSize>7</AverageFieldSize>
</Property>
<Property name="RequestType">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:</OutlierSelectivity>
<AverageFieldSize>2</AverageFieldSize>
</Property>
<Property name="StartDateTime">
<Selectivity>50.0000%</Selectivity>
<AverageFieldSize>21</AverageFieldSize>
</Property>
<Property name="Status">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:</OutlierSelectivity>
<AverageFieldSize>2</AverageFieldSize>
</Property>
<Property name="Total">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:</OutlierSelectivity>
<AverageFieldSize>2</AverageFieldSize>
</Property>
<Property name="TotalBuilt">
<Selectivity>50.0000%</Selectivity>
<AverageFieldSize>2.5</AverageFieldSize>
</Property>
<Property name="TotalErrors">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:</OutlierSelectivity>
<AverageFieldSize>2</AverageFieldSize>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="PXW.Xref.Builder">
<Super>%RegisteredObject</Super>
<TimeChanged>67126,59242.661556955</TimeChanged>
<TimeCreated>67126,54537.374574538</TimeCreated>

<Parameter name="CodeType">
</Parameter>

<Method name="Build">
<FormalSpec>Namespace:%String,ItemKey1:%String,PreLoadedText:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="RegisterType">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set sc=$$$OK 
    set codetype=..#CodeType
    if codetype'="" {
        s sc=##class(PXW.DEV.Dictionary.CodeTypeIndex).RegisterType("XrefBuilder",codetype,..%ClassName(1))
    }
    quit sc
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Xref.Builders.Class">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>PXW.Xref.Builder</Super>
<TimeChanged>67130,60438.652119342</TimeChanged>
<TimeCreated>67126,54528.102660613</TimeCreated>

<Parameter name="CodeType">
<Default>CLS</Default>
</Parameter>

<Property name="CalledByKeyword">
<Description>
The command used for the call (set/kill)</Description>
<Type>%String</Type>
</Property>

<Property name="CalledByCommand">
<Type>%String</Type>
</Property>

<Property name="CalledByClassName">
<Description>
The routine, class doing the call</Description>
<Type>%String</Type>
</Property>

<Property name="CalledByItemName">
<Description>
Line label, method</Description>
<Type>%String</Type>
<InitialExpression>"class"</InitialExpression>
</Property>

<Property name="Analyser">
<Type>PXW.DEV.BNF.Analyse.COS</Type>
</Property>

<Property name="ClassElementLineNumber">
<Type>%Integer</Type>
</Property>

<Property name="ERROR">
<Type>%String</Type>
</Property>

<Property name="ClassServer">
<Description>
the object that will act as the class data server</Description>
<Type>PXW.DEV.Dictionary.ClassDefinitionObject</Type>
</Property>

<Property name="ThisItemType">
<Type>%String</Type>
</Property>

<Property name="InView">
<Description>
Are we in a view</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SQLPaths">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="test">
<Description>
d ##class(PXW.Xref.Builders.Class).test()</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	; GET RID OF %NS
	Set %NS="LOCAL_USER",cls="PXW.Xref.Builders.Class"
	Set x=..%New()
	Set cs=##class(PXW.DEV.Dictionary.ClassDefinitionObject).OpenNamespace(%NS)
	Do cs.Load(cls,.text)
	Do x.Build(%NS,cls,text)
]]></Implementation>
</Method>

<Method name="Build">
<FormalSpec>Namespace:%String,ItemKey1:%String,PreLoadedText:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim ele as PXW.DEV.Element

	;;; YUCK
	Set %NS=Namespace
	
	Set sc=$$$OK

    Set ClassServer=##class(PXW.DEV.Dictionary.ClassDefinitionObject).OpenNamespace(Namespace)
	Set text=PreLoadedText

    Do ClassServer.CacheClearClassDetails(ItemKey1,1) ; pretend the class is deleted so that it REALLY clears it

	If $$$ISOK(sc) {
 		Set ..ClassServer=ClassServer
		Try {
			Set x=##class(PXW.DEV.BNF.Run.ClassDefinition).%New()
  		    Set x.stream=##class(PXW.DEV.InputStream).NewString(text)
  			
			Set element=##class(PXW.DEV.Element).%New()
			While x.cheese(element) {
   				Do ..xrefElement(element)
   				If ..ERROR'="" $$$ThrowStatus($$$ERROR(5001,..ERROR))
				Set element=##class(PXW.DEV.Element).%New()
			}
		} Catch e {
			Set sc=e.AsStatus()
		}
	}
	Quit sc
]]></Implementation>
</Method>

<Method name="SaveAnalysis">
<FormalSpec>atom:PXW.DEV.Atom,Description:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set adata=##class(PXW.Xref.AnalysisData).%New()
	Set adata.ItemKey1=..CalledByClassName
	Set adata.ItemKey2=..CalledByItemName
	Set adata.ItemType="CLS"
	Set adata.LineNumber=atom.line
	Set adata.Description=Description
	Set sc=adata.%Save()
	If $$$ISERR(sc) {
		$$$DEBUG($EXTRACT($SYSTEM.Status.GetErrorText(sc),1,100))
	}
	Quit sc
]]></Implementation>
</Method>

<Method name="SaveCDEFCref">
<FormalSpec>ItemKey1:%String,LineNumber:%Integer,ItemKey2:%String</FormalSpec>
<Implementation><![CDATA[
	Set ik2=$SELECT($DATA(ItemKey2):ItemKey2,1:"_class")
	$$$DEBUG("Saving CDEF "_ItemKey1_", "_ik2)
	Set xref=##class(PXW.Xref.Data).%New()
	Set xref.CalledByType="CLS"
	Set xref.CalledByKey1=..CalledByClassName
	Set xref.CalledByKey2=..CalledByItemName
	Set xref.CalledByKey3=0 ; definition of property/method etc
	Set xref.CalledByCommand="_"_..CalledByCommand ; _Extends,_Type etc
	Set xref.ItemType="CLS"
	Set xref.ItemKey1=..ClassServer.FullClassName(ItemKey1,$PIECE(..CalledByClassName,".",1,*-1))
	Set xref.ItemKey2=ik2
    Set xref.LineNumber=LineNumber
	Set sc=$$$OK
	If 'xref.AlreadyExists() {
		Set sc=xref.%Save()
		If $$$ISERR(sc) {
			$$$DEBUG($EXTRACT($SYSTEM.Status.GetErrorText(sc),1,100))
		}
	}
]]></Implementation>
</Method>

<Method name="SaveCOSXref">
<FormalSpec>ItemType:%String,ItemKey1:%String,ItemKey2:%String,CalledByCommand:%String,Atom:PXW.DEV.Atom=""</FormalSpec>
<Implementation><![CDATA[
	;i ItemKey2["Variables" zw ItemType,ItemKey1,ItemKey2
	$$$DEBUG("Saving COS "_ItemType_","_ ItemKey1_","_ItemKey2_","_CalledByCommand)
	Set xref=##class(PXW.Xref.Data).%New()
	Set xref.CalledByType="CLS"
	Set xref.CalledByKey1=..CalledByClassName
	Set xref.CalledByKey2=..CalledByItemName
	Set xref.CalledByCommand=CalledByCommand
	Set xref.ItemType=ItemType
	Set xref.ItemKey1=ItemKey1
	Set xref.ItemKey2=ItemKey2
	If $ISOBJECT(Atom) {
		Set xref.CalledByKey3=Atom.line-..ClassElementLineNumber
		Set xref.LineNumber=Atom.line
	} Else {
		Set xref.LineNumber=0
	}

	Set sc=$$$OK
	If 'xref.AlreadyExists() {
		Set sc=xref.%Save()
		If $$$ISERR(sc) {
			$$$DEBUG($EXTRACT($SYSTEM.Status.GetErrorText(sc),1,100))
		}
	}
	If $$$ISOK(sc),ItemType="CLS" {
		Set origin="",stub=""
		If ..ClassServer.GetMethodDetails(ItemKey1,ItemKey2,,.origin,.stub),origin'=ItemKey1 {
			; also xref the origin class
			Do ..SaveCOSXref(ItemType,origin,ItemKey2,CalledByCommand,Atom)
		} ElseIf ..ClassServer.GetPropertyDetails(ItemKey1,ItemKey2,,,,.origin),origin'=ItemKey1 {
			; also xref the origin class
			Do ..SaveCOSXref(ItemType,origin,ItemKey2,CalledByCommand,Atom)
		}
		If (stub'="") {
			If ($PIECE(stub,".",*)="q") {
				; if the item is a function based on a query (eg GetFunc) then xref the query
				Set query=$PIECE(stub,".",1)
				Do ..SaveCOSXref(ItemType,ItemKey1,query,CalledByCommand,Atom)
			} ElseIf $PIECE(stub,".",*)="a" {
				; if the item is a function based on a property (eg ThingGetLogicalToDisplay) then xref the property
				Set prop=$PIECE(stub,".",1)
				Do ..SaveCOSXref(ItemType,ItemKey1,prop,CalledByCommand,Atom)
			} ElseIf $PIECE(stub,".",*)="i" {
				; if the item is a function based on an index (eg PKOpen) then xref the property
				Set index=$PIECE(stub,".",1)
				Do ..SaveCOSXref(ItemType,ItemKey1,index,CalledByCommand,Atom)
			}

		}
	}
]]></Implementation>
</Method>

<Method name="SaveSQLXref">
<FormalSpec>ItemType:%String,ItemKey1:%String,ItemKey2:%String,CalledByCommand:%String,Atom:PXW.DEV.Atom="",CalledByKey2:%String=""</FormalSpec>
<Implementation><![CDATA[
	Set sc=$$$OK
	$$$DEBUG("Saving SQL "_ItemType_","_ ItemKey1_","_ItemKey2_","_CalledByCommand)
	Set xref=##class(PXW.Xref.Data).%New()
	Set xref.CalledByType="CLS" 
	Set xref.CalledByKey1=..CalledByClassName
	Set xref.CalledByKey2=$SELECT($GET(CalledByKey2)'="":CalledByKey2,1:..CalledByItemName)

	If $ISOBJECT(Atom) {
		Set xref.CalledByKey3=Atom.line-..ClassElementLineNumber
		Set xref.LineNumber=Atom.line ;+..LineOffset
	} Else {
		Set xref.LineNumber=0
	}

	Set xref.CalledByCommand=CalledByCommand
	Set xref.ItemType=ItemType
	Set xref.ItemKey1=ItemKey1
	Set xref.ItemKey2=ItemKey2
	If 'xref.AlreadyExists() {
		Set sc=xref.%Save()
		If $$$ISERR(sc) {
			$$$DEBUG($EXTRACT($SYSTEM.Status.GetErrorText(sc),1,100))
		}
	}

	If $$$ISOK(sc),ItemType="CLS" {
		If ..ClassServer.GetMethodDetails(ItemKey1,ItemKey2,,.origin),origin'=ItemKey1 {
			Do ..SaveCOSXref(ItemType,origin,ItemKey2,CalledByCommand,Atom)
		} ElseIf ..ClassServer.GetPropertyDetails(ItemKey1,ItemKey2,,,,.origin),origin'=ItemKey1 {
			Do ..SaveCOSXref(ItemType,origin,ItemKey2,CalledByCommand,Atom)
		}
	}
]]></Implementation>
</Method>

<Method name="xrefElement">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    #dim a as PXW.DEV.Atom

    /*i element.%IsA("PXW.DEV.ClassDefinition.Element") {
		#dim cdefelement as PXW.DEV.ClassDefinition.Element=element
		i $listfind($lb("Method","ClassMethod","ClientMethod"),cdefelement.ClassDefinitionType) {
			s ..ClassElementLineNumber=cdefelement.FirstAtom().line
			s overrides=##class(PXW.DEV.Dictionary.ClassDefinition).GetMethodOverrides(..CalledByClassName_"||"_cdefelement.Name)
            i overrides'="" {
				s ..CalledByItemName=cdefelement.Name
                s ..CalledByCommand="Method_Override"
				d ..SaveCDEFCref(overrides,..ClassElementLineNumber,cdefelement.Name)
			}
    	}
       	i $listfind($lb("Property","Relationship"),cdefelement.ClassDefinitionType) {
			s ..ClassElementLineNumber=cdefelement.FirstAtom().line
			s overrides=##class(PXW.DEV.Dictionary.ClassDefinition).GetPropertyOverrides(..CalledByClassName_"||"_cdefelement.Name)
            i overrides'="" {
				s ..CalledByItemName=cdefelement.Name
                s ..CalledByCommand="Property_Override"
				d ..SaveCDEFCref(overrides,..ClassElementLineNumber,cdefelement.Name)
			}
    	}
    	i $listfind($lb("Parameter"),cdefelement.ClassDefinitionType) {
			s ..ClassElementLineNumber=cdefelement.FirstAtom().line
			s overrides=##class(PXW.DEV.Dictionary.ClassDefinition).GetParameterOverrides(..CalledByClassName_"||"_cdefelement.Name)
            i overrides'="" {
				s ..CalledByItemName=cdefelement.Name
                s ..CalledByCommand="Parameter_Override"
				d ..SaveCDEFCref(overrides,..ClassElementLineNumber,cdefelement.Name)
			}
    	}
    }
	*/
    If element.type="ClassDefinition" {
        Set cnameE=element.findFirstElementByType("ClassName")
        If $ISOBJECT(cnameE) {
            Set ..CalledByClassName=cnameE.ToString(0)
        }
    }
    If $LISTFIND($LISTBUILD("PropertyName","MethodName","ClassParameterName","IndexName","TriggerName","ForeignkeyName","StorageName","QueryName"),element.type) {
        Set name=element.ToString(0)
        Set ..CalledByItemName=name        
        Set ..ClassElementLineNumber=element.FirstAtom().line
        Set overrides=""
        If $LISTFIND($LISTBUILD("MethodName"),element.type) {
            Set overrides=..ClassServer.GetMethodOverrides(..CalledByClassName_"||"_name)
        }
        If $LISTFIND($LISTBUILD("PropertyName"),element.type) {
            Set overrides=..ClassServer.GetPropertyOverrides(..CalledByClassName_"||"_name)
        }
        If $LISTFIND($LISTBUILD("ClassParameterName"),element.type) {
            Set overrides=..ClassServer.GetParameterOverrides(..CalledByClassName_"||"_name)
        }
        If overrides'="" {
            Set ..CalledByCommand="Override" 
            Do ..SaveCDEFCref(overrides,..ClassElementLineNumber,name)
        }
    }

    If element.type="MethodReference" {
		Do element.write()
		Set name=element.ToString(0)
		Set a=element.FirstAtom()
        Do ..SaveCDEFCref(..CalledByClassName,a.line,name)
    }

    If element.type="ClassReference" {
		Set name=element.ToString(0)
		Set a=element.FirstAtom()
        Do ..SaveCDEFCref(name,a.line)
    }

    If element.type="OneClassmember" {
        Set ..Analyser=##class(PXW.DEV.BNF.Analyse.COS).%New(..ClassServer)
        Set ..Analyser.This=..CalledByClassName
	    If $ISOBJECT(..Analyser) Do ..Analyser.middle(element)

 	    Set item=element.partsGetAt(1)
      	Set typeE=item.partsGetAt(1)
        Set ..ThisItemType=typeE.ToString(0)
	}

    /*
    Element=TypeClassReference PXW.DEV.BNF.Element @134
    .Element=ClassReference PXW.DEV.BNF.Element @310
    ..type=ClassReference:
    .. %String
    .Element=TypeParameters PXW.DEV.BNF.Element @208
    ..type=punctuation:
    .. (
    ..Element=TypeParametersList PXW.DEV.BNF.Element @86
    ...Element=TypeParameterItem PXW.DEV.BNF.Element @385
    ....Element=ClassItemIdentifier PXW.DEV.BNF.Element @347
    .....type=ClassItemIdentifier:
    ..... MAXLEN
    ....type=punctuation:
    .... =
    ....Element=Number PXW.DEV.BNF.Element @309
    .....type=Number:
    ..... 1
    ..type=punctuation:
    .. )
    */
    If element.type="TypeClassReference" {
        Set crefE=element.findFirstElementByType("ClassReference",0)
        If $ISOBJECT(crefE) {
            Set class=crefE.ToString(0)
        
            Set paramE=element.findFirstElementByType("TypeParameters",0)
            If $ISOBJECT(paramE) {
                Set list=##class(%ListOfObjects).%New()
                Do paramE.findElementsByType("ClassItemIdentifier",list,2)
                For i=1:1:list.Count() {
                    Set itemE=list.GetAt(i)
					Set a=itemE.FirstAtom()
                    ;d ..wrapElementHTML(itemE,"<a href='"_##class(PXW.Tools.DEV.Class).HREFTo(class,itemE.ToString(0),,,..This)_"'>","</a>")
					Set ..CalledByCommand="Override" 
                 	If $LISTFIND($LISTFROMSTRING("Property","Relationship"),..ThisItemType) {
                        ;Do ..wrapElementHTML(itemE,"<a href='"_..HREFToClass(..This,..ThisMethod,itemE.ToString(0))_"'>","</a>")
						If ..ClassServer.GetPropertyParameterDetails(..CalledByClassName,..CalledByItemName,itemE.ToString(0),.ppsource) {
							Do ..SaveCDEFCref(ppsource,a.line,itemE.ToString(0))
						}
                    } Else {
       					Do ..SaveCDEFCref(class,a.line,itemE.ToString(0))
                    }
                }
            }
        }
    }

  
    ;i $isobject(..Analyser) d ..Analyser.middle(element)
        
	/* ------------------------------------------- */
	; From COS
	/*i element.%IsA("PXW.DEV.COS.Objects.Property") {
		s propertyElement=element
		s linkclass=$s(propertyElement.ParentObject.CastClassName'="":propertyElement.ParentObject.CastClassName,1:propertyElement.ParentObject.DerivedClass)
		d ..SaveCOSXref("CLS",linkclass,propertyElement.Name.ToString(0),propertyElement.CommandMode,propertyElement.Name)
	}
	i element.%IsA("PXW.DEV.COS.Objects.Method") {
		s methodElement=element
		s linkclass=$s(methodElement.ParentObject.CastClassName'="":methodElement.ParentObject.CastClassName,1:methodElement.ParentObject.DerivedClass)
		s cls=linkclass,method=methodElement.Name.ToString(0)
		; save the call to the instance class
		d ..SaveCOSXref("CLS",cls,method,"fetch",methodElement.Name)

		s detailsfound=##class(PXW.DEV.Dictionary.ClassDefinition).GetMethodDetails(cls,method,,.origin)
		i detailsfound {
			i origin'=cls {
				s cls=origin,instance=cls
				; save the call to the ORIGIN as well,
				; eg. saving a persistent object saves both %Save on the instance
				; of the object AND on %Library.Persistent
				d ..SaveCOSXref("CLS",cls,method,"fetch",methodElement.Name)
			}
		}
	}
	
	i element.%IsA("PXW.DEV.COS.Global") {
		s globalElement=element
		d ..SaveCOSXref("GBL",globalElement.Name.ToString(0),globalElement.KeysForXref(),$s(globalElement.IsModified:"set",1:"fetch"),globalElement.Name)
	}
    */
	If element.type="ClassExpression" {
        Set classnameele=element.findFirstElementByType("ClassReference",0)
        Set classname=classnameele.ToString(0)
		Do ..FollowObjectChainForType(element,classname)
    }

    If $LISTFIND($LISTBUILD("ThisObject","ThisObjectDirectProperty","ThisObjectSet","ThisObjectDirectPropertySet"),element.type) {
        If ..CalledByClassName'="" {
            Set classname=..CalledByClassName
            If classname'="" Do ..FollowObjectChainForType(element,classname)
        }
    }
    ; known variable
    If ",Variable,VariableSet,ObjectVariable,"[(","_element.type_","),$ISOBJECT(..Analyser) {
        Set variablename=element.ToStringAtomsOnly(0)
        ; variable could be something like {*} or {field}  so the name above (using atoms only) will not find anything
        ; don't worry about that at the moment!
        If variablename'="" {
            ; when working out a type use the #DIM type if there is one
            Set classname=$GET(..Analyser.DimmedTypes(variablename))
            If classname="" Set classname=$GET(..Analyser.VariablesTypes(variablename))
            If classname'="" Do ..FollowObjectChainForType(element,classname)
        }
        ;zw element,variablename,classname,..Analyser
    }

    If (element.type="GlobalRef") || (element.type="GlobalRefSet") {
        Set setmode="fetch"
        If element.type="GlobalRefSet" Set setmode="SET"

        Set fullrefE=element.findFirstElementByType("GlobalRefFull",0)
        If $ISOBJECT(fullrefE) {
            ; On a global clicking on the ^ will take directly to the XREF since we don't
            ; have any other details about the global at the moment.
            ; Clicking on the name of the global highlights it like a regular variable
            Set globalElement=fullrefE.findFirstElementByType("GlobalName",0)
            Set upa=fullrefE.FirstAtom() ; ^ is always at the start
            Set namea=globalElement ;.ToStringAtomsOnly()
            ;d ..wrapAtomHTML(upa,"<a class='COSGlobalSet' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("GBL",globalElement.Name.ToString(0),globalElement.KeysForXref())_"'>","</a>")
            Set subsE=fullrefE.findFirstElementByType("SubscriptParameterList",0),subs=""
            If $ISOBJECT(subsE) Set subs=..Analyser.SimplifySubscripts(subsE)
            ;d ..wrapAtomHTML(upa,"<a class='COSGlobalSet' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("GBL",namea.ToStringAtomsOnly(0),subs)_"'>","</a>")
			If $ISOBJECT(namea) {
				Do ..SaveCOSXref("GBL",namea.ToStringAtomsOnly(0),subs,setmode,upa)            
			}
        } Else {
            ; not sure what we can do with naked refs here (other than make them stand out as a bad thing)
        }
	}	

	If element.type="Macrocall" {
		Set atom=element.FirstAtom()
		Set macroname=element.ToString(0)
		Set macroname=$PIECE(macroname,"(",1)
		If macroname?1"$$$"1.E Set macroname=$PIECE(macroname,"$$$",2)
		If ..ClassServer.GetMacroLocation(..CalledByClassName,macroname,.source) {
			If source'="" {
				; includename.inc is returned so file as INC and remove this from the name
				Set type=$$$UPPER($PIECE(source,".",*))
				Set source=$PIECE(source,".",1,*-1)
				Do ..SaveCOSXref("INC",source,macroname,"_macro",atom)
			}
		}
	}
	/* ------------------------------------------- */

	/* ------------------------------------------- */
	; from SQL
	If element.type="AttributeViewquery" {
		Set oldInView=..InView
		Set ..InView=1	
		Set ..CalledByItemName="" ; no name until we hit columns
	}
	If element.type="SelectCommand" {
		Do ..SQLInternalXREF(element)
        Set sqlanalyse=##class(PXW.DEV.BNF.Analyse.SQL).%New(..ClassServer)
		Set sqlanalyse.This=..CalledByClassName
        Do sqlanalyse.checkElement(element)
        Set cref=""
		While sqlanalyse.NextColumnReference(.cref,.fulltable,.fieldname) {
            Kill CalledByItem
            If fulltable'="" {
	            If ..InView {
					Set CalledByItem=""_$GET(..SQLPaths(+cref),"unk")
	            }
                ;d ..wrapAtomHTML(cref,"<a class='CDEFName' href='"_##class(PXW.Tools.DEV.Class).HREFTo(fulltable,fieldname)_"'>","</a>")
				Kill patharray
				Do ..ClassServer.GetClassPathFromTable(fulltable,fieldname,.patharray)
				Set atom=cref.FirstAtom()
				Set command=element.type
				For i=1:1:$GET(patharray) {
					Set data=patharray(i)
					Set class=$LISTGET(data,1),item=$LISTGET(data,2)
					If class'="",item'="" {
						Do ..SaveSQLXref("CLS",class,item,command,atom,.CalledByItem)
					}
				}
            } Else {
	            If ..InView {
		            Set aliasNameE=cref.findFirstElementByType("AliasName",0)
		            Set columnNameE=cref.findFirstElementByType("ColumnName",0)
					Set command=element.type
					Set atom=cref.FirstAtom()
		            Set CalledByItem=""_$GET(..SQLPaths(+cref),"unk")
		            If $ISOBJECT(aliasNameE),$ISOBJECT(columnNameE) {
			            Do ..SaveSQLXref("CLS",..CalledByClassName,aliasNameE.ToString(0)_"."_columnNameE.ToString(0),command,atom,.CalledByItem)
		            }
	            }

                ;s colname="col"_$$$UPPER(fieldname)
                ;d ..wrapAtomHTML(cref,"<span class='COSObjectsProperty' title='unable to determine class, possibly because of subquery' fetchid='"_colname_"' onclick=""HiliteSets('"_colname_"');"">","</span>")
            }
        }
    }
   If element.type="InsertCommand" {
        Set sqlanalyse=##class(PXW.DEV.BNF.Analyse.SQL).%New(..ClassServer)
		Set sqlanalyse.This=..CalledByClassName
        Do sqlanalyse.checkElement(element)
        Set columnNameE=""
        While sqlanalyse.NextColumnReference(.columnNameE,.fulltable,.fieldname) {
			Kill patharray
			Do ..ClassServer.GetClassPathFromTable(fulltable,fieldname,.patharray)
			Set atom=columnNameE.FirstAtom()
			Set command=element.type
			For i=1:1:$GET(patharray) {
				Set data=patharray(i)
				Set class=$LISTGET(data,1),item=$LISTGET(data,2)
				If class'="",item'="" {
					Do ..SaveSQLXref("CLS",class,item,command,atom)
				}
			}
        }
    }

	If element.type="DeleteCommand" {
		Set sqlanalyse=##class(PXW.DEV.BNF.Analyse.SQL).%New(..ClassServer)
		Set sqlanalyse.This=..CalledByClassName
        Do sqlanalyse.checkElement(element)
        Set columnNameE=""
		Kill tables
        While sqlanalyse.NextColumnReference(.columnNameE,.fulltable,.fieldname) {
			Kill patharray
			Do ..ClassServer.GetClassPathFromTable(fulltable,fieldname,.patharray)
			Set atom=columnNameE.FirstAtom()
			Set command=element.type
			For i=1:1:$GET(patharray) {
				Set data=patharray(i)
				Set class=$LISTGET(data,1),item=$LISTGET(data,2)
				If class'="",item'="" {
					Do ..SaveSQLXref("CLS",class,item,command,atom)
					If '$DATA(tables(class)) {
						Set tabatom=element.FirstAtom()
						Do ..SaveSQLXref("CLS",class,"_table",command,tabatom)
						Set tables(class)=1
					}
				}
			}
        }
	}
	
	/*If element.type="StoredProcCall" {
        Set spNameE=element.findFirstElementByType("StoredProcName",0)
        If $ISOBJECT(spNameE) {
            Set spname=spNameE.ToString(0)
			Set class=..ClassServer.GetClassNameFromStoredProc(spname,.method,..CalledByClassName)
			If class'="" {
				Set atom=element.FirstAtom()
				Set command=element.type
				Do ..SaveSQLXref("CLS",class,method,command,atom)    
			}
        }
    }*/
	If element.type="StoredProcName" {
        Set spNameE=element
        If $ISOBJECT(spNameE) {
            Set spname=spNameE.ToString(0)
			Set class=..ClassServer.GetClassNameFromStoredProc(spname,.method,..CalledByClassName)
			Set cbk2=$GET(..SQLPaths(+element),"unk")
			If class'="" {
				Set atom=element.FirstAtom()
				Set command=element.type
				Do ..SaveSQLXref("CLS",class,method,command,atom,cbk2)
			}
        }
    }
	/* ------------------------------------------- */


	For  {
		Set atom=element.partsGetNext(.akey)
		Quit:akey=""
		
	    If atom.%IsA("PXW.DEV.Element") {
			Do ..xrefElement(atom)
		} ElseIf atom.%IsA("PXW.DEV.Atom") {
            Set type=$$$UPPER($PIECE(atom.type,":",1))
            ; this is the word "method" or "property" etc
            If type="KEYWORD" {
               Set ..CalledByCommand=atom.value
            }
			If type="CDEFKEYWORD" {
               Set ..CalledByCommand=atom.value
            }

			If $ISOBJECT(..Analyser),$DATA(..Analyser.ElementWarnings(+atom)) {
				Set line=..Analyser.ElementWarnings(+atom)
				Do ..SaveAnalysis(atom,line)
			}


			; type="ERROR" happens when a RECOVERY takes place
			; the atom should contain a bit of code up to the point of the error
			If type="ERROR" {
				If ..ERROR="" Set ..ERROR=atom.ToString()
			}

		}
	}

	Set:$DATA(oldInView) ..InView=oldInView
]]></Implementation>
</Method>

<Method name="FollowObjectChainForType">
<FormalSpec>ParentElement:PXW.DEV.Element,StartClassName:%String</FormalSpec>
<Implementation><![CDATA[
    If (ParentElement.type="ThisObject") || (ParentElement.type="ThisObjectSet") {
        Set this=ParentElement.findFirstElementByType("ThisObjectSelf",0) ; ..property
        If $ISOBJECT(this) {
            Set objectchain=this.findFirstElementByType("ObjectChainNoDot",0)
        } Else {
            Set this=ParentElement.findFirstElementByType("ThisObjectThis",0) ; $this.property
            If $ISOBJECT(this) {
                Set objectchain=this.findFirstElementByType("ObjectChain",0)
            }
        }
    } ElseIf (ParentElement.type="ThisObjectDirectProperty") || (ParentElement.type="ThisObjectDirectPropertySet") {
        Set objectchain=ParentElement.findFirstElementByType("ObjectChainItem",0) ; i%property
    } Else {
        Set objectchain=ParentElement.findFirstElementByType("ObjectChain",1) ; var.property
    }
    Set path="",sep=""
    While $ISOBJECT(objectchain) {
        
        Set propertyatom=""
        ; the objectchain has the "." and the name
        For  {
            Set a=objectchain.partsGetNext(.akey)
            Quit:akey=""

            If a.%IsA("PXW.DEV.Atom"),a.value'="." {
                Set propertyatom=a
            }
        }

        Set path=path_sep_propertyatom.value,sep="."
		;d ..wrapAtomHTML(propertyatom,"<a class='COSObjectsProperty' href='"_##class(PXW.Tools.DEV.Class).HREFTo(StartClassName,path)_"'>","</a>")
		

        Set objectchain=objectchain.findFirstElementByType("ObjectChain",0) 
    }
	If path'="" {
		Do ..ClassServer.GetClassPath(StartClassName,path,.patharray)
		;zw StartClassName,path,patharray
		Set atom=ParentElement.FirstAtom()
		Set command=ParentElement.type
		For i=1:1:$GET(patharray) {
			Set data=patharray(i)
			Set class=$LISTGET(data,1),item=$LISTGET(data,2)
			If $EXTRACT(item,1)="#" Set item=$EXTRACT(item,2,*) ; strip the # from parameters
			If class'="",item'="" {
				Do ..SaveCOSXref("CLS",class,item,command,atom)
			}
		}
	}
]]></Implementation>
</Method>

<Method name="SQLInternalXREF">
<Description>
Recursive, pass in Element, get out the ..Index of what element is where on the path, path is the current path</Description>
<FormalSpec>Element:PXW.DEV.Element,table:%String="",column:%String=""</FormalSpec>
<Implementation><![CDATA[
	If '$DATA(..SQLPaths(+Element)) {

		If Element.type="SubquerySpecification" {
			
		}
		If Element.type="DerivedTable" {
			Set TableAsClauseE=Element.findFirstElementByType("TableAsClause",0)
			If $ISOBJECT(TableAsClauseE) {
				Set TableNameE=TableAsClauseE.findFirstElementByType("AliasName",0)
				If $ISOBJECT(TableNameE) {
					Set table=TableNameE.ToString(0)
					Set column=""
				}
			}
		}
		If Element.type="DerivedColumn" {
			Do ##class(PXW.DEV.BNF.Analyse.SQL).GetDerivedColumnInfo(Element,.colname)
			If column="" Set column=colname
		}
		Set ..SQLPaths(+Element)=$SELECT(column'="":"column:"_$SELECT(table'="":$$$UPPER(table)_".",1:"")_$$$UPPER(column),1:"")

		Set akey=""
		For  {
			Set atom=Element.partsGetNext(.akey)
			Quit:akey=""
			
			If atom.%IsA("PXW.DEV.Element") {
				Do ..SQLInternalXREF(atom,table,column)
			}
		}
	}
]]></Implementation>
</Method>
</Class>


<Class name="PXW.Xref.Data">
<Owner>_PUBLIC</Owner>
<Super>%Library.Persistent</Super>
<TimeChanged>67126,54886.254003395</TimeChanged>
<TimeCreated>67125,77563.682963603</TimeCreated>

<Property name="NameSpace">
<Type>%String</Type>
<InitialExpression>$GET(%NS)</InitialExpression>
<Required>1</Required>
</Property>

<Property name="ItemType">
<Description>
Class, Global, Routine</Description>
<Type>%String</Type>
</Property>

<Property name="ItemKey1">
<Description>
Name of Class, Global, Routine</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1024"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="ItemKey2">
<Description>
Method of Class, Subscripts of global or Label of routine</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1024"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="CalledByType">
<Description>
What is referencing this thing (class, routine)</Description>
<Type>%String</Type>
</Property>

<Property name="CalledByCommand">
<Description>
The command used for the call (set/kill)</Description>
<Type>%String</Type>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="CalledByKey1">
<Description>
The routine, class doing the call</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1024"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="CalledByKey2">
<Description>
Line label, method</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1024"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="CalledByKey3">
<Description>
label relative number</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1024"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="LineNumber">
<Description>
absolute line number within the entire class text, or routine text</Description>
<Type>%Integer</Type>
</Property>

<Property name="Parameters">
<Description>
data relating to this specific call (label parameters, global subscripts etc)</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1024"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="CalledBySection">
<Description><![CDATA[
Name of the section of code this is in.  EG the code:
<example>
  Q
A S X=1
  S Y=2
1 S Z=3 ; this is in section A
  Q
</example>]]></Description>
<Type>%String</Type>
</Property>

<Index name="CalledBy">
<PrimaryKey>1</PrimaryKey>
<Properties>NameSpace,ItemType,ItemKey1,ItemKey2,CalledByType,CalledByCommand,CalledByKey1,CalledByKey2,CalledByKey3</Properties>
<Unique>1</Unique>
</Index>

<Index name="CalledBy2">
<Properties>NameSpace,ItemKey1,ItemKey2,CalledByType,CalledByCommand,CalledByKey1,CalledByKey2,CalledByKey3</Properties>
</Index>

<Index name="CalledBy3">
<Properties>NameSpace,ItemKey2,ItemKey1,CalledByType,CalledByCommand,CalledByKey1,CalledByKey2,CalledByKey3</Properties>
</Index>

<Index name="Calls">
<Properties>NameSpace,CalledByType,CalledByKey1,CalledByKey2,ItemType,ItemKey1,ItemKey2</Properties>
</Index>

<Index name="Calls2">
<Properties>NameSpace,CalledByKey1,CalledByKey2,ItemType,ItemKey1,ItemKey2</Properties>
</Index>

<Index name="Calls3">
<Properties>NameSpace,CalledByKey2,CalledByKey1,ItemType,ItemKey1,ItemKey2</Properties>
</Index>

<Method name="AlreadyExists">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ..CalledByExists(..NameSpace,..ItemType, ..ItemKey1, ..ItemKey2, ..CalledByType, ..CalledByCommand, ..CalledByKey1, ..CalledByKey2, ..CalledByKey3)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^PXW.Xref.DataD</DataLocation>
<DefaultData>DataDefaultData</DefaultData>
<IdLocation>^PXW.Xref.DataD</IdLocation>
<IndexLocation>^PXW.Xref.DataI</IndexLocation>
<StreamLocation>^PXW.Xref.DataS</StreamLocation>
<ExtentSize>0</ExtentSize>
<Data name="DataDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>LineNumber</Value>
</Value>
<Value name="3">
<Value>Parameters</Value>
</Value>
<Value name="4">
<Value>CalledBySection</Value>
</Value>
<Value name="5">
<Value>NameSpace</Value>
</Value>
<Value name="6">
<Value>ItemType</Value>
</Value>
<Value name="7">
<Value>ItemKey1</Value>
</Value>
<Value name="8">
<Value>ItemKey2</Value>
</Value>
<Value name="9">
<Value>CalledByType</Value>
</Value>
<Value name="10">
<Value>CalledByCommand</Value>
</Value>
<Value name="11">
<Value>CalledByKey1</Value>
</Value>
<Value name="12">
<Value>CalledByKey2</Value>
</Value>
<Value name="13">
<Value>CalledByKey3</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="PXW.Xref.LastUpdated">
<Owner>_PUBLIC</Owner>
<Super>%Library.Persistent</Super>
<TimeChanged>67128,69728.935340271</TimeChanged>
<TimeCreated>67125,77563.682965454</TimeCreated>

<Property name="NameSpace">
<Type>%String</Type>
</Property>

<Property name="ItemType">
<Type>%String</Type>
</Property>

<Property name="ItemKey1">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1024"/>
</Property>

<Property name="LastUpdate">
<Type>%TimeStamp</Type>
</Property>

<Property name="BuildStatus">
<Type>%Status</Type>
</Property>

<Property name="BuiltAt">
<Type>%TimeStamp</Type>
</Property>

<Property name="CheckedAt">
<Type>%TimeStamp</Type>
</Property>

<Property name="BuildProcessTime">
<Type>%Numeric</Type>
</Property>

<Index name="PK">
<IdKey>1</IdKey>
<PrimaryKey>1</PrimaryKey>
<Properties>NameSpace,ItemType,ItemKey1</Properties>
<Unique>1</Unique>
</Index>

<Index name="iCheckedAtNS">
<Properties>CheckedAt,NameSpace</Properties>
</Index>

<Method name="OpenOrNew">
<ClassMethod>1</ClassMethod>
<FormalSpec>NameSpace:%String,ItemType:%String,ItemKey1:%String</FormalSpec>
<ReturnType>PXW.Xref.LastUpdated</ReturnType>
<Implementation><![CDATA[
    Set obj=..PKOpen(NameSpace,ItemType,ItemKey1)
    If '$ISOBJECT(obj) {
        Set obj=..%New()
        Set obj.NameSpace=NameSpace
        Set obj.ItemType=ItemType
        Set obj.ItemKey1=ItemKey1
    }
    Quit obj
]]></Implementation>
</Method>

<Method name="NeedsUpdate">
<FormalSpec>CheckTime:%TimeStamp</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    If ..LastUpdate="" Quit 1
    If CheckTime="" Quit 1
    If ..BuildStatus'="",$$$ISERR(..BuildStatus) Quit 1
    Set ct=..LastUpdateNormalize(CheckTime)
    If ct]..LastUpdate Quit 1
    Quit 0
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^PXW.Xref.LastUpdatedD</DataLocation>
<DefaultData>LastUpdatedDefaultData</DefaultData>
<IdLocation>^PXW.Xref.LastUpdatedD</IdLocation>
<IndexLocation>^PXW.Xref.LastUpdatedI</IndexLocation>
<StreamLocation>^PXW.Xref.LastUpdatedS</StreamLocation>
<ExtentSize>3718</ExtentSize>
<Data name="LastUpdatedDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>LastUpdate</Value>
</Value>
<Value name="3">
<Value>BuildStatus</Value>
</Value>
<Value name="4">
<Value>BuiltAt</Value>
</Value>
<Value name="5">
<Value>CheckedAt</Value>
</Value>
<Value name="6">
<Value>BuildProcessTime</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:</OutlierSelectivity>
<AverageFieldSize>2</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,16,$lb("-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000"),$lb(21,21,21,21,21,21,21,21,21,21,21,21,21,21,21),$lb(758198320,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,758198320))</Histogram>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>45.61</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb("LOCAL_USER||CLS||%ASQ.Exception","LOCAL_USER||CLS||%CSP.UI.Portal.Dialog.ColumnPriv","LOCAL_USER||CLS||%CSP.UI.System.FindPane","LOCAL_USER||CLS||%DeepSee.Model.SubjectArea.calculatedMember","LOCAL_USER||CLS||%DeepSee.PMML.ModelOutput","LOCAL_USER||CLS||%DeepSee.UI.Dialog.PivotLevelOptions","LOCAL_USER||CLS||%Document.Persistent","LOCAL_USER||CLS||%Library.SQLCatalog","LOCAL_USER||CLS||%SAML.AssertionURIRef","LOCAL_USER||CLS||%SYS.REST","LOCAL_USER||CLS||%WebStress.Portal.WebServers","LOCAL_USER||CLS||%ZEN.Component.select","LOCAL_USER||CLS||%ZEN.Report.Display.xslt","LOCAL_USER||CLS||Ens.Alerting.Action","LOCAL_USER||CLS||Ens.Rule.Assign","LOCAL_USER||CLS||PXW.Xref.bnf"),$lb(18,25,18,26,26,19,18,18,19,18,18,22,17,21,17),$lb(1280262977,1095979310,1129533486,1349481076,1400468340,1129533486,1147495792,1299145829,1347243340,1347243340,1430859332,1701146707,1868789101,1148150645,1281974898,1281974898,1396788556,1095584814,1498623570,1398362926,1466262099,1466262099,1514491438,1131375984,1382379631,626672974,1164866350,1097622898,1383427173,1164866350,1347966766,1280262977))</Histogram>
</Property>
<Property name="BuildProcessTime">
<Selectivity>0.3984%</Selectivity>
<OutlierSelectivity>.083647:.02</OutlierSelectivity>
<AverageFieldSize>3.99</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,1,0,$lb(0,.01,.02,.03,.04,.06,.08,.1,.13,.16,.21,.26,.35,.51,.87,21.95),$lb(0,2,2,2,2,2,1,2,2,1,2,1,1,1,0),"")</Histogram>
</Property>
<Property name="BuildStatus">
<Selectivity>0.0538%</Selectivity>
<OutlierSelectivity>.991931:1</OutlierSelectivity>
<AverageFieldSize>8.51</AverageFieldSize>
<Histogram><![CDATA[$lb(.06666666666666666667,0,0,$lb("1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","0 "_$c(0)_""_$c(2,1,4,4,138,19)_"G"_$c(1)_"<UNDEFINED>GetDerivedColumnInfo+19^PXW.DEV.BNF.Analyse.SQL.1 *ColName"_$c(1,1,1,1,1,1,1,0,132,2,1,1,9,1)_"IRISAPP"_$c(0)_"v"_$c(2,1)_"6"_$c(1)_"^GetDerivedColumnInf"),$lb(1,1,1,1,1,1,1,1,1,1,1,1,1,1,0),$lb(822083584,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,822083584,807403738,807403738))]]></Histogram>
</Property>
<Property name="BuiltAt">
<Selectivity>0.1232%</Selectivity>
<OutlierSelectivity>.009414:"2024-10-14 19:32:08"</OutlierSelectivity>
<AverageFieldSize>20.85</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,1,$lb("-10000000000000000000","2024-10-14 19:23:27","2024-10-14 19:24:18","2024-10-14 19:25:19","2024-10-14 19:26:01","2024-10-14 19:27:18","2024-10-14 19:28:51","2024-10-14 19:30:07","2024-10-14 19:31:30","2024-10-14 19:32:28","2024-10-14 19:33:59","2024-10-14 19:35:26","2024-10-14 19:36:24","2024-10-14 19:37:25","2024-10-14 19:38:02","2024-10-15 19:19:56"),$lb(0,15,15,15,15,15,14,15,15,15,15,15,15,15,9),$lb(758198320,758198320,842019380,859451959,876228920,876228920,893006137,893006137,909783089,909783089,926560568,926560568,943338801,842545717,858798640,809119799,825897776,825897776,842674744,842674744,859452729,859452729,893006390,893006390,909783604,909783604,926560821,926560821,943337522,874524985,891302201,842019380))</Histogram>
</Property>
<Property name="CheckedAt">
<Selectivity>0.1224%</Selectivity>
<OutlierSelectivity>.009414:"2024-10-14 19:32:08"</OutlierSelectivity>
<AverageFieldSize>21</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb("2024-10-14 19:22:02","2024-10-14 19:23:32","2024-10-14 19:24:27","2024-10-14 19:25:39","2024-10-14 19:26:04","2024-10-14 19:27:23","2024-10-14 19:28:57","2024-10-14 19:30:12","2024-10-14 19:31:42","2024-10-14 19:32:37","2024-10-14 19:34:07","2024-10-14 19:35:29","2024-10-14 19:36:28","2024-10-14 19:37:26","2024-10-14 19:38:03","2024-10-15 19:19:56"),$lb(15,15,15,15,15,15,14,15,15,15,15,15,15,15,9),$lb(842019380,842674226,859452210,859452210,876229175,876229175,893006649,893006649,909783092,909783092,926560819,926560819,943338807,842545717,858798641,809120050,825898034,825898034,842674999,842674999,876228663,876228663,893006393,893006393,909783608,909783608,926560822,926560822,943337523,874524985,891302201,842019380))</Histogram>
</Property>
<Property name="ItemKey1">
<Selectivity>0.0269%</Selectivity>
<AverageFieldSize>28.61</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb("%ASQ.Exception","%CSP.UI.Portal.Dialog.ColumnPriv","%CSP.UI.System.FindPane","%DeepSee.Model.SubjectArea.calculatedMember","%DeepSee.PMML.ModelOutput","%DeepSee.UI.Dialog.PivotLevelOptions","%Document.Persistent","%Library.SQLCatalog","%SAML.AssertionURIRef","%SYS.REST","%WebStress.Portal.WebServers","%ZEN.Component.select","%ZEN.Report.Display.xslt","Ens.Alerting.Action","Ens.Rule.Assign","PXW.Xref.bnf"),$lb(1,8,1,9,9,2,1,1,2,1,1,5,0,4,0),$lb(625038161,1095979310,1129533486,1349481076,1400468340,1129533486,1147495792,1299145829,1347243340,1347243340,1430859332,1701146707,1868789101,1148150645,1281974898,1281974898,1396788556,1095584814,1498623570,1398362926,1466262099,1466262099,1514491438,1131375984,1382379631,626672974,1164866350,1097622898,1383427173,1164866350,1347966766,1347966766))</Histogram>
</Property>
<Property name="ItemType">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:"CLS"</OutlierSelectivity>
<AverageFieldSize>5</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb("CLS","CLS","CLS","CLS","CLS","CLS","CLS","CLS","CLS","CLS","CLS","CLS","CLS","CLS","CLS","CLS"),$lb(4,4,4,4,4,4,4,4,4,4,4,4,4,4,4),$lb(1129075456,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1129075456))</Histogram>
</Property>
<Property name="LastUpdate">
<Selectivity>0.0336%</Selectivity>
<OutlierSelectivity>.008069:</OutlierSelectivity>
<AverageFieldSize>24.69</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,1,$lb("-10000000000000000000","2024-08-06 21:43:32.408","2024-08-06 21:43:38.012","2024-08-06 21:43:38.233","2024-08-06 21:43:38.522","2024-08-06 21:43:38.897","2024-08-06 21:43:39.121","2024-08-06 21:43:39.339","2024-08-06 21:43:39.716","2024-08-06 21:43:39.961","2024-08-06 21:43:40.367","2024-08-06 21:43:40.741","2024-08-06 21:43:41.047","2024-08-06 21:43:41.266","2024-08-06 22:45:49.026","2024-10-15 18:57:44.042"),$lb(0,18,20,20,20,18,20,20,20,17,20,18,20,12,5),$lb(758198320,758198320,842019380,841888816,942551089,808530432,842216192,842216192,892482048,892482048,943273728,942553145,959328562,825372928,858994944,858994944,925971968,925971968,959852800,859385401,875572787,859191040,926167296,808335156,825110580,808728320,842413568,825898035,842675253,808987952,825240881,842019380))</Histogram>
</Property>
<Property name="NameSpace">
<Selectivity>0.0001%</Selectivity>
<OutlierSelectivity>.999999:"LOCAL_USER"</OutlierSelectivity>
<AverageFieldSize>12</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb("LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER","LOCAL_USER"),$lb(11,11,11,11,11,11,11,11,11,11,11,11,11,11,11),$lb(1280262977,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1280262977))</Histogram>
</Property>
<SQLMap name="PK">
<BlockCount>-236</BlockCount>
</SQLMap>
<SQLMap name="iCheckedAtNS">
<BlockCount>-48</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="PXW.Xref.Queries">
<Owner>_PUBLIC</Owner>
<TimeChanged>67125,77563.700859851</TimeChanged>
<TimeCreated>67125,77563.700859851</TimeCreated>

<Query name="Get">
<Description><![CDATA[
<dl>
		<dt>ItemType</dt><dd>Class, Global, Rtn etc</dd>
		<dt>ItemKey1</dt><dd>Class name ,may be a comma separated list OR end in a * to do a package, you cannot mix , and *</dd>
		<dt>ItemKey2</dt><dd>Method name, may be a comma separated list</dd>
		<dt>CalledByKey2</dt><dd>Class name, may be a comma separated list</dd>
</dl>
Flags: string containing the following flags: 
       EXTERNAL : only list rows where the call is External]]></Description>
<Type>PXW.LIB.SQL.Query</Type>
<FormalSpec>NameSpace:%String,ItemType:%String="",ItemKey1:%String="",ItemKey2:%String="",CalledByCommand:%String="",CalledByKey1:%String="",CalledByKey2:%String="",WindowSize:%Integer=0,Flags:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT NameSpace,ItemType,ItemKey1,ItemKey2,
	       CalledByType,CalledByCommand,CalledByKey1,CalledByKey2,CalledByKey3,LineNumber,Parameters,
	       PXW_Xref.Queries_GetCode(NameSpace,CalledByType,CalledByKey1,CalledByKey2,CalledByKey3,ItemKey1,ItemKey2,LineNumber,:WindowSize) AS CallingCode 
	FROM PXW_Xref.Data
	WHERE NameSpace=:NameSpace
	--IF ItemType'=""
		AND ItemType=:ItemType
	--ENDIF 
	--IF ItemKey1'="" 
		--IF $E(ItemKey1,*)="*" 
			AND ItemKey1 %STARTSWITH $PIECE(:ItemKey1,'*',1)
		--ELSE
			AND ItemKey1 %INLIST $LISTFROMSTRING(:ItemKey1)
		--ENDIF
	--ENDIF 
	--IF CalledByKey1'=""
		--IF $E(CalledByKey1,*)="*" 
			AND CalledByKey1 %STARTSWITH $PIECE(:CalledByKey1,'*',1)
		--ELSE
			AND CalledByKey1 %INLIST $LISTFROMSTRING(:CalledByKey1)
		--ENDIF
	--ENDIF
	--IF CalledByKey2'=""
		--IF CalledByKey2["%" 
			AND UPPER(CalledByKey2) LIKE (UPPER(:CalledByKey2))			
		--ELSEIF $E(CalledByKey2,*)="*" 
			AND CalledByKey2 %STARTSWITH $PIECE(:CalledByKey2,'*',1)
		--ELSE
			AND CalledByKey2 %INLIST $LISTFROMSTRING(:CalledByKey2)
		--ENDIF
	--ENDIF
	--IF ItemKey2'=""
		--IF ItemKey2["*"
			AND UPPER(ItemKey2) LIKE (UPPER(:ItemKey2))
		--ELSE 
			AND UPPER(ItemKey2) %INLIST $LISTFROMSTRING(UPPER(:ItemKey2))
		--ENDIF
	--ENDIF
	--IF CalledByCommand'=""
		AND CalledByCommand=:CalledByCommand
	--ENDIF
	--IF Flags["EXTERNAL" 
		AND CalledByKey1!=ItemKey1
	--ENDIF
		ORDER BY 
		--IF Flags["BY CALLED"
			 CalledByKey1,CalledByKey2,CalledByKey3,
		--ENDIF
		ItemKey1,ItemKey2</SqlQuery>
</Query>

<Query name="GetSuper">
<Description>
Include all the calls to the same method in the superclasses.
EG there may be no direct call to the method you are looking at, but it is called because its an override of a superclass and the superclass method gets called.
Could this replace Get query entirely? IE in Get mode GetOverrideTree returns only 1 row... Needs testing.</Description>
<Type>PXW.LIB.SQL.Query</Type>
<FormalSpec>NameSpace:%String,ItemType:%String="",ItemKey1:%String="",ItemKey2:%String="",CalledByCommand:%String="",CalledByKey1:%String="",WindowSize:%Integer=0,Flags:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT dat.NameSpace,dat.ItemType,dat.ItemKey1,dat.ItemKey2,
	       dat.CalledByType,dat.CalledByCommand,dat.CalledByKey1,dat.CalledByKey2,dat.CalledByKey3,dat.LineNumber,dat.Parameters,
	       PXW_Xref.Queries_GetCode(dat.NameSpace,dat.CalledByType,dat.CalledByKey1,dat.CalledByKey2,dat.CalledByKey3,dat.ItemKey1,dat.ItemKey2,dat.LineNumber,:WindowSize) AS CallingCode 
	FROM PXW_Xref.Queries_GetOverrideTree(:NameSpace,:ItemKey1,:ItemKey2) as overs
	INNER JOIN PXW_Xref.Data as dat ON dat.NameSpace=overs.NameSpace 
	      AND ((overs.itemkey1 IS NULL) OR (dat.itemkey1=overs.itemkey1))
		  AND ((overs.itemkey2 IS NULL) OR (dat.itemkey2=overs.itemkey2))
	WHERE 1=1
	--IF ItemType'=""
		AND dat.ItemType=:ItemType
	--ENDIF 
	--IF CalledByKey1'=""
		--IF $E(CalledByKey1,*)="*" 
			AND dat.CalledByKey1 %STARTSWITH $PIECE(:CalledByKey1,'*',1)
		--ELSE
			AND dat.CalledByKey1 %INLIST $LISTFROMSTRING(:CalledByKey1)
		--ENDIF
	--ENDIF
	--IF CalledByCommand'=""
		AND dat.CalledByCommand=:CalledByCommand
	--ENDIF
	--IF Flags["EXTERNAL" 
		AND dat.CalledByKey1!=dat.ItemKey1
	--ENDIF
		ORDER BY 
		--IF Flags["BY CALLED"
			 dat.CalledByKey1,dat.CalledByKey2,dat.CalledByKey3,
		--ENDIF
		dat.ItemKey1,dat.ItemKey2</SqlQuery>
</Query>

<Query name="GetCount">
<Type>PXW.LIB.SQL.Query</Type>
<FormalSpec>NameSpace:%String,ItemType:%String="",ItemKey1:%String="",ItemKey2:%String="",CalledByCommand:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT COUNT(*) AS Number
	FROM PXW_Xref.Data
	WHERE NameSpace=:NameSpace
	--IF ItemType'=""
		AND ItemType=:ItemType
	--ENDIF
	--IF ItemKey1'=""
		AND ItemKey1=:ItemKey1
	--ENDIF
	--IF ItemKey2'=""
		AND ItemKey2=:ItemKey2
	--ENDIF
	--IF CalledByCommand'=""
		AND CalledByCommand=:CalledByCommand
	--ENDIF</SqlQuery>
</Query>

<Method name="GetCount">
<ClassMethod>1</ClassMethod>
<FormalSpec>NameSpace:%String,ItemType:%String="",ItemKey1:%String="",ItemKey2:%String="",CalledByCommand:%String=""</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	/*#dim rs as %SQL.StatementResult*/
		Set count=""
		Set rs=..GetCountFunc(NameSpace,ItemType,ItemKey1,ItemKey2,CalledByCommand)
		If rs.%Next() {
			Set count=+rs.%Get("Number")
		}
		Quit count
]]></Implementation>
</Method>

<Method name="GetCode">
<ClassMethod>1</ClassMethod>
<FormalSpec>%NS:%String,CodeType:%String,CodeKey1:%String,CodeKey2:%String,CodeKey3:%String,ItemKey1:%String,ItemKey2:%String,LineNumber:%Integer,WindowSize:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	#dim e as %Exception.SystemException

	Set ClassServer=$GET(%PXWClassServer(%NS))
	If '$ISOBJECT(ClassServer) {
		Set ClassServer=##class(PXW.DEV.Dictionary.ClassDefinitionObject).%OpenId(%NS)
		Set %PXWClassServer(%NS)=ClassServer
	}

	If WindowSize=0 Quit ""
	Set ws=WindowSize-1
	Try {
		If $LISTFIND($LISTBUILD("CLS","QRY","VEW"),CodeType) {
			If '$DATA(%PXWCacheCode(CodeKey1)) {
				Set sc=ClassServer.GetClassStudioText(CodeKey1,,.lines)
				If $$$ISOK(sc) {
					Merge %PXWCacheCode(CodeKey1)=lines
				} Else {
					Set %PXWCacheCode(CodeKey1,"ERROR")=$SYSTEM.Status.GetErrorText(sc)
				}
			}
			If '$DATA(%PXWCacheCode(CodeKey1,"ERROR")) {
				Set code="",sep=""
				Set from=LineNumber-ws
				If from<1 Set from=1
				Set to=LineNumber+ws
				If to>%PXWCacheCode(CodeKey1) Set to=%PXWCacheCode(CodeKey1)
				For i=from:1:to Set code=code_sep_%PXWCacheCode(CodeKey1,i),sep=$CHAR(13,10)
			} Else {
				Set code=%PXWCacheCodeCode(CodeKey1,"ERROR")
			}
		}
	} Catch e {
		Set code=e.DisplayString()
	}
	Quit code
]]></Implementation>
</Method>

<Query name="PackageSummary">
<Description>
Summary of where a class calls something not in the same package</Description>
<Type>PXW.LIB.SQL.Query</Type>
<FormalSpec>NameSpace:%String,Package:%String</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>SELECT distinct ItemPackage, CalledByPackage
FROM (
        
        SELECT NameSpace,ItemType,ItemKey1,ItemKey2,
	        CalledByType,CalledByCommand,CalledByKey1,CalledByKey2,CalledByKey3,LineNumber,Parameters,
            PXW_Xref.Queries_PackageName(NameSpace,ItemKey1) as ItemPackage,
            PXW_Xref.Queries_PackageName(NameSpace,CalledByKey1) as CalledByPackage
        FROM PXW_Xref.Data
    )
  WHERE (ItemType = 'CLS')
    AND (NameSpace=:NameSpace)
    AND (ItemPackage != CalledByPackage)
    AND $extract(itemPackage, 1) != '%'
    AND CalledByKey1 %STARTSWITH :Package</SqlQuery>
</Query>

<Query name="PackageDetail">
<Description>
Details of where a class calls something not in the same package</Description>
<Type>PXW.LIB.SQL.Query</Type>
<FormalSpec>NameSpace:%String,ItemPackage:%String,CalledByPackage:%String,WindowSize:%Integer=1</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>SELECT *
FROM (
        SELECT NameSpace,ItemType,ItemKey1,ItemKey2,
	        CalledByType,CalledByCommand,CalledByKey1,CalledByKey2,CalledByKey3,LineNumber,Parameters,
            PXW_Xref.Queries_PackageName(NameSpace,ItemKey1) as ItemPackage,
            PXW_Xref.Queries_PackageName(NameSpace,CalledByKey1) as CalledByPackage,
            PXW_Xref.Queries_GetCode(NameSpace,CalledByType,CalledByKey1,CalledByKey2,CalledByKey3,ItemKey1,ItemKey2,LineNumber,:WindowSize) AS CallingCode 
        FROM PXW_Xref.Data
    )
WHERE (ItemType = 'CLS')
    AND (NameSpace=:NameSpace)
    AND (ItemPackage != CalledByPackage)
    AND $extract(itemPackage, 1) != '%'
    AND CalledByKey1 %STARTSWITH :CalledByPackage -- makes it use an index
    AND $piece(CalledByPackage,'.',1,$length(:CalledByPackage,'.')) = :CalledByPackage 
    --IF ItemPackage=""
        AND ItemPackage IS NULL 
    --ELSE
        AND ItemPackage = :ItemPackage 
    --ENDIF</SqlQuery>
</Query>

<Query name="BuildProblems">
<Type>PXW.LIB.SQL.Query</Type>
<FormalSpec>NameSpace:%String</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>	SELECT ID, BuildStatus, ItemKey1, ItemType, LastUpdate, NameSpace
	  FROM LastUpdated
	 WHERE NameSpace=:NameSpace
	   AND BuildStatus!=1</SqlQuery>
</Query>

<Method name="PackageName">
<ClassMethod>1</ClassMethod>
<FormalSpec>NameSpace:%String,ClassName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	Set ClassServer=$GET(%PXWClassServer(NameSpace))
	If '$ISOBJECT(ClassServer) {
		Set ClassServer=##class(PXW.DEV.Dictionary.ClassDefinitionObject).%OpenId(NameSpace)
		Set %PXWClassServer(%NS)=ClassServer
	}

    Set full=ClassServer.FullClassName(ClassName)
    Set package=$PIECE(full,".",1,*-1)
    Quit package
]]></Implementation>
</Method>

<Query name="GetOverrideTree">
<Type>%Query</Type>
<FormalSpec>NameSpace:%String,ItemKey1:%String,ITemKey2:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="NameSpace:%String,ItemKey1:%String,ItemKey2:%String"/>
</Query>

<Method name="GetOverrideTreeExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,NameSpace:%String,ItemKey1:%String,ItemKey2:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill %PXWTree,%PXWTreeDone
	Set %PXWTree($INCREMENT(%PXWTree))=$LISTBUILD(NameSpace,ItemKey1,ItemKey2) ; include self
	Do gettreerecurse(NameSpace,ItemKey1,ItemKey2)
	Set qHandle=""
	Quit $$$OK
gettreerecurse(NameSpace,ItemKey1,ItemKey2)
	If $DATA(%PXWTreeDone(ItemKey1)) Quit
	
	Set %PXWTreeDone(ItemKey1)=1
	Set rs=..GetOverridesFunc(NameSpace,ItemKey1,ItemKey2)
	While rs.%Next() {
		Set %PXWTree($INCREMENT(%PXWTree))=$LISTBUILD(rs.NameSpace,rs.ItemKey1,rs.ItemKey2)
		Do gettreerecurse(NameSpace,rs.ItemKey1,ItemKey2)	
	}
	Quit
]]></Implementation>
</Method>

<Method name="GetOverrideTreeClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>GetOverrideTreeExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill %PXWTree,%PXWTreeDone
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetOverrideTreeFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>GetOverrideTreeExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle=$ORDER(%PXWTree(qHandle),1,Row)
	If qHandle="" {
		Set AtEnd=1
		Set Row=""
	} 
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="GetOverrides">
<Type>PXW.LIB.SQL.Query</Type>
<FormalSpec>NameSpace:%String,ItemKey1:%String,ItemKey2:%String</FormalSpec>
<SqlQuery>	SELECT * from PXW_Xref.Data
	WHERE Namespace=:NameSpace
	--IF ItemKey1'=""
		--IF $E(ItemKey1,*)="*" 
			AND CalledByKey1 %STARTSWITH $PIECE(:ItemKey1,'*',1)
		--ELSE
			AND CalledByKey1 %INLIST $LISTFROMSTRING(:ItemKey1)
		--ENDIF
	--ENDIF
	
	--IF ItemKey2'=""
		AND UPPER(CalledByKey2) %INLIST $LISTFROMSTRING(UPPER(:ItemKey2))
	--ENDIF
	
	AND CalledByCommand='_Override'</SqlQuery>
</Query>
</Class>


<Class name="PXW.Xref.bnf">
<IncludeCode>PXW.Debuggers.Macros</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeChanged>67125,77563.637129308</TimeChanged>
<TimeCreated>67125,77563.637129308</TimeCreated>

<Property name="CalledByKeyword">
<Description>
The command used for the call (set/kill)</Description>
<Type>%String</Type>
</Property>

<Property name="CalledByCommand">
<Type>%String</Type>
</Property>

<Property name="CalledByClassName">
<Description>
The routine, class doing the call</Description>
<Type>%String</Type>
</Property>

<Property name="CalledByItemName">
<Description>
Line label, method</Description>
<Type>%String</Type>
<InitialExpression>"class"</InitialExpression>
</Property>

<Property name="Analyser">
<Type>PXW.DEV.BNF.Analyse.COS</Type>
</Property>

<Property name="ClassElementLineNumber">
<Type>%Integer</Type>
</Property>

<Property name="ERROR">
<Type>%String</Type>
</Property>

<Property name="ClassServer">
<Description>
the object that will act as the class data server</Description>
<Type>PXW.DEV.Dictionary.ClassDefinitionObject</Type>
</Property>

<Property name="ThisItemType">
<Type>%String</Type>
</Property>

<Property name="InView">
<Description>
Are we in a view</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SQLPaths">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="SaveAnalysis">
<FormalSpec>atom:PXW.DEV.Atom,Description:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set adata=##class(PXW.Xref.AnalysisData).%New()
	Set adata.ItemKey1=..CalledByClassName
	Set adata.ItemKey2=..CalledByItemName
	Set adata.ItemType="CLS"
	Set adata.LineNumber=atom.line
	Set adata.Description=Description
	Set sc=adata.%Save()
	If $$$ISERR(sc) {
		$$$DEBUG($EXTRACT($SYSTEM.Status.GetErrorText(sc),1,100))
	}
	Quit sc
]]></Implementation>
</Method>

<Method name="SaveCDEFCref">
<FormalSpec>ItemKey1:%String,LineNumber:%Integer,ItemKey2:%String</FormalSpec>
<Implementation><![CDATA[
	Set ik2=$SELECT($DATA(ItemKey2):ItemKey2,1:"_class")
	$$$DEBUG("Saving CDEF "_ItemKey1_", "_ik2)
	Set xref=##class(PXW.Xref.Data).%New()
	Set xref.CalledByType="CLS"
	Set xref.CalledByKey1=..CalledByClassName
	Set xref.CalledByKey2=..CalledByItemName
	Set xref.CalledByKey3=0 ; definition of property/method etc
	Set xref.CalledByCommand="_"_..CalledByCommand ; _Extends,_Type etc
	Set xref.ItemType="CLS"
	Set xref.ItemKey1=..ClassServer.FullClassName(ItemKey1,$PIECE(..CalledByClassName,".",1,*-1))
	Set xref.ItemKey2=ik2
    Set xref.LineNumber=LineNumber
	Set sc=$$$OK
	If 'xref.AlreadyExists() {
		Set sc=xref.%Save()
		If $$$ISERR(sc) {
			$$$DEBUG($EXTRACT($SYSTEM.Status.GetErrorText(sc),1,100))
		}
	}
]]></Implementation>
</Method>

<Method name="SaveCOSXref">
<FormalSpec>ItemType:%String,ItemKey1:%String,ItemKey2:%String,CalledByCommand:%String,Atom:PXW.DEV.Atom=""</FormalSpec>
<Implementation><![CDATA[
	;i ItemKey2["Variables" zw ItemType,ItemKey1,ItemKey2
	$$$DEBUG("Saving COS "_ItemType_","_ ItemKey1_","_ItemKey2_","_CalledByCommand)
	Set xref=##class(PXW.Xref.Data).%New()
	Set xref.CalledByType="CLS"
	Set xref.CalledByKey1=..CalledByClassName
	Set xref.CalledByKey2=..CalledByItemName
	Set xref.CalledByCommand=CalledByCommand
	Set xref.ItemType=ItemType
	Set xref.ItemKey1=ItemKey1
	Set xref.ItemKey2=ItemKey2
	If $ISOBJECT(Atom) {
		Set xref.CalledByKey3=Atom.line-..ClassElementLineNumber
		Set xref.LineNumber=Atom.line
	} Else {
		Set xref.LineNumber=0
	}

	Set sc=$$$OK
	If 'xref.AlreadyExists() {
		Set sc=xref.%Save()
		If $$$ISERR(sc) {
			$$$DEBUG($EXTRACT($SYSTEM.Status.GetErrorText(sc),1,100))
		}
	}
	If $$$ISOK(sc),ItemType="CLS" {
		Set origin="",stub=""
		If ..ClassServer.GetMethodDetails(ItemKey1,ItemKey2,,.origin,.stub),origin'=ItemKey1 {
			; also xref the origin class
			Do ..SaveCOSXref(ItemType,origin,ItemKey2,CalledByCommand,Atom)
		} ElseIf ..ClassServer.GetPropertyDetails(ItemKey1,ItemKey2,,,,.origin),origin'=ItemKey1 {
			; also xref the origin class
			Do ..SaveCOSXref(ItemType,origin,ItemKey2,CalledByCommand,Atom)
		}
		If (stub'="") {
			If ($PIECE(stub,".",*)="q") {
				; if the item is a function based on a query (eg GetFunc) then xref the query
				Set query=$PIECE(stub,".",1)
				Do ..SaveCOSXref(ItemType,ItemKey1,query,CalledByCommand,Atom)
			} ElseIf $PIECE(stub,".",*)="a" {
				; if the item is a function based on a property (eg ThingGetLogicalToDisplay) then xref the property
				Set prop=$PIECE(stub,".",1)
				Do ..SaveCOSXref(ItemType,ItemKey1,prop,CalledByCommand,Atom)
			} ElseIf $PIECE(stub,".",*)="i" {
				; if the item is a function based on an index (eg PKOpen) then xref the property
				Set index=$PIECE(stub,".",1)
				Do ..SaveCOSXref(ItemType,ItemKey1,index,CalledByCommand,Atom)
			}

		}
	}
]]></Implementation>
</Method>

<Method name="SaveSQLXref">
<FormalSpec>ItemType:%String,ItemKey1:%String,ItemKey2:%String,CalledByCommand:%String,Atom:PXW.DEV.Atom="",CalledByKey2=""</FormalSpec>
<Implementation><![CDATA[
	Set sc=$$$OK
	$$$DEBUG("Saving SQL "_ItemType_","_ ItemKey1_","_ItemKey2_","_CalledByCommand)
	Set xref=##class(PXW.Xref.Data).%New()
	Set xref.CalledByType="CLS" 
	Set xref.CalledByKey1=..CalledByClassName
	Set xref.CalledByKey2=$s($g(CalledByKey2)'="":CalledByKey2,1:..CalledByItemName)

	If $ISOBJECT(Atom) {
		Set xref.CalledByKey3=Atom.line-..ClassElementLineNumber
		Set xref.LineNumber=Atom.line ;+..LineOffset
	} Else {
		Set xref.LineNumber=0
	}

	Set xref.CalledByCommand=CalledByCommand
	Set xref.ItemType=ItemType
	Set xref.ItemKey1=ItemKey1
	Set xref.ItemKey2=ItemKey2
	If 'xref.AlreadyExists() {
		Set sc=xref.%Save()
		If $$$ISERR(sc) {
			$$$DEBUG($EXTRACT($SYSTEM.Status.GetErrorText(sc),1,100))
		}
	}

	If $$$ISOK(sc),ItemType="CLS" {
		If ..ClassServer.GetMethodDetails(ItemKey1,ItemKey2,,.origin),origin'=ItemKey1 {
			Do ..SaveCOSXref(ItemType,origin,ItemKey2,CalledByCommand,Atom)
		} ElseIf ..ClassServer.GetPropertyDetails(ItemKey1,ItemKey2,,,,.origin),origin'=ItemKey1 {
			Do ..SaveCOSXref(ItemType,origin,ItemKey2,CalledByCommand,Atom)
		}
	}
]]></Implementation>
</Method>

<Method name="output">
<FormalSpec>text:%String</FormalSpec>
<Implementation><![CDATA[

    Write text
]]></Implementation>
</Method>

<Method name="begin">
<Implementation><![CDATA[	;d ..output("<pre>")
]]></Implementation>
</Method>

<Method name="end">
<Implementation><![CDATA[	;d ..output("</pre>")
]]></Implementation>
</Method>

<Method name="middle">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
   If $ISOBJECT(..Analyser) Do ..Analyser.middle(element) 
   Do ..xrefElement(element)
]]></Implementation>
</Method>

<Method name="xrefElement">
<FormalSpec>element:PXW.DEV.Element</FormalSpec>
<Implementation><![CDATA[
    #dim a as PXW.DEV.Atom

    /*i element.%IsA("PXW.DEV.ClassDefinition.Element") {
		#dim cdefelement as PXW.DEV.ClassDefinition.Element=element
		i $listfind($lb("Method","ClassMethod","ClientMethod"),cdefelement.ClassDefinitionType) {
			s ..ClassElementLineNumber=cdefelement.FirstAtom().line
			s overrides=##class(PXW.DEV.Dictionary.ClassDefinition).GetMethodOverrides(..CalledByClassName_"||"_cdefelement.Name)
            i overrides'="" {
				s ..CalledByItemName=cdefelement.Name
                s ..CalledByCommand="Method_Override"
				d ..SaveCDEFCref(overrides,..ClassElementLineNumber,cdefelement.Name)
			}
    	}
       	i $listfind($lb("Property","Relationship"),cdefelement.ClassDefinitionType) {
			s ..ClassElementLineNumber=cdefelement.FirstAtom().line
			s overrides=##class(PXW.DEV.Dictionary.ClassDefinition).GetPropertyOverrides(..CalledByClassName_"||"_cdefelement.Name)
            i overrides'="" {
				s ..CalledByItemName=cdefelement.Name
                s ..CalledByCommand="Property_Override"
				d ..SaveCDEFCref(overrides,..ClassElementLineNumber,cdefelement.Name)
			}
    	}
    	i $listfind($lb("Parameter"),cdefelement.ClassDefinitionType) {
			s ..ClassElementLineNumber=cdefelement.FirstAtom().line
			s overrides=##class(PXW.DEV.Dictionary.ClassDefinition).GetParameterOverrides(..CalledByClassName_"||"_cdefelement.Name)
            i overrides'="" {
				s ..CalledByItemName=cdefelement.Name
                s ..CalledByCommand="Parameter_Override"
				d ..SaveCDEFCref(overrides,..ClassElementLineNumber,cdefelement.Name)
			}
    	}
    }
	*/
    If element.type="ClassDefinition" {
        Set cnameE=element.findFirstElementByType("ClassName")
        If $ISOBJECT(cnameE) {
            Set ..CalledByClassName=cnameE.ToString(0)
        }
    }
    If $LISTFIND($LISTBUILD("PropertyName","MethodName","ClassParameterName","IndexName","TriggerName","ForeignkeyName","StorageName","QueryName"),element.type) {
        Set name=element.ToString(0)
        Set ..CalledByItemName=name        
        Set ..ClassElementLineNumber=element.FirstAtom().line
        Set overrides=""
        If $LISTFIND($LISTBUILD("MethodName"),element.type) {
            Set overrides=..ClassServer.GetMethodOverrides(..CalledByClassName_"||"_name)
        }
        If $LISTFIND($LISTBUILD("PropertyName"),element.type) {
            Set overrides=..ClassServer.GetPropertyOverrides(..CalledByClassName_"||"_name)
        }
        If $LISTFIND($LISTBUILD("ClassParameterName"),element.type) {
            Set overrides=..ClassServer.GetParameterOverrides(..CalledByClassName_"||"_name)
        }
        If overrides'="" {
            Set ..CalledByCommand="Override" 
            Do ..SaveCDEFCref(overrides,..ClassElementLineNumber,name)
        }
    }

    If element.type="MethodReference" {
		Do element.write()
		Set name=element.ToString(0)
		Set a=element.FirstAtom()
        Do ..SaveCDEFCref(..CalledByClassName,a.line,name)
    }

    If element.type="ClassReference" {
		Set name=element.ToString(0)
		Set a=element.FirstAtom()
        Do ..SaveCDEFCref(name,a.line)
    }

    If element.type="OneClassmember" {
        Set ..Analyser=##class(PXW.DEV.BNF.Analyse.COS).%New(..ClassServer)
        Set ..Analyser.This=..CalledByClassName
	    If $ISOBJECT(..Analyser) Do ..Analyser.middle(element)

 	    Set item=element.partsGetAt(1)
      	Set typeE=item.partsGetAt(1)
        Set ..ThisItemType=typeE.ToString(0)
	}

    /*
    Element=TypeClassReference PXW.DEV.BNF.Element @134
    .Element=ClassReference PXW.DEV.BNF.Element @310
    ..type=ClassReference:
    .. %String
    .Element=TypeParameters PXW.DEV.BNF.Element @208
    ..type=punctuation:
    .. (
    ..Element=TypeParametersList PXW.DEV.BNF.Element @86
    ...Element=TypeParameterItem PXW.DEV.BNF.Element @385
    ....Element=ClassItemIdentifier PXW.DEV.BNF.Element @347
    .....type=ClassItemIdentifier:
    ..... MAXLEN
    ....type=punctuation:
    .... =
    ....Element=Number PXW.DEV.BNF.Element @309
    .....type=Number:
    ..... 1
    ..type=punctuation:
    .. )
    */
    If element.type="TypeClassReference" {
        Set crefE=element.findFirstElementByType("ClassReference",0)
        If $ISOBJECT(crefE) {
            Set class=crefE.ToString(0)
        
            Set paramE=element.findFirstElementByType("TypeParameters",0)
            If $ISOBJECT(paramE) {
                Set list=##class(%ListOfObjects).%New()
                Do paramE.findElementsByType("ClassItemIdentifier",list,2)
                For i=1:1:list.Count() {
                    Set itemE=list.GetAt(i)
					Set a=itemE.FirstAtom()
                    ;d ..wrapElementHTML(itemE,"<a href='"_##class(PXW.Tools.DEV.Class).HREFTo(class,itemE.ToString(0),,,..This)_"'>","</a>")
					Set ..CalledByCommand="Override" 
                 	If $LISTFIND($LISTFROMSTRING("Property","Relationship"),..ThisItemType) {
                        ;Do ..wrapElementHTML(itemE,"<a href='"_..HREFToClass(..This,..ThisMethod,itemE.ToString(0))_"'>","</a>")
						If ..ClassServer.GetPropertyParameterDetails(..CalledByClassName,..CalledByItemName,itemE.ToString(0),.ppsource) {
							Do ..SaveCDEFCref(ppsource,a.line,itemE.ToString(0))
						}
                    } Else {
       					Do ..SaveCDEFCref(class,a.line,itemE.ToString(0))
                    }
                }
            }
        }
    }

  
    ;i $isobject(..Analyser) d ..Analyser.middle(element)
        
	/* ------------------------------------------- */
	; From COS
	/*i element.%IsA("PXW.DEV.COS.Objects.Property") {
		s propertyElement=element
		s linkclass=$s(propertyElement.ParentObject.CastClassName'="":propertyElement.ParentObject.CastClassName,1:propertyElement.ParentObject.DerivedClass)
		d ..SaveCOSXref("CLS",linkclass,propertyElement.Name.ToString(0),propertyElement.CommandMode,propertyElement.Name)
	}
	i element.%IsA("PXW.DEV.COS.Objects.Method") {
		s methodElement=element
		s linkclass=$s(methodElement.ParentObject.CastClassName'="":methodElement.ParentObject.CastClassName,1:methodElement.ParentObject.DerivedClass)
		s cls=linkclass,method=methodElement.Name.ToString(0)
		; save the call to the instance class
		d ..SaveCOSXref("CLS",cls,method,"fetch",methodElement.Name)

		s detailsfound=##class(PXW.DEV.Dictionary.ClassDefinition).GetMethodDetails(cls,method,,.origin)
		i detailsfound {
			i origin'=cls {
				s cls=origin,instance=cls
				; save the call to the ORIGIN as well,
				; eg. saving a persistent object saves both %Save on the instance
				; of the object AND on %Library.Persistent
				d ..SaveCOSXref("CLS",cls,method,"fetch",methodElement.Name)
			}
		}
	}
	
	i element.%IsA("PXW.DEV.COS.Global") {
		s globalElement=element
		d ..SaveCOSXref("GBL",globalElement.Name.ToString(0),globalElement.KeysForXref(),$s(globalElement.IsModified:"set",1:"fetch"),globalElement.Name)
	}
    */
	If element.type="ClassExpression" {
        Set classnameele=element.findFirstElementByType("ClassReference",0)
        Set classname=classnameele.ToString(0)
		Do ..FollowObjectChainForType(element,classname)
    }

    If $LISTFIND($LISTBUILD("ThisObject","ThisObjectDirectProperty","ThisObjectSet","ThisObjectDirectPropertySet"),element.type) {
        If ..CalledByClassName'="" {
            Set classname=..CalledByClassName
            If classname'="" Do ..FollowObjectChainForType(element,classname)
        }
    }
    ; known variable
    If ",Variable,VariableSet,ObjectVariable,"[(","_element.type_","),$ISOBJECT(..Analyser) {
        Set variablename=element.ToStringAtomsOnly(0)
        ; variable could be something like {*} or {field}  so the name above (using atoms only) will not find anything
        ; don't worry about that at the moment!
        If variablename'="" {
            ; when working out a type use the #DIM type if there is one
            Set classname=$GET(..Analyser.DimmedTypes(variablename))
            If classname="" Set classname=$GET(..Analyser.VariablesTypes(variablename))
            If classname'="" Do ..FollowObjectChainForType(element,classname)
        }
        ;zw element,variablename,classname,..Analyser
    }

    If (element.type="GlobalRef") || (element.type="GlobalRefSet") {
        Set setmode="fetch"
        If element.type="GlobalRefSet" Set setmode="SET"

        Set fullrefE=element.findFirstElementByType("GlobalRefFull",0)
        If $ISOBJECT(fullrefE) {
            ; On a global clicking on the ^ will take directly to the XREF since we don't
            ; have any other details about the global at the moment.
            ; Clicking on the name of the global highlights it like a regular variable
            Set globalElement=fullrefE.findFirstElementByType("GlobalName",0)
            Set upa=fullrefE.FirstAtom() ; ^ is always at the start
            Set namea=globalElement ;.ToStringAtomsOnly()
            ;d ..wrapAtomHTML(upa,"<a class='COSGlobalSet' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("GBL",globalElement.Name.ToString(0),globalElement.KeysForXref())_"'>","</a>")
            Set subsE=fullrefE.findFirstElementByType("SubscriptParameterList",0),subs=""
            If $ISOBJECT(subsE) Set subs=..Analyser.SimplifySubscripts(subsE)
            ;d ..wrapAtomHTML(upa,"<a class='COSGlobalSet' href='"_##class(PXW.Tools.DEV.Xref).HREFTo("GBL",namea.ToStringAtomsOnly(0),subs)_"'>","</a>")
			If $ISOBJECT(namea) {
				Do ..SaveCOSXref("GBL",namea.ToStringAtomsOnly(0),subs,setmode,upa)            
			}
        } Else {
            ; not sure what we can do with naked refs here (other than make them stand out as a bad thing)
        }
	}	

	If element.type="Macrocall" {
		Set atom=element.FirstAtom()
		Set macroname=element.ToString(0)
		Set macroname=$PIECE(macroname,"(",1)
		If macroname?1"$$$"1.E Set macroname=$PIECE(macroname,"$$$",2)
		If ..ClassServer.GetMacroLocation(..CalledByClassName,macroname,.source) {
			If source'="" {
				; includename.inc is returned so file as INC and remove this from the name
				Set type=$$$UPPER($PIECE(source,".",*))
				Set source=$PIECE(source,".",1,*-1)
				Do ..SaveCOSXref("INC",source,macroname,"_macro",atom)
			}
		}
	}
	/* ------------------------------------------- */

	/* ------------------------------------------- */
	; from SQL
	if element.type="AttributeViewquery" {
		set oldInView=..InView
		set ..InView=1	
		set ..CalledByItemName="" ; no name until we hit columns
	}
	If element.type="SelectCommand" {
		do ..SQLInternalXREF(element)
        Set sqlanalyse=##class(PXW.DEV.BNF.Analyse.SQL).%New(..ClassServer)
		Set sqlanalyse.This=..CalledByClassName
        Do sqlanalyse.checkElement(element)
        Set cref=""
		While sqlanalyse.NextColumnReference(.cref,.fulltable,.fieldname) {
            k CalledByItem
            If fulltable'="" {
	            if ..InView {
					s CalledByItem=""_$g(..SQLPaths(+cref),"unk")
	            }
                ;d ..wrapAtomHTML(cref,"<a class='CDEFName' href='"_##class(PXW.Tools.DEV.Class).HREFTo(fulltable,fieldname)_"'>","</a>")
				Kill patharray
				Do ..ClassServer.GetClassPathFromTable(fulltable,fieldname,.patharray)
				Set atom=cref.FirstAtom()
				Set command=element.type
				For i=1:1:$GET(patharray) {
					Set data=patharray(i)
					Set class=$LISTGET(data,1),item=$LISTGET(data,2)
					If class'="",item'="" {
						Do ..SaveSQLXref("CLS",class,item,command,atom,.CalledByItem)
					}
				}
            } Else {
	            if ..InView {
		            set aliasNameE=cref.findFirstElementByType("AliasName",0)
		            set columnNameE=cref.findFirstElementByType("ColumnName",0)
					Set command=element.type
					Set atom=cref.FirstAtom()
		            s CalledByItem=""_$g(..SQLPaths(+cref),"unk")
		            if $isobjecT(aliasNameE),$isobject(columnNameE) {
			            Do ..SaveSQLXref("CLS",..CalledByClassName,aliasNameE.ToString(0)_"."_columnNameE.ToString(0),command,atom,.CalledByItem)
		            }
	            }

                ;s colname="col"_$$$UPPER(fieldname)
                ;d ..wrapAtomHTML(cref,"<span class='COSObjectsProperty' title='unable to determine class, possibly because of subquery' fetchid='"_colname_"' onclick=""HiliteSets('"_colname_"');"">","</span>")
            }
        }
    }
   If element.type="InsertCommand" {
        Set sqlanalyse=##class(PXW.DEV.BNF.Analyse.SQL).%New(..ClassServer)
		Set sqlanalyse.This=..CalledByClassName
        Do sqlanalyse.checkElement(element)
        Set columnNameE=""
        While sqlanalyse.NextColumnReference(.columnNameE,.fulltable,.fieldname) {
			Kill patharray
			Do ..ClassServer.GetClassPathFromTable(fulltable,fieldname,.patharray)
			Set atom=columnNameE.FirstAtom()
			Set command=element.type
			For i=1:1:$GET(patharray) {
				Set data=patharray(i)
				Set class=$LISTGET(data,1),item=$LISTGET(data,2)
				If class'="",item'="" {
					Do ..SaveSQLXref("CLS",class,item,command,atom)
				}
			}
        }
    }

	If element.type="DeleteCommand" {
		Set sqlanalyse=##class(PXW.DEV.BNF.Analyse.SQL).%New(..ClassServer)
		Set sqlanalyse.This=..CalledByClassName
        Do sqlanalyse.checkElement(element)
        Set columnNameE=""
		Kill tables
        While sqlanalyse.NextColumnReference(.columnNameE,.fulltable,.fieldname) {
			Kill patharray
			Do ..ClassServer.GetClassPathFromTable(fulltable,fieldname,.patharray)
			Set atom=columnNameE.FirstAtom()
			Set command=element.type
			For i=1:1:$GET(patharray) {
				Set data=patharray(i)
				Set class=$LISTGET(data,1),item=$LISTGET(data,2)
				If class'="",item'="" {
					Do ..SaveSQLXref("CLS",class,item,command,atom)
					If '$DATA(tables(class)) {
						Set tabatom=element.FirstAtom()
						Do ..SaveSQLXref("CLS",class,"_table",command,tabatom)
						Set tables(class)=1
					}
				}
			}
        }
	}
	
	/*If element.type="StoredProcCall" {
        Set spNameE=element.findFirstElementByType("StoredProcName",0)
        If $ISOBJECT(spNameE) {
            Set spname=spNameE.ToString(0)
			Set class=..ClassServer.GetClassNameFromStoredProc(spname,.method,..CalledByClassName)
			If class'="" {
				Set atom=element.FirstAtom()
				Set command=element.type
				Do ..SaveSQLXref("CLS",class,method,command,atom)    
			}
        }
    }*/
	If element.type="StoredProcName" {
        Set spNameE=element
        If $ISOBJECT(spNameE) {
            Set spname=spNameE.ToString(0)
			Set class=..ClassServer.GetClassNameFromStoredProc(spname,.method,..CalledByClassName)
			set cbk2=$g(..SQLPaths(+element),"unk")
			If class'="" {
				Set atom=element.FirstAtom()
				Set command=element.type
				Do ..SaveSQLXref("CLS",class,method,command,atom,cbk2)
			}
        }
    }
	/* ------------------------------------------- */


	For  {
		Set atom=element.partsGetNext(.akey)
		Quit:akey=""
		
	    If atom.%IsA("PXW.DEV.Element") {
			Do ..xrefElement(atom)
		} ElseIf atom.%IsA("PXW.DEV.Atom") {
            Set type=$$$UPPER($PIECE(atom.type,":",1))
            ; this is the word "method" or "property" etc
            If type="KEYWORD" {
               Set ..CalledByCommand=atom.value
            }
			If type="CDEFKEYWORD" {
               Set ..CalledByCommand=atom.value
            }

			If $ISOBJECT(..Analyser),$DATA(..Analyser.ElementWarnings(+atom)) {
				Set line=..Analyser.ElementWarnings(+atom)
				Do ..SaveAnalysis(atom,line)
			}


			; type="ERROR" happens when a RECOVERY takes place
			; the atom should contain a bit of code up to the point of the error
			If type="ERROR" {
				If ..ERROR="" Set ..ERROR=atom.ToString()
			}

		}
	}
]]></Implementation>
</Method>

<Method name="FollowObjectChainForType">
<FormalSpec>ParentElement:PXW.DEV.Element,StartClassName:%String</FormalSpec>
<Implementation><![CDATA[
    If (ParentElement.type="ThisObject") || (ParentElement.type="ThisObjectSet") {
        Set this=ParentElement.findFirstElementByType("ThisObjectSelf",0) ; ..property
        If $ISOBJECT(this) {
            Set objectchain=this.findFirstElementByType("ObjectChainNoDot",0)
        } Else {
            Set this=ParentElement.findFirstElementByType("ThisObjectThis",0) ; $this.property
            If $ISOBJECT(this) {
                Set objectchain=this.findFirstElementByType("ObjectChain",0)
            }
        }
    } ElseIf (ParentElement.type="ThisObjectDirectProperty") || (ParentElement.type="ThisObjectDirectPropertySet") {
        Set objectchain=ParentElement.findFirstElementByType("ObjectChainItem",0) ; i%property
    } Else {
        Set objectchain=ParentElement.findFirstElementByType("ObjectChain",1) ; var.property
    }
    Set path="",sep=""
    While $IsObject(objectchain) {
        
        Set propertyatom=""
        ; the objectchain has the "." and the name
        For  {
            Set a=objectchain.partsGetNext(.akey)
            Quit:akey=""

            If a.%IsA("PXW.DEV.Atom"),a.value'="." {
                Set propertyatom=a
            }
        }

        Set path=path_sep_propertyatom.value,sep="."
		;d ..wrapAtomHTML(propertyatom,"<a class='COSObjectsProperty' href='"_##class(PXW.Tools.DEV.Class).HREFTo(StartClassName,path)_"'>","</a>")
		

        Set objectchain=objectchain.findFirstElementByType("ObjectChain",0) 
    }
	If path'="" {
		Do ..ClassServer.GetClassPath(StartClassName,path,.patharray)
		;zw StartClassName,path,patharray
		Set atom=ParentElement.FirstAtom()
		Set command=ParentElement.type
		For i=1:1:$GET(patharray) {
			Set data=patharray(i)
			Set class=$LISTGET(data,1),item=$LISTGET(data,2)
			If $EXTRACT(item,1)="#" Set item=$EXTRACT(item,2,*) ; strip the # from parameters
			If class'="",item'="" {
				Do ..SaveCOSXref("CLS",class,item,command,atom)
			}
		}
	}
]]></Implementation>
</Method>

<Method name="SQLInternalXREF">
<Description>
Recursive, pass in Element, get out the ..Index of what element is where on the path, path is the current path</Description>
<FormalSpec>Element:PXW.DEV.Element,path:%String=""</FormalSpec>
<Implementation><![CDATA[
	
	i '$d(..SQLPaths(+Element)) {
		s ..SQLPaths(+Element)=path

		if Element.type="SubquerySpecification" {
			
		}
		if Element.type="DerivedTable" {
			s TableAsClauseE=Element.findFirstElementByType("TableAsClause",0)
			i $isobject(TableAsClauseE) {
				s TableNameE=TableAsClauseE.findFirstElementByType("AliasName",0)
				i $ISOBJECT(TableNameE) {
					s path=path_$s(path'="":".",1:"column:")_""_TableNameE.ToString(0)
				}
			}
		}
		if Element.type="DerivedColumn" {
			d ##class(PXW.DEV.BNF.Analyse.SQL).GetDerivedColumnInfo(Element,.colname)
			s path=path_$s(path'="":".",1:"column:")_""_colname
		}
		s ..SQLPaths(+Element)=path

		s akey=""
		f  {
			Set atom=Element.partsGetNext(.akey)
			Quit:akey=""
			
			If atom.%IsA("PXW.DEV.Element") {
				Do ..SQLInternalXREF(atom,path)
			}
		}
	}
]]></Implementation>
</Method>
</Class>
</Export>
